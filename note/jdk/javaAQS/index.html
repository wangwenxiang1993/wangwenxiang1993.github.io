<!doctype html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <link rel="shortcut icon" href="/img/favicon.ico"/>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.css" rel="stylesheet"/>
    <link rel="stylesheet" type="text/css" href="/css/style.css"/>
    <link rel="stylesheet" type="text/css" href="/css/font-awesome.min.css"/>
    <script src="/js/jquery-1.7.1.min.js"></script>
    <script src="//cdn.bootcss.com/html5shiv/3.7.3/html5shiv.min.js"></script>
    <script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>
    <title>winx&#39;blog</title>
</head>
<body>
<div class="animated" id="info-min">
    <div id="guide">
    <div class="guide-button " _href="/tags/index/">首页</div>
    <div class="guide-button " _href="/tags/tech/">技术</div>
    <!--<div class="guide-button " _href="/tags/life/">生活</div>-->
    <div class="guide-button " _href="/categories/read/">阅读</div>
    <img src="/img/photo.png">
</div>
</div>
<div id="wrap">
    
  
    
      <div id="big-title" style="color: #666">
    

  <div id="title-name">Java并发之AQS</div><br>
  <div id="something">2018/04/09</div>
</div>
  <section id="content-specific">
    <article class="post">
        <div class="con"><h5 id="Java的并发工具，我们常用的有ReentrantLock-Semaphore-CountDownLatch等工具，而这些工具类又是如何实现的呢？这就不得不提到AbstractQueuedSynchronizer类，也就是AQS！类如其名，抽象的队列式的同步器，AQS定义了一套多线程访问共享资源的同步器框架"><a href="#Java的并发工具，我们常用的有ReentrantLock-Semaphore-CountDownLatch等工具，而这些工具类又是如何实现的呢？这就不得不提到AbstractQueuedSynchronizer类，也就是AQS！类如其名，抽象的队列式的同步器，AQS定义了一套多线程访问共享资源的同步器框架" class="headerlink" title="Java的并发工具，我们常用的有ReentrantLock/Semaphore/CountDownLatch等工具，而这些工具类又是如何实现的呢？这就不得不提到AbstractQueuedSynchronizer类，也就是AQS！类如其名，抽象的队列式的同步器，AQS定义了一套多线程访问共享资源的同步器框架!"></a>Java的并发工具，我们常用的有ReentrantLock/Semaphore/CountDownLatch等工具，而这些工具类又是如何实现的呢？这就不得不提到AbstractQueuedSynchronizer类，也就是AQS！类如其名，抽象的队列式的同步器，AQS定义了一套多线程访问共享资源的同步器框架!</h5><a id="more"></a>
<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><p><img src="/img/note/jdk/aqs.png" alt="AQS队列"> <div class="img-note">AQS队列</div></p>
<h5 id="AbstractQueuedSynchronizer类它维护了一个volatile-int-state（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列）。这里volatile是核心关键词，具体volatile的语义，在此不述。state的访问方式有三种"><a href="#AbstractQueuedSynchronizer类它维护了一个volatile-int-state（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列）。这里volatile是核心关键词，具体volatile的语义，在此不述。state的访问方式有三种" class="headerlink" title="AbstractQueuedSynchronizer类它维护了一个volatile int state（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列）。这里volatile是核心关键词，具体volatile的语义，在此不述。state的访问方式有三种:"></a><strong>AbstractQueuedSynchronizer</strong>类它维护了一个volatile int state（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列）。这里volatile是核心关键词，具体volatile的语义，在此不述。state的访问方式有三种:</h5><ul>
<li>getState</li>
<li>setState</li>
<li>compareAndSetState</li>
</ul>
<h5 id="AQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore-CountDownLatch）。"><a href="#AQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore-CountDownLatch）。" class="headerlink" title="AQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore/CountDownLatch）。"></a>AQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore/CountDownLatch）。</h5><h5 id="不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队-唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法："><a href="#不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队-唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：" class="headerlink" title="不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法："></a>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：</h5><ul>
<li><strong>isHeldExclusively()</strong>：该线程是否正在独占资源。只有用到condition才需要去实现它。</li>
<li><strong>tryAcquire(int)</strong>：独占方式。尝试获取资源，成功则返回true，失败则返回false。</li>
<li><strong>tryRelease(int)</strong>：独占方式。尝试释放资源，成功则返回true，失败则返回false。</li>
<li><strong>tryAcquireShared(int)</strong>：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li>
<li><strong>tryReleaseShared(int)</strong>：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</li>
</ul>
<h5 id="以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock-时，会调用tryAcquire-独占该锁并将state-1。此后，其他线程再tryAcquire-时就会失败，直到A线程unlock-到state-0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。"><a href="#以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock-时，会调用tryAcquire-独占该锁并将state-1。此后，其他线程再tryAcquire-时就会失败，直到A线程unlock-到state-0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。" class="headerlink" title="以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。"></a>以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。</h5><h5 id="再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown-一次，state会CAS减1。等到所有子线程都执行完后-即state-0-，会unpark-主调用线程，然后主调用线程就会从await-函数返回，继续后余动作。"><a href="#再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown-一次，state会CAS减1。等到所有子线程都执行完后-即state-0-，会unpark-主调用线程，然后主调用线程就会从await-函数返回，继续后余动作。" class="headerlink" title="再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS减1。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。"></a>再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS减1。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。</h5><h5 id="一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。"><a href="#一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。" class="headerlink" title="一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。"></a>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。</h5><h2 id="源码详解"><a href="#源码详解" class="headerlink" title="源码详解"></a>源码详解</h2><h3 id="acquire-int"><a href="#acquire-int" class="headerlink" title="acquire(int)"></a>acquire(int)</h3><h5 id="此方法是独占模式下线程获取共享资源的顶层入口。如果获取到资源，线程直接返回，否则进入等待队列，直到获取到资源为止，且整个过程忽略中断的影响。这也正是lock-的语义，当然不仅仅只限于lock-。获取到资源后，线程就可以去执行其临界区代码了。下面是acquire-的源码："><a href="#此方法是独占模式下线程获取共享资源的顶层入口。如果获取到资源，线程直接返回，否则进入等待队列，直到获取到资源为止，且整个过程忽略中断的影响。这也正是lock-的语义，当然不仅仅只限于lock-。获取到资源后，线程就可以去执行其临界区代码了。下面是acquire-的源码：" class="headerlink" title="此方法是独占模式下线程获取共享资源的顶层入口。如果获取到资源，线程直接返回，否则进入等待队列，直到获取到资源为止，且整个过程忽略中断的影响。这也正是lock()的语义，当然不仅仅只限于lock()。获取到资源后，线程就可以去执行其临界区代码了。下面是acquire()的源码："></a>此方法是独占模式下线程获取共享资源的顶层入口。如果获取到资源，线程直接返回，否则进入等待队列，直到获取到资源为止，且整个过程忽略中断的影响。这也正是lock()的语义，当然不仅仅只限于lock()。获取到资源后，线程就可以去执行其临界区代码了。下面是acquire()的源码：</h5><pre><code class="lang-java">public final void acquire(int arg) {
    if (!tryAcquire(arg) &amp;&amp;
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}
</code></pre>
<h4 id="函数流程如下："><a href="#函数流程如下：" class="headerlink" title="函数流程如下："></a>函数流程如下：</h4><ol>
<li>tryAcquire()尝试直接去获取资源，如果成功则直接返回；</li>
<li>addWaiter()将该线程加入等待队列的尾部，并标记为独占模式；</li>
<li>acquireQueued()使线程在等待队列中获取资源，一直获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。</li>
<li>如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。</li>
</ol>
<h5 id="这时单凭这4个抽象的函数来看流程还有点朦胧，不要紧，看完接下来的分析后，你就会明白了。"><a href="#这时单凭这4个抽象的函数来看流程还有点朦胧，不要紧，看完接下来的分析后，你就会明白了。" class="headerlink" title="这时单凭这4个抽象的函数来看流程还有点朦胧，不要紧，看完接下来的分析后，你就会明白了。"></a>这时单凭这4个抽象的函数来看流程还有点朦胧，不要紧，看完接下来的分析后，你就会明白了。</h5><h3 id="tryAcquire-int"><a href="#tryAcquire-int" class="headerlink" title="tryAcquire(int)"></a>tryAcquire(int)</h3><h5 id="此方法尝试去获取独占资源。如果获取成功，则直接返回true，否则直接返回false。这也正是tryLock-的语义，还是那句话，当然不仅仅只限于tryLock-。如下是tryAcquire-的源码："><a href="#此方法尝试去获取独占资源。如果获取成功，则直接返回true，否则直接返回false。这也正是tryLock-的语义，还是那句话，当然不仅仅只限于tryLock-。如下是tryAcquire-的源码：" class="headerlink" title="此方法尝试去获取独占资源。如果获取成功，则直接返回true，否则直接返回false。这也正是tryLock()的语义，还是那句话，当然不仅仅只限于tryLock()。如下是tryAcquire()的源码："></a>此方法尝试去获取独占资源。如果获取成功，则直接返回true，否则直接返回false。这也正是tryLock()的语义，还是那句话，当然不仅仅只限于tryLock()。如下是tryAcquire()的源码：</h5><pre><code class="lang-java">protected boolean tryAcquire(int arg) {
    throw new UnsupportedOperationException();
}
</code></pre>
<h5 id="什么？直接throw异常？说好的功能呢？好吧，还记得概述里讲的AQS只是一个框架，具体资源的获取-释放方式交由自定义同步器去实现吗？就是这里了！！！AQS这里只定义了一个接口，具体资源的获取交由自定义同步器去实现了（通过state的get-set-CAS）！！！至于能不能重入，能不能加塞，那就看具体的自定义同步器怎么去设计了！！！当然，自定义同步器在进行资源访问时要考虑线程安全的影响。"><a href="#什么？直接throw异常？说好的功能呢？好吧，还记得概述里讲的AQS只是一个框架，具体资源的获取-释放方式交由自定义同步器去实现吗？就是这里了！！！AQS这里只定义了一个接口，具体资源的获取交由自定义同步器去实现了（通过state的get-set-CAS）！！！至于能不能重入，能不能加塞，那就看具体的自定义同步器怎么去设计了！！！当然，自定义同步器在进行资源访问时要考虑线程安全的影响。" class="headerlink" title="什么？直接throw异常？说好的功能呢？好吧，还记得概述里讲的AQS只是一个框架，具体资源的获取/释放方式交由自定义同步器去实现吗？就是这里了！！！AQS这里只定义了一个接口，具体资源的获取交由自定义同步器去实现了（通过state的get/set/CAS）！！！至于能不能重入，能不能加塞，那就看具体的自定义同步器怎么去设计了！！！当然，自定义同步器在进行资源访问时要考虑线程安全的影响。"></a>什么？直接throw异常？说好的功能呢？好吧，还记得概述里讲的AQS只是一个框架，具体资源的获取/释放方式交由自定义同步器去实现吗？就是这里了！！！AQS这里只定义了一个接口，具体资源的获取交由自定义同步器去实现了（通过state的get/set/CAS）！！！至于能不能重入，能不能加塞，那就看具体的自定义同步器怎么去设计了！！！当然，自定义同步器在进行资源访问时要考虑线程安全的影响。</h5><h5 id="这里之所以没有定义成abstract，是因为独占模式下只用实现tryAcquire-tryRelease，而共享模式下只用实现tryAcquireShared-tryReleaseShared。如果都定义成abstract，那么每个模式也要去实现另一模式下的接口。说到底，Doug-Lea还是站在咱们开发者的角度，尽量减少不必要的工作量。"><a href="#这里之所以没有定义成abstract，是因为独占模式下只用实现tryAcquire-tryRelease，而共享模式下只用实现tryAcquireShared-tryReleaseShared。如果都定义成abstract，那么每个模式也要去实现另一模式下的接口。说到底，Doug-Lea还是站在咱们开发者的角度，尽量减少不必要的工作量。" class="headerlink" title="这里之所以没有定义成abstract，是因为独占模式下只用实现tryAcquire-tryRelease，而共享模式下只用实现tryAcquireShared-tryReleaseShared。如果都定义成abstract，那么每个模式也要去实现另一模式下的接口。说到底，Doug Lea还是站在咱们开发者的角度，尽量减少不必要的工作量。"></a>这里之所以没有定义成abstract，是因为独占模式下只用实现tryAcquire-tryRelease，而共享模式下只用实现tryAcquireShared-tryReleaseShared。如果都定义成abstract，那么每个模式也要去实现另一模式下的接口。说到底，Doug Lea还是站在咱们开发者的角度，尽量减少不必要的工作量。</h5><h3 id="addWaiter-Node"><a href="#addWaiter-Node" class="headerlink" title="addWaiter(Node)"></a>addWaiter(Node)</h3><h5 id="此方法用于将当前线程加入到等待队列的队尾，并返回当前线程所在的结点。还是上源码吧："><a href="#此方法用于将当前线程加入到等待队列的队尾，并返回当前线程所在的结点。还是上源码吧：" class="headerlink" title="此方法用于将当前线程加入到等待队列的队尾，并返回当前线程所在的结点。还是上源码吧："></a>此方法用于将当前线程加入到等待队列的队尾，并返回当前线程所在的结点。还是上源码吧：</h5><pre><code class="lang-java">private Node addWaiter(Node mode) {
    //以给定模式构造结点。mode有两种：EXCLUSIVE（独占）和SHARED（共享）
    Node node = new Node(Thread.currentThread(), mode);
    //尝试快速方式直接放到队尾。
    Node pred = tail;
    if (pred != null) {
        node.prev = pred;
        if (compareAndSetTail(pred, node)) {
            pred.next = node;
            return node;
        }
    }
    //上一步失败则通过enq入队。
    enq(node);
    return node;
}
</code></pre>
<h3 id="enq-Node"><a href="#enq-Node" class="headerlink" title="enq(Node)"></a>enq(Node)</h3><h5 id="此方法用于将node加入队尾。源码如下："><a href="#此方法用于将node加入队尾。源码如下：" class="headerlink" title="此方法用于将node加入队尾。源码如下："></a>此方法用于将node加入队尾。源码如下：</h5><pre><code class="lang-java">private Node enq(final Node node) {
    //CAS&quot;自旋&quot;，直到成功加入队尾
    for (;;) {
        Node t = tail;
        if (t == null) { // 队列为空，创建一个空的标志结点作为head结点，并将tail也指向它。
            if (compareAndSetHead(new Node()))
                tail = head;
        } else {//正常流程，放入队尾
            node.prev = t;
            if (compareAndSetTail(t, node)) {
                t.next = node;
                return t;
            }
        }
    }
}
</code></pre>
<h5 id="如果你看过AtomicInteger-getAndIncrement-函数源码，那么相信你一眼便看出这段代码的精华。CAS自旋volatile变量，是一种很经典的用法。还不太了解的，自己去百度一下吧。"><a href="#如果你看过AtomicInteger-getAndIncrement-函数源码，那么相信你一眼便看出这段代码的精华。CAS自旋volatile变量，是一种很经典的用法。还不太了解的，自己去百度一下吧。" class="headerlink" title="如果你看过AtomicInteger.getAndIncrement()函数源码，那么相信你一眼便看出这段代码的精华。CAS自旋volatile变量，是一种很经典的用法。还不太了解的，自己去百度一下吧。"></a>如果你看过AtomicInteger.getAndIncrement()函数源码，那么相信你一眼便看出这段代码的精华。CAS自旋volatile变量，是一种很经典的用法。还不太了解的，自己去百度一下吧。</h5><h3 id="acquireQueued-Node-int"><a href="#acquireQueued-Node-int" class="headerlink" title="acquireQueued(Node, int)"></a>acquireQueued(Node, int)</h3><h5 id="OK，通过tryAcquire-和addWaiter-，该线程获取资源失败，已经被放入等待队列尾部了。聪明的你立刻应该能想到该线程下一部该干什么了吧：进入等待状态休息，直到其他线程彻底释放资源后唤醒自己，自己再拿到资源，然后就可以去干自己想干的事了。没错，就是这样！是不是跟医院排队拿号有点相似-acquireQueued-就是干这件事：在等待队列中排队拿号（中间没其它事干可以休息），直到拿到号后再返回。这个函数非常关键，还是上源码吧："><a href="#OK，通过tryAcquire-和addWaiter-，该线程获取资源失败，已经被放入等待队列尾部了。聪明的你立刻应该能想到该线程下一部该干什么了吧：进入等待状态休息，直到其他线程彻底释放资源后唤醒自己，自己再拿到资源，然后就可以去干自己想干的事了。没错，就是这样！是不是跟医院排队拿号有点相似-acquireQueued-就是干这件事：在等待队列中排队拿号（中间没其它事干可以休息），直到拿到号后再返回。这个函数非常关键，还是上源码吧：" class="headerlink" title="OK，通过tryAcquire()和addWaiter()，该线程获取资源失败，已经被放入等待队列尾部了。聪明的你立刻应该能想到该线程下一部该干什么了吧：进入等待状态休息，直到其他线程彻底释放资源后唤醒自己，自己再拿到资源，然后就可以去干自己想干的事了。没错，就是这样！是不是跟医院排队拿号有点相似~~acquireQueued()就是干这件事：在等待队列中排队拿号（中间没其它事干可以休息），直到拿到号后再返回。这个函数非常关键，还是上源码吧："></a>OK，通过tryAcquire()和addWaiter()，该线程获取资源失败，已经被放入等待队列尾部了。聪明的你立刻应该能想到该线程下一部该干什么了吧：进入等待状态休息，直到其他线程彻底释放资源后唤醒自己，自己再拿到资源，然后就可以去干自己想干的事了。没错，就是这样！是不是跟医院排队拿号有点相似~~acquireQueued()就是干这件事：在等待队列中排队拿号（中间没其它事干可以休息），直到拿到号后再返回。这个函数非常关键，还是上源码吧：</h5><pre><code class="lang-java">final boolean acquireQueued(final Node node, int arg) {
    boolean failed = true;//标记是否成功拿到资源
    try {
        boolean interrupted = false;//标记等待过程中是否被中断过
        //又是一个“自旋”！
        for (;;) {
            final Node p = node.predecessor();//拿到前驱
            //如果前驱是head，即该结点已成老二，那么便有资格去尝试获取资源（可能是老大释放完资源唤醒自己的，当然也可能被interrupt了）。
            if (p == head &amp;&amp; tryAcquire(arg)) {
                setHead(node);//拿到资源后，将head指向该结点。所以head所指的标杆结点，就是当前获取到资源的那个结点或null。
                p.next = null; // setHead中node.prev已置为null，此处再将head.next置为null，就是为了方便GC回收以前的head结点。也就意味着之前拿完资源的结点出队了！
                failed = false;
                return interrupted;//返回等待过程中是否被中断过
            }
            //如果自己可以休息了，就进入waiting状态，直到被unpark()
            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                parkAndCheckInterrupt())
                interrupted = true;//如果等待过程中被中断过，哪怕只有那么一次，就将interrupted标记为true
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
</code></pre>
<h5 id="到这里了，我们先不急着总结acquireQueued-的函数流程，先看看shouldParkAfterFailedAcquire-和parkAndCheckInterrupt-具体干些什么。"><a href="#到这里了，我们先不急着总结acquireQueued-的函数流程，先看看shouldParkAfterFailedAcquire-和parkAndCheckInterrupt-具体干些什么。" class="headerlink" title="到这里了，我们先不急着总结acquireQueued()的函数流程，先看看shouldParkAfterFailedAcquire()和parkAndCheckInterrupt()具体干些什么。"></a>到这里了，我们先不急着总结acquireQueued()的函数流程，先看看shouldParkAfterFailedAcquire()和parkAndCheckInterrupt()具体干些什么。</h5><h3 id="shouldParkAfterFailedAcquire-Node-Node"><a href="#shouldParkAfterFailedAcquire-Node-Node" class="headerlink" title="shouldParkAfterFailedAcquire(Node, Node)"></a>shouldParkAfterFailedAcquire(Node, Node)</h3><h5 id="此方法主要用于检查状态，看看自己是否真的可以去休息了（进入waiting状态，如果线程状态转换不熟，可以参考本人上一篇写的Thread详解），万一队列前边的线程都放弃了只是瞎站着，那也说不定，对吧！"><a href="#此方法主要用于检查状态，看看自己是否真的可以去休息了（进入waiting状态，如果线程状态转换不熟，可以参考本人上一篇写的Thread详解），万一队列前边的线程都放弃了只是瞎站着，那也说不定，对吧！" class="headerlink" title="此方法主要用于检查状态，看看自己是否真的可以去休息了（进入waiting状态，如果线程状态转换不熟，可以参考本人上一篇写的Thread详解），万一队列前边的线程都放弃了只是瞎站着，那也说不定，对吧！"></a>此方法主要用于检查状态，看看自己是否真的可以去休息了（进入waiting状态，如果线程状态转换不熟，可以参考本人上一篇写的Thread详解），万一队列前边的线程都放弃了只是瞎站着，那也说不定，对吧！</h5><pre><code class="lang-java">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
    int ws = pred.waitStatus;//拿到前驱的状态
    if (ws == Node.SIGNAL)
        //如果已经告诉前驱拿完号后通知自己一下，那就可以安心休息了
        return true;
    if (ws &gt; 0) {
        /*
         * 如果前驱放弃了，那就一直往前找，直到找到最近一个正常等待的状态，并排在它的后边。
         * 注意：那些放弃的结点，由于被自己“加塞”到它们前边，它们相当于形成一个无引用链，稍后就会被保安大叔赶走了(GC回收)！
         */
        do {
            node.prev = pred = pred.prev;
        } while (pred.waitStatus &gt; 0);
        pred.next = node;
    } else {
         //如果前驱正常，那就把前驱的状态设置成SIGNAL，告诉它拿完号后通知自己一下。有可能失败，人家说不定刚刚释放完呢！
        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
    }
    return false;
}
</code></pre>
<h5 id="整个流程中，如果前驱结点的状态不是SIGNAL，那么自己就不能安心去休息，需要去找个安心的休息点，同时可以再尝试下看有没有机会轮到自己拿号。"><a href="#整个流程中，如果前驱结点的状态不是SIGNAL，那么自己就不能安心去休息，需要去找个安心的休息点，同时可以再尝试下看有没有机会轮到自己拿号。" class="headerlink" title="整个流程中，如果前驱结点的状态不是SIGNAL，那么自己就不能安心去休息，需要去找个安心的休息点，同时可以再尝试下看有没有机会轮到自己拿号。"></a>整个流程中，如果前驱结点的状态不是SIGNAL，那么自己就不能安心去休息，需要去找个安心的休息点，同时可以再尝试下看有没有机会轮到自己拿号。</h5><h3 id="parkAndCheckInterrupt"><a href="#parkAndCheckInterrupt" class="headerlink" title="parkAndCheckInterrupt()"></a>parkAndCheckInterrupt()</h3><h5 id="如果线程找好安全休息点后，那就可以安心去休息了。此方法就是让线程去休息，真正进入等待状态。"><a href="#如果线程找好安全休息点后，那就可以安心去休息了。此方法就是让线程去休息，真正进入等待状态。" class="headerlink" title="如果线程找好安全休息点后，那就可以安心去休息了。此方法就是让线程去休息，真正进入等待状态。"></a>如果线程找好安全休息点后，那就可以安心去休息了。此方法就是让线程去休息，真正进入等待状态。</h5><pre><code class="lang-java">private final boolean parkAndCheckInterrupt() {
    LockSupport.park(this);//调用park()使线程进入waiting状态
    return Thread.interrupted();//如果被唤醒，查看自己是不是被中断的。
}
</code></pre>
<h5 id="park-会让当前线程进入waiting状态。在此状态下，有两种途径可以唤醒该线程：1）被unpark-；2）被interrupt-。（再说一句，如果线程状态转换不熟，可以参考本人写的Thread详解）。需要注意的是，Thread-interrupted-会清除当前线程的中断标记位。"><a href="#park-会让当前线程进入waiting状态。在此状态下，有两种途径可以唤醒该线程：1）被unpark-；2）被interrupt-。（再说一句，如果线程状态转换不熟，可以参考本人写的Thread详解）。需要注意的是，Thread-interrupted-会清除当前线程的中断标记位。" class="headerlink" title="park()会让当前线程进入waiting状态。在此状态下，有两种途径可以唤醒该线程：1）被unpark()；2）被interrupt()。（再说一句，如果线程状态转换不熟，可以参考本人写的Thread详解）。需要注意的是，Thread.interrupted()会清除当前线程的中断标记位。"></a>park()会让当前线程进入waiting状态。在此状态下，有两种途径可以唤醒该线程：1）被unpark()；2）被interrupt()。（再说一句，如果线程状态转换不熟，可以参考本人写的Thread详解）。需要注意的是，Thread.interrupted()会清除当前线程的中断标记位。</h5><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><h5 id="OK，看了shouldParkAfterFailedAcquire-和parkAndCheckInterrupt-，现在让我们再回到acquireQueued-，总结下该函数的具体流程："><a href="#OK，看了shouldParkAfterFailedAcquire-和parkAndCheckInterrupt-，现在让我们再回到acquireQueued-，总结下该函数的具体流程：" class="headerlink" title="OK，看了shouldParkAfterFailedAcquire()和parkAndCheckInterrupt()，现在让我们再回到acquireQueued()，总结下该函数的具体流程："></a>OK，看了shouldParkAfterFailedAcquire()和parkAndCheckInterrupt()，现在让我们再回到acquireQueued()，总结下该函数的具体流程：</h5><ol>
<li>结点进入队尾后，检查状态，找到安全休息点；</li>
<li>调用park()进入waiting状态，等待unpark()或interrupt()唤醒自己；</li>
<li>被唤醒后，看自己是不是有资格能拿到号。如果拿到，head指向当前结点，并返回从入队到拿到号的整个过程中是否被中断过；如果没拿到，继续流程1。</li>
</ol>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><h5 id="OKOK，acquireQueued-分析完之后，我们接下来再回到acquire-！再贴上它的源码吧："><a href="#OKOK，acquireQueued-分析完之后，我们接下来再回到acquire-！再贴上它的源码吧：" class="headerlink" title="OKOK，acquireQueued()分析完之后，我们接下来再回到acquire()！再贴上它的源码吧："></a>OKOK，acquireQueued()分析完之后，我们接下来再回到acquire()！再贴上它的源码吧：</h5><pre><code class="lang-java">public final void acquire(int arg) {
    if (!tryAcquire(arg) &amp;&amp;
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}
</code></pre>
<h5 id="再来总结下它的流程吧："><a href="#再来总结下它的流程吧：" class="headerlink" title="再来总结下它的流程吧："></a>再来总结下它的流程吧：</h5><ol>
<li>调用自定义同步器的tryAcquire()尝试直接去获取资源，如果成功则直接返回；</li>
<li>没成功，则addWaiter()将该线程加入等待队列的尾部，并标记为独占模式；</li>
<li>acquireQueued()使线程在等待队列中休息，有机会时（轮到自己，会被unpark()）会去尝试获取资源。获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。</li>
<li>如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。</li>
</ol>
<h5 id="由于此函数是重中之重，我再用流程图总结一下："><a href="#由于此函数是重中之重，我再用流程图总结一下：" class="headerlink" title="由于此函数是重中之重，我再用流程图总结一下："></a>由于此函数是重中之重，我再用流程图总结一下：</h5><p><img src="/img/note/jdk/aqs1.png" alt="AQS队列"></p>
<h5 id="至此，acquire-的流程终于算是告一段落了。这也就是ReentrantLock-lock-的流程，不信你去看其lock-源码吧，整个函数就是一条acquire-1-！！！"><a href="#至此，acquire-的流程终于算是告一段落了。这也就是ReentrantLock-lock-的流程，不信你去看其lock-源码吧，整个函数就是一条acquire-1-！！！" class="headerlink" title="至此，acquire()的流程终于算是告一段落了。这也就是ReentrantLock.lock()的流程，不信你去看其lock()源码吧，整个函数就是一条acquire(1)！！！"></a>至此，acquire()的流程终于算是告一段落了。这也就是ReentrantLock.lock()的流程，不信你去看其lock()源码吧，整个函数就是一条acquire(1)！！！</h5><h3 id="release-int"><a href="#release-int" class="headerlink" title="release(int)"></a>release(int)</h3><h5 id="上一小节已经把acquire-说完了，这一小节就来讲讲它的反操作release-吧。此方法是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state-0）-它会唤醒等待队列里的其他线程来获取资源。这也正是unlock-的语义，当然不仅仅只限于unlock-。下面是release-的源码："><a href="#上一小节已经把acquire-说完了，这一小节就来讲讲它的反操作release-吧。此方法是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state-0）-它会唤醒等待队列里的其他线程来获取资源。这也正是unlock-的语义，当然不仅仅只限于unlock-。下面是release-的源码：" class="headerlink" title="上一小节已经把acquire()说完了，这一小节就来讲讲它的反操作release()吧。此方法是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state=0）,它会唤醒等待队列里的其他线程来获取资源。这也正是unlock()的语义，当然不仅仅只限于unlock()。下面是release()的源码："></a>上一小节已经把acquire()说完了，这一小节就来讲讲它的反操作release()吧。此方法是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state=0）,它会唤醒等待队列里的其他线程来获取资源。这也正是unlock()的语义，当然不仅仅只限于unlock()。下面是release()的源码：</h5><pre><code class="lang-java">public final boolean release(int arg) {
    if (tryRelease(arg)) {
        Node h = head;//找到头结点
        if (h != null &amp;&amp; h.waitStatus != 0)
            unparkSuccessor(h);//唤醒等待队列里的下一个线程
        return true;
    }
    return false;
}
</code></pre>
<h5 id="逻辑并不复杂。它调用tryRelease-来释放资源。有一点需要注意的是，它是根据tryRelease-的返回值来判断该线程是否已经完成释放掉资源了！所以自定义同步器在设计tryRelease-的时候要明确这一点！！"><a href="#逻辑并不复杂。它调用tryRelease-来释放资源。有一点需要注意的是，它是根据tryRelease-的返回值来判断该线程是否已经完成释放掉资源了！所以自定义同步器在设计tryRelease-的时候要明确这一点！！" class="headerlink" title="逻辑并不复杂。它调用tryRelease()来释放资源。有一点需要注意的是，它是根据tryRelease()的返回值来判断该线程是否已经完成释放掉资源了！所以自定义同步器在设计tryRelease()的时候要明确这一点！！"></a>逻辑并不复杂。它调用tryRelease()来释放资源。有一点需要注意的是，它是根据tryRelease()的返回值来判断该线程是否已经完成释放掉资源了！所以自定义同步器在设计tryRelease()的时候要明确这一点！！</h5><h3 id="tryRelease-int"><a href="#tryRelease-int" class="headerlink" title="tryRelease(int)"></a>tryRelease(int)</h3><h5 id="此方法尝试去释放指定量的资源。下面是tryRelease-的源码："><a href="#此方法尝试去释放指定量的资源。下面是tryRelease-的源码：" class="headerlink" title="此方法尝试去释放指定量的资源。下面是tryRelease()的源码："></a>此方法尝试去释放指定量的资源。下面是tryRelease()的源码：</h5><pre><code class="lang-java">protected boolean tryRelease(int arg) {
    throw new UnsupportedOperationException();
}
</code></pre>
<h5 id="跟tryAcquire-一样，这个方法是需要独占模式的自定义同步器去实现的。正常来说，tryRelease-都会成功的，因为这是独占模式，该线程来释放资源，那么它肯定已经拿到独占资源了，直接减掉相应量的资源即可-state-arg-，也不需要考虑线程安全的问题。但要注意它的返回值，上面已经提到了，release-是根据tryRelease-的返回值来判断该线程是否已经完成释放掉资源了！所以自义定同步器在实现时，如果已经彻底释放资源-state-0-，要返回true，否则返回false。"><a href="#跟tryAcquire-一样，这个方法是需要独占模式的自定义同步器去实现的。正常来说，tryRelease-都会成功的，因为这是独占模式，该线程来释放资源，那么它肯定已经拿到独占资源了，直接减掉相应量的资源即可-state-arg-，也不需要考虑线程安全的问题。但要注意它的返回值，上面已经提到了，release-是根据tryRelease-的返回值来判断该线程是否已经完成释放掉资源了！所以自义定同步器在实现时，如果已经彻底释放资源-state-0-，要返回true，否则返回false。" class="headerlink" title="跟tryAcquire()一样，这个方法是需要独占模式的自定义同步器去实现的。正常来说，tryRelease()都会成功的，因为这是独占模式，该线程来释放资源，那么它肯定已经拿到独占资源了，直接减掉相应量的资源即可(state-=arg)，也不需要考虑线程安全的问题。但要注意它的返回值，上面已经提到了，release()是根据tryRelease()的返回值来判断该线程是否已经完成释放掉资源了！所以自义定同步器在实现时，如果已经彻底释放资源(state=0)，要返回true，否则返回false。"></a>跟tryAcquire()一样，这个方法是需要独占模式的自定义同步器去实现的。正常来说，tryRelease()都会成功的，因为这是独占模式，该线程来释放资源，那么它肯定已经拿到独占资源了，直接减掉相应量的资源即可(state-=arg)，也不需要考虑线程安全的问题。但要注意它的返回值，上面已经提到了，release()是根据tryRelease()的返回值来判断该线程是否已经完成释放掉资源了！所以自义定同步器在实现时，如果已经彻底释放资源(state=0)，要返回true，否则返回false。</h5><h3 id="unparkSuccessor-Node"><a href="#unparkSuccessor-Node" class="headerlink" title="unparkSuccessor(Node)"></a>unparkSuccessor(Node)</h3><h5 id="此方法用于唤醒等待队列中下一个线程。下面是源码："><a href="#此方法用于唤醒等待队列中下一个线程。下面是源码：" class="headerlink" title="此方法用于唤醒等待队列中下一个线程。下面是源码："></a>此方法用于唤醒等待队列中下一个线程。下面是源码：</h5><pre><code class="lang-java">private void unparkSuccessor(Node node) {
    //这里，node一般为当前线程所在的结点。
    int ws = node.waitStatus;
    if (ws &lt; 0)//置零当前线程所在的结点状态，允许失败。
        compareAndSetWaitStatus(node, ws, 0);
    Node s = node.next;//找到下一个需要唤醒的结点s
    if (s == null || s.waitStatus &gt; 0) {//如果为空或已取消
        s = null;
        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)
            if (t.waitStatus &lt;= 0)//从这里可以看出，&lt;=0的结点，都是还有效的结点。
                s = t;
    }
    if (s != null)
        LockSupport.unpark(s.thread);//唤醒
}
</code></pre>
<h5 id="这个函数并不复杂。一句话概括：用unpark-唤醒等待队列中最前边的那个未放弃线程，这里我们也用s来表示吧。此时，再和acquireQueued-联系起来，s被唤醒后，进入if-p-head-amp-amp-tryAcquire-arg-的判断（即使p-head也没关系，它会再进入shouldParkAfterFailedAcquire-寻找一个安全点。这里既然s已经是等待队列中最前边的那个未放弃线程了，那么通过shouldParkAfterFailedAcquire-的调整，s也必然会跑到head的next结点，下一次自旋p-head就成立啦），然后s把自己设置成head标杆结点，表示自己已经获取到资源了，acquire-也返回了！！And-then-DO-what-you-WANT"><a href="#这个函数并不复杂。一句话概括：用unpark-唤醒等待队列中最前边的那个未放弃线程，这里我们也用s来表示吧。此时，再和acquireQueued-联系起来，s被唤醒后，进入if-p-head-amp-amp-tryAcquire-arg-的判断（即使p-head也没关系，它会再进入shouldParkAfterFailedAcquire-寻找一个安全点。这里既然s已经是等待队列中最前边的那个未放弃线程了，那么通过shouldParkAfterFailedAcquire-的调整，s也必然会跑到head的next结点，下一次自旋p-head就成立啦），然后s把自己设置成head标杆结点，表示自己已经获取到资源了，acquire-也返回了！！And-then-DO-what-you-WANT" class="headerlink" title="这个函数并不复杂。一句话概括：用unpark()唤醒等待队列中最前边的那个未放弃线程，这里我们也用s来表示吧。此时，再和acquireQueued()联系起来，s被唤醒后，进入if (p == head &amp;&amp; tryAcquire(arg))的判断（即使p!=head也没关系，它会再进入shouldParkAfterFailedAcquire()寻找一个安全点。这里既然s已经是等待队列中最前边的那个未放弃线程了，那么通过shouldParkAfterFailedAcquire()的调整，s也必然会跑到head的next结点，下一次自旋p==head就成立啦），然后s把自己设置成head标杆结点，表示自己已经获取到资源了，acquire()也返回了！！And then, DO what you WANT!"></a>这个函数并不复杂。一句话概括：用unpark()唤醒等待队列中最前边的那个未放弃线程，这里我们也用s来表示吧。此时，再和acquireQueued()联系起来，s被唤醒后，进入if (p == head &amp;&amp; tryAcquire(arg))的判断（即使p!=head也没关系，它会再进入shouldParkAfterFailedAcquire()寻找一个安全点。这里既然s已经是等待队列中最前边的那个未放弃线程了，那么通过shouldParkAfterFailedAcquire()的调整，s也必然会跑到head的next结点，下一次自旋p==head就成立啦），然后s把自己设置成head标杆结点，表示自己已经获取到资源了，acquire()也返回了！！And then, DO what you WANT!</h5><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><h5 id="release-是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state-0）-它会唤醒等待队列里的其他线程来获取资源。"><a href="#release-是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state-0）-它会唤醒等待队列里的其他线程来获取资源。" class="headerlink" title="release()是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state=0）,它会唤醒等待队列里的其他线程来获取资源。"></a>release()是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state=0）,它会唤醒等待队列里的其他线程来获取资源。</h5><h3 id="acquireShared-int"><a href="#acquireShared-int" class="headerlink" title="acquireShared(int)"></a>acquireShared(int)</h3><h5 id="此方法是共享模式下线程获取共享资源的顶层入口。它会获取指定量的资源，获取成功则直接返回，获取失败则进入等待队列，直到获取到资源为止，整个过程忽略中断。下面是acquireShared-的源码："><a href="#此方法是共享模式下线程获取共享资源的顶层入口。它会获取指定量的资源，获取成功则直接返回，获取失败则进入等待队列，直到获取到资源为止，整个过程忽略中断。下面是acquireShared-的源码：" class="headerlink" title="此方法是共享模式下线程获取共享资源的顶层入口。它会获取指定量的资源，获取成功则直接返回，获取失败则进入等待队列，直到获取到资源为止，整个过程忽略中断。下面是acquireShared()的源码："></a>此方法是共享模式下线程获取共享资源的顶层入口。它会获取指定量的资源，获取成功则直接返回，获取失败则进入等待队列，直到获取到资源为止，整个过程忽略中断。下面是acquireShared()的源码：</h5><pre><code class="lang-java">public final void acquireShared(int arg) {
    if (tryAcquireShared(arg) &lt; 0)
        doAcquireShared(arg);
}
</code></pre>
<h5 id="这里tryAcquireShared-依然需要自定义同步器去实现。但是AQS已经把其返回值的语义定义好了：负值代表获取失败；0代表获取成功，但没有剩余资源；正数表示获取成功，还有剩余资源，其他线程还可以去获取。所以这里acquireShared-的流程就是："><a href="#这里tryAcquireShared-依然需要自定义同步器去实现。但是AQS已经把其返回值的语义定义好了：负值代表获取失败；0代表获取成功，但没有剩余资源；正数表示获取成功，还有剩余资源，其他线程还可以去获取。所以这里acquireShared-的流程就是：" class="headerlink" title="这里tryAcquireShared()依然需要自定义同步器去实现。但是AQS已经把其返回值的语义定义好了：负值代表获取失败；0代表获取成功，但没有剩余资源；正数表示获取成功，还有剩余资源，其他线程还可以去获取。所以这里acquireShared()的流程就是："></a>这里tryAcquireShared()依然需要自定义同步器去实现。但是AQS已经把其返回值的语义定义好了：负值代表获取失败；0代表获取成功，但没有剩余资源；正数表示获取成功，还有剩余资源，其他线程还可以去获取。所以这里acquireShared()的流程就是：</h5><ol>
<li>tryAcquireShared()尝试获取资源，成功则直接返回；</li>
<li>失败则通过doAcquireShared()进入等待队列，直到获取到资源为止才返回。</li>
</ol>
<h3 id="doAcquireShared-int"><a href="#doAcquireShared-int" class="headerlink" title="doAcquireShared(int)"></a>doAcquireShared(int)</h3><h5 id="此方法用于将当前线程加入等待队列尾部休息，直到其他线程释放资源唤醒自己，自己成功拿到相应量的资源后才返回。下面是doAcquireShared-的源码："><a href="#此方法用于将当前线程加入等待队列尾部休息，直到其他线程释放资源唤醒自己，自己成功拿到相应量的资源后才返回。下面是doAcquireShared-的源码：" class="headerlink" title="此方法用于将当前线程加入等待队列尾部休息，直到其他线程释放资源唤醒自己，自己成功拿到相应量的资源后才返回。下面是doAcquireShared()的源码："></a>此方法用于将当前线程加入等待队列尾部休息，直到其他线程释放资源唤醒自己，自己成功拿到相应量的资源后才返回。下面是doAcquireShared()的源码：</h5><pre><code class="lang-java">private void doAcquireShared(int arg) {
    final Node node = addWaiter(Node.SHARED);//加入队列尾部
    boolean failed = true;//是否成功标志
    try {
        boolean interrupted = false;//等待过程中是否被中断过的标志
        for (;;) {
            final Node p = node.predecessor();//前驱
            if (p == head) {//如果到head的下一个，因为head是拿到资源的线程，此时node被唤醒，很可能是head用完资源来唤醒自己的
                int r = tryAcquireShared(arg);//尝试获取资源
                if (r &gt;= 0) {//成功
                    setHeadAndPropagate(node, r);//将head指向自己，还有剩余资源可以再唤醒之后的线程
                    p.next = null; // help GC
                    if (interrupted)//如果等待过程中被打断过，此时将中断补上。
                        selfInterrupt();
                    failed = false;
                    return;
                }
            }
            //判断状态，寻找安全点，进入waiting状态，等着被unpark()或interrupt()
            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
</code></pre>
<h5 id="有木有觉得跟acquireQueued-很相似？对，其实流程并没有太大区别。只不过这里将补中断的selfInterrupt-放到doAcquireShared-里了，而独占模式是放到acquireQueued-之外，其实都一样，不知道Doug-Lea是怎么想的。"><a href="#有木有觉得跟acquireQueued-很相似？对，其实流程并没有太大区别。只不过这里将补中断的selfInterrupt-放到doAcquireShared-里了，而独占模式是放到acquireQueued-之外，其实都一样，不知道Doug-Lea是怎么想的。" class="headerlink" title="有木有觉得跟acquireQueued()很相似？对，其实流程并没有太大区别。只不过这里将补中断的selfInterrupt()放到doAcquireShared()里了，而独占模式是放到acquireQueued()之外，其实都一样，不知道Doug Lea是怎么想的。"></a>有木有觉得跟acquireQueued()很相似？对，其实流程并没有太大区别。只不过这里将补中断的selfInterrupt()放到doAcquireShared()里了，而独占模式是放到acquireQueued()之外，其实都一样，不知道Doug Lea是怎么想的。</h5><h5 id="跟独占模式比，还有一点需要注意的是，这里只有线程是head-next时（“老二”），才会去尝试获取资源，有剩余的话还会唤醒之后的队友。那么问题就来了，假如老大用完后释放了5个资源，而老二需要6个，老三需要1个，老四需要2个。老大先唤醒老二，老二一看资源不够，他是把资源让给老三呢，还是不让？答案是否定的！老二会继续park-等待其他线程释放资源，也更不会去唤醒老三和老四了。独占模式，同一时刻只有一个线程去执行，这样做未尝不可；但共享模式下，多个线程是可以同时执行的，现在因为老二的资源需求量大，而把后面量小的老三和老四也都卡住了。当然，这并不是问题，只是AQS保证严格按照入队顺序唤醒罢了（保证公平，但降低了并发）。"><a href="#跟独占模式比，还有一点需要注意的是，这里只有线程是head-next时（“老二”），才会去尝试获取资源，有剩余的话还会唤醒之后的队友。那么问题就来了，假如老大用完后释放了5个资源，而老二需要6个，老三需要1个，老四需要2个。老大先唤醒老二，老二一看资源不够，他是把资源让给老三呢，还是不让？答案是否定的！老二会继续park-等待其他线程释放资源，也更不会去唤醒老三和老四了。独占模式，同一时刻只有一个线程去执行，这样做未尝不可；但共享模式下，多个线程是可以同时执行的，现在因为老二的资源需求量大，而把后面量小的老三和老四也都卡住了。当然，这并不是问题，只是AQS保证严格按照入队顺序唤醒罢了（保证公平，但降低了并发）。" class="headerlink" title="跟独占模式比，还有一点需要注意的是，这里只有线程是head.next时（“老二”），才会去尝试获取资源，有剩余的话还会唤醒之后的队友。那么问题就来了，假如老大用完后释放了5个资源，而老二需要6个，老三需要1个，老四需要2个。老大先唤醒老二，老二一看资源不够，他是把资源让给老三呢，还是不让？答案是否定的！老二会继续park()等待其他线程释放资源，也更不会去唤醒老三和老四了。独占模式，同一时刻只有一个线程去执行，这样做未尝不可；但共享模式下，多个线程是可以同时执行的，现在因为老二的资源需求量大，而把后面量小的老三和老四也都卡住了。当然，这并不是问题，只是AQS保证严格按照入队顺序唤醒罢了（保证公平，但降低了并发）。"></a>跟独占模式比，还有一点需要注意的是，这里只有线程是head.next时（“老二”），才会去尝试获取资源，有剩余的话还会唤醒之后的队友。那么问题就来了，假如老大用完后释放了5个资源，而老二需要6个，老三需要1个，老四需要2个。老大先唤醒老二，老二一看资源不够，他是把资源让给老三呢，还是不让？答案是否定的！老二会继续park()等待其他线程释放资源，也更不会去唤醒老三和老四了。独占模式，同一时刻只有一个线程去执行，这样做未尝不可；但共享模式下，多个线程是可以同时执行的，现在因为老二的资源需求量大，而把后面量小的老三和老四也都卡住了。当然，这并不是问题，只是AQS保证严格按照入队顺序唤醒罢了（保证公平，但降低了并发）。</h5><h3 id="setHeadAndPropagate-Node-int"><a href="#setHeadAndPropagate-Node-int" class="headerlink" title="setHeadAndPropagate(Node, int)"></a>setHeadAndPropagate(Node, int)</h3><pre><code class="lang-java">private void setHeadAndPropagate(Node node, int propagate) {
    Node h = head;
    setHead(node);//head指向自己
     //如果还有剩余量，继续唤醒下一个邻居线程
    if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0) {
        Node s = node.next;
        if (s == null || s.isShared())
            doReleaseShared();
    }
}
</code></pre>
<h5 id="此方法在setHead-的基础上多了一步，就是自己苏醒的同时，如果条件符合（比如还有剩余资源），还会去唤醒后继结点，毕竟是共享模式！"><a href="#此方法在setHead-的基础上多了一步，就是自己苏醒的同时，如果条件符合（比如还有剩余资源），还会去唤醒后继结点，毕竟是共享模式！" class="headerlink" title="此方法在setHead()的基础上多了一步，就是自己苏醒的同时，如果条件符合（比如还有剩余资源），还会去唤醒后继结点，毕竟是共享模式！"></a>此方法在setHead()的基础上多了一步，就是自己苏醒的同时，如果条件符合（比如还有剩余资源），还会去唤醒后继结点，毕竟是共享模式！</h5><h5 id="doReleaseShared-我们留着下一小节的releaseShared-里来讲。"><a href="#doReleaseShared-我们留着下一小节的releaseShared-里来讲。" class="headerlink" title="doReleaseShared()我们留着下一小节的releaseShared()里来讲。"></a>doReleaseShared()我们留着下一小节的releaseShared()里来讲。</h5><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><h5 id="OK，至此，acquireShared-也要告一段落了。让我们再梳理一下它的流程："><a href="#OK，至此，acquireShared-也要告一段落了。让我们再梳理一下它的流程：" class="headerlink" title="OK，至此，acquireShared()也要告一段落了。让我们再梳理一下它的流程："></a>OK，至此，acquireShared()也要告一段落了。让我们再梳理一下它的流程：</h5><ol>
<li>tryAcquireShared()尝试获取资源，成功则直接返回；</li>
<li>失败则通过doAcquireShared()进入等待队列park()，直到被unpark()/interrupt()并成功获取到资源才返回。整个等待过程也是忽略中断的。
　　<h5 id="其实跟acquire-的流程大同小异，只不过多了个自己拿到资源后，还会去唤醒后继队友的操作（这才是共享嘛）。"><a href="#其实跟acquire-的流程大同小异，只不过多了个自己拿到资源后，还会去唤醒后继队友的操作（这才是共享嘛）。" class="headerlink" title="其实跟acquire()的流程大同小异，只不过多了个自己拿到资源后，还会去唤醒后继队友的操作（这才是共享嘛）。"></a>其实跟acquire()的流程大同小异，只不过多了个自己拿到资源后，还会去唤醒后继队友的操作（这才是共享嘛）。</h5></li>
</ol>
<h3 id="releaseShared"><a href="#releaseShared" class="headerlink" title="releaseShared()"></a>releaseShared()</h3><h5 id="上一小节已经把acquireShared-说完了，这一小节就来讲讲它的反操作releaseShared-吧。此方法是共享模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果成功释放且允许唤醒等待线程，它会唤醒等待队列里的其他线程来获取资源。下面是releaseShared-的源码："><a href="#上一小节已经把acquireShared-说完了，这一小节就来讲讲它的反操作releaseShared-吧。此方法是共享模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果成功释放且允许唤醒等待线程，它会唤醒等待队列里的其他线程来获取资源。下面是releaseShared-的源码：" class="headerlink" title="上一小节已经把acquireShared()说完了，这一小节就来讲讲它的反操作releaseShared()吧。此方法是共享模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果成功释放且允许唤醒等待线程，它会唤醒等待队列里的其他线程来获取资源。下面是releaseShared()的源码："></a>上一小节已经把acquireShared()说完了，这一小节就来讲讲它的反操作releaseShared()吧。此方法是共享模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果成功释放且允许唤醒等待线程，它会唤醒等待队列里的其他线程来获取资源。下面是releaseShared()的源码：</h5><pre><code class="lang-java">public final boolean releaseShared(int arg) {
    if (tryReleaseShared(arg)) {//尝试释放资源
        doReleaseShared();//唤醒后继结点
        return true;
    }
    return false;
}
</code></pre>
<h5 id="此方法的流程也比较简单，一句话：释放掉资源后，唤醒后继。跟独占模式下的release-相似，但有一点稍微需要注意：独占模式下的tryRelease-在完全释放掉资源（state-0）后，才会返回true去唤醒其他线程，这主要是基于独占下可重入的考量；而共享模式下的releaseShared-则没有这种要求，共享模式实质就是控制一定量的线程并发执行，那么拥有资源的线程在释放掉部分资源时就可以唤醒后继等待结点。例如，资源总量是13，A（5）和B（7）分别获取到资源并发运行，C（4）来时只剩1个资源就需要等待。A在运行过程中释放掉2个资源量，然后tryReleaseShared-2-返回true唤醒C，C一看只有3个仍不够继续等待；随后B又释放2个，tryReleaseShared-2-返回true唤醒C，C一看有5个够自己用了，然后C就可以跟A和B一起运行。而ReentrantReadWriteLock读锁的tryReleaseShared-只有在完全释放掉资源（state-0）才返回true，所以自定义同步器可以根据需要决定tryReleaseShared-的返回值。"><a href="#此方法的流程也比较简单，一句话：释放掉资源后，唤醒后继。跟独占模式下的release-相似，但有一点稍微需要注意：独占模式下的tryRelease-在完全释放掉资源（state-0）后，才会返回true去唤醒其他线程，这主要是基于独占下可重入的考量；而共享模式下的releaseShared-则没有这种要求，共享模式实质就是控制一定量的线程并发执行，那么拥有资源的线程在释放掉部分资源时就可以唤醒后继等待结点。例如，资源总量是13，A（5）和B（7）分别获取到资源并发运行，C（4）来时只剩1个资源就需要等待。A在运行过程中释放掉2个资源量，然后tryReleaseShared-2-返回true唤醒C，C一看只有3个仍不够继续等待；随后B又释放2个，tryReleaseShared-2-返回true唤醒C，C一看有5个够自己用了，然后C就可以跟A和B一起运行。而ReentrantReadWriteLock读锁的tryReleaseShared-只有在完全释放掉资源（state-0）才返回true，所以自定义同步器可以根据需要决定tryReleaseShared-的返回值。" class="headerlink" title="此方法的流程也比较简单，一句话：释放掉资源后，唤醒后继。跟独占模式下的release()相似，但有一点稍微需要注意：独占模式下的tryRelease()在完全释放掉资源（state=0）后，才会返回true去唤醒其他线程，这主要是基于独占下可重入的考量；而共享模式下的releaseShared()则没有这种要求，共享模式实质就是控制一定量的线程并发执行，那么拥有资源的线程在释放掉部分资源时就可以唤醒后继等待结点。例如，资源总量是13，A（5）和B（7）分别获取到资源并发运行，C（4）来时只剩1个资源就需要等待。A在运行过程中释放掉2个资源量，然后tryReleaseShared(2)返回true唤醒C，C一看只有3个仍不够继续等待；随后B又释放2个，tryReleaseShared(2)返回true唤醒C，C一看有5个够自己用了，然后C就可以跟A和B一起运行。而ReentrantReadWriteLock读锁的tryReleaseShared()只有在完全释放掉资源（state=0）才返回true，所以自定义同步器可以根据需要决定tryReleaseShared()的返回值。"></a>此方法的流程也比较简单，一句话：释放掉资源后，唤醒后继。跟独占模式下的release()相似，但有一点稍微需要注意：独占模式下的tryRelease()在完全释放掉资源（state=0）后，才会返回true去唤醒其他线程，这主要是基于独占下可重入的考量；而共享模式下的releaseShared()则没有这种要求，共享模式实质就是控制一定量的线程并发执行，那么拥有资源的线程在释放掉部分资源时就可以唤醒后继等待结点。例如，资源总量是13，A（5）和B（7）分别获取到资源并发运行，C（4）来时只剩1个资源就需要等待。A在运行过程中释放掉2个资源量，然后tryReleaseShared(2)返回true唤醒C，C一看只有3个仍不够继续等待；随后B又释放2个，tryReleaseShared(2)返回true唤醒C，C一看有5个够自己用了，然后C就可以跟A和B一起运行。而ReentrantReadWriteLock读锁的tryReleaseShared()只有在完全释放掉资源（state=0）才返回true，所以自定义同步器可以根据需要决定tryReleaseShared()的返回值。</h5><h3 id="doReleaseShared"><a href="#doReleaseShared" class="headerlink" title="doReleaseShared()"></a>doReleaseShared()</h3><h5 id="此方法主要用于唤醒后继。下面是它的源码："><a href="#此方法主要用于唤醒后继。下面是它的源码：" class="headerlink" title="此方法主要用于唤醒后继。下面是它的源码："></a>此方法主要用于唤醒后继。下面是它的源码：</h5><pre><code class="lang-java">private void doReleaseShared() {
    for (;;) {
        Node h = head;
        if (h != null &amp;&amp; h != tail) {
            int ws = h.waitStatus;
            if (ws == Node.SIGNAL) {
                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))
                    continue;
                unparkSuccessor(h);//唤醒后继
            }
            else if (ws == 0 &amp;&amp;
                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))
                continue;
        }
        if (h == head)// head发生变化
            break;
    }
}
</code></pre>
<h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><h5 id="本节我们详解了独占和共享两种模式下获取-释放资源-acquire-release、acquireShared-releaseShared-的源码，相信大家都有一定认识了。值得注意的是，acquire-和acquireSahred-两种方法下，线程在等待队列中都是忽略中断的。AQS也支持响应中断的，acquireInterruptibly-acquireSharedInterruptibly-即是，这里相应的源码跟acquire-和acquireSahred-差不多，这里就不再详解了。"><a href="#本节我们详解了独占和共享两种模式下获取-释放资源-acquire-release、acquireShared-releaseShared-的源码，相信大家都有一定认识了。值得注意的是，acquire-和acquireSahred-两种方法下，线程在等待队列中都是忽略中断的。AQS也支持响应中断的，acquireInterruptibly-acquireSharedInterruptibly-即是，这里相应的源码跟acquire-和acquireSahred-差不多，这里就不再详解了。" class="headerlink" title="本节我们详解了独占和共享两种模式下获取-释放资源(acquire-release、acquireShared-releaseShared)的源码，相信大家都有一定认识了。值得注意的是，acquire()和acquireSahred()两种方法下，线程在等待队列中都是忽略中断的。AQS也支持响应中断的，acquireInterruptibly()/acquireSharedInterruptibly()即是，这里相应的源码跟acquire()和acquireSahred()差不多，这里就不再详解了。"></a>本节我们详解了独占和共享两种模式下获取-释放资源(acquire-release、acquireShared-releaseShared)的源码，相信大家都有一定认识了。值得注意的是，acquire()和acquireSahred()两种方法下，线程在等待队列中都是忽略中断的。AQS也支持响应中断的，acquireInterruptibly()/acquireSharedInterruptibly()即是，这里相应的源码跟acquire()和acquireSahred()差不多，这里就不再详解了。</h5><h2 id="简单应用"><a href="#简单应用" class="headerlink" title="简单应用"></a>简单应用</h2><h5 id="OK，下面我们就以AQS源码里的Mutex为例，讲一下AQS的简单应用。"><a href="#OK，下面我们就以AQS源码里的Mutex为例，讲一下AQS的简单应用。" class="headerlink" title="OK，下面我们就以AQS源码里的Mutex为例，讲一下AQS的简单应用。"></a>OK，下面我们就以AQS源码里的Mutex为例，讲一下AQS的简单应用。</h5><h3 id="Mutex（互斥锁）"><a href="#Mutex（互斥锁）" class="headerlink" title="Mutex（互斥锁）"></a>Mutex（互斥锁）</h3><h5 id="Mutex是一个不可重入的互斥锁实现。锁资源（AQS里的state）只有两种状态：0表示未锁定，1表示锁定。下边是Mutex的核心源码："><a href="#Mutex是一个不可重入的互斥锁实现。锁资源（AQS里的state）只有两种状态：0表示未锁定，1表示锁定。下边是Mutex的核心源码：" class="headerlink" title="Mutex是一个不可重入的互斥锁实现。锁资源（AQS里的state）只有两种状态：0表示未锁定，1表示锁定。下边是Mutex的核心源码："></a>Mutex是一个不可重入的互斥锁实现。锁资源（AQS里的state）只有两种状态：0表示未锁定，1表示锁定。下边是Mutex的核心源码：</h5><pre><code class="lang-java">class Mutex implements Lock, java.io.Serializable {
    // 自定义同步器
    private static class Sync extends AbstractQueuedSynchronizer {
        // 判断是否锁定状态
        protected boolean isHeldExclusively() {
            return getState() == 1;
        }
        // 尝试获取资源，立即返回。成功则返回true，否则false。
        public boolean tryAcquire(int acquires) {
            assert acquires == 1; // 这里限定只能为1个量
            if (compareAndSetState(0, 1)) {//state为0才设置为1，不可重入！
                setExclusiveOwnerThread(Thread.currentThread());//设置为当前线程独占资源
                return true;
            }
            return false;
        }
        // 尝试释放资源，立即返回。成功则为true，否则false。
        protected boolean tryRelease(int releases) {
            assert releases == 1; // 限定为1个量
            if (getState() == 0)//既然来释放，那肯定就是已占有状态了。只是为了保险，多层判断！
                throw new IllegalMonitorStateException();
            setExclusiveOwnerThread(null);
            setState(0);//释放资源，放弃占有状态
            return true;
        }
    }
    // 真正同步类的实现都依赖继承于AQS的自定义同步器！
    private final Sync sync = new Sync();
    //lock&lt;--&gt;acquire。两者语义一样：获取资源，即便等待，直到成功才返回。
    public void lock() {
        sync.acquire(1);
    }
    //tryLock&lt;--&gt;tryAcquire。两者语义一样：尝试获取资源，要求立即返回。成功则为true，失败则为false。
    public boolean tryLock() {
        return sync.tryAcquire(1);
    }
    //unlock&lt;--&gt;release。两者语文一样：释放资源。
    public void unlock() {
        sync.release(1);
    }
    //锁是否占有状态
    public boolean isLocked() {
        return sync.isHeldExclusively();
    }
}
</code></pre>
<h5 id="同步类在实现时一般都将自定义同步器（sync）定义为内部类，供自己使用；而同步类自己（Mutex）则实现某个接口，对外服务。当然，接口的实现要直接依赖sync，它们在语义上也存在某种对应关系！！而sync只用实现资源state的获取-释放方式tryAcquire-tryRelelase，至于线程的排队、等待、唤醒等，上层的AQS都已经实现好了，我们不用关心。"><a href="#同步类在实现时一般都将自定义同步器（sync）定义为内部类，供自己使用；而同步类自己（Mutex）则实现某个接口，对外服务。当然，接口的实现要直接依赖sync，它们在语义上也存在某种对应关系！！而sync只用实现资源state的获取-释放方式tryAcquire-tryRelelase，至于线程的排队、等待、唤醒等，上层的AQS都已经实现好了，我们不用关心。" class="headerlink" title="同步类在实现时一般都将自定义同步器（sync）定义为内部类，供自己使用；而同步类自己（Mutex）则实现某个接口，对外服务。当然，接口的实现要直接依赖sync，它们在语义上也存在某种对应关系！！而sync只用实现资源state的获取-释放方式tryAcquire-tryRelelase，至于线程的排队、等待、唤醒等，上层的AQS都已经实现好了，我们不用关心。"></a>同步类在实现时一般都将自定义同步器（sync）定义为内部类，供自己使用；而同步类自己（Mutex）则实现某个接口，对外服务。当然，接口的实现要直接依赖sync，它们在语义上也存在某种对应关系！！而sync只用实现资源state的获取-释放方式tryAcquire-tryRelelase，至于线程的排队、等待、唤醒等，上层的AQS都已经实现好了，我们不用关心。</h5><h5 id="除了Mutex，ReentrantLock-CountDownLatch-Semphore这些同步类的实现方式都差不多，不同的地方就在获取-释放资源的方式tryAcquire-tryRelelase。掌握了这点，AQS的核心便被攻破了！"><a href="#除了Mutex，ReentrantLock-CountDownLatch-Semphore这些同步类的实现方式都差不多，不同的地方就在获取-释放资源的方式tryAcquire-tryRelelase。掌握了这点，AQS的核心便被攻破了！" class="headerlink" title="除了Mutex，ReentrantLock/CountDownLatch/Semphore这些同步类的实现方式都差不多，不同的地方就在获取-释放资源的方式tryAcquire-tryRelelase。掌握了这点，AQS的核心便被攻破了！"></a>除了Mutex，ReentrantLock/CountDownLatch/Semphore这些同步类的实现方式都差不多，不同的地方就在获取-释放资源的方式tryAcquire-tryRelelase。掌握了这点，AQS的核心便被攻破了！</h5><h5 id="OK，至此，整个AQS的讲解也要落下帷幕了。希望本文能够对学习Java并发编程的同学有所借鉴，中间写的有不对的地方，也欢迎讨论和指正"><a href="#OK，至此，整个AQS的讲解也要落下帷幕了。希望本文能够对学习Java并发编程的同学有所借鉴，中间写的有不对的地方，也欢迎讨论和指正" class="headerlink" title="OK，至此，整个AQS的讲解也要落下帷幕了。希望本文能够对学习Java并发编程的同学有所借鉴，中间写的有不对的地方，也欢迎讨论和指正~"></a>OK，至此，整个AQS的讲解也要落下帷幕了。希望本文能够对学习Java并发编程的同学有所借鉴，中间写的有不对的地方，也欢迎讨论和指正~</h5><h3 id="文章转载自：https-www-cnblogs-com-waterystone-p-4920797-html"><a href="#文章转载自：https-www-cnblogs-com-waterystone-p-4920797-html" class="headerlink" title="文章转载自：https://www.cnblogs.com/waterystone/p/4920797.html"></a>文章转载自：<a href="https://www.cnblogs.com/waterystone/p/4920797.html" target="_blank" rel="external">https://www.cnblogs.com/waterystone/p/4920797.html</a></h3></div>
    </article>
</section>

<div class="clear"></div>



    <footer id="footer">
  <div class="foot">
    <!-- <a id="gotop">TOP</a> -->
    <!-- <div id="copyright">Copyright &copy; 2016 <a href="#" target="_blank">WangWenXiang</a><br>
       Power by <a href="https://github.com/winx402" target="_blank">Github Pages</a> |
      <a href="https://hexo.io/" target="_blank">HEXO</a></div> -->
      <div id="copyright">还没想好要写什么</div>
  </div>
</footer>

</div>
<div class="img-view">
    <span><img src="/img/guide.jpeg"></span>
</div>
<script type="text/javascript" src="/js/base.js"></script>
<script type="text/javascript" async
            src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>
<link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.2.0/styles/github.min.css">
<script src="//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>
</body>
</html>
