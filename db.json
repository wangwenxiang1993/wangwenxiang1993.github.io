{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/img/arithmetic/BinaryTree.png","path":"img/arithmetic/BinaryTree.png","modified":1,"renderable":0},{"_id":"source/img/book/crowd.png","path":"img/book/crowd.png","modified":1,"renderable":0},{"_id":"source/img/book/love.jpeg","path":"img/book/love.jpeg","modified":1,"renderable":0},{"_id":"source/img/book/fatherAndSon.jpeg","path":"img/book/fatherAndSon.jpeg","modified":1,"renderable":0},{"_id":"source/img/book/coreJavaVolume1.jpeg","path":"img/book/coreJavaVolume1.jpeg","modified":1,"renderable":0},{"_id":"source/img/book/loveYou.jpeg","path":"img/book/loveYou.jpeg","modified":1,"renderable":0},{"_id":"source/img/book/milk.jpeg","path":"img/book/milk.jpeg","modified":1,"renderable":0},{"_id":"source/img/book/thinkingInJava.jpeg","path":"img/book/thinkingInJava.jpeg","modified":1,"renderable":0},{"_id":"source/img/pvalue/pvalue7.png","path":"img/pvalue/pvalue7.png","modified":1,"renderable":0},{"_id":"source/img/zookeeper/zookeeper1.jpg","path":"img/zookeeper/zookeeper1.jpg","modified":1,"renderable":0},{"_id":"source/img/zookeeper/role.jpg","path":"img/zookeeper/role.jpg","modified":1,"renderable":0},{"_id":"source/img/zookeeper/zookeeper2.jpg","path":"img/zookeeper/zookeeper2.jpg","modified":1,"renderable":0},{"_id":"source/img/zookeeper/zookeeperLc.jpg","path":"img/zookeeper/zookeeperLc.jpg","modified":1,"renderable":0},{"_id":"source/img/zookeeper/zookeeperLc2.jpg","path":"img/zookeeper/zookeeperLc2.jpg","modified":1,"renderable":0},{"_id":"source/img/zookeeper/zookeeperLc3.jpg","path":"img/zookeeper/zookeeperLc3.jpg","modified":1,"renderable":0},{"_id":"source/img/zookeeper/zookeeperLc4.jpg","path":"img/zookeeper/zookeeperLc4.jpg","modified":1,"renderable":0},{"_id":"source/img/zookeeper/zookeeperLc5.jpg","path":"img/zookeeper/zookeeperLc5.jpg","modified":1,"renderable":0},{"_id":"source/img/zookeeper/zookeeperModel.jpg","path":"img/zookeeper/zookeeperModel.jpg","modified":1,"renderable":0},{"_id":"themes/maybe/source/css/style.css","path":"css/style.css","modified":1,"renderable":1},{"_id":"themes/maybe/source/css/highlight.css","path":"css/highlight.css","modified":1,"renderable":1},{"_id":"themes/maybe/source/css/font-awesome.min.css","path":"css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/maybe/source/img/photo.png","path":"img/photo.png","modified":1,"renderable":1},{"_id":"themes/maybe/source/js/base.js","path":"js/base.js","modified":1,"renderable":1},{"_id":"themes/maybe/source/js/canvas-nest.min.js","path":"js/canvas-nest.min.js","modified":1,"renderable":1},{"_id":"themes/maybe/source/js/highlight.pack.js","path":"js/highlight.pack.js","modified":1,"renderable":1},{"_id":"themes/maybe/source/js/jquery.tagcloud.js","path":"js/jquery.tagcloud.js","modified":1,"renderable":1},{"_id":"source/img/pvalue/pvalue1.png","path":"img/pvalue/pvalue1.png","modified":1,"renderable":0},{"_id":"source/img/pvalue/pvalue2.png","path":"img/pvalue/pvalue2.png","modified":1,"renderable":0},{"_id":"themes/maybe/source/fonts/FontAwesome.otf","path":"fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/maybe/source/fonts/fontawesome-webfont.eot","path":"fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/maybe/source/fonts/fontawesome-webfont.woff","path":"fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/maybe/source/img/favicon.ico","path":"img/favicon.ico","modified":1,"renderable":1},{"_id":"themes/maybe/source/fonts/fontawesome-webfont.woff2","path":"fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/maybe/source/img/guide.jpeg","path":"img/guide.jpeg","modified":1,"renderable":1},{"_id":"themes/maybe/source/js/jquery-1.7.1.min.js","path":"js/jquery-1.7.1.min.js","modified":1,"renderable":1},{"_id":"source/img/book/varietyShop.jpeg","path":"img/book/varietyShop.jpeg","modified":1,"renderable":0},{"_id":"source/img/life/2016-bg.jpg","path":"img/life/2016-bg.jpg","modified":1,"renderable":0},{"_id":"source/img/life/2016-roommate.jpeg","path":"img/life/2016-roommate.jpeg","modified":1,"renderable":0},{"_id":"source/img/pvalue/pvalue3.jpeg","path":"img/pvalue/pvalue3.jpeg","modified":1,"renderable":0},{"_id":"source/img/pvalue/pvalue4.png","path":"img/pvalue/pvalue4.png","modified":1,"renderable":0},{"_id":"source/img/pvalue/pvalue5.png","path":"img/pvalue/pvalue5.png","modified":1,"renderable":0},{"_id":"source/img/pvalue/pvalue6.png","path":"img/pvalue/pvalue6.png","modified":1,"renderable":0},{"_id":"themes/maybe/source/fonts/fontawesome-webfont.ttf","path":"fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/maybe/source/img/home-bg.jpg","path":"img/home-bg.jpg","modified":1,"renderable":1},{"_id":"themes/maybe/source/img/note-bg.jpg","path":"img/note-bg.jpg","modified":1,"renderable":1},{"_id":"source/img/life/2016-qunar.jpeg","path":"img/life/2016-qunar.jpeg","modified":1,"renderable":0},{"_id":"themes/maybe/source/img/life-bg.jpg","path":"img/life-bg.jpg","modified":1,"renderable":1},{"_id":"themes/maybe/source/img/read-bg.jpg","path":"img/read-bg.jpg","modified":1,"renderable":1},{"_id":"themes/maybe/source/fonts/fontawesome-webfont.svg","path":"fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/maybe/source/img/project-bg.jpg","path":"img/project-bg.jpg","modified":1,"renderable":1},{"_id":"themes/maybe/source/img/guide.png","path":"img/guide.png","modified":1,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"716d0bc21cd94a698461a5840683dd89204f0b06","modified":1471250308000},{"_id":"source/_posts/resume.md","hash":"d3d3ef1aed3e740036e35e97243d5fce1342b8ae","modified":1486996714000},{"_id":"source/img/.DS_Store","hash":"41189ec24957863c4c5312c4375aad6bc07d1f9a","modified":1487431765000},{"_id":"themes/maybe/layout/book.ejs","hash":"6a009727992f46be1128ad0a4f2c5a746e0c9409","modified":1486429913000},{"_id":"themes/maybe/layout/layout.ejs","hash":"22315b75c6fa4ee47e939dcd96f2a75442db2971","modified":1486479130000},{"_id":"themes/maybe/layout/category.ejs","hash":"38d62125a1e0c9a8ea602a03b6d27949aea98162","modified":1486392257000},{"_id":"themes/maybe/layout/index.ejs","hash":"1e14b73b3d56be216921ceae2c927a70978961ad","modified":1483695965000},{"_id":"themes/maybe/layout/post.ejs","hash":"7894bb0c10b9767d5bce302cdffcaaa2b1446379","modified":1486992697000},{"_id":"themes/maybe/layout/tag.ejs","hash":"6d0aace6ac00a4229c9d8e2851b4b619d0c2790a","modified":1487231150000},{"_id":"themes/maybe/source/.DS_Store","hash":"145f8d43dac5895bd20c95e49bc006e0e7c9326a","modified":1486346696000},{"_id":"source/_posts/arithmetic/JAVA-pValue.md","hash":"076ff6acc2dc56161762184e8ecc3e2214683d20","modified":1487230970000},{"_id":"source/_posts/arithmetic/arithmetic-17-02-18.md","hash":"3108ee54e8a18751c4b15d783506e98f99b16f10","modified":1487431989000},{"_id":"source/_posts/arithmetic/arithmetic-17-02-16.md","hash":"189da1baaa1099a73afe6f2cb6c22e96fd57cbb4","modified":1487418898000},{"_id":"source/_posts/life/summary-2016.md","hash":"d22528eebddf3f702dd81f46e8c9a2806bce303f","modified":1486430393000},{"_id":"source/_posts/note/vimNotes.md","hash":"45aa23603b1eef8ea212d291280bf27d25230918","modified":1483696483000},{"_id":"source/_posts/note/zookeeper.md","hash":"d0f7959e7c08cbbe4af080d4a1ab064828622e20","modified":1483696483000},{"_id":"source/_posts/read/coreJava.md","hash":"7021283bbadde925a917504b429cdf4dd0f42f08","modified":1486261121000},{"_id":"source/_posts/read/economics.md","hash":"5e5af10016bda64d9619b9bb876075d79c3b32d8","modified":1486261285000},{"_id":"source/_posts/read/crowd.md","hash":"4bfcd3431bef654cbee89c69abb64c11a1b36c34","modified":1486262309000},{"_id":"source/_posts/read/fatherAndSon.md","hash":"f213cc96df6d9cddd70335f7dcd5f39926d2ebea","modified":1486261172000},{"_id":"source/_posts/read/love.md","hash":"36d9ba377ac4458e22aaa24787269959cbd90410","modified":1486261032000},{"_id":"source/_posts/read/love0.md","hash":"9ffae64195f9cf2e4152929221efaca1af5beb4b","modified":1486261421000},{"_id":"source/_posts/read/loveYou.md","hash":"dc3db9e1e35dcfd83d9b35a176b69775a11c1d79","modified":1486261249000},{"_id":"source/img/arithmetic/BinaryTree.png","hash":"d9ef674ba717242f55c9c5decf2aae551e207069","modified":1487431784000},{"_id":"source/_posts/read/thinkInJava.md","hash":"df08e35d7da6f6aa78bf9d6010f184b81bd6aa7c","modified":1486261506000},{"_id":"source/img/book/crowd.png","hash":"c361d7acab3ce2677fe3a36ee7e60a72798ed0b8","modified":1485348878000},{"_id":"source/img/book/love.jpeg","hash":"10370ec4f714a1db9e039eccb697f3755ac51012","modified":1485348878000},{"_id":"source/img/book/fatherAndSon.jpeg","hash":"9e646337ead2f99132e452c8b1d2990ff5bcea6e","modified":1485348879000},{"_id":"source/img/book/coreJavaVolume1.jpeg","hash":"8ac34b32089baa4b522bd353339e79f74a807ca2","modified":1485348879000},{"_id":"source/img/book/loveYou.jpeg","hash":"b8b1df875965e3064b30cbdeecb507e3c4355371","modified":1485348879000},{"_id":"source/img/book/milk.jpeg","hash":"8689c651dbb9f897e3a5071c4c49c43050a1cae4","modified":1485348878000},{"_id":"source/img/book/thinkingInJava.jpeg","hash":"d06ecc2cc3ed14957e01383288588b83368de1b5","modified":1485348878000},{"_id":"source/img/pvalue/pvalue7.png","hash":"bfc9e87c820598e35401f3e526f6f57101efe170","modified":1486828656000},{"_id":"source/img/zookeeper/zookeeper1.jpg","hash":"a0fc99c61a07863e1e2e6578644b9b4c8d7e9a9d","modified":1480596415000},{"_id":"source/img/zookeeper/role.jpg","hash":"d122fcac106bc7683d39df78e0cdfd9872ffdce2","modified":1480595262000},{"_id":"source/img/zookeeper/zookeeper2.jpg","hash":"90d4398129d68d137a308b9b2af2cd85777f5daf","modified":1480596492000},{"_id":"source/img/zookeeper/zookeeperLc.jpg","hash":"f0c2c035130233d388a1d5339b9796182e890223","modified":1480595858000},{"_id":"source/img/zookeeper/zookeeperLc2.jpg","hash":"97825787eebfb7f5076792a0022911d45808f24a","modified":1480595954000},{"_id":"source/img/zookeeper/zookeeperLc3.jpg","hash":"3279498c50ea972f1e5abbad70c0cb634faa2284","modified":1480596037000},{"_id":"source/img/zookeeper/zookeeperLc4.jpg","hash":"83582be653544a3717b8a67199fae5a2e5f871a9","modified":1480596134000},{"_id":"source/img/zookeeper/zookeeperLc5.jpg","hash":"da3a39de610f48d2eba48eb72105b0b11dbb34f3","modified":1480596265000},{"_id":"themes/maybe/layout/_partial/article.ejs","hash":"821b4217e69e633d68749cbdc5e5edf4b2328498","modified":1487264535000},{"_id":"source/img/zookeeper/zookeeperModel.jpg","hash":"004e3d74e27234ca7a74ac15af37a3bbeac8331d","modified":1480595456000},{"_id":"themes/maybe/layout/_partial/books.ejs","hash":"07402436aeeb014f24b085fa84182170f0d4bbe9","modified":1486744084000},{"_id":"themes/maybe/layout/_partial/footer.ejs","hash":"b3f8e67b21b76b851800ae189991e089f488eb27","modified":1486780049000},{"_id":"themes/maybe/layout/_partial/info.ejs","hash":"a14ab3735947f3f9696f5371bdbdb17733bfcff8","modified":1487230640000},{"_id":"themes/maybe/layout/_partial/posts.ejs","hash":"4baa3d1079057375422bde4f21cb4127b29b6f3a","modified":1487420790000},{"_id":"themes/maybe/layout/_partial/resume.ejs","hash":"bd559022a17bf00520e5dee65deb1317338bbf02","modified":1486996548000},{"_id":"themes/maybe/layout/_partial/info_min.ejs","hash":"9edecf84880182b7670492b03320561190aca82b","modified":1487419706000},{"_id":"themes/maybe/layout/_partial/title.ejs","hash":"80109b9a53ccd780ed2d5622fc27160d35dfa996","modified":1486466312000},{"_id":"themes/maybe/source/css/style.css","hash":"5cc4ad34db2b494a1c67ae441f76c361e6460948","modified":1487422992000},{"_id":"themes/maybe/source/css/highlight.css","hash":"b89f3798b9fdce33ba7618077cfc35a95a20ffe3","modified":1476788773000},{"_id":"themes/maybe/source/css/font-awesome.min.css","hash":"a3ee202873390015bbebdce1d4a150c8208043c5","modified":1483593217000},{"_id":"themes/maybe/source/img/.DS_Store","hash":"888a415fad3d0407b24e69eebdbdf1fe0e749fdc","modified":1486398010000},{"_id":"themes/maybe/source/img/photo.png","hash":"dab7b9e06f7a1321ad178288d17ac0cf474e17df","modified":1486397193000},{"_id":"themes/maybe/source/js/base.js","hash":"c276e5e724fa2dc8c2a1f890109595fc3e358134","modified":1486870229000},{"_id":"themes/maybe/source/js/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1471182397000},{"_id":"themes/maybe/source/js/highlight.pack.js","hash":"c65d53d610fd48e1fbac66ac096699a4be8860fe","modified":1471182397000},{"_id":"themes/maybe/source/js/jquery.tagcloud.js","hash":"6d20fd10cc7ac4c2c94f206ac3285334b297cbf9","modified":1477899364000},{"_id":"source/img/pvalue/pvalue1.png","hash":"cee2568e455fd434c2255f9aea92b045c598fd1c","modified":1483114277000},{"_id":"source/img/pvalue/pvalue2.png","hash":"8a4671f34809d8c4fe55a015dc8da626e58d581e","modified":1483114907000},{"_id":"themes/maybe/source/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1473222980000},{"_id":"themes/maybe/source/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1473222980000},{"_id":"themes/maybe/source/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1473222980000},{"_id":"themes/maybe/source/img/favicon.ico","hash":"306c23de9697d77d5a123ecb10eb4b3cf1ac3b49","modified":1471182397000},{"_id":"themes/maybe/source/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1473222980000},{"_id":"themes/maybe/source/img/guide.jpeg","hash":"5f82a588eef9afb72264df0e9ea68fe17911dfef","modified":1486300905000},{"_id":"themes/maybe/source/js/jquery-1.7.1.min.js","hash":"d1e1f3f0828fa66fb5744f42bc912694e06300f9","modified":1471182397000},{"_id":"source/img/book/varietyShop.jpeg","hash":"0198030d9d492b101a5deec63621d9746961aad8","modified":1485348879000},{"_id":"source/img/life/2016-bg.jpg","hash":"6710230ec17d4bebaaf0f8a457512433abf0dc97","modified":1486428811000},{"_id":"source/img/life/2016-roommate.jpeg","hash":"4e5a47e2d9aef492184e19b93a6b2aa93e029c8e","modified":1485169250000},{"_id":"source/img/pvalue/pvalue3.jpeg","hash":"8f7a050e342907a74e3ad35c3e52076eba5ac2f1","modified":1483502418000},{"_id":"source/img/pvalue/pvalue4.png","hash":"bae37ceaaa098f40ac342af9dc676e7dc00e0411","modified":1486826820000},{"_id":"source/img/pvalue/pvalue5.png","hash":"39a6690b579ee31d1ab6dab8dcc32456aaf787f8","modified":1486826966000},{"_id":"source/img/pvalue/pvalue6.png","hash":"5231c3636459437c1b3e9493dcaa3e82f7e9cb1d","modified":1486828243000},{"_id":"themes/maybe/layout/_partial/_widget/url.ejs","hash":"88f77381dee52a3f720fb21722502708b4af0926","modified":1485006392000},{"_id":"themes/maybe/layout/_partial/post/date.ejs","hash":"1a35973ab623f279b073ca6c526f547afb250906","modified":1483623137000},{"_id":"themes/maybe/source/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1473222980000},{"_id":"themes/maybe/source/img/home-bg.jpg","hash":"990f6f9dd0ecb5348bfcc47305553d58c0d8f326","modified":1486306829000},{"_id":"themes/maybe/source/img/note-bg.jpg","hash":"3e03d6c9590ea59075c7f5538d7da389f640fab6","modified":1486395869000},{"_id":"source/img/life/2016-qunar.jpeg","hash":"076fc1b0b7008e0e183853ebbc5fe8160c704406","modified":1485169250000},{"_id":"themes/maybe/source/img/life-bg.jpg","hash":"967bc3a78eaf83b9f27fd7e02618083b2446d45c","modified":1486392691000},{"_id":"themes/maybe/source/img/read-bg.jpg","hash":"3d87f8a0606d71d41d16a8adbce4a1d9f1d20512","modified":1486387610000},{"_id":"themes/maybe/source/fonts/fontawesome-webfont.svg","hash":"c0522272bbaef2acb3d341912754d6ea2d0ecfc0","modified":1473222980000},{"_id":"themes/maybe/source/img/project-bg.jpg","hash":"309aa99f6db30ab07caeeb620e5b3d0f22f326b3","modified":1486395626000},{"_id":"themes/maybe/source/img/guide.png","hash":"01385d1071ee75c9e7eb358ec113b9eaaf097bf3","modified":1486301313000}],"Category":[{"name":"read","_id":"cizbemkmk000dsebfd9865xpj"}],"Data":[],"Page":[],"Post":[{"layout":"post","title":"王文祥的简历","date":"2017-02-12T16:00:00.000Z","type":"resume","_content":"","source":"_posts/resume.md","raw":"---\nlayout: post\ntitle: 王文祥的简历\ndate: 2017/02/13\ntype: resume\n---\n","slug":"resume","published":1,"updated":"2017-02-13T14:38:34.000Z","comments":1,"photos":[],"link":"","_id":"cizbemkky0000sebfj7gqoopu","content":"","excerpt":"","more":""},{"layout":"post","title":"假设检验中的P值计算-JAVA","date":"2016-12-27T16:00:00.000Z","_content":"<script type=\"text/javascript\" async\n            src=\"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML\">\n    </script>\n\n##### 　　最近产品提出需求，对于ab实验，希望能够通过实验数据计算出P值，以对数据的准确性做一个直观判断。最开始不知道P值是一个什么概念，觉得应该很简单，baidu或者google以下应该会有很多开源的代码或者jar包；又或者是自己将P值公式实现便可。但是一番查找后发现没有想的这么简单，网络上对于P值得计算过程大多含糊不清，更别提完整的计算代码。最后没办法，只有通过自己拿起概率论书本重新进行学习，以下便记录自己从P值是什么到java实现的一些细节。\n<!--more-->\n\n## 1. 统计学中P值\n##### 　　P值是指当假设为真时所得到的观察结果的概率，简单讲P值就是概率，反映某一事件发生的可能性大小。下面几个比较重要的基础概念对于理解P值的意义会有帮助。\n### 1.1 概率论中几个比较重要的基础概念\n#### 1.1.1 原假设与备择假设：\n##### __原假设（H<sub>0</sub>）__：通常将研究者想手机证据予以反对的假设称为原假设，用H<sub>0</sub>表示；\n##### __备择假设（H<sub>1</sub>）__：通常将研究者想收集证据予以支持的假设称为备择假设，或称研究假设，用H<sub>1</sub>活H<sub>2</sub>表示。\n\n##### 　　举个栗子：\n<div class=\"highlighter-rouge\"><pre class=\"highlight\"><code>某品牌洗涤剂在产品说明书中声称：平均净含量不少于500g。从消费者利益出发，有关研究人员要通过抽检其中的一批产品来验证该产品制造商的说明是否属实。    \n解：对于该洗涤剂的平均含量的真值为μ。如果抽检的结果发现μ<500，则表明该产品说明书中关于其净含量的内容是不真实的。一般来说，研究者抽检的意图是倾向于证实这种洗涤剂的平均净含量不符合说明书中的概述，因为这不符合说明书的陈述。如果研究者对于产品说明丝毫没有质疑，也就没有必要抽检了。所以μ<500是研究者想要收集证据支持的观点。    \n<br><h6>H<sub>0</sub>:μ≥500(净含量符合说明书);</h6><h6>H<sub>1</sub>:μ&lt;500(净含量不符合说明书)。</h6></code></pre></div>\n\n\n<div class=\"highlighter-rouge\"><pre class=\"highlight\"><code>一家研究机构估计，某城市中家庭拥有汽车的比例超过30%。为了验证这一估计是否正确，该研究机构随机抽取了一个样本进行检验。     \n解：设该城市中家庭拥有汽车的比例真值为π。显然，研究者想收集证据予以支持的假设是\"该城市中家庭拥有汽车的比例超过30%\"。因此建立的原假设与备择假设应为     \n<h6>H<sub>0</sub>:π≤30%（家庭拥有汽车的比例不超过30%）;</h6><h6>H<sub>1</sub>:π>30%（家庭拥有汽车的比例超过30%）。</h6></code></pre></div>\n\n* 原假设和备择假设是一个完备事件组，而且互相对立。也就是说在一项假设检验中，必有且只有一个成立；\n* 在假设检验中，等号\"=\"总是放在原假设上。   \n\n#### 1.1.2 单侧检验和双侧检验：\n##### __单侧检验__：备择假设具有特定的方向性，并含有符号\">\"或\"<\"的假设检验；\n##### __双侧检验__：备择假设没有特定的方向性，并含有符号\"≠\"的假设检验。     \n![假设检验的基本形式](../../img/pvalue/pvalue1.png)    <div class='img-note'>假设检验的基本形式</div>\n\n#### 1.1.3 两类错误与显著水平    \n##### 　　如前所述，原假设与备择假设不能同时成立，我们要么拒绝原假设，要么不拒绝原假设。我们希望的情况是：当原假设正确时没有拒绝它，当原假设不正确时拒绝它。但是我们无法保证不犯错。假设检验中过程中可能发生以下两类错误：    \n##### __I类错误__：当原假设为真是拒绝原假设，所犯的错误称为第I类错误；    \n##### __II类错误__：当原假设为假时没有拒绝原假设，所犯错误称为第II类错误。    \n![假设检验的结论与后果](../../img/pvalue/pvalue2.png)   <div class='img-note'>假设检验的结论与后果</div>\n\n##### 　　只有当原假设被拒绝时，我们才会犯第I类错误；只有当原假设未被拒绝时，我们才会犯第II类错误。因此，我们可以不犯第I类错误或不犯第II类错误，但不可能两类错误都不犯。两类错误就像一个跷跷板，当一个概率增大时，另一个减小。人们只能在两类错误的发生概率之间进行平衡。一般来说，发生哪一类错误的后果更为严重，就应该首要控制哪类错误发生的概率，但由于犯第I类错误的概率是可以又研究者控制的，因为此在假设检验中，人们往往先控制第I类错误的发生概率。\n\n``\n发生第I类错误的概率常被用于度量检验结论的可靠性，并将这一概率称为显著性水平，记为α。\n``\n\n##### 　　__显著水平__ 是人们事先指定的犯第I类错误概率α的最大允许值。显著水平α越小，犯第I类错误的可能性自然就越小，但犯第II类错误的可能性则随之增大。作为一个普遍使用的原则，人们通常选择显著性水平为0.05或比0.05更小的概率。\n\n#### 1.1.4 标准化检测量与拒绝域\n\n##### 　　__检验统计量__ 实际上是总体参数的点估计量，但点估计量并不能直接作为检验的统计量，只有将其标准化后，才能用于度量它与原假设的参数之间的差异程度。实际上，假设检验中所用的检验统计量都是标准化检验统计量，它反映了点估计量（比如样本均值）与假设的总体参数（比如假设的总体均值）相比相差了多少个标准差。\n\n$$标准化检验统计量 = \\frac{点估计量 - 假设值}{点估计量的抽样标准差}$$\n\n##### 　　__拒绝域__ 能够拒绝原假设的检验统计量的所有可能取值的集合。是由显著性水平α所围成的区域。如果利用样本观测结果计算出来的检验统计量的具体数值落在了拒绝域内，就拒绝原假设，否则就不拒绝原假设。\n![显著性水平、拒绝域和临界值](../../img/pvalue/pvalue3.jpeg)<div class='img-note'>显著性水平、拒绝域和临界值</div>\n\n##### 　　当样本容量固定时，拒绝域的面积随α的减小而减小。α值越小，拒绝域假设所需的检验统计量的临界值与原假设的参数值就越远。\n\n### 1.2 利用P值进行决策\n##### 　　显著性水平α是在检验之前确定的，这也就意味着我们事先确定了拒绝域。这样，不论检验统计量的值是大是小，只要它的值落入拒绝域就拒绝原假设，否者就不拒绝原假设。这种固定的显著性水平α对检验结果只能提供检验结论可靠性的一个大致范围，无法给出观测数据与原假设之间不一致程度的精确度量。\n\n##### 　　__P值__ 在原假设为真的条件下，检验统计量的观察值大于或等于其计算值的概率，称为P值。P值是反映实际观测到的数据与原假设之间不一致程度的一个概率值。P值越小，说明实际观测到的数据与原假设之间不一致的程度就越大，检验的结果也就越显著。\n\n### 1.3 一个总体参数的检验\n##### 　　当我们研究一个总体时，要检验的参数主要是总体均值μ、总体比例π和总体方差σ<SUP>2</SUP>。由于检验的参数不同，计算检验统计量的方法也有所不同。\n\n#### 1.3.1 总体均值的检验\n##### 　　对于总体均值进行假设检验，采用什么检验步骤和检验统计量取决于我们所抽取的样本是大样本（n≥30）还是小样本（n<30），此外还需要区分总体是否服从正太分布、总体方差σ<SUP>2</SUP>是否已知等几种情况。\n![大样本情况下一个总体均值的检验方法](../../img/pvalue/pvalue4.png)    <div class='img-note'>大样本情况下一个总体均值的检验方法</div>\n![小样本情况下一个总体均值的检验方法](../../img/pvalue/pvalue5.png)    <div class='img-note'>小样本情况下一个总体均值的检验方法</div>\n\n##### 　　Z表示转换为标准正太分布下的检验统计量。\n\n#### 1.3.2 总体比例的检验\n##### 　　总体比例是指总体中具有某种相同特征的个体所占的比例，这些特征可以是数据型的（如一定的重量、一定的厚度或一定规格等），也可以是品质型的（如男女比例、学历等级、职称高低等）。\n##### 　　在构造检验统计量时，我们仍然利用样本比例p与总体比例π之间的距离等于多少个标准差来衡量，因为在大样本情况下统计量p近似服从正太分布，而统计量\n$$z = \\frac{P - π_0}{\\sqrt{\\frac{π_0(1-π_0)}{n}}}$$\n\n![大样本情况下一个总体比例的检验方法](../../img/pvalue/pvalue6.png)    <div class='img-note'>大样本情况下一个总体比例的检验方法</div>\n\n### 1.4 两个总体参数的检验\n##### 　　在实际研究中，我们常常要比较两个总体的差异，如一所学校的重点班和普通班两个班级学生的英语成绩是否有显著差异；生产企业在改进生产线后的平均产量与原生产线的平均产量相比是否有显著提高等等。\n![两个总体均值之差的三种基本假设检验形式](../../img/pvalue/pvalue7.png)    <div class='img-note'>两个总体均值之差的三种基本假设检验形式</div>\n\n## 2. JAVA实现P值计算\n","source":"_posts/arithmetic/JAVA-pValue.md","raw":"---\nlayout: post\ntitle: 假设检验中的P值计算-JAVA\ndate: 2016/12/28\ntags: [arithmetic, index]\n---\n<script type=\"text/javascript\" async\n            src=\"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML\">\n    </script>\n\n##### 　　最近产品提出需求，对于ab实验，希望能够通过实验数据计算出P值，以对数据的准确性做一个直观判断。最开始不知道P值是一个什么概念，觉得应该很简单，baidu或者google以下应该会有很多开源的代码或者jar包；又或者是自己将P值公式实现便可。但是一番查找后发现没有想的这么简单，网络上对于P值得计算过程大多含糊不清，更别提完整的计算代码。最后没办法，只有通过自己拿起概率论书本重新进行学习，以下便记录自己从P值是什么到java实现的一些细节。\n<!--more-->\n\n## 1. 统计学中P值\n##### 　　P值是指当假设为真时所得到的观察结果的概率，简单讲P值就是概率，反映某一事件发生的可能性大小。下面几个比较重要的基础概念对于理解P值的意义会有帮助。\n### 1.1 概率论中几个比较重要的基础概念\n#### 1.1.1 原假设与备择假设：\n##### __原假设（H<sub>0</sub>）__：通常将研究者想手机证据予以反对的假设称为原假设，用H<sub>0</sub>表示；\n##### __备择假设（H<sub>1</sub>）__：通常将研究者想收集证据予以支持的假设称为备择假设，或称研究假设，用H<sub>1</sub>活H<sub>2</sub>表示。\n\n##### 　　举个栗子：\n<div class=\"highlighter-rouge\"><pre class=\"highlight\"><code>某品牌洗涤剂在产品说明书中声称：平均净含量不少于500g。从消费者利益出发，有关研究人员要通过抽检其中的一批产品来验证该产品制造商的说明是否属实。    \n解：对于该洗涤剂的平均含量的真值为μ。如果抽检的结果发现μ<500，则表明该产品说明书中关于其净含量的内容是不真实的。一般来说，研究者抽检的意图是倾向于证实这种洗涤剂的平均净含量不符合说明书中的概述，因为这不符合说明书的陈述。如果研究者对于产品说明丝毫没有质疑，也就没有必要抽检了。所以μ<500是研究者想要收集证据支持的观点。    \n<br><h6>H<sub>0</sub>:μ≥500(净含量符合说明书);</h6><h6>H<sub>1</sub>:μ&lt;500(净含量不符合说明书)。</h6></code></pre></div>\n\n\n<div class=\"highlighter-rouge\"><pre class=\"highlight\"><code>一家研究机构估计，某城市中家庭拥有汽车的比例超过30%。为了验证这一估计是否正确，该研究机构随机抽取了一个样本进行检验。     \n解：设该城市中家庭拥有汽车的比例真值为π。显然，研究者想收集证据予以支持的假设是\"该城市中家庭拥有汽车的比例超过30%\"。因此建立的原假设与备择假设应为     \n<h6>H<sub>0</sub>:π≤30%（家庭拥有汽车的比例不超过30%）;</h6><h6>H<sub>1</sub>:π>30%（家庭拥有汽车的比例超过30%）。</h6></code></pre></div>\n\n* 原假设和备择假设是一个完备事件组，而且互相对立。也就是说在一项假设检验中，必有且只有一个成立；\n* 在假设检验中，等号\"=\"总是放在原假设上。   \n\n#### 1.1.2 单侧检验和双侧检验：\n##### __单侧检验__：备择假设具有特定的方向性，并含有符号\">\"或\"<\"的假设检验；\n##### __双侧检验__：备择假设没有特定的方向性，并含有符号\"≠\"的假设检验。     \n![假设检验的基本形式](../../img/pvalue/pvalue1.png)    <div class='img-note'>假设检验的基本形式</div>\n\n#### 1.1.3 两类错误与显著水平    \n##### 　　如前所述，原假设与备择假设不能同时成立，我们要么拒绝原假设，要么不拒绝原假设。我们希望的情况是：当原假设正确时没有拒绝它，当原假设不正确时拒绝它。但是我们无法保证不犯错。假设检验中过程中可能发生以下两类错误：    \n##### __I类错误__：当原假设为真是拒绝原假设，所犯的错误称为第I类错误；    \n##### __II类错误__：当原假设为假时没有拒绝原假设，所犯错误称为第II类错误。    \n![假设检验的结论与后果](../../img/pvalue/pvalue2.png)   <div class='img-note'>假设检验的结论与后果</div>\n\n##### 　　只有当原假设被拒绝时，我们才会犯第I类错误；只有当原假设未被拒绝时，我们才会犯第II类错误。因此，我们可以不犯第I类错误或不犯第II类错误，但不可能两类错误都不犯。两类错误就像一个跷跷板，当一个概率增大时，另一个减小。人们只能在两类错误的发生概率之间进行平衡。一般来说，发生哪一类错误的后果更为严重，就应该首要控制哪类错误发生的概率，但由于犯第I类错误的概率是可以又研究者控制的，因为此在假设检验中，人们往往先控制第I类错误的发生概率。\n\n``\n发生第I类错误的概率常被用于度量检验结论的可靠性，并将这一概率称为显著性水平，记为α。\n``\n\n##### 　　__显著水平__ 是人们事先指定的犯第I类错误概率α的最大允许值。显著水平α越小，犯第I类错误的可能性自然就越小，但犯第II类错误的可能性则随之增大。作为一个普遍使用的原则，人们通常选择显著性水平为0.05或比0.05更小的概率。\n\n#### 1.1.4 标准化检测量与拒绝域\n\n##### 　　__检验统计量__ 实际上是总体参数的点估计量，但点估计量并不能直接作为检验的统计量，只有将其标准化后，才能用于度量它与原假设的参数之间的差异程度。实际上，假设检验中所用的检验统计量都是标准化检验统计量，它反映了点估计量（比如样本均值）与假设的总体参数（比如假设的总体均值）相比相差了多少个标准差。\n\n$$标准化检验统计量 = \\frac{点估计量 - 假设值}{点估计量的抽样标准差}$$\n\n##### 　　__拒绝域__ 能够拒绝原假设的检验统计量的所有可能取值的集合。是由显著性水平α所围成的区域。如果利用样本观测结果计算出来的检验统计量的具体数值落在了拒绝域内，就拒绝原假设，否则就不拒绝原假设。\n![显著性水平、拒绝域和临界值](../../img/pvalue/pvalue3.jpeg)<div class='img-note'>显著性水平、拒绝域和临界值</div>\n\n##### 　　当样本容量固定时，拒绝域的面积随α的减小而减小。α值越小，拒绝域假设所需的检验统计量的临界值与原假设的参数值就越远。\n\n### 1.2 利用P值进行决策\n##### 　　显著性水平α是在检验之前确定的，这也就意味着我们事先确定了拒绝域。这样，不论检验统计量的值是大是小，只要它的值落入拒绝域就拒绝原假设，否者就不拒绝原假设。这种固定的显著性水平α对检验结果只能提供检验结论可靠性的一个大致范围，无法给出观测数据与原假设之间不一致程度的精确度量。\n\n##### 　　__P值__ 在原假设为真的条件下，检验统计量的观察值大于或等于其计算值的概率，称为P值。P值是反映实际观测到的数据与原假设之间不一致程度的一个概率值。P值越小，说明实际观测到的数据与原假设之间不一致的程度就越大，检验的结果也就越显著。\n\n### 1.3 一个总体参数的检验\n##### 　　当我们研究一个总体时，要检验的参数主要是总体均值μ、总体比例π和总体方差σ<SUP>2</SUP>。由于检验的参数不同，计算检验统计量的方法也有所不同。\n\n#### 1.3.1 总体均值的检验\n##### 　　对于总体均值进行假设检验，采用什么检验步骤和检验统计量取决于我们所抽取的样本是大样本（n≥30）还是小样本（n<30），此外还需要区分总体是否服从正太分布、总体方差σ<SUP>2</SUP>是否已知等几种情况。\n![大样本情况下一个总体均值的检验方法](../../img/pvalue/pvalue4.png)    <div class='img-note'>大样本情况下一个总体均值的检验方法</div>\n![小样本情况下一个总体均值的检验方法](../../img/pvalue/pvalue5.png)    <div class='img-note'>小样本情况下一个总体均值的检验方法</div>\n\n##### 　　Z表示转换为标准正太分布下的检验统计量。\n\n#### 1.3.2 总体比例的检验\n##### 　　总体比例是指总体中具有某种相同特征的个体所占的比例，这些特征可以是数据型的（如一定的重量、一定的厚度或一定规格等），也可以是品质型的（如男女比例、学历等级、职称高低等）。\n##### 　　在构造检验统计量时，我们仍然利用样本比例p与总体比例π之间的距离等于多少个标准差来衡量，因为在大样本情况下统计量p近似服从正太分布，而统计量\n$$z = \\frac{P - π_0}{\\sqrt{\\frac{π_0(1-π_0)}{n}}}$$\n\n![大样本情况下一个总体比例的检验方法](../../img/pvalue/pvalue6.png)    <div class='img-note'>大样本情况下一个总体比例的检验方法</div>\n\n### 1.4 两个总体参数的检验\n##### 　　在实际研究中，我们常常要比较两个总体的差异，如一所学校的重点班和普通班两个班级学生的英语成绩是否有显著差异；生产企业在改进生产线后的平均产量与原生产线的平均产量相比是否有显著提高等等。\n![两个总体均值之差的三种基本假设检验形式](../../img/pvalue/pvalue7.png)    <div class='img-note'>两个总体均值之差的三种基本假设检验形式</div>\n\n## 2. JAVA实现P值计算\n","slug":"arithmetic/JAVA-pValue","published":1,"updated":"2017-02-16T07:42:50.000Z","comments":1,"photos":[],"link":"","_id":"cizbemklt0001sebfk6qkyv1k","content":"<script type=\"text/javascript\" async src=\"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML\">\n    </script>\n\n<h5 id=\"最近产品提出需求，对于ab实验，希望能够通过实验数据计算出P值，以对数据的准确性做一个直观判断。最开始不知道P值是一个什么概念，觉得应该很简单，baidu或者google以下应该会有很多开源的代码或者jar包；又或者是自己将P值公式实现便可。但是一番查找后发现没有想的这么简单，网络上对于P值得计算过程大多含糊不清，更别提完整的计算代码。最后没办法，只有通过自己拿起概率论书本重新进行学习，以下便记录自己从P值是什么到java实现的一些细节。\"><a href=\"#最近产品提出需求，对于ab实验，希望能够通过实验数据计算出P值，以对数据的准确性做一个直观判断。最开始不知道P值是一个什么概念，觉得应该很简单，baidu或者google以下应该会有很多开源的代码或者jar包；又或者是自己将P值公式实现便可。但是一番查找后发现没有想的这么简单，网络上对于P值得计算过程大多含糊不清，更别提完整的计算代码。最后没办法，只有通过自己拿起概率论书本重新进行学习，以下便记录自己从P值是什么到java实现的一些细节。\" class=\"headerlink\" title=\"　　最近产品提出需求，对于ab实验，希望能够通过实验数据计算出P值，以对数据的准确性做一个直观判断。最开始不知道P值是一个什么概念，觉得应该很简单，baidu或者google以下应该会有很多开源的代码或者jar包；又或者是自己将P值公式实现便可。但是一番查找后发现没有想的这么简单，网络上对于P值得计算过程大多含糊不清，更别提完整的计算代码。最后没办法，只有通过自己拿起概率论书本重新进行学习，以下便记录自己从P值是什么到java实现的一些细节。\"></a>　　最近产品提出需求，对于ab实验，希望能够通过实验数据计算出P值，以对数据的准确性做一个直观判断。最开始不知道P值是一个什么概念，觉得应该很简单，baidu或者google以下应该会有很多开源的代码或者jar包；又或者是自己将P值公式实现便可。但是一番查找后发现没有想的这么简单，网络上对于P值得计算过程大多含糊不清，更别提完整的计算代码。最后没办法，只有通过自己拿起概率论书本重新进行学习，以下便记录自己从P值是什么到java实现的一些细节。</h5><a id=\"more\"></a>\n<h2 id=\"1-统计学中P值\"><a href=\"#1-统计学中P值\" class=\"headerlink\" title=\"1. 统计学中P值\"></a>1. 统计学中P值</h2><h5 id=\"P值是指当假设为真时所得到的观察结果的概率，简单讲P值就是概率，反映某一事件发生的可能性大小。下面几个比较重要的基础概念对于理解P值的意义会有帮助。\"><a href=\"#P值是指当假设为真时所得到的观察结果的概率，简单讲P值就是概率，反映某一事件发生的可能性大小。下面几个比较重要的基础概念对于理解P值的意义会有帮助。\" class=\"headerlink\" title=\"　　P值是指当假设为真时所得到的观察结果的概率，简单讲P值就是概率，反映某一事件发生的可能性大小。下面几个比较重要的基础概念对于理解P值的意义会有帮助。\"></a>　　P值是指当假设为真时所得到的观察结果的概率，简单讲P值就是概率，反映某一事件发生的可能性大小。下面几个比较重要的基础概念对于理解P值的意义会有帮助。</h5><h3 id=\"1-1-概率论中几个比较重要的基础概念\"><a href=\"#1-1-概率论中几个比较重要的基础概念\" class=\"headerlink\" title=\"1.1 概率论中几个比较重要的基础概念\"></a>1.1 概率论中几个比较重要的基础概念</h3><h4 id=\"1-1-1-原假设与备择假设：\"><a href=\"#1-1-1-原假设与备择假设：\" class=\"headerlink\" title=\"1.1.1 原假设与备择假设：\"></a>1.1.1 原假设与备择假设：</h4><h5 id=\"原假设（H0）：通常将研究者想手机证据予以反对的假设称为原假设，用H0表示；\"><a href=\"#原假设（H0）：通常将研究者想手机证据予以反对的假设称为原假设，用H0表示；\" class=\"headerlink\" title=\"原假设（H0）：通常将研究者想手机证据予以反对的假设称为原假设，用H0表示；\"></a><strong>原假设（H<sub>0</sub>）</strong>：通常将研究者想手机证据予以反对的假设称为原假设，用H<sub>0</sub>表示；</h5><h5 id=\"备择假设（H1）：通常将研究者想收集证据予以支持的假设称为备择假设，或称研究假设，用H1活H2表示。\"><a href=\"#备择假设（H1）：通常将研究者想收集证据予以支持的假设称为备择假设，或称研究假设，用H1活H2表示。\" class=\"headerlink\" title=\"备择假设（H1）：通常将研究者想收集证据予以支持的假设称为备择假设，或称研究假设，用H1活H2表示。\"></a><strong>备择假设（H<sub>1</sub>）</strong>：通常将研究者想收集证据予以支持的假设称为备择假设，或称研究假设，用H<sub>1</sub>活H<sub>2</sub>表示。</h5><h5 id=\"举个栗子：\"><a href=\"#举个栗子：\" class=\"headerlink\" title=\"　　举个栗子：\"></a>　　举个栗子：</h5><div class=\"highlighter-rouge\"><pre class=\"highlight\"><code>某品牌洗涤剂在产品说明书中声称：平均净含量不少于500g。从消费者利益出发，有关研究人员要通过抽检其中的一批产品来验证该产品制造商的说明是否属实。    \n解：对于该洗涤剂的平均含量的真值为μ。如果抽检的结果发现μ<500，则表明该产品说明书中关于其净含量的内容是不真实的。一般来说，研究者抽检的意图是倾向于证实这种洗涤剂的平均净含量不符合说明书中的概述，因为这不符合说明书的陈述。如果研究者对于产品说明丝毫没有质疑，也就没有必要抽检了。所以μ<500是研究者想要收集证据支持的观点。 <br=\"\"><h6>H<sub>0</sub>:μ≥500(净含量符合说明书);</h6><h6>H<sub>1</sub>:μ&lt;500(净含量不符合说明书)。</h6></500，则表明该产品说明书中关于其净含量的内容是不真实的。一般来说，研究者抽检的意图是倾向于证实这种洗涤剂的平均净含量不符合说明书中的概述，因为这不符合说明书的陈述。如果研究者对于产品说明丝毫没有质疑，也就没有必要抽检了。所以μ<500是研究者想要收集证据支持的观点。></code></pre></div>\n\n\n<div class=\"highlighter-rouge\"><pre class=\"highlight\"><code>一家研究机构估计，某城市中家庭拥有汽车的比例超过30%。为了验证这一估计是否正确，该研究机构随机抽取了一个样本进行检验。     \n解：设该城市中家庭拥有汽车的比例真值为π。显然，研究者想收集证据予以支持的假设是\"该城市中家庭拥有汽车的比例超过30%\"。因此建立的原假设与备择假设应为     \n<h6>H<sub>0</sub>:π≤30%（家庭拥有汽车的比例不超过30%）;</h6><h6>H<sub>1</sub>:π>30%（家庭拥有汽车的比例超过30%）。</h6></code></pre></div>\n\n<ul>\n<li>原假设和备择假设是一个完备事件组，而且互相对立。也就是说在一项假设检验中，必有且只有一个成立；</li>\n<li>在假设检验中，等号”=”总是放在原假设上。   </li>\n</ul>\n<h4 id=\"1-1-2-单侧检验和双侧检验：\"><a href=\"#1-1-2-单侧检验和双侧检验：\" class=\"headerlink\" title=\"1.1.2 单侧检验和双侧检验：\"></a>1.1.2 单侧检验和双侧检验：</h4><h5 id=\"单侧检验：备择假设具有特定的方向性，并含有符号”-gt-”或”-lt-”的假设检验；\"><a href=\"#单侧检验：备择假设具有特定的方向性，并含有符号”-gt-”或”-lt-”的假设检验；\" class=\"headerlink\" title=\"单侧检验：备择假设具有特定的方向性，并含有符号”&gt;”或”&lt;”的假设检验；\"></a><strong>单侧检验</strong>：备择假设具有特定的方向性，并含有符号”&gt;”或”&lt;”的假设检验；</h5><h5 id=\"双侧检验：备择假设没有特定的方向性，并含有符号”≠”的假设检验。\"><a href=\"#双侧检验：备择假设没有特定的方向性，并含有符号”≠”的假设检验。\" class=\"headerlink\" title=\"双侧检验：备择假设没有特定的方向性，并含有符号”≠”的假设检验。\"></a><strong>双侧检验</strong>：备择假设没有特定的方向性，并含有符号”≠”的假设检验。</h5><p><img src=\"../../img/pvalue/pvalue1.png\" alt=\"假设检验的基本形式\">    <div class=\"img-note\">假设检验的基本形式</div></p>\n<h4 id=\"1-1-3-两类错误与显著水平\"><a href=\"#1-1-3-两类错误与显著水平\" class=\"headerlink\" title=\"1.1.3 两类错误与显著水平\"></a>1.1.3 两类错误与显著水平</h4><h5 id=\"如前所述，原假设与备择假设不能同时成立，我们要么拒绝原假设，要么不拒绝原假设。我们希望的情况是：当原假设正确时没有拒绝它，当原假设不正确时拒绝它。但是我们无法保证不犯错。假设检验中过程中可能发生以下两类错误：\"><a href=\"#如前所述，原假设与备择假设不能同时成立，我们要么拒绝原假设，要么不拒绝原假设。我们希望的情况是：当原假设正确时没有拒绝它，当原假设不正确时拒绝它。但是我们无法保证不犯错。假设检验中过程中可能发生以下两类错误：\" class=\"headerlink\" title=\"　　如前所述，原假设与备择假设不能同时成立，我们要么拒绝原假设，要么不拒绝原假设。我们希望的情况是：当原假设正确时没有拒绝它，当原假设不正确时拒绝它。但是我们无法保证不犯错。假设检验中过程中可能发生以下两类错误：\"></a>　　如前所述，原假设与备择假设不能同时成立，我们要么拒绝原假设，要么不拒绝原假设。我们希望的情况是：当原假设正确时没有拒绝它，当原假设不正确时拒绝它。但是我们无法保证不犯错。假设检验中过程中可能发生以下两类错误：</h5><h5 id=\"I类错误：当原假设为真是拒绝原假设，所犯的错误称为第I类错误；\"><a href=\"#I类错误：当原假设为真是拒绝原假设，所犯的错误称为第I类错误；\" class=\"headerlink\" title=\"I类错误：当原假设为真是拒绝原假设，所犯的错误称为第I类错误；\"></a><strong>I类错误</strong>：当原假设为真是拒绝原假设，所犯的错误称为第I类错误；</h5><h5 id=\"II类错误：当原假设为假时没有拒绝原假设，所犯错误称为第II类错误。\"><a href=\"#II类错误：当原假设为假时没有拒绝原假设，所犯错误称为第II类错误。\" class=\"headerlink\" title=\"II类错误：当原假设为假时没有拒绝原假设，所犯错误称为第II类错误。\"></a><strong>II类错误</strong>：当原假设为假时没有拒绝原假设，所犯错误称为第II类错误。</h5><p><img src=\"../../img/pvalue/pvalue2.png\" alt=\"假设检验的结论与后果\">   <div class=\"img-note\">假设检验的结论与后果</div></p>\n<h5 id=\"只有当原假设被拒绝时，我们才会犯第I类错误；只有当原假设未被拒绝时，我们才会犯第II类错误。因此，我们可以不犯第I类错误或不犯第II类错误，但不可能两类错误都不犯。两类错误就像一个跷跷板，当一个概率增大时，另一个减小。人们只能在两类错误的发生概率之间进行平衡。一般来说，发生哪一类错误的后果更为严重，就应该首要控制哪类错误发生的概率，但由于犯第I类错误的概率是可以又研究者控制的，因为此在假设检验中，人们往往先控制第I类错误的发生概率。\"><a href=\"#只有当原假设被拒绝时，我们才会犯第I类错误；只有当原假设未被拒绝时，我们才会犯第II类错误。因此，我们可以不犯第I类错误或不犯第II类错误，但不可能两类错误都不犯。两类错误就像一个跷跷板，当一个概率增大时，另一个减小。人们只能在两类错误的发生概率之间进行平衡。一般来说，发生哪一类错误的后果更为严重，就应该首要控制哪类错误发生的概率，但由于犯第I类错误的概率是可以又研究者控制的，因为此在假设检验中，人们往往先控制第I类错误的发生概率。\" class=\"headerlink\" title=\"　　只有当原假设被拒绝时，我们才会犯第I类错误；只有当原假设未被拒绝时，我们才会犯第II类错误。因此，我们可以不犯第I类错误或不犯第II类错误，但不可能两类错误都不犯。两类错误就像一个跷跷板，当一个概率增大时，另一个减小。人们只能在两类错误的发生概率之间进行平衡。一般来说，发生哪一类错误的后果更为严重，就应该首要控制哪类错误发生的概率，但由于犯第I类错误的概率是可以又研究者控制的，因为此在假设检验中，人们往往先控制第I类错误的发生概率。\"></a>　　只有当原假设被拒绝时，我们才会犯第I类错误；只有当原假设未被拒绝时，我们才会犯第II类错误。因此，我们可以不犯第I类错误或不犯第II类错误，但不可能两类错误都不犯。两类错误就像一个跷跷板，当一个概率增大时，另一个减小。人们只能在两类错误的发生概率之间进行平衡。一般来说，发生哪一类错误的后果更为严重，就应该首要控制哪类错误发生的概率，但由于犯第I类错误的概率是可以又研究者控制的，因为此在假设检验中，人们往往先控制第I类错误的发生概率。</h5><p><code>发生第I类错误的概率常被用于度量检验结论的可靠性，并将这一概率称为显著性水平，记为α。</code></p>\n<h5 id=\"显著水平-是人们事先指定的犯第I类错误概率α的最大允许值。显著水平α越小，犯第I类错误的可能性自然就越小，但犯第II类错误的可能性则随之增大。作为一个普遍使用的原则，人们通常选择显著性水平为0-05或比0-05更小的概率。\"><a href=\"#显著水平-是人们事先指定的犯第I类错误概率α的最大允许值。显著水平α越小，犯第I类错误的可能性自然就越小，但犯第II类错误的可能性则随之增大。作为一个普遍使用的原则，人们通常选择显著性水平为0-05或比0-05更小的概率。\" class=\"headerlink\" title=\"　　显著水平 是人们事先指定的犯第I类错误概率α的最大允许值。显著水平α越小，犯第I类错误的可能性自然就越小，但犯第II类错误的可能性则随之增大。作为一个普遍使用的原则，人们通常选择显著性水平为0.05或比0.05更小的概率。\"></a>　　<strong>显著水平</strong> 是人们事先指定的犯第I类错误概率α的最大允许值。显著水平α越小，犯第I类错误的可能性自然就越小，但犯第II类错误的可能性则随之增大。作为一个普遍使用的原则，人们通常选择显著性水平为0.05或比0.05更小的概率。</h5><h4 id=\"1-1-4-标准化检测量与拒绝域\"><a href=\"#1-1-4-标准化检测量与拒绝域\" class=\"headerlink\" title=\"1.1.4 标准化检测量与拒绝域\"></a>1.1.4 标准化检测量与拒绝域</h4><h5 id=\"检验统计量-实际上是总体参数的点估计量，但点估计量并不能直接作为检验的统计量，只有将其标准化后，才能用于度量它与原假设的参数之间的差异程度。实际上，假设检验中所用的检验统计量都是标准化检验统计量，它反映了点估计量（比如样本均值）与假设的总体参数（比如假设的总体均值）相比相差了多少个标准差。\"><a href=\"#检验统计量-实际上是总体参数的点估计量，但点估计量并不能直接作为检验的统计量，只有将其标准化后，才能用于度量它与原假设的参数之间的差异程度。实际上，假设检验中所用的检验统计量都是标准化检验统计量，它反映了点估计量（比如样本均值）与假设的总体参数（比如假设的总体均值）相比相差了多少个标准差。\" class=\"headerlink\" title=\"　　检验统计量 实际上是总体参数的点估计量，但点估计量并不能直接作为检验的统计量，只有将其标准化后，才能用于度量它与原假设的参数之间的差异程度。实际上，假设检验中所用的检验统计量都是标准化检验统计量，它反映了点估计量（比如样本均值）与假设的总体参数（比如假设的总体均值）相比相差了多少个标准差。\"></a>　　<strong>检验统计量</strong> 实际上是总体参数的点估计量，但点估计量并不能直接作为检验的统计量，只有将其标准化后，才能用于度量它与原假设的参数之间的差异程度。实际上，假设检验中所用的检验统计量都是标准化检验统计量，它反映了点估计量（比如样本均值）与假设的总体参数（比如假设的总体均值）相比相差了多少个标准差。</h5><script type=\"math/tex; mode=display\">标准化检验统计量 = \\frac{点估计量 - 假设值}{点估计量的抽样标准差}</script><h5 id=\"拒绝域-能够拒绝原假设的检验统计量的所有可能取值的集合。是由显著性水平α所围成的区域。如果利用样本观测结果计算出来的检验统计量的具体数值落在了拒绝域内，就拒绝原假设，否则就不拒绝原假设。\"><a href=\"#拒绝域-能够拒绝原假设的检验统计量的所有可能取值的集合。是由显著性水平α所围成的区域。如果利用样本观测结果计算出来的检验统计量的具体数值落在了拒绝域内，就拒绝原假设，否则就不拒绝原假设。\" class=\"headerlink\" title=\"　　拒绝域 能够拒绝原假设的检验统计量的所有可能取值的集合。是由显著性水平α所围成的区域。如果利用样本观测结果计算出来的检验统计量的具体数值落在了拒绝域内，就拒绝原假设，否则就不拒绝原假设。\"></a>　　<strong>拒绝域</strong> 能够拒绝原假设的检验统计量的所有可能取值的集合。是由显著性水平α所围成的区域。如果利用样本观测结果计算出来的检验统计量的具体数值落在了拒绝域内，就拒绝原假设，否则就不拒绝原假设。</h5><p><img src=\"../../img/pvalue/pvalue3.jpeg\" alt=\"显著性水平、拒绝域和临界值\"><div class=\"img-note\">显著性水平、拒绝域和临界值</div></p>\n<h5 id=\"当样本容量固定时，拒绝域的面积随α的减小而减小。α值越小，拒绝域假设所需的检验统计量的临界值与原假设的参数值就越远。\"><a href=\"#当样本容量固定时，拒绝域的面积随α的减小而减小。α值越小，拒绝域假设所需的检验统计量的临界值与原假设的参数值就越远。\" class=\"headerlink\" title=\"　　当样本容量固定时，拒绝域的面积随α的减小而减小。α值越小，拒绝域假设所需的检验统计量的临界值与原假设的参数值就越远。\"></a>　　当样本容量固定时，拒绝域的面积随α的减小而减小。α值越小，拒绝域假设所需的检验统计量的临界值与原假设的参数值就越远。</h5><h3 id=\"1-2-利用P值进行决策\"><a href=\"#1-2-利用P值进行决策\" class=\"headerlink\" title=\"1.2 利用P值进行决策\"></a>1.2 利用P值进行决策</h3><h5 id=\"显著性水平α是在检验之前确定的，这也就意味着我们事先确定了拒绝域。这样，不论检验统计量的值是大是小，只要它的值落入拒绝域就拒绝原假设，否者就不拒绝原假设。这种固定的显著性水平α对检验结果只能提供检验结论可靠性的一个大致范围，无法给出观测数据与原假设之间不一致程度的精确度量。\"><a href=\"#显著性水平α是在检验之前确定的，这也就意味着我们事先确定了拒绝域。这样，不论检验统计量的值是大是小，只要它的值落入拒绝域就拒绝原假设，否者就不拒绝原假设。这种固定的显著性水平α对检验结果只能提供检验结论可靠性的一个大致范围，无法给出观测数据与原假设之间不一致程度的精确度量。\" class=\"headerlink\" title=\"　　显著性水平α是在检验之前确定的，这也就意味着我们事先确定了拒绝域。这样，不论检验统计量的值是大是小，只要它的值落入拒绝域就拒绝原假设，否者就不拒绝原假设。这种固定的显著性水平α对检验结果只能提供检验结论可靠性的一个大致范围，无法给出观测数据与原假设之间不一致程度的精确度量。\"></a>　　显著性水平α是在检验之前确定的，这也就意味着我们事先确定了拒绝域。这样，不论检验统计量的值是大是小，只要它的值落入拒绝域就拒绝原假设，否者就不拒绝原假设。这种固定的显著性水平α对检验结果只能提供检验结论可靠性的一个大致范围，无法给出观测数据与原假设之间不一致程度的精确度量。</h5><h5 id=\"P值-在原假设为真的条件下，检验统计量的观察值大于或等于其计算值的概率，称为P值。P值是反映实际观测到的数据与原假设之间不一致程度的一个概率值。P值越小，说明实际观测到的数据与原假设之间不一致的程度就越大，检验的结果也就越显著。\"><a href=\"#P值-在原假设为真的条件下，检验统计量的观察值大于或等于其计算值的概率，称为P值。P值是反映实际观测到的数据与原假设之间不一致程度的一个概率值。P值越小，说明实际观测到的数据与原假设之间不一致的程度就越大，检验的结果也就越显著。\" class=\"headerlink\" title=\"　　P值 在原假设为真的条件下，检验统计量的观察值大于或等于其计算值的概率，称为P值。P值是反映实际观测到的数据与原假设之间不一致程度的一个概率值。P值越小，说明实际观测到的数据与原假设之间不一致的程度就越大，检验的结果也就越显著。\"></a>　　<strong>P值</strong> 在原假设为真的条件下，检验统计量的观察值大于或等于其计算值的概率，称为P值。P值是反映实际观测到的数据与原假设之间不一致程度的一个概率值。P值越小，说明实际观测到的数据与原假设之间不一致的程度就越大，检验的结果也就越显著。</h5><h3 id=\"1-3-一个总体参数的检验\"><a href=\"#1-3-一个总体参数的检验\" class=\"headerlink\" title=\"1.3 一个总体参数的检验\"></a>1.3 一个总体参数的检验</h3><h5 id=\"当我们研究一个总体时，要检验的参数主要是总体均值μ、总体比例π和总体方差σ2。由于检验的参数不同，计算检验统计量的方法也有所不同。\"><a href=\"#当我们研究一个总体时，要检验的参数主要是总体均值μ、总体比例π和总体方差σ2。由于检验的参数不同，计算检验统计量的方法也有所不同。\" class=\"headerlink\" title=\"　　当我们研究一个总体时，要检验的参数主要是总体均值μ、总体比例π和总体方差σ2。由于检验的参数不同，计算检验统计量的方法也有所不同。\"></a>　　当我们研究一个总体时，要检验的参数主要是总体均值μ、总体比例π和总体方差σ<sup>2</sup>。由于检验的参数不同，计算检验统计量的方法也有所不同。</h5><h4 id=\"1-3-1-总体均值的检验\"><a href=\"#1-3-1-总体均值的检验\" class=\"headerlink\" title=\"1.3.1 总体均值的检验\"></a>1.3.1 总体均值的检验</h4><h5 id=\"对于总体均值进行假设检验，采用什么检验步骤和检验统计量取决于我们所抽取的样本是大样本（n≥30）还是小样本（n\"><a href=\"#对于总体均值进行假设检验，采用什么检验步骤和检验统计量取决于我们所抽取的样本是大样本（n≥30）还是小样本（n\" class=\"headerlink\" title=\"　　对于总体均值进行假设检验，采用什么检验步骤和检验统计量取决于我们所抽取的样本是大样本（n≥30）还是小样本（n\"></a>　　对于总体均值进行假设检验，采用什么检验步骤和检验统计量取决于我们所抽取的样本是大样本（n≥30）还是小样本（n<30），此外还需要区分总体是否服从正太分布、总体方差σ<sup>2&lt;/SUP&gt;是否已知等几种情况。</30），此外还需要区分总体是否服从正太分布、总体方差σ<sup></h5><p><img src=\"../../img/pvalue/pvalue4.png\" alt=\"大样本情况下一个总体均值的检验方法\">    <div class=\"img-note\">大样本情况下一个总体均值的检验方法</div><br><img src=\"../../img/pvalue/pvalue5.png\" alt=\"小样本情况下一个总体均值的检验方法\">    <div class=\"img-note\">小样本情况下一个总体均值的检验方法</div></p>\n<h5 id=\"Z表示转换为标准正太分布下的检验统计量。\"><a href=\"#Z表示转换为标准正太分布下的检验统计量。\" class=\"headerlink\" title=\"　　Z表示转换为标准正太分布下的检验统计量。\"></a>　　Z表示转换为标准正太分布下的检验统计量。</h5><h4 id=\"1-3-2-总体比例的检验\"><a href=\"#1-3-2-总体比例的检验\" class=\"headerlink\" title=\"1.3.2 总体比例的检验\"></a>1.3.2 总体比例的检验</h4><h5 id=\"总体比例是指总体中具有某种相同特征的个体所占的比例，这些特征可以是数据型的（如一定的重量、一定的厚度或一定规格等），也可以是品质型的（如男女比例、学历等级、职称高低等）。\"><a href=\"#总体比例是指总体中具有某种相同特征的个体所占的比例，这些特征可以是数据型的（如一定的重量、一定的厚度或一定规格等），也可以是品质型的（如男女比例、学历等级、职称高低等）。\" class=\"headerlink\" title=\"　　总体比例是指总体中具有某种相同特征的个体所占的比例，这些特征可以是数据型的（如一定的重量、一定的厚度或一定规格等），也可以是品质型的（如男女比例、学历等级、职称高低等）。\"></a>　　总体比例是指总体中具有某种相同特征的个体所占的比例，这些特征可以是数据型的（如一定的重量、一定的厚度或一定规格等），也可以是品质型的（如男女比例、学历等级、职称高低等）。</h5><h5 id=\"在构造检验统计量时，我们仍然利用样本比例p与总体比例π之间的距离等于多少个标准差来衡量，因为在大样本情况下统计量p近似服从正太分布，而统计量\"><a href=\"#在构造检验统计量时，我们仍然利用样本比例p与总体比例π之间的距离等于多少个标准差来衡量，因为在大样本情况下统计量p近似服从正太分布，而统计量\" class=\"headerlink\" title=\"　　在构造检验统计量时，我们仍然利用样本比例p与总体比例π之间的距离等于多少个标准差来衡量，因为在大样本情况下统计量p近似服从正太分布，而统计量\"></a>　　在构造检验统计量时，我们仍然利用样本比例p与总体比例π之间的距离等于多少个标准差来衡量，因为在大样本情况下统计量p近似服从正太分布，而统计量</h5><script type=\"math/tex; mode=display\">z = \\frac{P - π_0}{\\sqrt{\\frac{π_0(1-π_0)}{n}}}</script><p><img src=\"../../img/pvalue/pvalue6.png\" alt=\"大样本情况下一个总体比例的检验方法\">    <div class=\"img-note\">大样本情况下一个总体比例的检验方法</div></p>\n<h3 id=\"1-4-两个总体参数的检验\"><a href=\"#1-4-两个总体参数的检验\" class=\"headerlink\" title=\"1.4 两个总体参数的检验\"></a>1.4 两个总体参数的检验</h3><h5 id=\"在实际研究中，我们常常要比较两个总体的差异，如一所学校的重点班和普通班两个班级学生的英语成绩是否有显著差异；生产企业在改进生产线后的平均产量与原生产线的平均产量相比是否有显著提高等等。\"><a href=\"#在实际研究中，我们常常要比较两个总体的差异，如一所学校的重点班和普通班两个班级学生的英语成绩是否有显著差异；生产企业在改进生产线后的平均产量与原生产线的平均产量相比是否有显著提高等等。\" class=\"headerlink\" title=\"　　在实际研究中，我们常常要比较两个总体的差异，如一所学校的重点班和普通班两个班级学生的英语成绩是否有显著差异；生产企业在改进生产线后的平均产量与原生产线的平均产量相比是否有显著提高等等。\"></a>　　在实际研究中，我们常常要比较两个总体的差异，如一所学校的重点班和普通班两个班级学生的英语成绩是否有显著差异；生产企业在改进生产线后的平均产量与原生产线的平均产量相比是否有显著提高等等。</h5><p><img src=\"../../img/pvalue/pvalue7.png\" alt=\"两个总体均值之差的三种基本假设检验形式\">    <div class=\"img-note\">两个总体均值之差的三种基本假设检验形式</div></p>\n<h2 id=\"2-JAVA实现P值计算\"><a href=\"#2-JAVA实现P值计算\" class=\"headerlink\" title=\"2. JAVA实现P值计算\"></a>2. JAVA实现P值计算</h2>","excerpt":"<script type=\"text/javascript\" async\n            src=\"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML\">\n    </script>\n\n<h5 id=\"最近产品提出需求，对于ab实验，希望能够通过实验数据计算出P值，以对数据的准确性做一个直观判断。最开始不知道P值是一个什么概念，觉得应该很简单，baidu或者google以下应该会有很多开源的代码或者jar包；又或者是自己将P值公式实现便可。但是一番查找后发现没有想的这么简单，网络上对于P值得计算过程大多含糊不清，更别提完整的计算代码。最后没办法，只有通过自己拿起概率论书本重新进行学习，以下便记录自己从P值是什么到java实现的一些细节。\"><a href=\"#最近产品提出需求，对于ab实验，希望能够通过实验数据计算出P值，以对数据的准确性做一个直观判断。最开始不知道P值是一个什么概念，觉得应该很简单，baidu或者google以下应该会有很多开源的代码或者jar包；又或者是自己将P值公式实现便可。但是一番查找后发现没有想的这么简单，网络上对于P值得计算过程大多含糊不清，更别提完整的计算代码。最后没办法，只有通过自己拿起概率论书本重新进行学习，以下便记录自己从P值是什么到java实现的一些细节。\" class=\"headerlink\" title=\"　　最近产品提出需求，对于ab实验，希望能够通过实验数据计算出P值，以对数据的准确性做一个直观判断。最开始不知道P值是一个什么概念，觉得应该很简单，baidu或者google以下应该会有很多开源的代码或者jar包；又或者是自己将P值公式实现便可。但是一番查找后发现没有想的这么简单，网络上对于P值得计算过程大多含糊不清，更别提完整的计算代码。最后没办法，只有通过自己拿起概率论书本重新进行学习，以下便记录自己从P值是什么到java实现的一些细节。\"></a>　　最近产品提出需求，对于ab实验，希望能够通过实验数据计算出P值，以对数据的准确性做一个直观判断。最开始不知道P值是一个什么概念，觉得应该很简单，baidu或者google以下应该会有很多开源的代码或者jar包；又或者是自己将P值公式实现便可。但是一番查找后发现没有想的这么简单，网络上对于P值得计算过程大多含糊不清，更别提完整的计算代码。最后没办法，只有通过自己拿起概率论书本重新进行学习，以下便记录自己从P值是什么到java实现的一些细节。</h5>","more":"<h2 id=\"1-统计学中P值\"><a href=\"#1-统计学中P值\" class=\"headerlink\" title=\"1. 统计学中P值\"></a>1. 统计学中P值</h2><h5 id=\"P值是指当假设为真时所得到的观察结果的概率，简单讲P值就是概率，反映某一事件发生的可能性大小。下面几个比较重要的基础概念对于理解P值的意义会有帮助。\"><a href=\"#P值是指当假设为真时所得到的观察结果的概率，简单讲P值就是概率，反映某一事件发生的可能性大小。下面几个比较重要的基础概念对于理解P值的意义会有帮助。\" class=\"headerlink\" title=\"　　P值是指当假设为真时所得到的观察结果的概率，简单讲P值就是概率，反映某一事件发生的可能性大小。下面几个比较重要的基础概念对于理解P值的意义会有帮助。\"></a>　　P值是指当假设为真时所得到的观察结果的概率，简单讲P值就是概率，反映某一事件发生的可能性大小。下面几个比较重要的基础概念对于理解P值的意义会有帮助。</h5><h3 id=\"1-1-概率论中几个比较重要的基础概念\"><a href=\"#1-1-概率论中几个比较重要的基础概念\" class=\"headerlink\" title=\"1.1 概率论中几个比较重要的基础概念\"></a>1.1 概率论中几个比较重要的基础概念</h3><h4 id=\"1-1-1-原假设与备择假设：\"><a href=\"#1-1-1-原假设与备择假设：\" class=\"headerlink\" title=\"1.1.1 原假设与备择假设：\"></a>1.1.1 原假设与备择假设：</h4><h5 id=\"原假设（H0）：通常将研究者想手机证据予以反对的假设称为原假设，用H0表示；\"><a href=\"#原假设（H0）：通常将研究者想手机证据予以反对的假设称为原假设，用H0表示；\" class=\"headerlink\" title=\"原假设（H0）：通常将研究者想手机证据予以反对的假设称为原假设，用H0表示；\"></a><strong>原假设（H<sub>0</sub>）</strong>：通常将研究者想手机证据予以反对的假设称为原假设，用H<sub>0</sub>表示；</h5><h5 id=\"备择假设（H1）：通常将研究者想收集证据予以支持的假设称为备择假设，或称研究假设，用H1活H2表示。\"><a href=\"#备择假设（H1）：通常将研究者想收集证据予以支持的假设称为备择假设，或称研究假设，用H1活H2表示。\" class=\"headerlink\" title=\"备择假设（H1）：通常将研究者想收集证据予以支持的假设称为备择假设，或称研究假设，用H1活H2表示。\"></a><strong>备择假设（H<sub>1</sub>）</strong>：通常将研究者想收集证据予以支持的假设称为备择假设，或称研究假设，用H<sub>1</sub>活H<sub>2</sub>表示。</h5><h5 id=\"举个栗子：\"><a href=\"#举个栗子：\" class=\"headerlink\" title=\"　　举个栗子：\"></a>　　举个栗子：</h5><div class=\"highlighter-rouge\"><pre class=\"highlight\"><code>某品牌洗涤剂在产品说明书中声称：平均净含量不少于500g。从消费者利益出发，有关研究人员要通过抽检其中的一批产品来验证该产品制造商的说明是否属实。    \n解：对于该洗涤剂的平均含量的真值为μ。如果抽检的结果发现μ<500，则表明该产品说明书中关于其净含量的内容是不真实的。一般来说，研究者抽检的意图是倾向于证实这种洗涤剂的平均净含量不符合说明书中的概述，因为这不符合说明书的陈述。如果研究者对于产品说明丝毫没有质疑，也就没有必要抽检了。所以μ<500是研究者想要收集证据支持的观点。    \n<br><h6>H<sub>0</sub>:μ≥500(净含量符合说明书);</h6><h6>H<sub>1</sub>:μ&lt;500(净含量不符合说明书)。</h6></code></pre></div>\n\n\n<div class=\"highlighter-rouge\"><pre class=\"highlight\"><code>一家研究机构估计，某城市中家庭拥有汽车的比例超过30%。为了验证这一估计是否正确，该研究机构随机抽取了一个样本进行检验。     \n解：设该城市中家庭拥有汽车的比例真值为π。显然，研究者想收集证据予以支持的假设是\"该城市中家庭拥有汽车的比例超过30%\"。因此建立的原假设与备择假设应为     \n<h6>H<sub>0</sub>:π≤30%（家庭拥有汽车的比例不超过30%）;</h6><h6>H<sub>1</sub>:π>30%（家庭拥有汽车的比例超过30%）。</h6></code></pre></div>\n\n<ul>\n<li>原假设和备择假设是一个完备事件组，而且互相对立。也就是说在一项假设检验中，必有且只有一个成立；</li>\n<li>在假设检验中，等号”=”总是放在原假设上。   </li>\n</ul>\n<h4 id=\"1-1-2-单侧检验和双侧检验：\"><a href=\"#1-1-2-单侧检验和双侧检验：\" class=\"headerlink\" title=\"1.1.2 单侧检验和双侧检验：\"></a>1.1.2 单侧检验和双侧检验：</h4><h5 id=\"单侧检验：备择假设具有特定的方向性，并含有符号”-gt-”或”-lt-”的假设检验；\"><a href=\"#单侧检验：备择假设具有特定的方向性，并含有符号”-gt-”或”-lt-”的假设检验；\" class=\"headerlink\" title=\"单侧检验：备择假设具有特定的方向性，并含有符号”&gt;”或”&lt;”的假设检验；\"></a><strong>单侧检验</strong>：备择假设具有特定的方向性，并含有符号”&gt;”或”&lt;”的假设检验；</h5><h5 id=\"双侧检验：备择假设没有特定的方向性，并含有符号”≠”的假设检验。\"><a href=\"#双侧检验：备择假设没有特定的方向性，并含有符号”≠”的假设检验。\" class=\"headerlink\" title=\"双侧检验：备择假设没有特定的方向性，并含有符号”≠”的假设检验。\"></a><strong>双侧检验</strong>：备择假设没有特定的方向性，并含有符号”≠”的假设检验。</h5><p><img src=\"../../img/pvalue/pvalue1.png\" alt=\"假设检验的基本形式\">    <div class='img-note'>假设检验的基本形式</div></p>\n<h4 id=\"1-1-3-两类错误与显著水平\"><a href=\"#1-1-3-两类错误与显著水平\" class=\"headerlink\" title=\"1.1.3 两类错误与显著水平\"></a>1.1.3 两类错误与显著水平</h4><h5 id=\"如前所述，原假设与备择假设不能同时成立，我们要么拒绝原假设，要么不拒绝原假设。我们希望的情况是：当原假设正确时没有拒绝它，当原假设不正确时拒绝它。但是我们无法保证不犯错。假设检验中过程中可能发生以下两类错误：\"><a href=\"#如前所述，原假设与备择假设不能同时成立，我们要么拒绝原假设，要么不拒绝原假设。我们希望的情况是：当原假设正确时没有拒绝它，当原假设不正确时拒绝它。但是我们无法保证不犯错。假设检验中过程中可能发生以下两类错误：\" class=\"headerlink\" title=\"　　如前所述，原假设与备择假设不能同时成立，我们要么拒绝原假设，要么不拒绝原假设。我们希望的情况是：当原假设正确时没有拒绝它，当原假设不正确时拒绝它。但是我们无法保证不犯错。假设检验中过程中可能发生以下两类错误：\"></a>　　如前所述，原假设与备择假设不能同时成立，我们要么拒绝原假设，要么不拒绝原假设。我们希望的情况是：当原假设正确时没有拒绝它，当原假设不正确时拒绝它。但是我们无法保证不犯错。假设检验中过程中可能发生以下两类错误：</h5><h5 id=\"I类错误：当原假设为真是拒绝原假设，所犯的错误称为第I类错误；\"><a href=\"#I类错误：当原假设为真是拒绝原假设，所犯的错误称为第I类错误；\" class=\"headerlink\" title=\"I类错误：当原假设为真是拒绝原假设，所犯的错误称为第I类错误；\"></a><strong>I类错误</strong>：当原假设为真是拒绝原假设，所犯的错误称为第I类错误；</h5><h5 id=\"II类错误：当原假设为假时没有拒绝原假设，所犯错误称为第II类错误。\"><a href=\"#II类错误：当原假设为假时没有拒绝原假设，所犯错误称为第II类错误。\" class=\"headerlink\" title=\"II类错误：当原假设为假时没有拒绝原假设，所犯错误称为第II类错误。\"></a><strong>II类错误</strong>：当原假设为假时没有拒绝原假设，所犯错误称为第II类错误。</h5><p><img src=\"../../img/pvalue/pvalue2.png\" alt=\"假设检验的结论与后果\">   <div class='img-note'>假设检验的结论与后果</div></p>\n<h5 id=\"只有当原假设被拒绝时，我们才会犯第I类错误；只有当原假设未被拒绝时，我们才会犯第II类错误。因此，我们可以不犯第I类错误或不犯第II类错误，但不可能两类错误都不犯。两类错误就像一个跷跷板，当一个概率增大时，另一个减小。人们只能在两类错误的发生概率之间进行平衡。一般来说，发生哪一类错误的后果更为严重，就应该首要控制哪类错误发生的概率，但由于犯第I类错误的概率是可以又研究者控制的，因为此在假设检验中，人们往往先控制第I类错误的发生概率。\"><a href=\"#只有当原假设被拒绝时，我们才会犯第I类错误；只有当原假设未被拒绝时，我们才会犯第II类错误。因此，我们可以不犯第I类错误或不犯第II类错误，但不可能两类错误都不犯。两类错误就像一个跷跷板，当一个概率增大时，另一个减小。人们只能在两类错误的发生概率之间进行平衡。一般来说，发生哪一类错误的后果更为严重，就应该首要控制哪类错误发生的概率，但由于犯第I类错误的概率是可以又研究者控制的，因为此在假设检验中，人们往往先控制第I类错误的发生概率。\" class=\"headerlink\" title=\"　　只有当原假设被拒绝时，我们才会犯第I类错误；只有当原假设未被拒绝时，我们才会犯第II类错误。因此，我们可以不犯第I类错误或不犯第II类错误，但不可能两类错误都不犯。两类错误就像一个跷跷板，当一个概率增大时，另一个减小。人们只能在两类错误的发生概率之间进行平衡。一般来说，发生哪一类错误的后果更为严重，就应该首要控制哪类错误发生的概率，但由于犯第I类错误的概率是可以又研究者控制的，因为此在假设检验中，人们往往先控制第I类错误的发生概率。\"></a>　　只有当原假设被拒绝时，我们才会犯第I类错误；只有当原假设未被拒绝时，我们才会犯第II类错误。因此，我们可以不犯第I类错误或不犯第II类错误，但不可能两类错误都不犯。两类错误就像一个跷跷板，当一个概率增大时，另一个减小。人们只能在两类错误的发生概率之间进行平衡。一般来说，发生哪一类错误的后果更为严重，就应该首要控制哪类错误发生的概率，但由于犯第I类错误的概率是可以又研究者控制的，因为此在假设检验中，人们往往先控制第I类错误的发生概率。</h5><p><code>发生第I类错误的概率常被用于度量检验结论的可靠性，并将这一概率称为显著性水平，记为α。</code></p>\n<h5 id=\"显著水平-是人们事先指定的犯第I类错误概率α的最大允许值。显著水平α越小，犯第I类错误的可能性自然就越小，但犯第II类错误的可能性则随之增大。作为一个普遍使用的原则，人们通常选择显著性水平为0-05或比0-05更小的概率。\"><a href=\"#显著水平-是人们事先指定的犯第I类错误概率α的最大允许值。显著水平α越小，犯第I类错误的可能性自然就越小，但犯第II类错误的可能性则随之增大。作为一个普遍使用的原则，人们通常选择显著性水平为0-05或比0-05更小的概率。\" class=\"headerlink\" title=\"　　显著水平 是人们事先指定的犯第I类错误概率α的最大允许值。显著水平α越小，犯第I类错误的可能性自然就越小，但犯第II类错误的可能性则随之增大。作为一个普遍使用的原则，人们通常选择显著性水平为0.05或比0.05更小的概率。\"></a>　　<strong>显著水平</strong> 是人们事先指定的犯第I类错误概率α的最大允许值。显著水平α越小，犯第I类错误的可能性自然就越小，但犯第II类错误的可能性则随之增大。作为一个普遍使用的原则，人们通常选择显著性水平为0.05或比0.05更小的概率。</h5><h4 id=\"1-1-4-标准化检测量与拒绝域\"><a href=\"#1-1-4-标准化检测量与拒绝域\" class=\"headerlink\" title=\"1.1.4 标准化检测量与拒绝域\"></a>1.1.4 标准化检测量与拒绝域</h4><h5 id=\"检验统计量-实际上是总体参数的点估计量，但点估计量并不能直接作为检验的统计量，只有将其标准化后，才能用于度量它与原假设的参数之间的差异程度。实际上，假设检验中所用的检验统计量都是标准化检验统计量，它反映了点估计量（比如样本均值）与假设的总体参数（比如假设的总体均值）相比相差了多少个标准差。\"><a href=\"#检验统计量-实际上是总体参数的点估计量，但点估计量并不能直接作为检验的统计量，只有将其标准化后，才能用于度量它与原假设的参数之间的差异程度。实际上，假设检验中所用的检验统计量都是标准化检验统计量，它反映了点估计量（比如样本均值）与假设的总体参数（比如假设的总体均值）相比相差了多少个标准差。\" class=\"headerlink\" title=\"　　检验统计量 实际上是总体参数的点估计量，但点估计量并不能直接作为检验的统计量，只有将其标准化后，才能用于度量它与原假设的参数之间的差异程度。实际上，假设检验中所用的检验统计量都是标准化检验统计量，它反映了点估计量（比如样本均值）与假设的总体参数（比如假设的总体均值）相比相差了多少个标准差。\"></a>　　<strong>检验统计量</strong> 实际上是总体参数的点估计量，但点估计量并不能直接作为检验的统计量，只有将其标准化后，才能用于度量它与原假设的参数之间的差异程度。实际上，假设检验中所用的检验统计量都是标准化检验统计量，它反映了点估计量（比如样本均值）与假设的总体参数（比如假设的总体均值）相比相差了多少个标准差。</h5><script type=\"math/tex; mode=display\">标准化检验统计量 = \\frac{点估计量 - 假设值}{点估计量的抽样标准差}</script><h5 id=\"拒绝域-能够拒绝原假设的检验统计量的所有可能取值的集合。是由显著性水平α所围成的区域。如果利用样本观测结果计算出来的检验统计量的具体数值落在了拒绝域内，就拒绝原假设，否则就不拒绝原假设。\"><a href=\"#拒绝域-能够拒绝原假设的检验统计量的所有可能取值的集合。是由显著性水平α所围成的区域。如果利用样本观测结果计算出来的检验统计量的具体数值落在了拒绝域内，就拒绝原假设，否则就不拒绝原假设。\" class=\"headerlink\" title=\"　　拒绝域 能够拒绝原假设的检验统计量的所有可能取值的集合。是由显著性水平α所围成的区域。如果利用样本观测结果计算出来的检验统计量的具体数值落在了拒绝域内，就拒绝原假设，否则就不拒绝原假设。\"></a>　　<strong>拒绝域</strong> 能够拒绝原假设的检验统计量的所有可能取值的集合。是由显著性水平α所围成的区域。如果利用样本观测结果计算出来的检验统计量的具体数值落在了拒绝域内，就拒绝原假设，否则就不拒绝原假设。</h5><p><img src=\"../../img/pvalue/pvalue3.jpeg\" alt=\"显著性水平、拒绝域和临界值\"><div class='img-note'>显著性水平、拒绝域和临界值</div></p>\n<h5 id=\"当样本容量固定时，拒绝域的面积随α的减小而减小。α值越小，拒绝域假设所需的检验统计量的临界值与原假设的参数值就越远。\"><a href=\"#当样本容量固定时，拒绝域的面积随α的减小而减小。α值越小，拒绝域假设所需的检验统计量的临界值与原假设的参数值就越远。\" class=\"headerlink\" title=\"　　当样本容量固定时，拒绝域的面积随α的减小而减小。α值越小，拒绝域假设所需的检验统计量的临界值与原假设的参数值就越远。\"></a>　　当样本容量固定时，拒绝域的面积随α的减小而减小。α值越小，拒绝域假设所需的检验统计量的临界值与原假设的参数值就越远。</h5><h3 id=\"1-2-利用P值进行决策\"><a href=\"#1-2-利用P值进行决策\" class=\"headerlink\" title=\"1.2 利用P值进行决策\"></a>1.2 利用P值进行决策</h3><h5 id=\"显著性水平α是在检验之前确定的，这也就意味着我们事先确定了拒绝域。这样，不论检验统计量的值是大是小，只要它的值落入拒绝域就拒绝原假设，否者就不拒绝原假设。这种固定的显著性水平α对检验结果只能提供检验结论可靠性的一个大致范围，无法给出观测数据与原假设之间不一致程度的精确度量。\"><a href=\"#显著性水平α是在检验之前确定的，这也就意味着我们事先确定了拒绝域。这样，不论检验统计量的值是大是小，只要它的值落入拒绝域就拒绝原假设，否者就不拒绝原假设。这种固定的显著性水平α对检验结果只能提供检验结论可靠性的一个大致范围，无法给出观测数据与原假设之间不一致程度的精确度量。\" class=\"headerlink\" title=\"　　显著性水平α是在检验之前确定的，这也就意味着我们事先确定了拒绝域。这样，不论检验统计量的值是大是小，只要它的值落入拒绝域就拒绝原假设，否者就不拒绝原假设。这种固定的显著性水平α对检验结果只能提供检验结论可靠性的一个大致范围，无法给出观测数据与原假设之间不一致程度的精确度量。\"></a>　　显著性水平α是在检验之前确定的，这也就意味着我们事先确定了拒绝域。这样，不论检验统计量的值是大是小，只要它的值落入拒绝域就拒绝原假设，否者就不拒绝原假设。这种固定的显著性水平α对检验结果只能提供检验结论可靠性的一个大致范围，无法给出观测数据与原假设之间不一致程度的精确度量。</h5><h5 id=\"P值-在原假设为真的条件下，检验统计量的观察值大于或等于其计算值的概率，称为P值。P值是反映实际观测到的数据与原假设之间不一致程度的一个概率值。P值越小，说明实际观测到的数据与原假设之间不一致的程度就越大，检验的结果也就越显著。\"><a href=\"#P值-在原假设为真的条件下，检验统计量的观察值大于或等于其计算值的概率，称为P值。P值是反映实际观测到的数据与原假设之间不一致程度的一个概率值。P值越小，说明实际观测到的数据与原假设之间不一致的程度就越大，检验的结果也就越显著。\" class=\"headerlink\" title=\"　　P值 在原假设为真的条件下，检验统计量的观察值大于或等于其计算值的概率，称为P值。P值是反映实际观测到的数据与原假设之间不一致程度的一个概率值。P值越小，说明实际观测到的数据与原假设之间不一致的程度就越大，检验的结果也就越显著。\"></a>　　<strong>P值</strong> 在原假设为真的条件下，检验统计量的观察值大于或等于其计算值的概率，称为P值。P值是反映实际观测到的数据与原假设之间不一致程度的一个概率值。P值越小，说明实际观测到的数据与原假设之间不一致的程度就越大，检验的结果也就越显著。</h5><h3 id=\"1-3-一个总体参数的检验\"><a href=\"#1-3-一个总体参数的检验\" class=\"headerlink\" title=\"1.3 一个总体参数的检验\"></a>1.3 一个总体参数的检验</h3><h5 id=\"当我们研究一个总体时，要检验的参数主要是总体均值μ、总体比例π和总体方差σ2。由于检验的参数不同，计算检验统计量的方法也有所不同。\"><a href=\"#当我们研究一个总体时，要检验的参数主要是总体均值μ、总体比例π和总体方差σ2。由于检验的参数不同，计算检验统计量的方法也有所不同。\" class=\"headerlink\" title=\"　　当我们研究一个总体时，要检验的参数主要是总体均值μ、总体比例π和总体方差σ2。由于检验的参数不同，计算检验统计量的方法也有所不同。\"></a>　　当我们研究一个总体时，要检验的参数主要是总体均值μ、总体比例π和总体方差σ<SUP>2</SUP>。由于检验的参数不同，计算检验统计量的方法也有所不同。</h5><h4 id=\"1-3-1-总体均值的检验\"><a href=\"#1-3-1-总体均值的检验\" class=\"headerlink\" title=\"1.3.1 总体均值的检验\"></a>1.3.1 总体均值的检验</h4><h5 id=\"对于总体均值进行假设检验，采用什么检验步骤和检验统计量取决于我们所抽取的样本是大样本（n≥30）还是小样本（n\"><a href=\"#对于总体均值进行假设检验，采用什么检验步骤和检验统计量取决于我们所抽取的样本是大样本（n≥30）还是小样本（n\" class=\"headerlink\" title=\"　　对于总体均值进行假设检验，采用什么检验步骤和检验统计量取决于我们所抽取的样本是大样本（n≥30）还是小样本（n\"></a>　　对于总体均值进行假设检验，采用什么检验步骤和检验统计量取决于我们所抽取的样本是大样本（n≥30）还是小样本（n<30），此外还需要区分总体是否服从正太分布、总体方差σ<SUP>2&lt;/SUP&gt;是否已知等几种情况。</h5><p><img src=\"../../img/pvalue/pvalue4.png\" alt=\"大样本情况下一个总体均值的检验方法\">    <div class='img-note'>大样本情况下一个总体均值的检验方法</div><br><img src=\"../../img/pvalue/pvalue5.png\" alt=\"小样本情况下一个总体均值的检验方法\">    <div class='img-note'>小样本情况下一个总体均值的检验方法</div></p>\n<h5 id=\"Z表示转换为标准正太分布下的检验统计量。\"><a href=\"#Z表示转换为标准正太分布下的检验统计量。\" class=\"headerlink\" title=\"　　Z表示转换为标准正太分布下的检验统计量。\"></a>　　Z表示转换为标准正太分布下的检验统计量。</h5><h4 id=\"1-3-2-总体比例的检验\"><a href=\"#1-3-2-总体比例的检验\" class=\"headerlink\" title=\"1.3.2 总体比例的检验\"></a>1.3.2 总体比例的检验</h4><h5 id=\"总体比例是指总体中具有某种相同特征的个体所占的比例，这些特征可以是数据型的（如一定的重量、一定的厚度或一定规格等），也可以是品质型的（如男女比例、学历等级、职称高低等）。\"><a href=\"#总体比例是指总体中具有某种相同特征的个体所占的比例，这些特征可以是数据型的（如一定的重量、一定的厚度或一定规格等），也可以是品质型的（如男女比例、学历等级、职称高低等）。\" class=\"headerlink\" title=\"　　总体比例是指总体中具有某种相同特征的个体所占的比例，这些特征可以是数据型的（如一定的重量、一定的厚度或一定规格等），也可以是品质型的（如男女比例、学历等级、职称高低等）。\"></a>　　总体比例是指总体中具有某种相同特征的个体所占的比例，这些特征可以是数据型的（如一定的重量、一定的厚度或一定规格等），也可以是品质型的（如男女比例、学历等级、职称高低等）。</h5><h5 id=\"在构造检验统计量时，我们仍然利用样本比例p与总体比例π之间的距离等于多少个标准差来衡量，因为在大样本情况下统计量p近似服从正太分布，而统计量\"><a href=\"#在构造检验统计量时，我们仍然利用样本比例p与总体比例π之间的距离等于多少个标准差来衡量，因为在大样本情况下统计量p近似服从正太分布，而统计量\" class=\"headerlink\" title=\"　　在构造检验统计量时，我们仍然利用样本比例p与总体比例π之间的距离等于多少个标准差来衡量，因为在大样本情况下统计量p近似服从正太分布，而统计量\"></a>　　在构造检验统计量时，我们仍然利用样本比例p与总体比例π之间的距离等于多少个标准差来衡量，因为在大样本情况下统计量p近似服从正太分布，而统计量</h5><script type=\"math/tex; mode=display\">z = \\frac{P - π_0}{\\sqrt{\\frac{π_0(1-π_0)}{n}}}</script><p><img src=\"../../img/pvalue/pvalue6.png\" alt=\"大样本情况下一个总体比例的检验方法\">    <div class='img-note'>大样本情况下一个总体比例的检验方法</div></p>\n<h3 id=\"1-4-两个总体参数的检验\"><a href=\"#1-4-两个总体参数的检验\" class=\"headerlink\" title=\"1.4 两个总体参数的检验\"></a>1.4 两个总体参数的检验</h3><h5 id=\"在实际研究中，我们常常要比较两个总体的差异，如一所学校的重点班和普通班两个班级学生的英语成绩是否有显著差异；生产企业在改进生产线后的平均产量与原生产线的平均产量相比是否有显著提高等等。\"><a href=\"#在实际研究中，我们常常要比较两个总体的差异，如一所学校的重点班和普通班两个班级学生的英语成绩是否有显著差异；生产企业在改进生产线后的平均产量与原生产线的平均产量相比是否有显著提高等等。\" class=\"headerlink\" title=\"　　在实际研究中，我们常常要比较两个总体的差异，如一所学校的重点班和普通班两个班级学生的英语成绩是否有显著差异；生产企业在改进生产线后的平均产量与原生产线的平均产量相比是否有显著提高等等。\"></a>　　在实际研究中，我们常常要比较两个总体的差异，如一所学校的重点班和普通班两个班级学生的英语成绩是否有显著差异；生产企业在改进生产线后的平均产量与原生产线的平均产量相比是否有显著提高等等。</h5><p><img src=\"../../img/pvalue/pvalue7.png\" alt=\"两个总体均值之差的三种基本假设检验形式\">    <div class='img-note'>两个总体均值之差的三种基本假设检验形式</div></p>\n<h2 id=\"2-JAVA实现P值计算\"><a href=\"#2-JAVA实现P值计算\" class=\"headerlink\" title=\"2. JAVA实现P值计算\"></a>2. JAVA实现P值计算</h2>"},{"layout":"post","title":"将二元查找树转变成排序的双向链表","date":"2017-02-17T16:00:00.000Z","_content":"\n### 题目要求：\n##### 输入一棵二元查找树，将该二元查找树转换成一个排序的双向链表。\n##### 要求不能创建任何新的结点，只调整指针的指向。\n<!--more-->\n#### 举个例子，\n![二元查找树](../../img/arithmetic/BinaryTree.png)\n##### 转换成双向链表\n##### 4=6=8=10=12=14=16\n#### 首先我们定义的二元查找树 节点的数据结构如下：\n``\nstruct BSTreeNode\n{\n  int m_nValue; // value of node\n  BSTreeNode *m_pLeft;\n  BSTreeNode *m_pRight; // right child of node\n};\n``\n### 分析过程（不一定正确）：\n##### 二元查找树的特征比较明显，每个节点最多有两个子节点，分别为左节点和右节点，左节点的所有值都小于该节点，右节点的值大于该节点。这个题目其实很简单，就是实现二叉树的中序遍历。中序遍历就是左中右遍历。\n\n#### 遍历过程，利用数据结构-栈实现，从根节点开始遍历\n1. 判断是否有左节点，\n　　1.1 如果有，则将该节点如栈，然后左节点重复流程1\n　　1.2 如果没有，则将本节点写入连表尾部\n　　1.3 判断是否有右节点\n","source":"_posts/arithmetic/arithmetic-17-02-18.md","raw":"---\nlayout: post\ntitle: 将二元查找树转变成排序的双向链表\ndate: 2017/02/18\ntags: [arithmetic, index]\n---\n\n### 题目要求：\n##### 输入一棵二元查找树，将该二元查找树转换成一个排序的双向链表。\n##### 要求不能创建任何新的结点，只调整指针的指向。\n<!--more-->\n#### 举个例子，\n![二元查找树](../../img/arithmetic/BinaryTree.png)\n##### 转换成双向链表\n##### 4=6=8=10=12=14=16\n#### 首先我们定义的二元查找树 节点的数据结构如下：\n``\nstruct BSTreeNode\n{\n  int m_nValue; // value of node\n  BSTreeNode *m_pLeft;\n  BSTreeNode *m_pRight; // right child of node\n};\n``\n### 分析过程（不一定正确）：\n##### 二元查找树的特征比较明显，每个节点最多有两个子节点，分别为左节点和右节点，左节点的所有值都小于该节点，右节点的值大于该节点。这个题目其实很简单，就是实现二叉树的中序遍历。中序遍历就是左中右遍历。\n\n#### 遍历过程，利用数据结构-栈实现，从根节点开始遍历\n1. 判断是否有左节点，\n　　1.1 如果有，则将该节点如栈，然后左节点重复流程1\n　　1.2 如果没有，则将本节点写入连表尾部\n　　1.3 判断是否有右节点\n","slug":"arithmetic/arithmetic-17-02-18","published":1,"updated":"2017-02-18T16:32:54.000Z","_id":"cizbemklw0002sebf4jctsb5y","comments":1,"photos":[],"link":"","content":"<h3 id=\"题目要求：\"><a href=\"#题目要求：\" class=\"headerlink\" title=\"题目要求：\"></a>题目要求：</h3><h5 id=\"输入一棵二元查找树，将该二元查找树转换成一个排序的双向链表。\"><a href=\"#输入一棵二元查找树，将该二元查找树转换成一个排序的双向链表。\" class=\"headerlink\" title=\"输入一棵二元查找树，将该二元查找树转换成一个排序的双向链表。\"></a>输入一棵二元查找树，将该二元查找树转换成一个排序的双向链表。</h5><h5 id=\"要求不能创建任何新的结点，只调整指针的指向。\"><a href=\"#要求不能创建任何新的结点，只调整指针的指向。\" class=\"headerlink\" title=\"要求不能创建任何新的结点，只调整指针的指向。\"></a>要求不能创建任何新的结点，只调整指针的指向。</h5><a id=\"more\"></a>\n<h4 id=\"举个例子，\"><a href=\"#举个例子，\" class=\"headerlink\" title=\"举个例子，\"></a>举个例子，</h4><p><img src=\"../../img/arithmetic/BinaryTree.png\" alt=\"二元查找树\"></p>\n<h5 id=\"转换成双向链表\"><a href=\"#转换成双向链表\" class=\"headerlink\" title=\"转换成双向链表\"></a>转换成双向链表</h5><h5 id=\"4-6-8-10-12-14-16\"><a href=\"#4-6-8-10-12-14-16\" class=\"headerlink\" title=\"4=6=8=10=12=14=16\"></a>4=6=8=10=12=14=16</h5><h4 id=\"首先我们定义的二元查找树-节点的数据结构如下：\"><a href=\"#首先我们定义的二元查找树-节点的数据结构如下：\" class=\"headerlink\" title=\"首先我们定义的二元查找树 节点的数据结构如下：\"></a>首先我们定义的二元查找树 节点的数据结构如下：</h4><p><code>struct BSTreeNode\n{\n  int m_nValue; // value of node\n  BSTreeNode *m_pLeft;\n  BSTreeNode *m_pRight; // right child of node\n};</code></p>\n<h3 id=\"分析过程（不一定正确）：\"><a href=\"#分析过程（不一定正确）：\" class=\"headerlink\" title=\"分析过程（不一定正确）：\"></a>分析过程（不一定正确）：</h3><h5 id=\"二元查找树的特征比较明显，每个节点最多有两个子节点，分别为左节点和右节点，左节点的所有值都小于该节点，右节点的值大于该节点。这个题目其实很简单，就是实现二叉树的中序遍历。中序遍历就是左中右遍历。\"><a href=\"#二元查找树的特征比较明显，每个节点最多有两个子节点，分别为左节点和右节点，左节点的所有值都小于该节点，右节点的值大于该节点。这个题目其实很简单，就是实现二叉树的中序遍历。中序遍历就是左中右遍历。\" class=\"headerlink\" title=\"二元查找树的特征比较明显，每个节点最多有两个子节点，分别为左节点和右节点，左节点的所有值都小于该节点，右节点的值大于该节点。这个题目其实很简单，就是实现二叉树的中序遍历。中序遍历就是左中右遍历。\"></a>二元查找树的特征比较明显，每个节点最多有两个子节点，分别为左节点和右节点，左节点的所有值都小于该节点，右节点的值大于该节点。这个题目其实很简单，就是实现二叉树的中序遍历。中序遍历就是左中右遍历。</h5><h4 id=\"遍历过程，利用数据结构-栈实现，从根节点开始遍历\"><a href=\"#遍历过程，利用数据结构-栈实现，从根节点开始遍历\" class=\"headerlink\" title=\"遍历过程，利用数据结构-栈实现，从根节点开始遍历\"></a>遍历过程，利用数据结构-栈实现，从根节点开始遍历</h4><ol>\n<li>判断是否有左节点，<br>　　1.1 如果有，则将该节点如栈，然后左节点重复流程1<br>　　1.2 如果没有，则将本节点写入连表尾部<br>　　1.3 判断是否有右节点</li>\n</ol>\n","excerpt":"<h3 id=\"题目要求：\"><a href=\"#题目要求：\" class=\"headerlink\" title=\"题目要求：\"></a>题目要求：</h3><h5 id=\"输入一棵二元查找树，将该二元查找树转换成一个排序的双向链表。\"><a href=\"#输入一棵二元查找树，将该二元查找树转换成一个排序的双向链表。\" class=\"headerlink\" title=\"输入一棵二元查找树，将该二元查找树转换成一个排序的双向链表。\"></a>输入一棵二元查找树，将该二元查找树转换成一个排序的双向链表。</h5><h5 id=\"要求不能创建任何新的结点，只调整指针的指向。\"><a href=\"#要求不能创建任何新的结点，只调整指针的指向。\" class=\"headerlink\" title=\"要求不能创建任何新的结点，只调整指针的指向。\"></a>要求不能创建任何新的结点，只调整指针的指向。</h5>","more":"<h4 id=\"举个例子，\"><a href=\"#举个例子，\" class=\"headerlink\" title=\"举个例子，\"></a>举个例子，</h4><p><img src=\"../../img/arithmetic/BinaryTree.png\" alt=\"二元查找树\"></p>\n<h5 id=\"转换成双向链表\"><a href=\"#转换成双向链表\" class=\"headerlink\" title=\"转换成双向链表\"></a>转换成双向链表</h5><h5 id=\"4-6-8-10-12-14-16\"><a href=\"#4-6-8-10-12-14-16\" class=\"headerlink\" title=\"4=6=8=10=12=14=16\"></a>4=6=8=10=12=14=16</h5><h4 id=\"首先我们定义的二元查找树-节点的数据结构如下：\"><a href=\"#首先我们定义的二元查找树-节点的数据结构如下：\" class=\"headerlink\" title=\"首先我们定义的二元查找树 节点的数据结构如下：\"></a>首先我们定义的二元查找树 节点的数据结构如下：</h4><p><code>struct BSTreeNode\n{\n  int m_nValue; // value of node\n  BSTreeNode *m_pLeft;\n  BSTreeNode *m_pRight; // right child of node\n};</code></p>\n<h3 id=\"分析过程（不一定正确）：\"><a href=\"#分析过程（不一定正确）：\" class=\"headerlink\" title=\"分析过程（不一定正确）：\"></a>分析过程（不一定正确）：</h3><h5 id=\"二元查找树的特征比较明显，每个节点最多有两个子节点，分别为左节点和右节点，左节点的所有值都小于该节点，右节点的值大于该节点。这个题目其实很简单，就是实现二叉树的中序遍历。中序遍历就是左中右遍历。\"><a href=\"#二元查找树的特征比较明显，每个节点最多有两个子节点，分别为左节点和右节点，左节点的所有值都小于该节点，右节点的值大于该节点。这个题目其实很简单，就是实现二叉树的中序遍历。中序遍历就是左中右遍历。\" class=\"headerlink\" title=\"二元查找树的特征比较明显，每个节点最多有两个子节点，分别为左节点和右节点，左节点的所有值都小于该节点，右节点的值大于该节点。这个题目其实很简单，就是实现二叉树的中序遍历。中序遍历就是左中右遍历。\"></a>二元查找树的特征比较明显，每个节点最多有两个子节点，分别为左节点和右节点，左节点的所有值都小于该节点，右节点的值大于该节点。这个题目其实很简单，就是实现二叉树的中序遍历。中序遍历就是左中右遍历。</h5><h4 id=\"遍历过程，利用数据结构-栈实现，从根节点开始遍历\"><a href=\"#遍历过程，利用数据结构-栈实现，从根节点开始遍历\" class=\"headerlink\" title=\"遍历过程，利用数据结构-栈实现，从根节点开始遍历\"></a>遍历过程，利用数据结构-栈实现，从根节点开始遍历</h4><ol>\n<li>判断是否有左节点，<br>　　1.1 如果有，则将该节点如栈，然后左节点重复流程1<br>　　1.2 如果没有，则将本节点写入连表尾部<br>　　1.3 判断是否有右节点</li>\n</ol>"},{"layout":"post","title":"根据上排给出十个数，在其下排填出对应的十个数","date":"2017-02-15T16:00:00.000Z","_content":"\n<script type=\"text/javascript\" async\n            src=\"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML\">\n    </script>\n\n### 题目要求：\n##### 给你10分钟时间，根据上排给出十个数，在其下排填出对应的十个数,要求下排每个数都是先前上排那十个数在下排出现的次数。\n##### 上排的十个数如下：【0，1，2，3，4，5，6，7，8，9】\n<!--more-->\n\n#### 举个例子，\n##### 上排数值: 0,1,2,3,4,5,6,7,8,9\n##### 下排数值: 6,2,1,0,0,0,1,0,0,0\n##### 0在下排出现了6次，1在下排出现了2次，\n##### 2在下排出现了1次，3在下排出现了0次...\n\n### 分析过程（不一定正确）：\n##### 看到题目的时候觉得有一点绕，切没有太理解题目，以为是一直循环输出下排数组，于是有了下面的解题过程。\n#### 根据题目得到的一些条件：\n1. 10个数，每个数都大于等于0；\n2. 下排的数字为上排数字出现的次数；\n3. 基于条件2，下排数字相加一定等于10；\n4. 基于条件3，下排数字有0，要么下排全等于1，很明显全等于1就不符合条件2，所以下排数字一定有0；\n5. 根据条件4，上排数字也有0；\n\n#### 基于上面几个条件，做出下面的一些假设：\n##### 上排的10个数中，有n个数字为0，则非0的数有10-n：\n$$ \\underbrace{0...0}_{\\text{n个0}},\\overbrace{v_1...v_i}^{\\text{10-n个非0数字}} $$\n##### 如果上排为0的下排也为0，显然不符合条件2，所以0的下排数字为非0，切所有0的下排数字相等，假设为非0数x,则上排一定有一个数字为x,对应的下排数字为n：\n$$ 上排：0...0,v_1...v_i,x $$\n$$ 下排：\\underbrace{x...x}_{\\text{n个x}},i_1...i_i,n $$\n##### 上排的0在下排为x，则说明下排有x个0,进一步得出下面的组合：\n$$ 上排：0...0,v_1...v_i,v_j...v_k,x $$\n$$ 下排：\\underbrace{x...x}_{\\text{n个x}},\\underbrace{0....0}_{\\text{x个0}},i_i....i_k,n $$\n##### 根据条件1，下排一共10个数，所以：\n$$ n+x+1≤10 $$\n##### 根据条件3，下排数字相加等于10，所以：\n$$ nx+n≤10 $$\n##### 当v<sub>j</sub>到v<sub>k</sub>不存在，也就是个数为0时，上面两个不等式的等号成立，所以有以下两个函数：\n$$\\begin{cases}\nn+x+1=10 \\\\\\\\\nnx+n=10 \\\\\\\\\nx,n 为 正整数\n\\end{cases}\n\\implies\n\\begin{cases}\nn+x+1<10 \\\\\\\\\nnx+n<10 \\\\\\\\\nx,n 为 正整数\n\\end{cases}\n$$\n##### 因为x，n均为正整数，所以枚举所有情况如下：\n$$\nn=\\begin{cases}\n[1,2,3,4] &x=1 \\\\\\\\\n[1,2,3] &x=2 \\\\\\\\\n[1,2,] &x=3 \\\\\\\\\n[1] &x=4 \\\\\\\\\n[1] &x=5 \\\\\\\\\n[1] &x=6 \\\\\\\\\n[1] &x=7 \\\\\\\\\n[1] &x=8\n\\end{cases}\n$$\n##### 于是我基于这种组合，将6,2,1,0,0,0,1,0,0,0默认为上排函数，发现n=6,计算不出下排函数。百度以后发现，人家根本不是按照我的这种方式去计算。下面说一下正确的解题思路.\n\n### 解题：\n##### 它的原型跟八皇后有点类似，都是用回溯递归的方法去一次一次尝试，直到找出正确解。\n##### 具体的想法是：不断的去从下排数组中捉取在上排数组中对应位置中出现的个数，如果个数不对就更新下排数组中对应的值，只到找到正确值。（下排数组先初始为任意值）\n##### 如：\n##### 上排数组A：0,1,2,3,4,5,6,7,8,9\n##### 下排数组B：0,1,2,3,4,5,6,7,8,9\n##### 从上牌数组Index = 0开始，A[0] = 0，0在下排数组中的个数为1，那么下排数组B此时就要更新为：1,1,2,3,4,5,6,7,8,9\n##### Index = 1, A[1] = 1, 1在下排数组中的个数为2，那么下排数组B此时就要更新为：1,2,2,3,4,5,6,7,8,9，从此不断的往下进行，只要找不到正确值就一直往下进行，如果Index >= 数组长度时，那么重新恢复Index = 0再往下进行测试直到找出正确解。\n\n### 最后在说一些：\n##### 其实按照上面的这种解题思路，我的解题过程也不能算是错误的，只是排除了大部分的可能性。并且题目也理解有误，所以以后做题一定要看清楚题，理解题目的正真含义。\n","source":"_posts/arithmetic/arithmetic-17-02-16.md","raw":"---\nlayout: post\ntitle: 根据上排给出十个数，在其下排填出对应的十个数\ndate: 2017/02/16\ntags: [arithmetic, index]\n---\n\n<script type=\"text/javascript\" async\n            src=\"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML\">\n    </script>\n\n### 题目要求：\n##### 给你10分钟时间，根据上排给出十个数，在其下排填出对应的十个数,要求下排每个数都是先前上排那十个数在下排出现的次数。\n##### 上排的十个数如下：【0，1，2，3，4，5，6，7，8，9】\n<!--more-->\n\n#### 举个例子，\n##### 上排数值: 0,1,2,3,4,5,6,7,8,9\n##### 下排数值: 6,2,1,0,0,0,1,0,0,0\n##### 0在下排出现了6次，1在下排出现了2次，\n##### 2在下排出现了1次，3在下排出现了0次...\n\n### 分析过程（不一定正确）：\n##### 看到题目的时候觉得有一点绕，切没有太理解题目，以为是一直循环输出下排数组，于是有了下面的解题过程。\n#### 根据题目得到的一些条件：\n1. 10个数，每个数都大于等于0；\n2. 下排的数字为上排数字出现的次数；\n3. 基于条件2，下排数字相加一定等于10；\n4. 基于条件3，下排数字有0，要么下排全等于1，很明显全等于1就不符合条件2，所以下排数字一定有0；\n5. 根据条件4，上排数字也有0；\n\n#### 基于上面几个条件，做出下面的一些假设：\n##### 上排的10个数中，有n个数字为0，则非0的数有10-n：\n$$ \\underbrace{0...0}_{\\text{n个0}},\\overbrace{v_1...v_i}^{\\text{10-n个非0数字}} $$\n##### 如果上排为0的下排也为0，显然不符合条件2，所以0的下排数字为非0，切所有0的下排数字相等，假设为非0数x,则上排一定有一个数字为x,对应的下排数字为n：\n$$ 上排：0...0,v_1...v_i,x $$\n$$ 下排：\\underbrace{x...x}_{\\text{n个x}},i_1...i_i,n $$\n##### 上排的0在下排为x，则说明下排有x个0,进一步得出下面的组合：\n$$ 上排：0...0,v_1...v_i,v_j...v_k,x $$\n$$ 下排：\\underbrace{x...x}_{\\text{n个x}},\\underbrace{0....0}_{\\text{x个0}},i_i....i_k,n $$\n##### 根据条件1，下排一共10个数，所以：\n$$ n+x+1≤10 $$\n##### 根据条件3，下排数字相加等于10，所以：\n$$ nx+n≤10 $$\n##### 当v<sub>j</sub>到v<sub>k</sub>不存在，也就是个数为0时，上面两个不等式的等号成立，所以有以下两个函数：\n$$\\begin{cases}\nn+x+1=10 \\\\\\\\\nnx+n=10 \\\\\\\\\nx,n 为 正整数\n\\end{cases}\n\\implies\n\\begin{cases}\nn+x+1<10 \\\\\\\\\nnx+n<10 \\\\\\\\\nx,n 为 正整数\n\\end{cases}\n$$\n##### 因为x，n均为正整数，所以枚举所有情况如下：\n$$\nn=\\begin{cases}\n[1,2,3,4] &x=1 \\\\\\\\\n[1,2,3] &x=2 \\\\\\\\\n[1,2,] &x=3 \\\\\\\\\n[1] &x=4 \\\\\\\\\n[1] &x=5 \\\\\\\\\n[1] &x=6 \\\\\\\\\n[1] &x=7 \\\\\\\\\n[1] &x=8\n\\end{cases}\n$$\n##### 于是我基于这种组合，将6,2,1,0,0,0,1,0,0,0默认为上排函数，发现n=6,计算不出下排函数。百度以后发现，人家根本不是按照我的这种方式去计算。下面说一下正确的解题思路.\n\n### 解题：\n##### 它的原型跟八皇后有点类似，都是用回溯递归的方法去一次一次尝试，直到找出正确解。\n##### 具体的想法是：不断的去从下排数组中捉取在上排数组中对应位置中出现的个数，如果个数不对就更新下排数组中对应的值，只到找到正确值。（下排数组先初始为任意值）\n##### 如：\n##### 上排数组A：0,1,2,3,4,5,6,7,8,9\n##### 下排数组B：0,1,2,3,4,5,6,7,8,9\n##### 从上牌数组Index = 0开始，A[0] = 0，0在下排数组中的个数为1，那么下排数组B此时就要更新为：1,1,2,3,4,5,6,7,8,9\n##### Index = 1, A[1] = 1, 1在下排数组中的个数为2，那么下排数组B此时就要更新为：1,2,2,3,4,5,6,7,8,9，从此不断的往下进行，只要找不到正确值就一直往下进行，如果Index >= 数组长度时，那么重新恢复Index = 0再往下进行测试直到找出正确解。\n\n### 最后在说一些：\n##### 其实按照上面的这种解题思路，我的解题过程也不能算是错误的，只是排除了大部分的可能性。并且题目也理解有误，所以以后做题一定要看清楚题，理解题目的正真含义。\n","slug":"arithmetic/arithmetic-17-02-16","published":1,"updated":"2017-02-18T15:35:08.000Z","_id":"cizbemkm60004sebfchxxnug6","comments":1,"photos":[],"link":"","content":"<script type=\"text/javascript\" async src=\"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML\">\n    </script>\n\n<h3 id=\"题目要求：\"><a href=\"#题目要求：\" class=\"headerlink\" title=\"题目要求：\"></a>题目要求：</h3><h5 id=\"给你10分钟时间，根据上排给出十个数，在其下排填出对应的十个数-要求下排每个数都是先前上排那十个数在下排出现的次数。\"><a href=\"#给你10分钟时间，根据上排给出十个数，在其下排填出对应的十个数-要求下排每个数都是先前上排那十个数在下排出现的次数。\" class=\"headerlink\" title=\"给你10分钟时间，根据上排给出十个数，在其下排填出对应的十个数,要求下排每个数都是先前上排那十个数在下排出现的次数。\"></a>给你10分钟时间，根据上排给出十个数，在其下排填出对应的十个数,要求下排每个数都是先前上排那十个数在下排出现的次数。</h5><h5 id=\"上排的十个数如下：【0，1，2，3，4，5，6，7，8，9】\"><a href=\"#上排的十个数如下：【0，1，2，3，4，5，6，7，8，9】\" class=\"headerlink\" title=\"上排的十个数如下：【0，1，2，3，4，5，6，7，8，9】\"></a>上排的十个数如下：【0，1，2，3，4，5，6，7，8，9】</h5><a id=\"more\"></a>\n<h4 id=\"举个例子，\"><a href=\"#举个例子，\" class=\"headerlink\" title=\"举个例子，\"></a>举个例子，</h4><h5 id=\"上排数值-0-1-2-3-4-5-6-7-8-9\"><a href=\"#上排数值-0-1-2-3-4-5-6-7-8-9\" class=\"headerlink\" title=\"上排数值: 0,1,2,3,4,5,6,7,8,9\"></a>上排数值: 0,1,2,3,4,5,6,7,8,9</h5><h5 id=\"下排数值-6-2-1-0-0-0-1-0-0-0\"><a href=\"#下排数值-6-2-1-0-0-0-1-0-0-0\" class=\"headerlink\" title=\"下排数值: 6,2,1,0,0,0,1,0,0,0\"></a>下排数值: 6,2,1,0,0,0,1,0,0,0</h5><h5 id=\"0在下排出现了6次，1在下排出现了2次，\"><a href=\"#0在下排出现了6次，1在下排出现了2次，\" class=\"headerlink\" title=\"0在下排出现了6次，1在下排出现了2次，\"></a>0在下排出现了6次，1在下排出现了2次，</h5><h5 id=\"2在下排出现了1次，3在下排出现了0次…\"><a href=\"#2在下排出现了1次，3在下排出现了0次…\" class=\"headerlink\" title=\"2在下排出现了1次，3在下排出现了0次…\"></a>2在下排出现了1次，3在下排出现了0次…</h5><h3 id=\"分析过程（不一定正确）：\"><a href=\"#分析过程（不一定正确）：\" class=\"headerlink\" title=\"分析过程（不一定正确）：\"></a>分析过程（不一定正确）：</h3><h5 id=\"看到题目的时候觉得有一点绕，切没有太理解题目，以为是一直循环输出下排数组，于是有了下面的解题过程。\"><a href=\"#看到题目的时候觉得有一点绕，切没有太理解题目，以为是一直循环输出下排数组，于是有了下面的解题过程。\" class=\"headerlink\" title=\"看到题目的时候觉得有一点绕，切没有太理解题目，以为是一直循环输出下排数组，于是有了下面的解题过程。\"></a>看到题目的时候觉得有一点绕，切没有太理解题目，以为是一直循环输出下排数组，于是有了下面的解题过程。</h5><h4 id=\"根据题目得到的一些条件：\"><a href=\"#根据题目得到的一些条件：\" class=\"headerlink\" title=\"根据题目得到的一些条件：\"></a>根据题目得到的一些条件：</h4><ol>\n<li>10个数，每个数都大于等于0；</li>\n<li>下排的数字为上排数字出现的次数；</li>\n<li>基于条件2，下排数字相加一定等于10；</li>\n<li>基于条件3，下排数字有0，要么下排全等于1，很明显全等于1就不符合条件2，所以下排数字一定有0；</li>\n<li>根据条件4，上排数字也有0；</li>\n</ol>\n<h4 id=\"基于上面几个条件，做出下面的一些假设：\"><a href=\"#基于上面几个条件，做出下面的一些假设：\" class=\"headerlink\" title=\"基于上面几个条件，做出下面的一些假设：\"></a>基于上面几个条件，做出下面的一些假设：</h4><h5 id=\"上排的10个数中，有n个数字为0，则非0的数有10-n：\"><a href=\"#上排的10个数中，有n个数字为0，则非0的数有10-n：\" class=\"headerlink\" title=\"上排的10个数中，有n个数字为0，则非0的数有10-n：\"></a>上排的10个数中，有n个数字为0，则非0的数有10-n：</h5><script type=\"math/tex; mode=display\">\\underbrace{0...0}_{\\text{n个0}},\\overbrace{v_1...v_i}^{\\text{10-n个非0数字}}</script><h5 id=\"如果上排为0的下排也为0，显然不符合条件2，所以0的下排数字为非0，切所有0的下排数字相等，假设为非0数x-则上排一定有一个数字为x-对应的下排数字为n：\"><a href=\"#如果上排为0的下排也为0，显然不符合条件2，所以0的下排数字为非0，切所有0的下排数字相等，假设为非0数x-则上排一定有一个数字为x-对应的下排数字为n：\" class=\"headerlink\" title=\"如果上排为0的下排也为0，显然不符合条件2，所以0的下排数字为非0，切所有0的下排数字相等，假设为非0数x,则上排一定有一个数字为x,对应的下排数字为n：\"></a>如果上排为0的下排也为0，显然不符合条件2，所以0的下排数字为非0，切所有0的下排数字相等，假设为非0数x,则上排一定有一个数字为x,对应的下排数字为n：</h5><script type=\"math/tex; mode=display\">上排：0...0,v_1...v_i,x</script><script type=\"math/tex; mode=display\">下排：\\underbrace{x...x}_{\\text{n个x}},i_1...i_i,n</script><h5 id=\"上排的0在下排为x，则说明下排有x个0-进一步得出下面的组合：\"><a href=\"#上排的0在下排为x，则说明下排有x个0-进一步得出下面的组合：\" class=\"headerlink\" title=\"上排的0在下排为x，则说明下排有x个0,进一步得出下面的组合：\"></a>上排的0在下排为x，则说明下排有x个0,进一步得出下面的组合：</h5><script type=\"math/tex; mode=display\">上排：0...0,v_1...v_i,v_j...v_k,x</script><script type=\"math/tex; mode=display\">下排：\\underbrace{x...x}_{\\text{n个x}},\\underbrace{0....0}_{\\text{x个0}},i_i....i_k,n</script><h5 id=\"根据条件1，下排一共10个数，所以：\"><a href=\"#根据条件1，下排一共10个数，所以：\" class=\"headerlink\" title=\"根据条件1，下排一共10个数，所以：\"></a>根据条件1，下排一共10个数，所以：</h5><script type=\"math/tex; mode=display\">n+x+1≤10</script><h5 id=\"根据条件3，下排数字相加等于10，所以：\"><a href=\"#根据条件3，下排数字相加等于10，所以：\" class=\"headerlink\" title=\"根据条件3，下排数字相加等于10，所以：\"></a>根据条件3，下排数字相加等于10，所以：</h5><script type=\"math/tex; mode=display\">nx+n≤10</script><h5 id=\"当vj到vk不存在，也就是个数为0时，上面两个不等式的等号成立，所以有以下两个函数：\"><a href=\"#当vj到vk不存在，也就是个数为0时，上面两个不等式的等号成立，所以有以下两个函数：\" class=\"headerlink\" title=\"当vj到vk不存在，也就是个数为0时，上面两个不等式的等号成立，所以有以下两个函数：\"></a>当v<sub>j</sub>到v<sub>k</sub>不存在，也就是个数为0时，上面两个不等式的等号成立，所以有以下两个函数：</h5><script type=\"math/tex; mode=display\">\\begin{cases}\nn+x+1=10 \\\\\\\\\nnx+n=10 \\\\\\\\\nx,n 为 正整数\n\\end{cases}\n\\implies\n\\begin{cases}\nn+x+1<10 \\\\\\\\\nnx+n<10 \\\\\\\\\nx,n 为 正整数\n\\end{cases}</script><h5 id=\"因为x，n均为正整数，所以枚举所有情况如下：\"><a href=\"#因为x，n均为正整数，所以枚举所有情况如下：\" class=\"headerlink\" title=\"因为x，n均为正整数，所以枚举所有情况如下：\"></a>因为x，n均为正整数，所以枚举所有情况如下：</h5><script type=\"math/tex; mode=display\">\nn=\\begin{cases}\n[1,2,3,4] &x=1 \\\\\\\\\n[1,2,3] &x=2 \\\\\\\\\n[1,2,] &x=3 \\\\\\\\\n[1] &x=4 \\\\\\\\\n[1] &x=5 \\\\\\\\\n[1] &x=6 \\\\\\\\\n[1] &x=7 \\\\\\\\\n[1] &x=8\n\\end{cases}</script><h5 id=\"于是我基于这种组合，将6-2-1-0-0-0-1-0-0-0默认为上排函数，发现n-6-计算不出下排函数。百度以后发现，人家根本不是按照我的这种方式去计算。下面说一下正确的解题思路\"><a href=\"#于是我基于这种组合，将6-2-1-0-0-0-1-0-0-0默认为上排函数，发现n-6-计算不出下排函数。百度以后发现，人家根本不是按照我的这种方式去计算。下面说一下正确的解题思路\" class=\"headerlink\" title=\"于是我基于这种组合，将6,2,1,0,0,0,1,0,0,0默认为上排函数，发现n=6,计算不出下排函数。百度以后发现，人家根本不是按照我的这种方式去计算。下面说一下正确的解题思路.\"></a>于是我基于这种组合，将6,2,1,0,0,0,1,0,0,0默认为上排函数，发现n=6,计算不出下排函数。百度以后发现，人家根本不是按照我的这种方式去计算。下面说一下正确的解题思路.</h5><h3 id=\"解题：\"><a href=\"#解题：\" class=\"headerlink\" title=\"解题：\"></a>解题：</h3><h5 id=\"它的原型跟八皇后有点类似，都是用回溯递归的方法去一次一次尝试，直到找出正确解。\"><a href=\"#它的原型跟八皇后有点类似，都是用回溯递归的方法去一次一次尝试，直到找出正确解。\" class=\"headerlink\" title=\"它的原型跟八皇后有点类似，都是用回溯递归的方法去一次一次尝试，直到找出正确解。\"></a>它的原型跟八皇后有点类似，都是用回溯递归的方法去一次一次尝试，直到找出正确解。</h5><h5 id=\"具体的想法是：不断的去从下排数组中捉取在上排数组中对应位置中出现的个数，如果个数不对就更新下排数组中对应的值，只到找到正确值。（下排数组先初始为任意值）\"><a href=\"#具体的想法是：不断的去从下排数组中捉取在上排数组中对应位置中出现的个数，如果个数不对就更新下排数组中对应的值，只到找到正确值。（下排数组先初始为任意值）\" class=\"headerlink\" title=\"具体的想法是：不断的去从下排数组中捉取在上排数组中对应位置中出现的个数，如果个数不对就更新下排数组中对应的值，只到找到正确值。（下排数组先初始为任意值）\"></a>具体的想法是：不断的去从下排数组中捉取在上排数组中对应位置中出现的个数，如果个数不对就更新下排数组中对应的值，只到找到正确值。（下排数组先初始为任意值）</h5><h5 id=\"如：\"><a href=\"#如：\" class=\"headerlink\" title=\"如：\"></a>如：</h5><h5 id=\"上排数组A：0-1-2-3-4-5-6-7-8-9\"><a href=\"#上排数组A：0-1-2-3-4-5-6-7-8-9\" class=\"headerlink\" title=\"上排数组A：0,1,2,3,4,5,6,7,8,9\"></a>上排数组A：0,1,2,3,4,5,6,7,8,9</h5><h5 id=\"下排数组B：0-1-2-3-4-5-6-7-8-9\"><a href=\"#下排数组B：0-1-2-3-4-5-6-7-8-9\" class=\"headerlink\" title=\"下排数组B：0,1,2,3,4,5,6,7,8,9\"></a>下排数组B：0,1,2,3,4,5,6,7,8,9</h5><h5 id=\"从上牌数组Index-0开始，A-0-0，0在下排数组中的个数为1，那么下排数组B此时就要更新为：1-1-2-3-4-5-6-7-8-9\"><a href=\"#从上牌数组Index-0开始，A-0-0，0在下排数组中的个数为1，那么下排数组B此时就要更新为：1-1-2-3-4-5-6-7-8-9\" class=\"headerlink\" title=\"从上牌数组Index = 0开始，A[0] = 0，0在下排数组中的个数为1，那么下排数组B此时就要更新为：1,1,2,3,4,5,6,7,8,9\"></a>从上牌数组Index = 0开始，A[0] = 0，0在下排数组中的个数为1，那么下排数组B此时就要更新为：1,1,2,3,4,5,6,7,8,9</h5><h5 id=\"Index-1-A-1-1-1在下排数组中的个数为2，那么下排数组B此时就要更新为：1-2-2-3-4-5-6-7-8-9，从此不断的往下进行，只要找不到正确值就一直往下进行，如果Index-gt-数组长度时，那么重新恢复Index-0再往下进行测试直到找出正确解。\"><a href=\"#Index-1-A-1-1-1在下排数组中的个数为2，那么下排数组B此时就要更新为：1-2-2-3-4-5-6-7-8-9，从此不断的往下进行，只要找不到正确值就一直往下进行，如果Index-gt-数组长度时，那么重新恢复Index-0再往下进行测试直到找出正确解。\" class=\"headerlink\" title=\"Index = 1, A[1] = 1, 1在下排数组中的个数为2，那么下排数组B此时就要更新为：1,2,2,3,4,5,6,7,8,9，从此不断的往下进行，只要找不到正确值就一直往下进行，如果Index &gt;= 数组长度时，那么重新恢复Index = 0再往下进行测试直到找出正确解。\"></a>Index = 1, A[1] = 1, 1在下排数组中的个数为2，那么下排数组B此时就要更新为：1,2,2,3,4,5,6,7,8,9，从此不断的往下进行，只要找不到正确值就一直往下进行，如果Index &gt;= 数组长度时，那么重新恢复Index = 0再往下进行测试直到找出正确解。</h5><h3 id=\"最后在说一些：\"><a href=\"#最后在说一些：\" class=\"headerlink\" title=\"最后在说一些：\"></a>最后在说一些：</h3><h5 id=\"其实按照上面的这种解题思路，我的解题过程也不能算是错误的，只是排除了大部分的可能性。并且题目也理解有误，所以以后做题一定要看清楚题，理解题目的正真含义。\"><a href=\"#其实按照上面的这种解题思路，我的解题过程也不能算是错误的，只是排除了大部分的可能性。并且题目也理解有误，所以以后做题一定要看清楚题，理解题目的正真含义。\" class=\"headerlink\" title=\"其实按照上面的这种解题思路，我的解题过程也不能算是错误的，只是排除了大部分的可能性。并且题目也理解有误，所以以后做题一定要看清楚题，理解题目的正真含义。\"></a>其实按照上面的这种解题思路，我的解题过程也不能算是错误的，只是排除了大部分的可能性。并且题目也理解有误，所以以后做题一定要看清楚题，理解题目的正真含义。</h5>","excerpt":"<script type=\"text/javascript\" async\n            src=\"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML\">\n    </script>\n\n<h3 id=\"题目要求：\"><a href=\"#题目要求：\" class=\"headerlink\" title=\"题目要求：\"></a>题目要求：</h3><h5 id=\"给你10分钟时间，根据上排给出十个数，在其下排填出对应的十个数-要求下排每个数都是先前上排那十个数在下排出现的次数。\"><a href=\"#给你10分钟时间，根据上排给出十个数，在其下排填出对应的十个数-要求下排每个数都是先前上排那十个数在下排出现的次数。\" class=\"headerlink\" title=\"给你10分钟时间，根据上排给出十个数，在其下排填出对应的十个数,要求下排每个数都是先前上排那十个数在下排出现的次数。\"></a>给你10分钟时间，根据上排给出十个数，在其下排填出对应的十个数,要求下排每个数都是先前上排那十个数在下排出现的次数。</h5><h5 id=\"上排的十个数如下：【0，1，2，3，4，5，6，7，8，9】\"><a href=\"#上排的十个数如下：【0，1，2，3，4，5，6，7，8，9】\" class=\"headerlink\" title=\"上排的十个数如下：【0，1，2，3，4，5，6，7，8，9】\"></a>上排的十个数如下：【0，1，2，3，4，5，6，7，8，9】</h5>","more":"<h4 id=\"举个例子，\"><a href=\"#举个例子，\" class=\"headerlink\" title=\"举个例子，\"></a>举个例子，</h4><h5 id=\"上排数值-0-1-2-3-4-5-6-7-8-9\"><a href=\"#上排数值-0-1-2-3-4-5-6-7-8-9\" class=\"headerlink\" title=\"上排数值: 0,1,2,3,4,5,6,7,8,9\"></a>上排数值: 0,1,2,3,4,5,6,7,8,9</h5><h5 id=\"下排数值-6-2-1-0-0-0-1-0-0-0\"><a href=\"#下排数值-6-2-1-0-0-0-1-0-0-0\" class=\"headerlink\" title=\"下排数值: 6,2,1,0,0,0,1,0,0,0\"></a>下排数值: 6,2,1,0,0,0,1,0,0,0</h5><h5 id=\"0在下排出现了6次，1在下排出现了2次，\"><a href=\"#0在下排出现了6次，1在下排出现了2次，\" class=\"headerlink\" title=\"0在下排出现了6次，1在下排出现了2次，\"></a>0在下排出现了6次，1在下排出现了2次，</h5><h5 id=\"2在下排出现了1次，3在下排出现了0次…\"><a href=\"#2在下排出现了1次，3在下排出现了0次…\" class=\"headerlink\" title=\"2在下排出现了1次，3在下排出现了0次…\"></a>2在下排出现了1次，3在下排出现了0次…</h5><h3 id=\"分析过程（不一定正确）：\"><a href=\"#分析过程（不一定正确）：\" class=\"headerlink\" title=\"分析过程（不一定正确）：\"></a>分析过程（不一定正确）：</h3><h5 id=\"看到题目的时候觉得有一点绕，切没有太理解题目，以为是一直循环输出下排数组，于是有了下面的解题过程。\"><a href=\"#看到题目的时候觉得有一点绕，切没有太理解题目，以为是一直循环输出下排数组，于是有了下面的解题过程。\" class=\"headerlink\" title=\"看到题目的时候觉得有一点绕，切没有太理解题目，以为是一直循环输出下排数组，于是有了下面的解题过程。\"></a>看到题目的时候觉得有一点绕，切没有太理解题目，以为是一直循环输出下排数组，于是有了下面的解题过程。</h5><h4 id=\"根据题目得到的一些条件：\"><a href=\"#根据题目得到的一些条件：\" class=\"headerlink\" title=\"根据题目得到的一些条件：\"></a>根据题目得到的一些条件：</h4><ol>\n<li>10个数，每个数都大于等于0；</li>\n<li>下排的数字为上排数字出现的次数；</li>\n<li>基于条件2，下排数字相加一定等于10；</li>\n<li>基于条件3，下排数字有0，要么下排全等于1，很明显全等于1就不符合条件2，所以下排数字一定有0；</li>\n<li>根据条件4，上排数字也有0；</li>\n</ol>\n<h4 id=\"基于上面几个条件，做出下面的一些假设：\"><a href=\"#基于上面几个条件，做出下面的一些假设：\" class=\"headerlink\" title=\"基于上面几个条件，做出下面的一些假设：\"></a>基于上面几个条件，做出下面的一些假设：</h4><h5 id=\"上排的10个数中，有n个数字为0，则非0的数有10-n：\"><a href=\"#上排的10个数中，有n个数字为0，则非0的数有10-n：\" class=\"headerlink\" title=\"上排的10个数中，有n个数字为0，则非0的数有10-n：\"></a>上排的10个数中，有n个数字为0，则非0的数有10-n：</h5><script type=\"math/tex; mode=display\">\\underbrace{0...0}_{\\text{n个0}},\\overbrace{v_1...v_i}^{\\text{10-n个非0数字}}</script><h5 id=\"如果上排为0的下排也为0，显然不符合条件2，所以0的下排数字为非0，切所有0的下排数字相等，假设为非0数x-则上排一定有一个数字为x-对应的下排数字为n：\"><a href=\"#如果上排为0的下排也为0，显然不符合条件2，所以0的下排数字为非0，切所有0的下排数字相等，假设为非0数x-则上排一定有一个数字为x-对应的下排数字为n：\" class=\"headerlink\" title=\"如果上排为0的下排也为0，显然不符合条件2，所以0的下排数字为非0，切所有0的下排数字相等，假设为非0数x,则上排一定有一个数字为x,对应的下排数字为n：\"></a>如果上排为0的下排也为0，显然不符合条件2，所以0的下排数字为非0，切所有0的下排数字相等，假设为非0数x,则上排一定有一个数字为x,对应的下排数字为n：</h5><script type=\"math/tex; mode=display\">上排：0...0,v_1...v_i,x</script><script type=\"math/tex; mode=display\">下排：\\underbrace{x...x}_{\\text{n个x}},i_1...i_i,n</script><h5 id=\"上排的0在下排为x，则说明下排有x个0-进一步得出下面的组合：\"><a href=\"#上排的0在下排为x，则说明下排有x个0-进一步得出下面的组合：\" class=\"headerlink\" title=\"上排的0在下排为x，则说明下排有x个0,进一步得出下面的组合：\"></a>上排的0在下排为x，则说明下排有x个0,进一步得出下面的组合：</h5><script type=\"math/tex; mode=display\">上排：0...0,v_1...v_i,v_j...v_k,x</script><script type=\"math/tex; mode=display\">下排：\\underbrace{x...x}_{\\text{n个x}},\\underbrace{0....0}_{\\text{x个0}},i_i....i_k,n</script><h5 id=\"根据条件1，下排一共10个数，所以：\"><a href=\"#根据条件1，下排一共10个数，所以：\" class=\"headerlink\" title=\"根据条件1，下排一共10个数，所以：\"></a>根据条件1，下排一共10个数，所以：</h5><script type=\"math/tex; mode=display\">n+x+1≤10</script><h5 id=\"根据条件3，下排数字相加等于10，所以：\"><a href=\"#根据条件3，下排数字相加等于10，所以：\" class=\"headerlink\" title=\"根据条件3，下排数字相加等于10，所以：\"></a>根据条件3，下排数字相加等于10，所以：</h5><script type=\"math/tex; mode=display\">nx+n≤10</script><h5 id=\"当vj到vk不存在，也就是个数为0时，上面两个不等式的等号成立，所以有以下两个函数：\"><a href=\"#当vj到vk不存在，也就是个数为0时，上面两个不等式的等号成立，所以有以下两个函数：\" class=\"headerlink\" title=\"当vj到vk不存在，也就是个数为0时，上面两个不等式的等号成立，所以有以下两个函数：\"></a>当v<sub>j</sub>到v<sub>k</sub>不存在，也就是个数为0时，上面两个不等式的等号成立，所以有以下两个函数：</h5><script type=\"math/tex; mode=display\">\\begin{cases}\nn+x+1=10 \\\\\\\\\nnx+n=10 \\\\\\\\\nx,n 为 正整数\n\\end{cases}\n\\implies\n\\begin{cases}\nn+x+1<10 \\\\\\\\\nnx+n<10 \\\\\\\\\nx,n 为 正整数\n\\end{cases}</script><h5 id=\"因为x，n均为正整数，所以枚举所有情况如下：\"><a href=\"#因为x，n均为正整数，所以枚举所有情况如下：\" class=\"headerlink\" title=\"因为x，n均为正整数，所以枚举所有情况如下：\"></a>因为x，n均为正整数，所以枚举所有情况如下：</h5><script type=\"math/tex; mode=display\">\nn=\\begin{cases}\n[1,2,3,4] &x=1 \\\\\\\\\n[1,2,3] &x=2 \\\\\\\\\n[1,2,] &x=3 \\\\\\\\\n[1] &x=4 \\\\\\\\\n[1] &x=5 \\\\\\\\\n[1] &x=6 \\\\\\\\\n[1] &x=7 \\\\\\\\\n[1] &x=8\n\\end{cases}</script><h5 id=\"于是我基于这种组合，将6-2-1-0-0-0-1-0-0-0默认为上排函数，发现n-6-计算不出下排函数。百度以后发现，人家根本不是按照我的这种方式去计算。下面说一下正确的解题思路\"><a href=\"#于是我基于这种组合，将6-2-1-0-0-0-1-0-0-0默认为上排函数，发现n-6-计算不出下排函数。百度以后发现，人家根本不是按照我的这种方式去计算。下面说一下正确的解题思路\" class=\"headerlink\" title=\"于是我基于这种组合，将6,2,1,0,0,0,1,0,0,0默认为上排函数，发现n=6,计算不出下排函数。百度以后发现，人家根本不是按照我的这种方式去计算。下面说一下正确的解题思路.\"></a>于是我基于这种组合，将6,2,1,0,0,0,1,0,0,0默认为上排函数，发现n=6,计算不出下排函数。百度以后发现，人家根本不是按照我的这种方式去计算。下面说一下正确的解题思路.</h5><h3 id=\"解题：\"><a href=\"#解题：\" class=\"headerlink\" title=\"解题：\"></a>解题：</h3><h5 id=\"它的原型跟八皇后有点类似，都是用回溯递归的方法去一次一次尝试，直到找出正确解。\"><a href=\"#它的原型跟八皇后有点类似，都是用回溯递归的方法去一次一次尝试，直到找出正确解。\" class=\"headerlink\" title=\"它的原型跟八皇后有点类似，都是用回溯递归的方法去一次一次尝试，直到找出正确解。\"></a>它的原型跟八皇后有点类似，都是用回溯递归的方法去一次一次尝试，直到找出正确解。</h5><h5 id=\"具体的想法是：不断的去从下排数组中捉取在上排数组中对应位置中出现的个数，如果个数不对就更新下排数组中对应的值，只到找到正确值。（下排数组先初始为任意值）\"><a href=\"#具体的想法是：不断的去从下排数组中捉取在上排数组中对应位置中出现的个数，如果个数不对就更新下排数组中对应的值，只到找到正确值。（下排数组先初始为任意值）\" class=\"headerlink\" title=\"具体的想法是：不断的去从下排数组中捉取在上排数组中对应位置中出现的个数，如果个数不对就更新下排数组中对应的值，只到找到正确值。（下排数组先初始为任意值）\"></a>具体的想法是：不断的去从下排数组中捉取在上排数组中对应位置中出现的个数，如果个数不对就更新下排数组中对应的值，只到找到正确值。（下排数组先初始为任意值）</h5><h5 id=\"如：\"><a href=\"#如：\" class=\"headerlink\" title=\"如：\"></a>如：</h5><h5 id=\"上排数组A：0-1-2-3-4-5-6-7-8-9\"><a href=\"#上排数组A：0-1-2-3-4-5-6-7-8-9\" class=\"headerlink\" title=\"上排数组A：0,1,2,3,4,5,6,7,8,9\"></a>上排数组A：0,1,2,3,4,5,6,7,8,9</h5><h5 id=\"下排数组B：0-1-2-3-4-5-6-7-8-9\"><a href=\"#下排数组B：0-1-2-3-4-5-6-7-8-9\" class=\"headerlink\" title=\"下排数组B：0,1,2,3,4,5,6,7,8,9\"></a>下排数组B：0,1,2,3,4,5,6,7,8,9</h5><h5 id=\"从上牌数组Index-0开始，A-0-0，0在下排数组中的个数为1，那么下排数组B此时就要更新为：1-1-2-3-4-5-6-7-8-9\"><a href=\"#从上牌数组Index-0开始，A-0-0，0在下排数组中的个数为1，那么下排数组B此时就要更新为：1-1-2-3-4-5-6-7-8-9\" class=\"headerlink\" title=\"从上牌数组Index = 0开始，A[0] = 0，0在下排数组中的个数为1，那么下排数组B此时就要更新为：1,1,2,3,4,5,6,7,8,9\"></a>从上牌数组Index = 0开始，A[0] = 0，0在下排数组中的个数为1，那么下排数组B此时就要更新为：1,1,2,3,4,5,6,7,8,9</h5><h5 id=\"Index-1-A-1-1-1在下排数组中的个数为2，那么下排数组B此时就要更新为：1-2-2-3-4-5-6-7-8-9，从此不断的往下进行，只要找不到正确值就一直往下进行，如果Index-gt-数组长度时，那么重新恢复Index-0再往下进行测试直到找出正确解。\"><a href=\"#Index-1-A-1-1-1在下排数组中的个数为2，那么下排数组B此时就要更新为：1-2-2-3-4-5-6-7-8-9，从此不断的往下进行，只要找不到正确值就一直往下进行，如果Index-gt-数组长度时，那么重新恢复Index-0再往下进行测试直到找出正确解。\" class=\"headerlink\" title=\"Index = 1, A[1] = 1, 1在下排数组中的个数为2，那么下排数组B此时就要更新为：1,2,2,3,4,5,6,7,8,9，从此不断的往下进行，只要找不到正确值就一直往下进行，如果Index &gt;= 数组长度时，那么重新恢复Index = 0再往下进行测试直到找出正确解。\"></a>Index = 1, A[1] = 1, 1在下排数组中的个数为2，那么下排数组B此时就要更新为：1,2,2,3,4,5,6,7,8,9，从此不断的往下进行，只要找不到正确值就一直往下进行，如果Index &gt;= 数组长度时，那么重新恢复Index = 0再往下进行测试直到找出正确解。</h5><h3 id=\"最后在说一些：\"><a href=\"#最后在说一些：\" class=\"headerlink\" title=\"最后在说一些：\"></a>最后在说一些：</h3><h5 id=\"其实按照上面的这种解题思路，我的解题过程也不能算是错误的，只是排除了大部分的可能性。并且题目也理解有误，所以以后做题一定要看清楚题，理解题目的正真含义。\"><a href=\"#其实按照上面的这种解题思路，我的解题过程也不能算是错误的，只是排除了大部分的可能性。并且题目也理解有误，所以以后做题一定要看清楚题，理解题目的正真含义。\" class=\"headerlink\" title=\"其实按照上面的这种解题思路，我的解题过程也不能算是错误的，只是排除了大部分的可能性。并且题目也理解有误，所以以后做题一定要看清楚题，理解题目的正真含义。\"></a>其实按照上面的这种解题思路，我的解题过程也不能算是错误的，只是排除了大部分的可能性。并且题目也理解有误，所以以后做题一定要看清楚题，理解题目的正真含义。</h5>"},{"layout":"post","title":"2016走了","date":"2016-12-31T16:00:00.000Z","img":"/life/2016-bg.jpg","color":"#777","_content":"\n##### 　　2017年1月份已经快过去了，再有两天就是春节。在这之前的春节，都是作为一个学生的身份，自然是有寒假的，这第一年工作，却要等到大年三十才能回家，多少还是有些不适应。加上北京这两天风特别大，这不，得了感冒了，今天还请了一天病假，才有时间坐在家里开始完成这一篇16年总结。其实20多天前就计划要写年终总结，但是最近很多事情都在耽误这一计划。加上需要将博客从jekyll迁移到hexo，使得每次打开博客，大部分时间都是在完成博客页面主题的编写，所以在博客文章上花的时间少了很多（其实之前好像也没花多少时间，惭愧）。\n<!--more-->\n\n##### 　　其实除了几篇技术文章，我几乎没有写过博客，以前倒是坚持写过一段时间的日记，但也总是断断续续。这当中一个很重要的原因就是从小作文就不太好，不太会用文字去描述身边的事情和自己的想法（比如上面这一段文字，就花了大概十分钟，删删减减才完成的），但我本身是很想去表达一些东西的。这个博客是16年10月份左右搭建起来的，大部分时间都用在了前端页面的编写上面了，起初是希望能够做一些技术上的总结，后来发现可以将生活中的一些总结也记录在此，再之后又添加了read版块。有点偏题了，已经不像是年终总结了。下面开始回到正题。\n\n##### 　　去年这一年是我从一个面向学校的学生转变为面向社会的工作者的一年。和很多毕业生一样，有一点迷茫，也有对未来的无限向往，我们就像一个个梦想家，有着无限的期望。但是我现在更希望做一个实干家，或者说行动大于空想。我是在15年的9月21号左右通过qunar面试的，这之前也参加过其他公司的校招，但是我之前的校招经历比较坎坷。因此我对qunar是非常感激的，加上面试的两位面试官也给我很好的感觉。所以在拿到qunar的offer之后，我几乎没有再考虑过其他公司。虽然随之而来的消息是qunar被携程合并，管理层的集体退出，以及多家航司对qunar的联合打击。\n\n##### 　　16年春节后，来到北京参加qunar的技术培训，和另外几个qunar的小伙伴，一起合租，一个房间睡了三个人，当时算了下，那一套房子有5个房间，一共住了14个人，当时最大的愿望就是，转正之后一定要有自己房间。期间公司培训的内容就是java后端开发那一套，个人觉得那是面向初学者的，所以我一有时间就去写毕业设计了，现在想起来多少有一些后悔。这可以算是我第一次参加工作，之前在学校很少出去兼职赚钱，大多数时间都是在团队或者实验室写代码做项目，感觉自己确实很契合程序员这个职业-够宅够闷骚。\n![2016-qunar技术培训照片](../../img/life/2016-qunar.jpeg)\n\n##### 　　5月初的时候，趁着劳动节就回学校了，因为马上就要做毕业答辩，但是论文什么都还没写。记得离开北京的时候，还是挺高兴的，毕竟学校还有一大堆的同学和朋友在等着我回去。期间和几个好朋友去了一趟云南，这是第一次去云南，我们先是坐飞机来到了昆明，然后去了大理、丽江、香格里拉。那边的风景实在是很漂亮，特别是从大理的苍山上俯瞰整个大理。说来也是缘分，之后我在qunar工作认识的，也就是我现在的女朋友，就是来自云南的，因此我觉得我和云南还是挺有缘分的。回到学校，便是答辩，合照，聚会。有些细节现在已经忘记，记得最清楚的是毕业季真的很难过。可能是因为大家都舍不得，室友们几乎都是同一天走的。\n![2016-室友毕业小聚](../../img/life/2016-roommate.jpeg)\n\n##### 　　兜兜转转，现在已经是2017年1月26号凌晨1点半，我正在火车站的候车室内席地而坐，等候回家的列车，车需要等到3点半才行，但是我现在已经有点困了。说到回家，虽然已经工作，但是今年回家的次数还真不少。除掉办领身份证、办理护照回去两次，另外还回去了大概两三次。可能是因为要工作了，想到以后没有了暑假，只有过年才有时间回家，所以一有时间便往家里赶。幸运的是，父母现在身体还算好,能够照顾好自己。在这方面我做的实在不够好，可能是因为和从小的教育有关，父母较偏向于传统教育，使得我和父母之间。他们（特别是我的妈妈）希望我能够像朋友一样与她交流，但是我们的每一次谈话，无不是一种父母对儿子的教育的交流方式和言语，这让我有一些不厌其烦。但是你们千万不要怀疑我对我父母的感情，我打心底里是爱他们的。这一年和他们的交流比以往大学的时候还要少一些，其实主要是不想让他们担心自己。希望他们永远健康。\n\n##### 　　继续说说2016吧，其实也没什么好说的了。对了，我和我的女朋友就是这一年在公司认识的，和她在一起4个多月了，吵了无数次架，我们的感情却越来越深，她真的是一个好女孩，希望在我今后的道路当中，都有她的陪伴。至于2016年这一年的工作情况，就不在这里总结了，总之希望新的一年越来越好。我也需要更加努力。这一年对我来说有一个大的变化就是，之前我是一个悲观主义者，对很多东西都不看好，认为那都是命中注定，我们改变不了什么，我们太渺小了。现在，我依然认为我们改变不了任何事情，但是我坚信我们可以改变自己。这个世界不是你想象中的那个样子，你也没有办法将它改变成你想要的样子，那就改变你自己，改变你看这个世界的角度和观点，那世界将是一个崭新的世界。\n","source":"_posts/life/summary-2016.md","raw":"---\nlayout: post\ntitle: 2016走了\ndate: 2017/01/01\ntags: [life, index]\nimg: /life/2016-bg.jpg\ncolor: \"#777\"\n---\n\n##### 　　2017年1月份已经快过去了，再有两天就是春节。在这之前的春节，都是作为一个学生的身份，自然是有寒假的，这第一年工作，却要等到大年三十才能回家，多少还是有些不适应。加上北京这两天风特别大，这不，得了感冒了，今天还请了一天病假，才有时间坐在家里开始完成这一篇16年总结。其实20多天前就计划要写年终总结，但是最近很多事情都在耽误这一计划。加上需要将博客从jekyll迁移到hexo，使得每次打开博客，大部分时间都是在完成博客页面主题的编写，所以在博客文章上花的时间少了很多（其实之前好像也没花多少时间，惭愧）。\n<!--more-->\n\n##### 　　其实除了几篇技术文章，我几乎没有写过博客，以前倒是坚持写过一段时间的日记，但也总是断断续续。这当中一个很重要的原因就是从小作文就不太好，不太会用文字去描述身边的事情和自己的想法（比如上面这一段文字，就花了大概十分钟，删删减减才完成的），但我本身是很想去表达一些东西的。这个博客是16年10月份左右搭建起来的，大部分时间都用在了前端页面的编写上面了，起初是希望能够做一些技术上的总结，后来发现可以将生活中的一些总结也记录在此，再之后又添加了read版块。有点偏题了，已经不像是年终总结了。下面开始回到正题。\n\n##### 　　去年这一年是我从一个面向学校的学生转变为面向社会的工作者的一年。和很多毕业生一样，有一点迷茫，也有对未来的无限向往，我们就像一个个梦想家，有着无限的期望。但是我现在更希望做一个实干家，或者说行动大于空想。我是在15年的9月21号左右通过qunar面试的，这之前也参加过其他公司的校招，但是我之前的校招经历比较坎坷。因此我对qunar是非常感激的，加上面试的两位面试官也给我很好的感觉。所以在拿到qunar的offer之后，我几乎没有再考虑过其他公司。虽然随之而来的消息是qunar被携程合并，管理层的集体退出，以及多家航司对qunar的联合打击。\n\n##### 　　16年春节后，来到北京参加qunar的技术培训，和另外几个qunar的小伙伴，一起合租，一个房间睡了三个人，当时算了下，那一套房子有5个房间，一共住了14个人，当时最大的愿望就是，转正之后一定要有自己房间。期间公司培训的内容就是java后端开发那一套，个人觉得那是面向初学者的，所以我一有时间就去写毕业设计了，现在想起来多少有一些后悔。这可以算是我第一次参加工作，之前在学校很少出去兼职赚钱，大多数时间都是在团队或者实验室写代码做项目，感觉自己确实很契合程序员这个职业-够宅够闷骚。\n![2016-qunar技术培训照片](../../img/life/2016-qunar.jpeg)\n\n##### 　　5月初的时候，趁着劳动节就回学校了，因为马上就要做毕业答辩，但是论文什么都还没写。记得离开北京的时候，还是挺高兴的，毕竟学校还有一大堆的同学和朋友在等着我回去。期间和几个好朋友去了一趟云南，这是第一次去云南，我们先是坐飞机来到了昆明，然后去了大理、丽江、香格里拉。那边的风景实在是很漂亮，特别是从大理的苍山上俯瞰整个大理。说来也是缘分，之后我在qunar工作认识的，也就是我现在的女朋友，就是来自云南的，因此我觉得我和云南还是挺有缘分的。回到学校，便是答辩，合照，聚会。有些细节现在已经忘记，记得最清楚的是毕业季真的很难过。可能是因为大家都舍不得，室友们几乎都是同一天走的。\n![2016-室友毕业小聚](../../img/life/2016-roommate.jpeg)\n\n##### 　　兜兜转转，现在已经是2017年1月26号凌晨1点半，我正在火车站的候车室内席地而坐，等候回家的列车，车需要等到3点半才行，但是我现在已经有点困了。说到回家，虽然已经工作，但是今年回家的次数还真不少。除掉办领身份证、办理护照回去两次，另外还回去了大概两三次。可能是因为要工作了，想到以后没有了暑假，只有过年才有时间回家，所以一有时间便往家里赶。幸运的是，父母现在身体还算好,能够照顾好自己。在这方面我做的实在不够好，可能是因为和从小的教育有关，父母较偏向于传统教育，使得我和父母之间。他们（特别是我的妈妈）希望我能够像朋友一样与她交流，但是我们的每一次谈话，无不是一种父母对儿子的教育的交流方式和言语，这让我有一些不厌其烦。但是你们千万不要怀疑我对我父母的感情，我打心底里是爱他们的。这一年和他们的交流比以往大学的时候还要少一些，其实主要是不想让他们担心自己。希望他们永远健康。\n\n##### 　　继续说说2016吧，其实也没什么好说的了。对了，我和我的女朋友就是这一年在公司认识的，和她在一起4个多月了，吵了无数次架，我们的感情却越来越深，她真的是一个好女孩，希望在我今后的道路当中，都有她的陪伴。至于2016年这一年的工作情况，就不在这里总结了，总之希望新的一年越来越好。我也需要更加努力。这一年对我来说有一个大的变化就是，之前我是一个悲观主义者，对很多东西都不看好，认为那都是命中注定，我们改变不了什么，我们太渺小了。现在，我依然认为我们改变不了任何事情，但是我坚信我们可以改变自己。这个世界不是你想象中的那个样子，你也没有办法将它改变成你想要的样子，那就改变你自己，改变你看这个世界的角度和观点，那世界将是一个崭新的世界。\n","slug":"life/summary-2016","published":1,"updated":"2017-02-07T01:19:53.000Z","comments":1,"photos":[],"link":"","_id":"cizbemkm80005sebfgz6sqw91","content":"<h5 id=\"2017年1月份已经快过去了，再有两天就是春节。在这之前的春节，都是作为一个学生的身份，自然是有寒假的，这第一年工作，却要等到大年三十才能回家，多少还是有些不适应。加上北京这两天风特别大，这不，得了感冒了，今天还请了一天病假，才有时间坐在家里开始完成这一篇16年总结。其实20多天前就计划要写年终总结，但是最近很多事情都在耽误这一计划。加上需要将博客从jekyll迁移到hexo，使得每次打开博客，大部分时间都是在完成博客页面主题的编写，所以在博客文章上花的时间少了很多（其实之前好像也没花多少时间，惭愧）。\"><a href=\"#2017年1月份已经快过去了，再有两天就是春节。在这之前的春节，都是作为一个学生的身份，自然是有寒假的，这第一年工作，却要等到大年三十才能回家，多少还是有些不适应。加上北京这两天风特别大，这不，得了感冒了，今天还请了一天病假，才有时间坐在家里开始完成这一篇16年总结。其实20多天前就计划要写年终总结，但是最近很多事情都在耽误这一计划。加上需要将博客从jekyll迁移到hexo，使得每次打开博客，大部分时间都是在完成博客页面主题的编写，所以在博客文章上花的时间少了很多（其实之前好像也没花多少时间，惭愧）。\" class=\"headerlink\" title=\"　　2017年1月份已经快过去了，再有两天就是春节。在这之前的春节，都是作为一个学生的身份，自然是有寒假的，这第一年工作，却要等到大年三十才能回家，多少还是有些不适应。加上北京这两天风特别大，这不，得了感冒了，今天还请了一天病假，才有时间坐在家里开始完成这一篇16年总结。其实20多天前就计划要写年终总结，但是最近很多事情都在耽误这一计划。加上需要将博客从jekyll迁移到hexo，使得每次打开博客，大部分时间都是在完成博客页面主题的编写，所以在博客文章上花的时间少了很多（其实之前好像也没花多少时间，惭愧）。\"></a>　　2017年1月份已经快过去了，再有两天就是春节。在这之前的春节，都是作为一个学生的身份，自然是有寒假的，这第一年工作，却要等到大年三十才能回家，多少还是有些不适应。加上北京这两天风特别大，这不，得了感冒了，今天还请了一天病假，才有时间坐在家里开始完成这一篇16年总结。其实20多天前就计划要写年终总结，但是最近很多事情都在耽误这一计划。加上需要将博客从jekyll迁移到hexo，使得每次打开博客，大部分时间都是在完成博客页面主题的编写，所以在博客文章上花的时间少了很多（其实之前好像也没花多少时间，惭愧）。</h5><a id=\"more\"></a>\n<h5 id=\"其实除了几篇技术文章，我几乎没有写过博客，以前倒是坚持写过一段时间的日记，但也总是断断续续。这当中一个很重要的原因就是从小作文就不太好，不太会用文字去描述身边的事情和自己的想法（比如上面这一段文字，就花了大概十分钟，删删减减才完成的），但我本身是很想去表达一些东西的。这个博客是16年10月份左右搭建起来的，大部分时间都用在了前端页面的编写上面了，起初是希望能够做一些技术上的总结，后来发现可以将生活中的一些总结也记录在此，再之后又添加了read版块。有点偏题了，已经不像是年终总结了。下面开始回到正题。\"><a href=\"#其实除了几篇技术文章，我几乎没有写过博客，以前倒是坚持写过一段时间的日记，但也总是断断续续。这当中一个很重要的原因就是从小作文就不太好，不太会用文字去描述身边的事情和自己的想法（比如上面这一段文字，就花了大概十分钟，删删减减才完成的），但我本身是很想去表达一些东西的。这个博客是16年10月份左右搭建起来的，大部分时间都用在了前端页面的编写上面了，起初是希望能够做一些技术上的总结，后来发现可以将生活中的一些总结也记录在此，再之后又添加了read版块。有点偏题了，已经不像是年终总结了。下面开始回到正题。\" class=\"headerlink\" title=\"　　其实除了几篇技术文章，我几乎没有写过博客，以前倒是坚持写过一段时间的日记，但也总是断断续续。这当中一个很重要的原因就是从小作文就不太好，不太会用文字去描述身边的事情和自己的想法（比如上面这一段文字，就花了大概十分钟，删删减减才完成的），但我本身是很想去表达一些东西的。这个博客是16年10月份左右搭建起来的，大部分时间都用在了前端页面的编写上面了，起初是希望能够做一些技术上的总结，后来发现可以将生活中的一些总结也记录在此，再之后又添加了read版块。有点偏题了，已经不像是年终总结了。下面开始回到正题。\"></a>　　其实除了几篇技术文章，我几乎没有写过博客，以前倒是坚持写过一段时间的日记，但也总是断断续续。这当中一个很重要的原因就是从小作文就不太好，不太会用文字去描述身边的事情和自己的想法（比如上面这一段文字，就花了大概十分钟，删删减减才完成的），但我本身是很想去表达一些东西的。这个博客是16年10月份左右搭建起来的，大部分时间都用在了前端页面的编写上面了，起初是希望能够做一些技术上的总结，后来发现可以将生活中的一些总结也记录在此，再之后又添加了read版块。有点偏题了，已经不像是年终总结了。下面开始回到正题。</h5><h5 id=\"去年这一年是我从一个面向学校的学生转变为面向社会的工作者的一年。和很多毕业生一样，有一点迷茫，也有对未来的无限向往，我们就像一个个梦想家，有着无限的期望。但是我现在更希望做一个实干家，或者说行动大于空想。我是在15年的9月21号左右通过qunar面试的，这之前也参加过其他公司的校招，但是我之前的校招经历比较坎坷。因此我对qunar是非常感激的，加上面试的两位面试官也给我很好的感觉。所以在拿到qunar的offer之后，我几乎没有再考虑过其他公司。虽然随之而来的消息是qunar被携程合并，管理层的集体退出，以及多家航司对qunar的联合打击。\"><a href=\"#去年这一年是我从一个面向学校的学生转变为面向社会的工作者的一年。和很多毕业生一样，有一点迷茫，也有对未来的无限向往，我们就像一个个梦想家，有着无限的期望。但是我现在更希望做一个实干家，或者说行动大于空想。我是在15年的9月21号左右通过qunar面试的，这之前也参加过其他公司的校招，但是我之前的校招经历比较坎坷。因此我对qunar是非常感激的，加上面试的两位面试官也给我很好的感觉。所以在拿到qunar的offer之后，我几乎没有再考虑过其他公司。虽然随之而来的消息是qunar被携程合并，管理层的集体退出，以及多家航司对qunar的联合打击。\" class=\"headerlink\" title=\"　　去年这一年是我从一个面向学校的学生转变为面向社会的工作者的一年。和很多毕业生一样，有一点迷茫，也有对未来的无限向往，我们就像一个个梦想家，有着无限的期望。但是我现在更希望做一个实干家，或者说行动大于空想。我是在15年的9月21号左右通过qunar面试的，这之前也参加过其他公司的校招，但是我之前的校招经历比较坎坷。因此我对qunar是非常感激的，加上面试的两位面试官也给我很好的感觉。所以在拿到qunar的offer之后，我几乎没有再考虑过其他公司。虽然随之而来的消息是qunar被携程合并，管理层的集体退出，以及多家航司对qunar的联合打击。\"></a>　　去年这一年是我从一个面向学校的学生转变为面向社会的工作者的一年。和很多毕业生一样，有一点迷茫，也有对未来的无限向往，我们就像一个个梦想家，有着无限的期望。但是我现在更希望做一个实干家，或者说行动大于空想。我是在15年的9月21号左右通过qunar面试的，这之前也参加过其他公司的校招，但是我之前的校招经历比较坎坷。因此我对qunar是非常感激的，加上面试的两位面试官也给我很好的感觉。所以在拿到qunar的offer之后，我几乎没有再考虑过其他公司。虽然随之而来的消息是qunar被携程合并，管理层的集体退出，以及多家航司对qunar的联合打击。</h5><h5 id=\"16年春节后，来到北京参加qunar的技术培训，和另外几个qunar的小伙伴，一起合租，一个房间睡了三个人，当时算了下，那一套房子有5个房间，一共住了14个人，当时最大的愿望就是，转正之后一定要有自己房间。期间公司培训的内容就是java后端开发那一套，个人觉得那是面向初学者的，所以我一有时间就去写毕业设计了，现在想起来多少有一些后悔。这可以算是我第一次参加工作，之前在学校很少出去兼职赚钱，大多数时间都是在团队或者实验室写代码做项目，感觉自己确实很契合程序员这个职业-够宅够闷骚。\"><a href=\"#16年春节后，来到北京参加qunar的技术培训，和另外几个qunar的小伙伴，一起合租，一个房间睡了三个人，当时算了下，那一套房子有5个房间，一共住了14个人，当时最大的愿望就是，转正之后一定要有自己房间。期间公司培训的内容就是java后端开发那一套，个人觉得那是面向初学者的，所以我一有时间就去写毕业设计了，现在想起来多少有一些后悔。这可以算是我第一次参加工作，之前在学校很少出去兼职赚钱，大多数时间都是在团队或者实验室写代码做项目，感觉自己确实很契合程序员这个职业-够宅够闷骚。\" class=\"headerlink\" title=\"　　16年春节后，来到北京参加qunar的技术培训，和另外几个qunar的小伙伴，一起合租，一个房间睡了三个人，当时算了下，那一套房子有5个房间，一共住了14个人，当时最大的愿望就是，转正之后一定要有自己房间。期间公司培训的内容就是java后端开发那一套，个人觉得那是面向初学者的，所以我一有时间就去写毕业设计了，现在想起来多少有一些后悔。这可以算是我第一次参加工作，之前在学校很少出去兼职赚钱，大多数时间都是在团队或者实验室写代码做项目，感觉自己确实很契合程序员这个职业-够宅够闷骚。\"></a>　　16年春节后，来到北京参加qunar的技术培训，和另外几个qunar的小伙伴，一起合租，一个房间睡了三个人，当时算了下，那一套房子有5个房间，一共住了14个人，当时最大的愿望就是，转正之后一定要有自己房间。期间公司培训的内容就是java后端开发那一套，个人觉得那是面向初学者的，所以我一有时间就去写毕业设计了，现在想起来多少有一些后悔。这可以算是我第一次参加工作，之前在学校很少出去兼职赚钱，大多数时间都是在团队或者实验室写代码做项目，感觉自己确实很契合程序员这个职业-够宅够闷骚。</h5><p><img src=\"../../img/life/2016-qunar.jpeg\" alt=\"2016-qunar技术培训照片\"></p>\n<h5 id=\"5月初的时候，趁着劳动节就回学校了，因为马上就要做毕业答辩，但是论文什么都还没写。记得离开北京的时候，还是挺高兴的，毕竟学校还有一大堆的同学和朋友在等着我回去。期间和几个好朋友去了一趟云南，这是第一次去云南，我们先是坐飞机来到了昆明，然后去了大理、丽江、香格里拉。那边的风景实在是很漂亮，特别是从大理的苍山上俯瞰整个大理。说来也是缘分，之后我在qunar工作认识的，也就是我现在的女朋友，就是来自云南的，因此我觉得我和云南还是挺有缘分的。回到学校，便是答辩，合照，聚会。有些细节现在已经忘记，记得最清楚的是毕业季真的很难过。可能是因为大家都舍不得，室友们几乎都是同一天走的。\"><a href=\"#5月初的时候，趁着劳动节就回学校了，因为马上就要做毕业答辩，但是论文什么都还没写。记得离开北京的时候，还是挺高兴的，毕竟学校还有一大堆的同学和朋友在等着我回去。期间和几个好朋友去了一趟云南，这是第一次去云南，我们先是坐飞机来到了昆明，然后去了大理、丽江、香格里拉。那边的风景实在是很漂亮，特别是从大理的苍山上俯瞰整个大理。说来也是缘分，之后我在qunar工作认识的，也就是我现在的女朋友，就是来自云南的，因此我觉得我和云南还是挺有缘分的。回到学校，便是答辩，合照，聚会。有些细节现在已经忘记，记得最清楚的是毕业季真的很难过。可能是因为大家都舍不得，室友们几乎都是同一天走的。\" class=\"headerlink\" title=\"　　5月初的时候，趁着劳动节就回学校了，因为马上就要做毕业答辩，但是论文什么都还没写。记得离开北京的时候，还是挺高兴的，毕竟学校还有一大堆的同学和朋友在等着我回去。期间和几个好朋友去了一趟云南，这是第一次去云南，我们先是坐飞机来到了昆明，然后去了大理、丽江、香格里拉。那边的风景实在是很漂亮，特别是从大理的苍山上俯瞰整个大理。说来也是缘分，之后我在qunar工作认识的，也就是我现在的女朋友，就是来自云南的，因此我觉得我和云南还是挺有缘分的。回到学校，便是答辩，合照，聚会。有些细节现在已经忘记，记得最清楚的是毕业季真的很难过。可能是因为大家都舍不得，室友们几乎都是同一天走的。\"></a>　　5月初的时候，趁着劳动节就回学校了，因为马上就要做毕业答辩，但是论文什么都还没写。记得离开北京的时候，还是挺高兴的，毕竟学校还有一大堆的同学和朋友在等着我回去。期间和几个好朋友去了一趟云南，这是第一次去云南，我们先是坐飞机来到了昆明，然后去了大理、丽江、香格里拉。那边的风景实在是很漂亮，特别是从大理的苍山上俯瞰整个大理。说来也是缘分，之后我在qunar工作认识的，也就是我现在的女朋友，就是来自云南的，因此我觉得我和云南还是挺有缘分的。回到学校，便是答辩，合照，聚会。有些细节现在已经忘记，记得最清楚的是毕业季真的很难过。可能是因为大家都舍不得，室友们几乎都是同一天走的。</h5><p><img src=\"../../img/life/2016-roommate.jpeg\" alt=\"2016-室友毕业小聚\"></p>\n<h5 id=\"兜兜转转，现在已经是2017年1月26号凌晨1点半，我正在火车站的候车室内席地而坐，等候回家的列车，车需要等到3点半才行，但是我现在已经有点困了。说到回家，虽然已经工作，但是今年回家的次数还真不少。除掉办领身份证、办理护照回去两次，另外还回去了大概两三次。可能是因为要工作了，想到以后没有了暑假，只有过年才有时间回家，所以一有时间便往家里赶。幸运的是，父母现在身体还算好-能够照顾好自己。在这方面我做的实在不够好，可能是因为和从小的教育有关，父母较偏向于传统教育，使得我和父母之间。他们（特别是我的妈妈）希望我能够像朋友一样与她交流，但是我们的每一次谈话，无不是一种父母对儿子的教育的交流方式和言语，这让我有一些不厌其烦。但是你们千万不要怀疑我对我父母的感情，我打心底里是爱他们的。这一年和他们的交流比以往大学的时候还要少一些，其实主要是不想让他们担心自己。希望他们永远健康。\"><a href=\"#兜兜转转，现在已经是2017年1月26号凌晨1点半，我正在火车站的候车室内席地而坐，等候回家的列车，车需要等到3点半才行，但是我现在已经有点困了。说到回家，虽然已经工作，但是今年回家的次数还真不少。除掉办领身份证、办理护照回去两次，另外还回去了大概两三次。可能是因为要工作了，想到以后没有了暑假，只有过年才有时间回家，所以一有时间便往家里赶。幸运的是，父母现在身体还算好-能够照顾好自己。在这方面我做的实在不够好，可能是因为和从小的教育有关，父母较偏向于传统教育，使得我和父母之间。他们（特别是我的妈妈）希望我能够像朋友一样与她交流，但是我们的每一次谈话，无不是一种父母对儿子的教育的交流方式和言语，这让我有一些不厌其烦。但是你们千万不要怀疑我对我父母的感情，我打心底里是爱他们的。这一年和他们的交流比以往大学的时候还要少一些，其实主要是不想让他们担心自己。希望他们永远健康。\" class=\"headerlink\" title=\"　　兜兜转转，现在已经是2017年1月26号凌晨1点半，我正在火车站的候车室内席地而坐，等候回家的列车，车需要等到3点半才行，但是我现在已经有点困了。说到回家，虽然已经工作，但是今年回家的次数还真不少。除掉办领身份证、办理护照回去两次，另外还回去了大概两三次。可能是因为要工作了，想到以后没有了暑假，只有过年才有时间回家，所以一有时间便往家里赶。幸运的是，父母现在身体还算好,能够照顾好自己。在这方面我做的实在不够好，可能是因为和从小的教育有关，父母较偏向于传统教育，使得我和父母之间。他们（特别是我的妈妈）希望我能够像朋友一样与她交流，但是我们的每一次谈话，无不是一种父母对儿子的教育的交流方式和言语，这让我有一些不厌其烦。但是你们千万不要怀疑我对我父母的感情，我打心底里是爱他们的。这一年和他们的交流比以往大学的时候还要少一些，其实主要是不想让他们担心自己。希望他们永远健康。\"></a>　　兜兜转转，现在已经是2017年1月26号凌晨1点半，我正在火车站的候车室内席地而坐，等候回家的列车，车需要等到3点半才行，但是我现在已经有点困了。说到回家，虽然已经工作，但是今年回家的次数还真不少。除掉办领身份证、办理护照回去两次，另外还回去了大概两三次。可能是因为要工作了，想到以后没有了暑假，只有过年才有时间回家，所以一有时间便往家里赶。幸运的是，父母现在身体还算好,能够照顾好自己。在这方面我做的实在不够好，可能是因为和从小的教育有关，父母较偏向于传统教育，使得我和父母之间。他们（特别是我的妈妈）希望我能够像朋友一样与她交流，但是我们的每一次谈话，无不是一种父母对儿子的教育的交流方式和言语，这让我有一些不厌其烦。但是你们千万不要怀疑我对我父母的感情，我打心底里是爱他们的。这一年和他们的交流比以往大学的时候还要少一些，其实主要是不想让他们担心自己。希望他们永远健康。</h5><h5 id=\"继续说说2016吧，其实也没什么好说的了。对了，我和我的女朋友就是这一年在公司认识的，和她在一起4个多月了，吵了无数次架，我们的感情却越来越深，她真的是一个好女孩，希望在我今后的道路当中，都有她的陪伴。至于2016年这一年的工作情况，就不在这里总结了，总之希望新的一年越来越好。我也需要更加努力。这一年对我来说有一个大的变化就是，之前我是一个悲观主义者，对很多东西都不看好，认为那都是命中注定，我们改变不了什么，我们太渺小了。现在，我依然认为我们改变不了任何事情，但是我坚信我们可以改变自己。这个世界不是你想象中的那个样子，你也没有办法将它改变成你想要的样子，那就改变你自己，改变你看这个世界的角度和观点，那世界将是一个崭新的世界。\"><a href=\"#继续说说2016吧，其实也没什么好说的了。对了，我和我的女朋友就是这一年在公司认识的，和她在一起4个多月了，吵了无数次架，我们的感情却越来越深，她真的是一个好女孩，希望在我今后的道路当中，都有她的陪伴。至于2016年这一年的工作情况，就不在这里总结了，总之希望新的一年越来越好。我也需要更加努力。这一年对我来说有一个大的变化就是，之前我是一个悲观主义者，对很多东西都不看好，认为那都是命中注定，我们改变不了什么，我们太渺小了。现在，我依然认为我们改变不了任何事情，但是我坚信我们可以改变自己。这个世界不是你想象中的那个样子，你也没有办法将它改变成你想要的样子，那就改变你自己，改变你看这个世界的角度和观点，那世界将是一个崭新的世界。\" class=\"headerlink\" title=\"　　继续说说2016吧，其实也没什么好说的了。对了，我和我的女朋友就是这一年在公司认识的，和她在一起4个多月了，吵了无数次架，我们的感情却越来越深，她真的是一个好女孩，希望在我今后的道路当中，都有她的陪伴。至于2016年这一年的工作情况，就不在这里总结了，总之希望新的一年越来越好。我也需要更加努力。这一年对我来说有一个大的变化就是，之前我是一个悲观主义者，对很多东西都不看好，认为那都是命中注定，我们改变不了什么，我们太渺小了。现在，我依然认为我们改变不了任何事情，但是我坚信我们可以改变自己。这个世界不是你想象中的那个样子，你也没有办法将它改变成你想要的样子，那就改变你自己，改变你看这个世界的角度和观点，那世界将是一个崭新的世界。\"></a>　　继续说说2016吧，其实也没什么好说的了。对了，我和我的女朋友就是这一年在公司认识的，和她在一起4个多月了，吵了无数次架，我们的感情却越来越深，她真的是一个好女孩，希望在我今后的道路当中，都有她的陪伴。至于2016年这一年的工作情况，就不在这里总结了，总之希望新的一年越来越好。我也需要更加努力。这一年对我来说有一个大的变化就是，之前我是一个悲观主义者，对很多东西都不看好，认为那都是命中注定，我们改变不了什么，我们太渺小了。现在，我依然认为我们改变不了任何事情，但是我坚信我们可以改变自己。这个世界不是你想象中的那个样子，你也没有办法将它改变成你想要的样子，那就改变你自己，改变你看这个世界的角度和观点，那世界将是一个崭新的世界。</h5>","excerpt":"<h5 id=\"2017年1月份已经快过去了，再有两天就是春节。在这之前的春节，都是作为一个学生的身份，自然是有寒假的，这第一年工作，却要等到大年三十才能回家，多少还是有些不适应。加上北京这两天风特别大，这不，得了感冒了，今天还请了一天病假，才有时间坐在家里开始完成这一篇16年总结。其实20多天前就计划要写年终总结，但是最近很多事情都在耽误这一计划。加上需要将博客从jekyll迁移到hexo，使得每次打开博客，大部分时间都是在完成博客页面主题的编写，所以在博客文章上花的时间少了很多（其实之前好像也没花多少时间，惭愧）。\"><a href=\"#2017年1月份已经快过去了，再有两天就是春节。在这之前的春节，都是作为一个学生的身份，自然是有寒假的，这第一年工作，却要等到大年三十才能回家，多少还是有些不适应。加上北京这两天风特别大，这不，得了感冒了，今天还请了一天病假，才有时间坐在家里开始完成这一篇16年总结。其实20多天前就计划要写年终总结，但是最近很多事情都在耽误这一计划。加上需要将博客从jekyll迁移到hexo，使得每次打开博客，大部分时间都是在完成博客页面主题的编写，所以在博客文章上花的时间少了很多（其实之前好像也没花多少时间，惭愧）。\" class=\"headerlink\" title=\"　　2017年1月份已经快过去了，再有两天就是春节。在这之前的春节，都是作为一个学生的身份，自然是有寒假的，这第一年工作，却要等到大年三十才能回家，多少还是有些不适应。加上北京这两天风特别大，这不，得了感冒了，今天还请了一天病假，才有时间坐在家里开始完成这一篇16年总结。其实20多天前就计划要写年终总结，但是最近很多事情都在耽误这一计划。加上需要将博客从jekyll迁移到hexo，使得每次打开博客，大部分时间都是在完成博客页面主题的编写，所以在博客文章上花的时间少了很多（其实之前好像也没花多少时间，惭愧）。\"></a>　　2017年1月份已经快过去了，再有两天就是春节。在这之前的春节，都是作为一个学生的身份，自然是有寒假的，这第一年工作，却要等到大年三十才能回家，多少还是有些不适应。加上北京这两天风特别大，这不，得了感冒了，今天还请了一天病假，才有时间坐在家里开始完成这一篇16年总结。其实20多天前就计划要写年终总结，但是最近很多事情都在耽误这一计划。加上需要将博客从jekyll迁移到hexo，使得每次打开博客，大部分时间都是在完成博客页面主题的编写，所以在博客文章上花的时间少了很多（其实之前好像也没花多少时间，惭愧）。</h5>","more":"<h5 id=\"其实除了几篇技术文章，我几乎没有写过博客，以前倒是坚持写过一段时间的日记，但也总是断断续续。这当中一个很重要的原因就是从小作文就不太好，不太会用文字去描述身边的事情和自己的想法（比如上面这一段文字，就花了大概十分钟，删删减减才完成的），但我本身是很想去表达一些东西的。这个博客是16年10月份左右搭建起来的，大部分时间都用在了前端页面的编写上面了，起初是希望能够做一些技术上的总结，后来发现可以将生活中的一些总结也记录在此，再之后又添加了read版块。有点偏题了，已经不像是年终总结了。下面开始回到正题。\"><a href=\"#其实除了几篇技术文章，我几乎没有写过博客，以前倒是坚持写过一段时间的日记，但也总是断断续续。这当中一个很重要的原因就是从小作文就不太好，不太会用文字去描述身边的事情和自己的想法（比如上面这一段文字，就花了大概十分钟，删删减减才完成的），但我本身是很想去表达一些东西的。这个博客是16年10月份左右搭建起来的，大部分时间都用在了前端页面的编写上面了，起初是希望能够做一些技术上的总结，后来发现可以将生活中的一些总结也记录在此，再之后又添加了read版块。有点偏题了，已经不像是年终总结了。下面开始回到正题。\" class=\"headerlink\" title=\"　　其实除了几篇技术文章，我几乎没有写过博客，以前倒是坚持写过一段时间的日记，但也总是断断续续。这当中一个很重要的原因就是从小作文就不太好，不太会用文字去描述身边的事情和自己的想法（比如上面这一段文字，就花了大概十分钟，删删减减才完成的），但我本身是很想去表达一些东西的。这个博客是16年10月份左右搭建起来的，大部分时间都用在了前端页面的编写上面了，起初是希望能够做一些技术上的总结，后来发现可以将生活中的一些总结也记录在此，再之后又添加了read版块。有点偏题了，已经不像是年终总结了。下面开始回到正题。\"></a>　　其实除了几篇技术文章，我几乎没有写过博客，以前倒是坚持写过一段时间的日记，但也总是断断续续。这当中一个很重要的原因就是从小作文就不太好，不太会用文字去描述身边的事情和自己的想法（比如上面这一段文字，就花了大概十分钟，删删减减才完成的），但我本身是很想去表达一些东西的。这个博客是16年10月份左右搭建起来的，大部分时间都用在了前端页面的编写上面了，起初是希望能够做一些技术上的总结，后来发现可以将生活中的一些总结也记录在此，再之后又添加了read版块。有点偏题了，已经不像是年终总结了。下面开始回到正题。</h5><h5 id=\"去年这一年是我从一个面向学校的学生转变为面向社会的工作者的一年。和很多毕业生一样，有一点迷茫，也有对未来的无限向往，我们就像一个个梦想家，有着无限的期望。但是我现在更希望做一个实干家，或者说行动大于空想。我是在15年的9月21号左右通过qunar面试的，这之前也参加过其他公司的校招，但是我之前的校招经历比较坎坷。因此我对qunar是非常感激的，加上面试的两位面试官也给我很好的感觉。所以在拿到qunar的offer之后，我几乎没有再考虑过其他公司。虽然随之而来的消息是qunar被携程合并，管理层的集体退出，以及多家航司对qunar的联合打击。\"><a href=\"#去年这一年是我从一个面向学校的学生转变为面向社会的工作者的一年。和很多毕业生一样，有一点迷茫，也有对未来的无限向往，我们就像一个个梦想家，有着无限的期望。但是我现在更希望做一个实干家，或者说行动大于空想。我是在15年的9月21号左右通过qunar面试的，这之前也参加过其他公司的校招，但是我之前的校招经历比较坎坷。因此我对qunar是非常感激的，加上面试的两位面试官也给我很好的感觉。所以在拿到qunar的offer之后，我几乎没有再考虑过其他公司。虽然随之而来的消息是qunar被携程合并，管理层的集体退出，以及多家航司对qunar的联合打击。\" class=\"headerlink\" title=\"　　去年这一年是我从一个面向学校的学生转变为面向社会的工作者的一年。和很多毕业生一样，有一点迷茫，也有对未来的无限向往，我们就像一个个梦想家，有着无限的期望。但是我现在更希望做一个实干家，或者说行动大于空想。我是在15年的9月21号左右通过qunar面试的，这之前也参加过其他公司的校招，但是我之前的校招经历比较坎坷。因此我对qunar是非常感激的，加上面试的两位面试官也给我很好的感觉。所以在拿到qunar的offer之后，我几乎没有再考虑过其他公司。虽然随之而来的消息是qunar被携程合并，管理层的集体退出，以及多家航司对qunar的联合打击。\"></a>　　去年这一年是我从一个面向学校的学生转变为面向社会的工作者的一年。和很多毕业生一样，有一点迷茫，也有对未来的无限向往，我们就像一个个梦想家，有着无限的期望。但是我现在更希望做一个实干家，或者说行动大于空想。我是在15年的9月21号左右通过qunar面试的，这之前也参加过其他公司的校招，但是我之前的校招经历比较坎坷。因此我对qunar是非常感激的，加上面试的两位面试官也给我很好的感觉。所以在拿到qunar的offer之后，我几乎没有再考虑过其他公司。虽然随之而来的消息是qunar被携程合并，管理层的集体退出，以及多家航司对qunar的联合打击。</h5><h5 id=\"16年春节后，来到北京参加qunar的技术培训，和另外几个qunar的小伙伴，一起合租，一个房间睡了三个人，当时算了下，那一套房子有5个房间，一共住了14个人，当时最大的愿望就是，转正之后一定要有自己房间。期间公司培训的内容就是java后端开发那一套，个人觉得那是面向初学者的，所以我一有时间就去写毕业设计了，现在想起来多少有一些后悔。这可以算是我第一次参加工作，之前在学校很少出去兼职赚钱，大多数时间都是在团队或者实验室写代码做项目，感觉自己确实很契合程序员这个职业-够宅够闷骚。\"><a href=\"#16年春节后，来到北京参加qunar的技术培训，和另外几个qunar的小伙伴，一起合租，一个房间睡了三个人，当时算了下，那一套房子有5个房间，一共住了14个人，当时最大的愿望就是，转正之后一定要有自己房间。期间公司培训的内容就是java后端开发那一套，个人觉得那是面向初学者的，所以我一有时间就去写毕业设计了，现在想起来多少有一些后悔。这可以算是我第一次参加工作，之前在学校很少出去兼职赚钱，大多数时间都是在团队或者实验室写代码做项目，感觉自己确实很契合程序员这个职业-够宅够闷骚。\" class=\"headerlink\" title=\"　　16年春节后，来到北京参加qunar的技术培训，和另外几个qunar的小伙伴，一起合租，一个房间睡了三个人，当时算了下，那一套房子有5个房间，一共住了14个人，当时最大的愿望就是，转正之后一定要有自己房间。期间公司培训的内容就是java后端开发那一套，个人觉得那是面向初学者的，所以我一有时间就去写毕业设计了，现在想起来多少有一些后悔。这可以算是我第一次参加工作，之前在学校很少出去兼职赚钱，大多数时间都是在团队或者实验室写代码做项目，感觉自己确实很契合程序员这个职业-够宅够闷骚。\"></a>　　16年春节后，来到北京参加qunar的技术培训，和另外几个qunar的小伙伴，一起合租，一个房间睡了三个人，当时算了下，那一套房子有5个房间，一共住了14个人，当时最大的愿望就是，转正之后一定要有自己房间。期间公司培训的内容就是java后端开发那一套，个人觉得那是面向初学者的，所以我一有时间就去写毕业设计了，现在想起来多少有一些后悔。这可以算是我第一次参加工作，之前在学校很少出去兼职赚钱，大多数时间都是在团队或者实验室写代码做项目，感觉自己确实很契合程序员这个职业-够宅够闷骚。</h5><p><img src=\"../../img/life/2016-qunar.jpeg\" alt=\"2016-qunar技术培训照片\"></p>\n<h5 id=\"5月初的时候，趁着劳动节就回学校了，因为马上就要做毕业答辩，但是论文什么都还没写。记得离开北京的时候，还是挺高兴的，毕竟学校还有一大堆的同学和朋友在等着我回去。期间和几个好朋友去了一趟云南，这是第一次去云南，我们先是坐飞机来到了昆明，然后去了大理、丽江、香格里拉。那边的风景实在是很漂亮，特别是从大理的苍山上俯瞰整个大理。说来也是缘分，之后我在qunar工作认识的，也就是我现在的女朋友，就是来自云南的，因此我觉得我和云南还是挺有缘分的。回到学校，便是答辩，合照，聚会。有些细节现在已经忘记，记得最清楚的是毕业季真的很难过。可能是因为大家都舍不得，室友们几乎都是同一天走的。\"><a href=\"#5月初的时候，趁着劳动节就回学校了，因为马上就要做毕业答辩，但是论文什么都还没写。记得离开北京的时候，还是挺高兴的，毕竟学校还有一大堆的同学和朋友在等着我回去。期间和几个好朋友去了一趟云南，这是第一次去云南，我们先是坐飞机来到了昆明，然后去了大理、丽江、香格里拉。那边的风景实在是很漂亮，特别是从大理的苍山上俯瞰整个大理。说来也是缘分，之后我在qunar工作认识的，也就是我现在的女朋友，就是来自云南的，因此我觉得我和云南还是挺有缘分的。回到学校，便是答辩，合照，聚会。有些细节现在已经忘记，记得最清楚的是毕业季真的很难过。可能是因为大家都舍不得，室友们几乎都是同一天走的。\" class=\"headerlink\" title=\"　　5月初的时候，趁着劳动节就回学校了，因为马上就要做毕业答辩，但是论文什么都还没写。记得离开北京的时候，还是挺高兴的，毕竟学校还有一大堆的同学和朋友在等着我回去。期间和几个好朋友去了一趟云南，这是第一次去云南，我们先是坐飞机来到了昆明，然后去了大理、丽江、香格里拉。那边的风景实在是很漂亮，特别是从大理的苍山上俯瞰整个大理。说来也是缘分，之后我在qunar工作认识的，也就是我现在的女朋友，就是来自云南的，因此我觉得我和云南还是挺有缘分的。回到学校，便是答辩，合照，聚会。有些细节现在已经忘记，记得最清楚的是毕业季真的很难过。可能是因为大家都舍不得，室友们几乎都是同一天走的。\"></a>　　5月初的时候，趁着劳动节就回学校了，因为马上就要做毕业答辩，但是论文什么都还没写。记得离开北京的时候，还是挺高兴的，毕竟学校还有一大堆的同学和朋友在等着我回去。期间和几个好朋友去了一趟云南，这是第一次去云南，我们先是坐飞机来到了昆明，然后去了大理、丽江、香格里拉。那边的风景实在是很漂亮，特别是从大理的苍山上俯瞰整个大理。说来也是缘分，之后我在qunar工作认识的，也就是我现在的女朋友，就是来自云南的，因此我觉得我和云南还是挺有缘分的。回到学校，便是答辩，合照，聚会。有些细节现在已经忘记，记得最清楚的是毕业季真的很难过。可能是因为大家都舍不得，室友们几乎都是同一天走的。</h5><p><img src=\"../../img/life/2016-roommate.jpeg\" alt=\"2016-室友毕业小聚\"></p>\n<h5 id=\"兜兜转转，现在已经是2017年1月26号凌晨1点半，我正在火车站的候车室内席地而坐，等候回家的列车，车需要等到3点半才行，但是我现在已经有点困了。说到回家，虽然已经工作，但是今年回家的次数还真不少。除掉办领身份证、办理护照回去两次，另外还回去了大概两三次。可能是因为要工作了，想到以后没有了暑假，只有过年才有时间回家，所以一有时间便往家里赶。幸运的是，父母现在身体还算好-能够照顾好自己。在这方面我做的实在不够好，可能是因为和从小的教育有关，父母较偏向于传统教育，使得我和父母之间。他们（特别是我的妈妈）希望我能够像朋友一样与她交流，但是我们的每一次谈话，无不是一种父母对儿子的教育的交流方式和言语，这让我有一些不厌其烦。但是你们千万不要怀疑我对我父母的感情，我打心底里是爱他们的。这一年和他们的交流比以往大学的时候还要少一些，其实主要是不想让他们担心自己。希望他们永远健康。\"><a href=\"#兜兜转转，现在已经是2017年1月26号凌晨1点半，我正在火车站的候车室内席地而坐，等候回家的列车，车需要等到3点半才行，但是我现在已经有点困了。说到回家，虽然已经工作，但是今年回家的次数还真不少。除掉办领身份证、办理护照回去两次，另外还回去了大概两三次。可能是因为要工作了，想到以后没有了暑假，只有过年才有时间回家，所以一有时间便往家里赶。幸运的是，父母现在身体还算好-能够照顾好自己。在这方面我做的实在不够好，可能是因为和从小的教育有关，父母较偏向于传统教育，使得我和父母之间。他们（特别是我的妈妈）希望我能够像朋友一样与她交流，但是我们的每一次谈话，无不是一种父母对儿子的教育的交流方式和言语，这让我有一些不厌其烦。但是你们千万不要怀疑我对我父母的感情，我打心底里是爱他们的。这一年和他们的交流比以往大学的时候还要少一些，其实主要是不想让他们担心自己。希望他们永远健康。\" class=\"headerlink\" title=\"　　兜兜转转，现在已经是2017年1月26号凌晨1点半，我正在火车站的候车室内席地而坐，等候回家的列车，车需要等到3点半才行，但是我现在已经有点困了。说到回家，虽然已经工作，但是今年回家的次数还真不少。除掉办领身份证、办理护照回去两次，另外还回去了大概两三次。可能是因为要工作了，想到以后没有了暑假，只有过年才有时间回家，所以一有时间便往家里赶。幸运的是，父母现在身体还算好,能够照顾好自己。在这方面我做的实在不够好，可能是因为和从小的教育有关，父母较偏向于传统教育，使得我和父母之间。他们（特别是我的妈妈）希望我能够像朋友一样与她交流，但是我们的每一次谈话，无不是一种父母对儿子的教育的交流方式和言语，这让我有一些不厌其烦。但是你们千万不要怀疑我对我父母的感情，我打心底里是爱他们的。这一年和他们的交流比以往大学的时候还要少一些，其实主要是不想让他们担心自己。希望他们永远健康。\"></a>　　兜兜转转，现在已经是2017年1月26号凌晨1点半，我正在火车站的候车室内席地而坐，等候回家的列车，车需要等到3点半才行，但是我现在已经有点困了。说到回家，虽然已经工作，但是今年回家的次数还真不少。除掉办领身份证、办理护照回去两次，另外还回去了大概两三次。可能是因为要工作了，想到以后没有了暑假，只有过年才有时间回家，所以一有时间便往家里赶。幸运的是，父母现在身体还算好,能够照顾好自己。在这方面我做的实在不够好，可能是因为和从小的教育有关，父母较偏向于传统教育，使得我和父母之间。他们（特别是我的妈妈）希望我能够像朋友一样与她交流，但是我们的每一次谈话，无不是一种父母对儿子的教育的交流方式和言语，这让我有一些不厌其烦。但是你们千万不要怀疑我对我父母的感情，我打心底里是爱他们的。这一年和他们的交流比以往大学的时候还要少一些，其实主要是不想让他们担心自己。希望他们永远健康。</h5><h5 id=\"继续说说2016吧，其实也没什么好说的了。对了，我和我的女朋友就是这一年在公司认识的，和她在一起4个多月了，吵了无数次架，我们的感情却越来越深，她真的是一个好女孩，希望在我今后的道路当中，都有她的陪伴。至于2016年这一年的工作情况，就不在这里总结了，总之希望新的一年越来越好。我也需要更加努力。这一年对我来说有一个大的变化就是，之前我是一个悲观主义者，对很多东西都不看好，认为那都是命中注定，我们改变不了什么，我们太渺小了。现在，我依然认为我们改变不了任何事情，但是我坚信我们可以改变自己。这个世界不是你想象中的那个样子，你也没有办法将它改变成你想要的样子，那就改变你自己，改变你看这个世界的角度和观点，那世界将是一个崭新的世界。\"><a href=\"#继续说说2016吧，其实也没什么好说的了。对了，我和我的女朋友就是这一年在公司认识的，和她在一起4个多月了，吵了无数次架，我们的感情却越来越深，她真的是一个好女孩，希望在我今后的道路当中，都有她的陪伴。至于2016年这一年的工作情况，就不在这里总结了，总之希望新的一年越来越好。我也需要更加努力。这一年对我来说有一个大的变化就是，之前我是一个悲观主义者，对很多东西都不看好，认为那都是命中注定，我们改变不了什么，我们太渺小了。现在，我依然认为我们改变不了任何事情，但是我坚信我们可以改变自己。这个世界不是你想象中的那个样子，你也没有办法将它改变成你想要的样子，那就改变你自己，改变你看这个世界的角度和观点，那世界将是一个崭新的世界。\" class=\"headerlink\" title=\"　　继续说说2016吧，其实也没什么好说的了。对了，我和我的女朋友就是这一年在公司认识的，和她在一起4个多月了，吵了无数次架，我们的感情却越来越深，她真的是一个好女孩，希望在我今后的道路当中，都有她的陪伴。至于2016年这一年的工作情况，就不在这里总结了，总之希望新的一年越来越好。我也需要更加努力。这一年对我来说有一个大的变化就是，之前我是一个悲观主义者，对很多东西都不看好，认为那都是命中注定，我们改变不了什么，我们太渺小了。现在，我依然认为我们改变不了任何事情，但是我坚信我们可以改变自己。这个世界不是你想象中的那个样子，你也没有办法将它改变成你想要的样子，那就改变你自己，改变你看这个世界的角度和观点，那世界将是一个崭新的世界。\"></a>　　继续说说2016吧，其实也没什么好说的了。对了，我和我的女朋友就是这一年在公司认识的，和她在一起4个多月了，吵了无数次架，我们的感情却越来越深，她真的是一个好女孩，希望在我今后的道路当中，都有她的陪伴。至于2016年这一年的工作情况，就不在这里总结了，总之希望新的一年越来越好。我也需要更加努力。这一年对我来说有一个大的变化就是，之前我是一个悲观主义者，对很多东西都不看好，认为那都是命中注定，我们改变不了什么，我们太渺小了。现在，我依然认为我们改变不了任何事情，但是我坚信我们可以改变自己。这个世界不是你想象中的那个样子，你也没有办法将它改变成你想要的样子，那就改变你自己，改变你看这个世界的角度和观点，那世界将是一个崭新的世界。</h5>"},{"layout":"post","title":"vim快捷键笔记","date":"2016-10-13T16:00:00.000Z","_content":"\n## 一. 移动光标\n1. 左移h. 右移l. 下移j. 上移k\n2. 向下翻页ctrl + f，向上翻页ctrl + b    \n3. 向下翻半页ctrl + d，向上翻半页ctrl + u\n4. 移动到行尾$，移动到行首0（数字），移动到行首第一个字符处^\n5. 移动光标到下一个句子 ），移动光标到上一个句子（\n6. 移动到段首{，移动到段尾}\n7. 移动到下一个词w，移动到上一个词b\n8. 移动到文档开始gg，移动到文档结束G\n9. 移动到匹配的{}.().[]处%\n10. 跳到第n行 ngg 或 nG 或 :n\n11. 移动光标到屏幕顶端H，移动到屏幕中间M，移动到底部L\n12. 读取当前字符，并移动到本屏幕内下一次出现的地方\n13. 读取当前字符，并移动到本屏幕内上一次出现的地方\n\n<!--more-->\n\n## 二. 查找替换\n1. 光标向后查找关键字 #或者g#\n2. 光标向前查找关键字 *或者g*\n3. 当前行查找字符 fx, Fx, tx, Tx\n4. 基本替换 :s/s1/s2 （将下一个s1替换为s2）\n5. 全部替换 :%s/s1/s2\n6. 只替换当前行 :s/s1/s2/g\n7. 替换某些行 :n1,n2 s/s1/s2/g\n8. 搜索模式为 /string，搜索下一处为n，搜索上一处为N\n9. 制定书签 mx, 但是看不到书签标记，而且只能用小写字母\n10. 移动到某标签处 `x，1旁边的键\n11. 移动到上次编辑文件的位置 `.\n\n#PS：.代表一个任意字符 *代表一个或多个字符的重复\n\n## 三. 编辑操作\n1. 光标后插入a, 行尾插入A\n2. 后插一行插入o，前插一行插入O\n3. 删除字符插入s， 删除正行插入S\n4. 光标前插入i，行首插入I\n5. 删除一行dd，删除后进入插入模式cc或者S\n6. 删除一个单词dw，删除一个单词进入插入模式cw\n7. 删除一个字符x或者dl，删除一个字符进入插入模式s或者cl\n8. 粘贴p，交换两个字符xp，交换两行ddp\n9. 复制y，复制一行yy\n10. 撤销u，重做ctrl + r，重复.\n11. 智能提示 ctrl + n 或者 ctrl + p\n12. 删除motion跨过的字符，删除并进入插入模式 c{motion}\n13. 删除到下一个字符跨过的字符，删除并进入插入模式，不包括x字符 ctx\n14. 删除当前字符到下一个字符处的所有字符，并进入插入模式，包括x字符，cfx\n15. 删除motion跨过的字符，删除但不进入插入模式 d{motion}\n16. 删除motion跨过的字符，删除但不进入插入模式，不包括x字符 dtx\n17. 删除当前字符到下一个字符处的所有字符，包括x字符 dfx\n18. 如果只是复制的情况时，将12-17条中的c或d改为y\n19. 删除到行尾可以使用D或C\n20. 拷贝当前行 yy或者Y\n21. 删除当前字符 x\n22. 粘贴 p\n23. 可以使用多重剪切板，查看状态使用:reg，使用剪切板使用”，例如复制到w寄存器，”wyy，或者使用可视模式v”wy\n24. 重复执行上一个作用使用.\n25. 使用数字可以跨过n个区域，如y3x，会拷贝光标到第三个x之间的区域，3j向下移动3行\n26. 在编写代码的时候可以使用]p粘贴，这样可以自动进行代码缩进\n27. \\>> 缩进所有选择的代码\n28. << 反缩进所有选择的代码\n29. gd 移动到光标所处的函数或变量的定义处\n30. K 在man里搜索光标所在的词\n31. 合并两行 J\n32. 若不想保存文件，而重新打开 :e!\n33. 若想打开新文件 :e filename，然后使用ctrl + ^进行文件切换\n\n## 四. 窗口操作\n1. 分隔一个窗口:split或者:vsplit\n2. 创建一个窗口:new或者:vnew\n3. 在新窗口打开文件:sf {filename}\n4. 关闭当前窗口:close\n5. 仅保留当前窗口:only\n6. 到左边窗口 ctrl + w, h\n7. 到右边窗口 ctrl + w, l\n8. 到上边窗口 ctrl + w, k\n9. 到下边窗口 ctrl + w, j\n10. 到顶部窗口 ctrl + w, t\n11. 到底部窗口 ctrl + w, b\n\n## 五. 宏操作\n1. 开始记录宏操作q[a-z]，按q结束，保存操作到寄存器[a-z]中\n2. @[a-z]执行寄存器[a-z]中的操作\n3. @@执行最近一次记录的宏操作\n\n## 六. 可视操作\n1. 进入块可视模式 ctrl + v\n2. 进入字符可视模式 v\n3. 进入行可视模式 V\n4. 删除选定的块 d\n5. 删除选定的块然后进入插入模式 c\n6. 在选中的块同是插入相同的字符 IESC\n\n## 七. 跳到声明\n1. [[ 向前跳到顶格第一个{  \n2. [] 向前跳到顶格第一个}\n3. ]] 向后跳到顶格的第一个{\n4. ]] 向后跳到顶格的第一个}\n5. [{ 跳到本代码块的开头\n6. ]} 跳到本代码块的结尾\n\n## 八. 挂起操作\n1. 挂起Vim ctrl + z 或者 :suspend\n2. 查看任务 在shell中输入 jobs\n3. 恢复任务 fg [job number]（将后台程序放到前台）或者 bg [job number]（将前台程序放到后台）\n4. 执行shell命令 :!command\n5. 开启shell命令 :shell，退出该shell exit\n6. 保存vim状态 :mksession name.vim\n7. 恢复vim状态 :source name.vim\n8. 启动vim时恢复状态 vim -S name.vim","source":"_posts/note/vimNotes.md","raw":"---\nlayout: post\ntitle: vim快捷键笔记\ndate: 2016/10/14\ntags: [note, index]\n---\n\n## 一. 移动光标\n1. 左移h. 右移l. 下移j. 上移k\n2. 向下翻页ctrl + f，向上翻页ctrl + b    \n3. 向下翻半页ctrl + d，向上翻半页ctrl + u\n4. 移动到行尾$，移动到行首0（数字），移动到行首第一个字符处^\n5. 移动光标到下一个句子 ），移动光标到上一个句子（\n6. 移动到段首{，移动到段尾}\n7. 移动到下一个词w，移动到上一个词b\n8. 移动到文档开始gg，移动到文档结束G\n9. 移动到匹配的{}.().[]处%\n10. 跳到第n行 ngg 或 nG 或 :n\n11. 移动光标到屏幕顶端H，移动到屏幕中间M，移动到底部L\n12. 读取当前字符，并移动到本屏幕内下一次出现的地方\n13. 读取当前字符，并移动到本屏幕内上一次出现的地方\n\n<!--more-->\n\n## 二. 查找替换\n1. 光标向后查找关键字 #或者g#\n2. 光标向前查找关键字 *或者g*\n3. 当前行查找字符 fx, Fx, tx, Tx\n4. 基本替换 :s/s1/s2 （将下一个s1替换为s2）\n5. 全部替换 :%s/s1/s2\n6. 只替换当前行 :s/s1/s2/g\n7. 替换某些行 :n1,n2 s/s1/s2/g\n8. 搜索模式为 /string，搜索下一处为n，搜索上一处为N\n9. 制定书签 mx, 但是看不到书签标记，而且只能用小写字母\n10. 移动到某标签处 `x，1旁边的键\n11. 移动到上次编辑文件的位置 `.\n\n#PS：.代表一个任意字符 *代表一个或多个字符的重复\n\n## 三. 编辑操作\n1. 光标后插入a, 行尾插入A\n2. 后插一行插入o，前插一行插入O\n3. 删除字符插入s， 删除正行插入S\n4. 光标前插入i，行首插入I\n5. 删除一行dd，删除后进入插入模式cc或者S\n6. 删除一个单词dw，删除一个单词进入插入模式cw\n7. 删除一个字符x或者dl，删除一个字符进入插入模式s或者cl\n8. 粘贴p，交换两个字符xp，交换两行ddp\n9. 复制y，复制一行yy\n10. 撤销u，重做ctrl + r，重复.\n11. 智能提示 ctrl + n 或者 ctrl + p\n12. 删除motion跨过的字符，删除并进入插入模式 c{motion}\n13. 删除到下一个字符跨过的字符，删除并进入插入模式，不包括x字符 ctx\n14. 删除当前字符到下一个字符处的所有字符，并进入插入模式，包括x字符，cfx\n15. 删除motion跨过的字符，删除但不进入插入模式 d{motion}\n16. 删除motion跨过的字符，删除但不进入插入模式，不包括x字符 dtx\n17. 删除当前字符到下一个字符处的所有字符，包括x字符 dfx\n18. 如果只是复制的情况时，将12-17条中的c或d改为y\n19. 删除到行尾可以使用D或C\n20. 拷贝当前行 yy或者Y\n21. 删除当前字符 x\n22. 粘贴 p\n23. 可以使用多重剪切板，查看状态使用:reg，使用剪切板使用”，例如复制到w寄存器，”wyy，或者使用可视模式v”wy\n24. 重复执行上一个作用使用.\n25. 使用数字可以跨过n个区域，如y3x，会拷贝光标到第三个x之间的区域，3j向下移动3行\n26. 在编写代码的时候可以使用]p粘贴，这样可以自动进行代码缩进\n27. \\>> 缩进所有选择的代码\n28. << 反缩进所有选择的代码\n29. gd 移动到光标所处的函数或变量的定义处\n30. K 在man里搜索光标所在的词\n31. 合并两行 J\n32. 若不想保存文件，而重新打开 :e!\n33. 若想打开新文件 :e filename，然后使用ctrl + ^进行文件切换\n\n## 四. 窗口操作\n1. 分隔一个窗口:split或者:vsplit\n2. 创建一个窗口:new或者:vnew\n3. 在新窗口打开文件:sf {filename}\n4. 关闭当前窗口:close\n5. 仅保留当前窗口:only\n6. 到左边窗口 ctrl + w, h\n7. 到右边窗口 ctrl + w, l\n8. 到上边窗口 ctrl + w, k\n9. 到下边窗口 ctrl + w, j\n10. 到顶部窗口 ctrl + w, t\n11. 到底部窗口 ctrl + w, b\n\n## 五. 宏操作\n1. 开始记录宏操作q[a-z]，按q结束，保存操作到寄存器[a-z]中\n2. @[a-z]执行寄存器[a-z]中的操作\n3. @@执行最近一次记录的宏操作\n\n## 六. 可视操作\n1. 进入块可视模式 ctrl + v\n2. 进入字符可视模式 v\n3. 进入行可视模式 V\n4. 删除选定的块 d\n5. 删除选定的块然后进入插入模式 c\n6. 在选中的块同是插入相同的字符 IESC\n\n## 七. 跳到声明\n1. [[ 向前跳到顶格第一个{  \n2. [] 向前跳到顶格第一个}\n3. ]] 向后跳到顶格的第一个{\n4. ]] 向后跳到顶格的第一个}\n5. [{ 跳到本代码块的开头\n6. ]} 跳到本代码块的结尾\n\n## 八. 挂起操作\n1. 挂起Vim ctrl + z 或者 :suspend\n2. 查看任务 在shell中输入 jobs\n3. 恢复任务 fg [job number]（将后台程序放到前台）或者 bg [job number]（将前台程序放到后台）\n4. 执行shell命令 :!command\n5. 开启shell命令 :shell，退出该shell exit\n6. 保存vim状态 :mksession name.vim\n7. 恢复vim状态 :source name.vim\n8. 启动vim时恢复状态 vim -S name.vim","slug":"note/vimNotes","published":1,"updated":"2017-01-06T09:54:43.000Z","comments":1,"photos":[],"link":"","_id":"cizbemkm90006sebfklli44rl","content":"<h2 id=\"一-移动光标\"><a href=\"#一-移动光标\" class=\"headerlink\" title=\"一. 移动光标\"></a>一. 移动光标</h2><ol>\n<li>左移h. 右移l. 下移j. 上移k</li>\n<li>向下翻页ctrl + f，向上翻页ctrl + b    </li>\n<li>向下翻半页ctrl + d，向上翻半页ctrl + u</li>\n<li>移动到行尾$，移动到行首0（数字），移动到行首第一个字符处^</li>\n<li>移动光标到下一个句子 ），移动光标到上一个句子（</li>\n<li>移动到段首{，移动到段尾}</li>\n<li>移动到下一个词w，移动到上一个词b</li>\n<li>移动到文档开始gg，移动到文档结束G</li>\n<li>移动到匹配的{}.().[]处%</li>\n<li>跳到第n行 ngg 或 nG 或 :n</li>\n<li>移动光标到屏幕顶端H，移动到屏幕中间M，移动到底部L</li>\n<li>读取当前字符，并移动到本屏幕内下一次出现的地方</li>\n<li>读取当前字符，并移动到本屏幕内上一次出现的地方</li>\n</ol>\n<a id=\"more\"></a>\n<h2 id=\"二-查找替换\"><a href=\"#二-查找替换\" class=\"headerlink\" title=\"二. 查找替换\"></a>二. 查找替换</h2><ol>\n<li>光标向后查找关键字 #或者g#</li>\n<li>光标向前查找关键字 <em>或者g</em></li>\n<li>当前行查找字符 fx, Fx, tx, Tx</li>\n<li>基本替换 :s/s1/s2 （将下一个s1替换为s2）</li>\n<li>全部替换 :%s/s1/s2</li>\n<li>只替换当前行 :s/s1/s2/g</li>\n<li>替换某些行 :n1,n2 s/s1/s2/g</li>\n<li>搜索模式为 /string，搜索下一处为n，搜索上一处为N</li>\n<li>制定书签 mx, 但是看不到书签标记，而且只能用小写字母</li>\n<li>移动到某标签处 `x，1旁边的键</li>\n<li>移动到上次编辑文件的位置 `.</li>\n</ol>\n<h1 id=\"PS：-代表一个任意字符-代表一个或多个字符的重复\"><a href=\"#PS：-代表一个任意字符-代表一个或多个字符的重复\" class=\"headerlink\" title=\"PS：.代表一个任意字符 *代表一个或多个字符的重复\"></a>PS：.代表一个任意字符 *代表一个或多个字符的重复</h1><h2 id=\"三-编辑操作\"><a href=\"#三-编辑操作\" class=\"headerlink\" title=\"三. 编辑操作\"></a>三. 编辑操作</h2><ol>\n<li>光标后插入a, 行尾插入A</li>\n<li>后插一行插入o，前插一行插入O</li>\n<li>删除字符插入s， 删除正行插入S</li>\n<li>光标前插入i，行首插入I</li>\n<li>删除一行dd，删除后进入插入模式cc或者S</li>\n<li>删除一个单词dw，删除一个单词进入插入模式cw</li>\n<li>删除一个字符x或者dl，删除一个字符进入插入模式s或者cl</li>\n<li>粘贴p，交换两个字符xp，交换两行ddp</li>\n<li>复制y，复制一行yy</li>\n<li>撤销u，重做ctrl + r，重复.</li>\n<li>智能提示 ctrl + n 或者 ctrl + p</li>\n<li>删除motion跨过的字符，删除并进入插入模式 c{motion}</li>\n<li>删除到下一个字符跨过的字符，删除并进入插入模式，不包括x字符 ctx</li>\n<li>删除当前字符到下一个字符处的所有字符，并进入插入模式，包括x字符，cfx</li>\n<li>删除motion跨过的字符，删除但不进入插入模式 d{motion}</li>\n<li>删除motion跨过的字符，删除但不进入插入模式，不包括x字符 dtx</li>\n<li>删除当前字符到下一个字符处的所有字符，包括x字符 dfx</li>\n<li>如果只是复制的情况时，将12-17条中的c或d改为y</li>\n<li>删除到行尾可以使用D或C</li>\n<li>拷贝当前行 yy或者Y</li>\n<li>删除当前字符 x</li>\n<li>粘贴 p</li>\n<li>可以使用多重剪切板，查看状态使用:reg，使用剪切板使用”，例如复制到w寄存器，”wyy，或者使用可视模式v”wy</li>\n<li>重复执行上一个作用使用.</li>\n<li>使用数字可以跨过n个区域，如y3x，会拷贝光标到第三个x之间的区域，3j向下移动3行</li>\n<li>在编写代码的时候可以使用]p粘贴，这样可以自动进行代码缩进</li>\n<li>>&gt; 缩进所有选择的代码</li>\n<li>&lt;&lt; 反缩进所有选择的代码</li>\n<li>gd 移动到光标所处的函数或变量的定义处</li>\n<li>K 在man里搜索光标所在的词</li>\n<li>合并两行 J</li>\n<li>若不想保存文件，而重新打开 :e!</li>\n<li>若想打开新文件 :e filename，然后使用ctrl + ^进行文件切换</li>\n</ol>\n<h2 id=\"四-窗口操作\"><a href=\"#四-窗口操作\" class=\"headerlink\" title=\"四. 窗口操作\"></a>四. 窗口操作</h2><ol>\n<li>分隔一个窗口:split或者:vsplit</li>\n<li>创建一个窗口:new或者:vnew</li>\n<li>在新窗口打开文件:sf {filename}</li>\n<li>关闭当前窗口:close</li>\n<li>仅保留当前窗口:only</li>\n<li>到左边窗口 ctrl + w, h</li>\n<li>到右边窗口 ctrl + w, l</li>\n<li>到上边窗口 ctrl + w, k</li>\n<li>到下边窗口 ctrl + w, j</li>\n<li>到顶部窗口 ctrl + w, t</li>\n<li>到底部窗口 ctrl + w, b</li>\n</ol>\n<h2 id=\"五-宏操作\"><a href=\"#五-宏操作\" class=\"headerlink\" title=\"五. 宏操作\"></a>五. 宏操作</h2><ol>\n<li>开始记录宏操作q[a-z]，按q结束，保存操作到寄存器[a-z]中</li>\n<li>@[a-z]执行寄存器[a-z]中的操作</li>\n<li>@@执行最近一次记录的宏操作</li>\n</ol>\n<h2 id=\"六-可视操作\"><a href=\"#六-可视操作\" class=\"headerlink\" title=\"六. 可视操作\"></a>六. 可视操作</h2><ol>\n<li>进入块可视模式 ctrl + v</li>\n<li>进入字符可视模式 v</li>\n<li>进入行可视模式 V</li>\n<li>删除选定的块 d</li>\n<li>删除选定的块然后进入插入模式 c</li>\n<li>在选中的块同是插入相同的字符 IESC</li>\n</ol>\n<h2 id=\"七-跳到声明\"><a href=\"#七-跳到声明\" class=\"headerlink\" title=\"七. 跳到声明\"></a>七. 跳到声明</h2><ol>\n<li>[[ 向前跳到顶格第一个{  </li>\n<li>[] 向前跳到顶格第一个}</li>\n<li>]] 向后跳到顶格的第一个{</li>\n<li>]] 向后跳到顶格的第一个}</li>\n<li>[{ 跳到本代码块的开头</li>\n<li>]} 跳到本代码块的结尾</li>\n</ol>\n<h2 id=\"八-挂起操作\"><a href=\"#八-挂起操作\" class=\"headerlink\" title=\"八. 挂起操作\"></a>八. 挂起操作</h2><ol>\n<li>挂起Vim ctrl + z 或者 :suspend</li>\n<li>查看任务 在shell中输入 jobs</li>\n<li>恢复任务 fg [job number]（将后台程序放到前台）或者 bg [job number]（将前台程序放到后台）</li>\n<li>执行shell命令 :!command</li>\n<li>开启shell命令 :shell，退出该shell exit</li>\n<li>保存vim状态 :mksession name.vim</li>\n<li>恢复vim状态 :source name.vim</li>\n<li>启动vim时恢复状态 vim -S name.vim</li>\n</ol>\n","excerpt":"<h2 id=\"一-移动光标\"><a href=\"#一-移动光标\" class=\"headerlink\" title=\"一. 移动光标\"></a>一. 移动光标</h2><ol>\n<li>左移h. 右移l. 下移j. 上移k</li>\n<li>向下翻页ctrl + f，向上翻页ctrl + b    </li>\n<li>向下翻半页ctrl + d，向上翻半页ctrl + u</li>\n<li>移动到行尾$，移动到行首0（数字），移动到行首第一个字符处^</li>\n<li>移动光标到下一个句子 ），移动光标到上一个句子（</li>\n<li>移动到段首{，移动到段尾}</li>\n<li>移动到下一个词w，移动到上一个词b</li>\n<li>移动到文档开始gg，移动到文档结束G</li>\n<li>移动到匹配的{}.().[]处%</li>\n<li>跳到第n行 ngg 或 nG 或 :n</li>\n<li>移动光标到屏幕顶端H，移动到屏幕中间M，移动到底部L</li>\n<li>读取当前字符，并移动到本屏幕内下一次出现的地方</li>\n<li>读取当前字符，并移动到本屏幕内上一次出现的地方</li>\n</ol>","more":"<h2 id=\"二-查找替换\"><a href=\"#二-查找替换\" class=\"headerlink\" title=\"二. 查找替换\"></a>二. 查找替换</h2><ol>\n<li>光标向后查找关键字 #或者g#</li>\n<li>光标向前查找关键字 <em>或者g</em></li>\n<li>当前行查找字符 fx, Fx, tx, Tx</li>\n<li>基本替换 :s/s1/s2 （将下一个s1替换为s2）</li>\n<li>全部替换 :%s/s1/s2</li>\n<li>只替换当前行 :s/s1/s2/g</li>\n<li>替换某些行 :n1,n2 s/s1/s2/g</li>\n<li>搜索模式为 /string，搜索下一处为n，搜索上一处为N</li>\n<li>制定书签 mx, 但是看不到书签标记，而且只能用小写字母</li>\n<li>移动到某标签处 `x，1旁边的键</li>\n<li>移动到上次编辑文件的位置 `.</li>\n</ol>\n<h1 id=\"PS：-代表一个任意字符-代表一个或多个字符的重复\"><a href=\"#PS：-代表一个任意字符-代表一个或多个字符的重复\" class=\"headerlink\" title=\"PS：.代表一个任意字符 *代表一个或多个字符的重复\"></a>PS：.代表一个任意字符 *代表一个或多个字符的重复</h1><h2 id=\"三-编辑操作\"><a href=\"#三-编辑操作\" class=\"headerlink\" title=\"三. 编辑操作\"></a>三. 编辑操作</h2><ol>\n<li>光标后插入a, 行尾插入A</li>\n<li>后插一行插入o，前插一行插入O</li>\n<li>删除字符插入s， 删除正行插入S</li>\n<li>光标前插入i，行首插入I</li>\n<li>删除一行dd，删除后进入插入模式cc或者S</li>\n<li>删除一个单词dw，删除一个单词进入插入模式cw</li>\n<li>删除一个字符x或者dl，删除一个字符进入插入模式s或者cl</li>\n<li>粘贴p，交换两个字符xp，交换两行ddp</li>\n<li>复制y，复制一行yy</li>\n<li>撤销u，重做ctrl + r，重复.</li>\n<li>智能提示 ctrl + n 或者 ctrl + p</li>\n<li>删除motion跨过的字符，删除并进入插入模式 c{motion}</li>\n<li>删除到下一个字符跨过的字符，删除并进入插入模式，不包括x字符 ctx</li>\n<li>删除当前字符到下一个字符处的所有字符，并进入插入模式，包括x字符，cfx</li>\n<li>删除motion跨过的字符，删除但不进入插入模式 d{motion}</li>\n<li>删除motion跨过的字符，删除但不进入插入模式，不包括x字符 dtx</li>\n<li>删除当前字符到下一个字符处的所有字符，包括x字符 dfx</li>\n<li>如果只是复制的情况时，将12-17条中的c或d改为y</li>\n<li>删除到行尾可以使用D或C</li>\n<li>拷贝当前行 yy或者Y</li>\n<li>删除当前字符 x</li>\n<li>粘贴 p</li>\n<li>可以使用多重剪切板，查看状态使用:reg，使用剪切板使用”，例如复制到w寄存器，”wyy，或者使用可视模式v”wy</li>\n<li>重复执行上一个作用使用.</li>\n<li>使用数字可以跨过n个区域，如y3x，会拷贝光标到第三个x之间的区域，3j向下移动3行</li>\n<li>在编写代码的时候可以使用]p粘贴，这样可以自动进行代码缩进</li>\n<li>>&gt; 缩进所有选择的代码</li>\n<li>&lt;&lt; 反缩进所有选择的代码</li>\n<li>gd 移动到光标所处的函数或变量的定义处</li>\n<li>K 在man里搜索光标所在的词</li>\n<li>合并两行 J</li>\n<li>若不想保存文件，而重新打开 :e!</li>\n<li>若想打开新文件 :e filename，然后使用ctrl + ^进行文件切换</li>\n</ol>\n<h2 id=\"四-窗口操作\"><a href=\"#四-窗口操作\" class=\"headerlink\" title=\"四. 窗口操作\"></a>四. 窗口操作</h2><ol>\n<li>分隔一个窗口:split或者:vsplit</li>\n<li>创建一个窗口:new或者:vnew</li>\n<li>在新窗口打开文件:sf {filename}</li>\n<li>关闭当前窗口:close</li>\n<li>仅保留当前窗口:only</li>\n<li>到左边窗口 ctrl + w, h</li>\n<li>到右边窗口 ctrl + w, l</li>\n<li>到上边窗口 ctrl + w, k</li>\n<li>到下边窗口 ctrl + w, j</li>\n<li>到顶部窗口 ctrl + w, t</li>\n<li>到底部窗口 ctrl + w, b</li>\n</ol>\n<h2 id=\"五-宏操作\"><a href=\"#五-宏操作\" class=\"headerlink\" title=\"五. 宏操作\"></a>五. 宏操作</h2><ol>\n<li>开始记录宏操作q[a-z]，按q结束，保存操作到寄存器[a-z]中</li>\n<li>@[a-z]执行寄存器[a-z]中的操作</li>\n<li>@@执行最近一次记录的宏操作</li>\n</ol>\n<h2 id=\"六-可视操作\"><a href=\"#六-可视操作\" class=\"headerlink\" title=\"六. 可视操作\"></a>六. 可视操作</h2><ol>\n<li>进入块可视模式 ctrl + v</li>\n<li>进入字符可视模式 v</li>\n<li>进入行可视模式 V</li>\n<li>删除选定的块 d</li>\n<li>删除选定的块然后进入插入模式 c</li>\n<li>在选中的块同是插入相同的字符 IESC</li>\n</ol>\n<h2 id=\"七-跳到声明\"><a href=\"#七-跳到声明\" class=\"headerlink\" title=\"七. 跳到声明\"></a>七. 跳到声明</h2><ol>\n<li>[[ 向前跳到顶格第一个{  </li>\n<li>[] 向前跳到顶格第一个}</li>\n<li>]] 向后跳到顶格的第一个{</li>\n<li>]] 向后跳到顶格的第一个}</li>\n<li>[{ 跳到本代码块的开头</li>\n<li>]} 跳到本代码块的结尾</li>\n</ol>\n<h2 id=\"八-挂起操作\"><a href=\"#八-挂起操作\" class=\"headerlink\" title=\"八. 挂起操作\"></a>八. 挂起操作</h2><ol>\n<li>挂起Vim ctrl + z 或者 :suspend</li>\n<li>查看任务 在shell中输入 jobs</li>\n<li>恢复任务 fg [job number]（将后台程序放到前台）或者 bg [job number]（将前台程序放到后台）</li>\n<li>执行shell命令 :!command</li>\n<li>开启shell命令 :shell，退出该shell exit</li>\n<li>保存vim状态 :mksession name.vim</li>\n<li>恢复vim状态 :source name.vim</li>\n<li>启动vim时恢复状态 vim -S name.vim</li>\n</ol>"},{"layout":"post","title":"zookeeper原理","date":"2016-11-30T16:00:00.000Z","_content":"\n##### ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，它包含一个简单的原语集，分布式应用程序可以基于它实现同步服务，配置维护和命名服务等。Zookeeper是hadoop的一个子项目，其发展历程无需赘述。在分布式应用中，由于工程师不能很好地使用锁机制，以及基于消息的协调机制不适合在某些应用中使用，因此需要有一种可靠的、可扩展的、分布式的、可配置的协调机制来统一系统的状态。Zookeeper的目的就在于此。本文简单分析zookeeper的工作原理，对于如何使用zookeeper不是本文讨论的重点。\n<!--more-->\n## 1 Zookeeper的基本概念\n### 1.1 角色\n\n##### Zookeeper中的角色主要有以下三类，如下表所示：\n![zookeeper角色](../../img/zookeeper/role.jpg)\n\n##### 系统模型如图所示：\n![zookeeper系统模型](../../img/zookeeper/zookeeperModel.jpg)\n\n\n### 1.2 设计目的\n\n1. 最终一致性：client不论连接到哪个Server，展示给它都是同一个视图，这是zookeeper最重要的性能。\n2. 可靠性：具有简单、健壮、良好的性能，如果消息m被到一台服务器接受，那么它将被所有的服务器接受。\n3. 实时性：Zookeeper保证客户端将在一个时间间隔范围内获得服务器的更新信息，或者服务器失效的信息。但由于网络延时等原因，Zookeeper不能保证两个客户端能同时得到刚更新的数据，如果需要最新数据，应该在读数据之前调用sync()接口。\n4. 等待无关（wait-free）：慢的或者失效的client不得干预快速的client的请求，使得每个client都能有效的等待。\n5. 原子性：更新只能成功或者失败，没有中间状态。\n6. 顺序性：包括全局有序和偏序两种：全局有序是指如果在一台服务器上消息a在消息b前发布，则在所有Server上消息a都将在消息b前被发布；偏序是指如果一个消息b在消息a后被同一个发送者发布，a必将排在b前面。\n\n## 2 ZooKeeper的工作原理\n##### Zookeeper的核心是原子广播，这个机制保证了各个Server之间的同步。实现这个机制的协议叫做Zab协议。Zab协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数Server完成了和leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和Server具有相同的系统状态。\n##### 为了保证事务的顺序一致性，zookeeper采用了递增的事务id号（zxid）来标识事务。所有的提议（proposal）都在被提出的时候加上了zxid。实现中zxid是一个64位的数字，它高32位是epoch用来标识leader关系是否改变，每次一个leader被选出来，它都会有一个新的epoch，标识当前属于那个leader的统治时期。低32位用于递增计数。\n##### 每个Server在工作过程中有三种状态：\n* LOOKING：当前Server不知道leader是谁，正在搜寻\n* LEADING：当前Server即为选举出来的leader\n* FOLLOWING：leader已经选举出来，当前Server与之同步\n\n### 2.1 选主流程\n\n##### 当leader崩溃或者leader失去大多数的follower，这时候zk进入恢复模式，恢复模式需要重新选举出一个新的leader，让所有的Server都恢复到一个正确的状态。Zk的选举算法有两种：一种是基于basic paxos实现的，另外一种是基于fast paxos算法实现的。系统默认的选举算法为fast paxos。先介绍basic paxos流程：\n1. 选举线程由当前Server发起选举的线程担任，其主要功能是对投票结果进行统计，并选出推荐的Server；\n2. 选举线程首先向所有Server发起一次询问(包括自己)；\n3. 选举线程收到回复后，验证是否是自己发起的询问(验证zxid是否一致)，然后获取对方的id(myid)，并存储到当前询问对象列表中，最后获取对方提议的leader相关信息(id,zxid)，并将这些信息存储到当次选举的投票记录表中；\n4. 收到所有Server回复以后，就计算出zxid最大的那个Server，并将这个Server相关信息设置成下一次要投票的Server；\n5. 线程将当前zxid最大的Server设置为当前Server要推荐的Leader，如果此时获胜的Server获得n/2 + 1的Server票数， 设置当前推荐的leader为获胜的Server，将根据获胜的Server相关信息设置自己的状态，否则，继续这个过程，直到leader被选举出来。\n\n##### 通过流程分析我们可以得出：要使Leader获得多数Server的支持，则Server总数必须是奇数2n+1，且存活的Server的数目不得少于n+1.\n##### 每个Server启动后都会重复以上流程。在恢复模式下，如果是刚从崩溃状态恢复的或者刚启动的server还会从磁盘快照中恢复数据和会话信息，zk会记录事务日志并定期进行快照，方便在恢复时进行状态恢复。选主的具体流程图如下所示：\n![zookeeper流程图](../../img/zookeeper/zookeeperLc.jpg)\n\n##### fast paxos流程是在选举过程中，某Server首先向所有Server提议自己要成为leader，当其它Server收到提议以后，解决epoch和zxid的冲突，并接受对方的提议，然后向对方发送接受提议完成的消息，重复这个流程，最后一定能选举出Leader。其流程图如下所示：\n![zookeeper流程图](../../img/zookeeper/zookeeperLc2.jpg)\n\n### 2.2 同步流程\n##### 选完leader以后，zk就进入状态同步过程。\n1. leader等待server连接；\n2. Follower连接leader，将最大的zxid发送给leader；\n3. Leader根据follower的zxid确定同步点；\n4. 完成同步后通知follower 已经成为uptodate状态；\n5. Follower收到uptodate消息后，又可以重新接受client的请求进行服务了。\n\n##### 流程图如下所示：\n![zookeeper流程图](../../img/zookeeper/zookeeperLc3.jpg)\n\n### 2.3 工作流程\n#### 2.3.1 Leader工作流程\n##### Leader主要有三个功能：\n1. 恢复数据；\n2. 维持与Learner的心跳，接收Learner请求并判断Learner的请求消息类型；\n3. Learner的消息类型主要有PING消息、REQUEST消息、ACK消息、REVALIDATE消息，根据不同的消息类型，进行不同的处理。\n\n##### PING消息是指Learner的心跳信息；REQUEST消息是Follower发送的提议信息，包括写请求及同步请求；ACK消息是Follower的对提议的回复，超过半数的Follower通过，则commit该提议；REVALIDATE消息是用来延长SESSION有效时间。\n##### Leader的工作流程简图如下所示，在实际实现中，流程要比下图复杂得多，启动了三个线程来实现功能。\n![zookeeper流程图](../../img/zookeeper/zookeeperLc4.jpg)\n\n#### 2.3.2 Follower工作流程\n##### Follower主要有四个功能：\n1. 向Leader发送请求（PING消息、REQUEST消息、ACK消息、REVALIDATE消息）；\n2. 接收Leader消息并进行处理；\n3. 接收Client的请求，如果为写请求，发送给Leader进行投票；\n4. 返回Client结果。\n\n##### Follower的消息循环处理如下几种来自Leader的消息：\n1. PING消息： 心跳消息；\n2. PROPOSAL消息：Leader发起的提案，要求Follower投票；\n3. COMMIT消息：服务器端最新一次提案的信息；\n4. UPTODATE消息：表明同步完成；\n5. REVALIDATE消息：根据Leader的REVALIDATE结果，关闭待revalidate的session还是允许其接受消息；\n6. SYNC消息：返回SYNC结果到客户端，这个消息最初由客户端发起，用来强制得到最新的更新。\n\n##### Follower的工作流程简图如下所示，在实际实现中，Follower是通过5个线程来实现功能的。\n![zookeeper流程图](../../img/zookeeper/zookeeperLc5.jpg)\n\n##### 对于observer的流程不再叙述，observer流程和Follower的唯一不同的地方就是observer不会参加leader发起的投票。\n##### 主流应用场景：\n##### __Zookeeper的主流应用场景实现思路（除去官方示例）__ \n\n#### (1)配置管理\n##### 集中式的配置管理在应用集群中是非常常见的，一般商业公司内部都会实现一套集中的配置管理中心，应对不同的应用集群对于共享各自配置的需求，并且在配置变更时能够通知到集群中的每一个机器。\n##### Zookeeper很容易实现这种集中式的配置管理，比如将APP1的所有配置配置到/APP1 znode下，APP1所有机器一启动就对/APP1这个节点进行监控(zk.exist(\"/APP1\",true)),并且实现回调方法Watcher，那么在zookeeper上/APP1 znode节点下数据发生变化的时候，每个机器都会收到通知，Watcher方法将会被执行，那么应用再取下数据即可(zk.getData(\"/APP1\",false,null));\n##### 以上这个例子只是简单的粗颗粒度配置监控，细颗粒度的数据可以进行分层级监控，这一切都是可以设计和控制的。     \n![zookeeper流程图](../../img/zookeeper/zookeeper1.jpg)\n\n#### (2)集群管理 \n##### 应用集群中，我们常常需要让每一个机器知道集群中（或依赖的其他某一个集群）哪些机器是活着的，并且在集群机器因为宕机，网络断链等原因能够不在人工介入的情况下迅速通知到每一个机器。\n##### Zookeeper同样很容易实现这个功能，比如我在zookeeper服务器端有一个znode叫/APP1SERVERS,那么集群中每一个机器启动的时候都去这个节点下创建一个EPHEMERAL类型的节点，比如server1创建/APP1SERVERS/SERVER1(可以使用ip,保证不重复)，server2创建/APP1SERVERS/SERVER2，然后SERVER1和SERVER2都watch /APP1SERVERS这个父节点，那么也就是这个父节点下数据或者子节点变化都会通知对该节点进行watch的客户端。因为EPHEMERAL类型节点有一个很重要的特性，就是客户端和服务器端连接断掉或者session过期就会使节点消失，那么在某一个机器挂掉或者断链的时候，其对应的节点就会消失，然后集群中所有对/APP1SERVERS进行watch的客户端都会收到通知，然后取得最新列表即可。\n##### 另外有一个应用场景就是集群选master,一旦master挂掉能够马上能从slave中选出一个master,实现步骤和前者一样，只是机器在启动的时候在APP1SERVERS创建的节点类型变为EPHEMERAL_SEQUENTIAL类型，这样每个节点会自动被编号\n##### 我们默认规定编号最小的为master,所以当我们对/APP1SERVERS节点做监控的时候，得到服务器列表，只要所有集群机器逻辑认为最小编号节点为master，那么master就被选出，而这个master宕机的时候，相应的znode会消失，然后新的服务器列表就被推送到客户端，然后每个节点逻辑认为最小编号节点为master，这样就做到动态master选举。\n![zookeeper流程图](../../img/zookeeper/zookeeper2.jpg)\n\n#### Zookeeper 监视（Watches） 简介\n##### Zookeeper C API 的声明和描述在 include/zookeeper.h 中可以找到，另外大部分的 Zookeeper C API 常量、结构体声明也在 zookeeper.h 中，如果如果你在使用 C API 是遇到不明白的地方，最好看看 zookeeper.h，或者自己使用 doxygen 生成 Zookeeper C API 的帮助文档。\n##### Zookeeper 中最有特色且最不容易理解的是监视(Watches)。Zookeeper 所有的读操作——getData(), getChildren(), 和 exists() 都 可以设置监视(watch)，监视事件可以理解为一次性的触发器， 官方定义如下： a watch event is one-time trigger, sent to the client that set the watch, which occurs when the data for which the watch was set changes。对此需要作出如下理解：\n* （一次性触发）One-time trigger\n\n##### 当设置监视的数据发生改变时，该监视事件会被发送到客户端，例如，如果客户端调用了 getData(\"/znode1\", true) 并且稍后 /znode1 节点上的数据发生了改变或者被删除了，客户端将会获取到 /znode1 发生变化的监视事件，而如果 /znode1 再一次发生了变化，除非客户端再次对 /znode1 设置监视，否则客户端不会收到事件通知。\n* （发送至客户端）Sent to the client\n\n##### Zookeeper 客户端和服务端是通过 socket 进行通信的，由于网络存在故障，所以监视事件很有可能不会成功地到达客户端，监视事件是异步发送至监视者的，Zookeeper 本身提供了保序性(ordering guarantee)：即客户端只有首先看到了监视事件后，才会感知到它所设置监视的 znode 发生了变化(a client will never see a change for which it has set a watch until it first sees the watch event). 网络延迟或者其他因素可能导致不同的客户端在不同的时刻感知某一监视事件，但是不同的客户端所看到的一切具有一致的顺序。\n* （被设置 watch 的数据）The data for which the watch was set\n\n##### 这意味着 znode 节点本身具有不同的改变方式。你也可以想象 Zookeeper 维护了两条监视链表：数据监视和子节点监视(data watches and child watches) getData() and exists() 设置数据监视，getChildren() 设置子节点监视。 或者，你也可以想象 Zookeeper 设置的不同监视返回不同的数据，getData() 和 exists() 返回 znode 节点的相关信息，而 getChildren() 返回子节点列表。因此， setData() 会触发设置在某一节点上所设置的数据监视(假定数据设置成功)，而一次成功的 create() 操作则会出发当前节点上所设置的数据监视以及父节点的子节点监视。一次成功的 delete() 操作将会触发当前节点的数据监视和子节点监视事件，同时也会触发该节点父节点的child watch。\n##### Zookeeper 中的监视是轻量级的，因此容易设置、维护和分发。当客户端与 Zookeeper 服务器端失去联系时，客户端并不会收到监视事件的通知，只有当客户端重新连接后，若在必要的情况下，以前注册的监视会重新被注册并触发，对于开发人员来说 这通常是透明的。只有一种情况会导致监视事件的丢失，即：通过 exists() 设置了某个 znode 节点的监视，但是如果某个客户端在此 znode 节点被创建和删除的时间间隔内与 zookeeper 服务器失去了联系，该客户端即使稍后重新连接 zookeeper服务器后也得不到事件通知。\n\n### Zookeeper C API 常量与部分结构(struct)介绍\n\n#### 与 ACL 相关的结构与常量：\n##### struct Id 结构为：\n```\nstruct Id {     char * scheme;     char * id; };\n```\n##### struct ACL 结构为：\n```\nstruct ACL {     int32_t perms;     struct Id id; };\n```\n##### struct ACL_vector 结构为：\n```\nstruct ACL_vector {     int32_t count;     struct ACL *data; };\n```\n##### 与 znode 访问权限有关的常量\n* const int ZOO_PERM_READ; //允许客户端读取 znode 节点的值以及子节点列表。\n* const int ZOO_PERM_WRITE;// 允许客户端设置 znode 节点的值。\n* const int ZOO_PERM_CREATE; //允许客户端在该 znode 节点下创建子节点。\n* const int ZOO_PERM_DELETE;//允许客户端删除子节点。\n* const int ZOO_PERM_ADMIN; //允许客户端执行 set_acl()。\n* const int ZOO_PERM_ALL;//允许客户端执行所有操作，等价与上述所有标志的或(OR) 。\n\n##### 与 ACL IDs 相关的常量\n* struct Id ZOO_ANYONE_ID_UNSAFE; //(‘world’,’anyone’)\n* struct Id ZOO_AUTH_IDS;// (‘auth’,’’)\n\n##### 三种标准的 ACL\n* struct ACL_vector ZOO_OPEN_ACL_UNSAFE; //(ZOO_PERM_ALL,ZOO_ANYONE_ID_UNSAFE)\n* struct ACL_vector ZOO_READ_ACL_UNSAFE;// (ZOO_PERM_READ, ZOO_ANYONE_ID_UNSAFE)\n* struct ACL_vector ZOO_CREATOR_ALL_ACL; //(ZOO_PERM_ALL,ZOO_AUTH_IDS)\n\n#### 与 Interest 相关的常量：ZOOKEEPER_WRITE, ZOOKEEPER_READ\n##### 这两个常量用于标识感兴趣的事件并通知zookeeper发生了哪些事件。Interest 常量可以进行组合或（OR）来标识多种兴趣(multiple interests: write, read)，这两个常量一般用于 zookeeper_interest() 和 zookeeper_process()两个函数中。\n\n#### 与节点创建相关的常量：ZOO_EPHEMERAL, ZOO_SEQUENCE\n##### zoo_create 函数标志，ZOO_EPHEMERAL 用来标识创建临时节点，ZOO_SEQUENCE 用来标识节点命名具有递增的后缀序号(一般是节点名称后填充 10 位字符的序号，如 /xyz0000000000, /xyz0000000001, /xyz0000000002, ...)，同样地，ZOO_EPHEMERAL, ZOO_SEQUENCE 可以组合。\n\n#### 与连接状态 Stat 相关的常量\n\n##### 以下常量均与 Zookeeper 连接状态有关，他们通常用作监视器回调函数的参数。\n\n| ZOOAPI const int | ZOO_EXPIRED_SESSION_STATE |\n|:-----------------|:--------------------------|\n| ZOOAPI const int |     ZOO_AUTH_FAILED_STATE |\n| ZOOAPI const int |      ZOO_CONNECTING_STATE |\n| ZOOAPI const int |     ZOO_ASSOCIATING_STATE |\n| ZOOAPI const int |       ZOO_CONNECTED_STATE |\n\n#### 与监视类型(Watch Types)相关的常量\n\n##### 以下常量标识监视事件的类型，他们通常用作监视器回调函数的第一个参数。\n* ZOO_CREATED_EVENT; // 节点被创建(此前该节点不存在)，通过 zoo_exists() 设置监视。\n* ZOO_DELETED_EVENT; // 节点被删除，通过 zoo_exists() 和 zoo_get() 设置监视。\n* ZOO_CHANGED_EVENT; // 节点发生变化，通过 zoo_exists() 和 zoo_get() 设置监视。\n* ZOO_CHILD_EVENT; // 子节点事件，通过zoo_get_children() 和 zoo_get_children2()设置监视。\n* ZOO_SESSION_EVENT; // 会话丢失\n* ZOO_NOTWATCHING_EVENT; // 监视被移除。\n\n#### Zookeeper C API 错误码介绍 ZOO_ERRORS\n\nZOK | 正常返回\n----|--------\nZSYSTEMERROR | 系统或服务器端错误(System and server-side errors)，服务器不会抛出该错误，该错误也只是用来标识错误范围的，即大于该错误值，且小于 ZAPIERROR 都是系统错误。\nZRUNTIMEINCONSISTENCY | 运行时非一致性错误。\nZDATAINCONSISTENCY | 数据非一致性错误。\nZCONNECTIONLOSS | Zookeeper 客户端与服务器端失去连接\nZMARSHALLINGERROR | 在 marshalling 和 unmarshalling 数据时出现错误(Error while marshalling or unmarshalling data)\nZUNIMPLEMENTED | 该操作未实现(Operation is unimplemented)\nZOPERATIONTIMEOUT | 该操作超时(Operation timeout)\nZBADARGUMENTS | 非法参数错误(Invalid arguments)\nZINVALIDSTATE | 非法句柄状态(Invliad zhandle state)\nZAPIERROR | API 错误(API errors)，服务器不会抛出该错误，该错误也只是用来标识错误范围的，错误值大于该值的标识 API 错误，而小于该值的标识 ZSYSTEMERROR。\nZNONODE | 节点不存在(Node does not exist)\nZNOAUTH | 没有经过授权(Not authenticated)\nZBADVERSION | 版本冲突(Version conflict)\nZNOCHILDRENFOREPHEMERALS | 临时节点不能拥有子节点(Ephemeral nodes may not have children)\nZNODEEXISTS | 节点已经存在(The node already exists)\nZNOTEMPTY | 该节点具有自身的子节点(The node has children)\nZSESSIONEXPIRED | 会话过期(The session has been expired by the server)\nZINVALIDCALLBACK | 非法的回调函数(Invalid callback specified)\nZINVALIDACL | 非法的ACL(Invalid ACL specified)\nZAUTHFAILED | 客户端授权失败(Client authentication failed)\nZCLOSING | Zookeeper 连接关闭(ZooKeeper is closing)\nZNOTHING | 并非错误，客户端不需要处理服务器的响应(not error, no server responses to process)\nZSESSIONMOVED | 会话转移至其他服务器，所以操作被忽略(session moved to another server, so operation is ignored) \n\n##### Watch事件类型：\n* ZOO_CREATED_EVENT：节点创建事件，需要watch一个不存在的节点，当节点被创建时触发，此watch通过zoo_exists()设置\n* ZOO_DELETED_EVENT：节点删除事件，此watch通过zoo_exists()或zoo_get()设置\n* ZOO_CHANGED_EVENT：节点数据改变事件，此watch通过zoo_exists()或zoo_get()设置\n* ZOO_CHILD_EVENT：子节点列表改变事件，此watch通过zoo_get_children()或zoo_get_children2()设置\n* ZOO_SESSION_EVENT：会话失效事件，客户端与服务端断开或重连时触发\n* ZOO_NOTWATCHING_EVENT：watch移除事件，服务端出于某些原因不再为客户端watch节点时触发","source":"_posts/note/zookeeper.md","raw":"---\nlayout: post\ntitle: zookeeper原理\ndate: 2016/12/01\ntags: [note, index]\n---\n\n##### ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，它包含一个简单的原语集，分布式应用程序可以基于它实现同步服务，配置维护和命名服务等。Zookeeper是hadoop的一个子项目，其发展历程无需赘述。在分布式应用中，由于工程师不能很好地使用锁机制，以及基于消息的协调机制不适合在某些应用中使用，因此需要有一种可靠的、可扩展的、分布式的、可配置的协调机制来统一系统的状态。Zookeeper的目的就在于此。本文简单分析zookeeper的工作原理，对于如何使用zookeeper不是本文讨论的重点。\n<!--more-->\n## 1 Zookeeper的基本概念\n### 1.1 角色\n\n##### Zookeeper中的角色主要有以下三类，如下表所示：\n![zookeeper角色](../../img/zookeeper/role.jpg)\n\n##### 系统模型如图所示：\n![zookeeper系统模型](../../img/zookeeper/zookeeperModel.jpg)\n\n\n### 1.2 设计目的\n\n1. 最终一致性：client不论连接到哪个Server，展示给它都是同一个视图，这是zookeeper最重要的性能。\n2. 可靠性：具有简单、健壮、良好的性能，如果消息m被到一台服务器接受，那么它将被所有的服务器接受。\n3. 实时性：Zookeeper保证客户端将在一个时间间隔范围内获得服务器的更新信息，或者服务器失效的信息。但由于网络延时等原因，Zookeeper不能保证两个客户端能同时得到刚更新的数据，如果需要最新数据，应该在读数据之前调用sync()接口。\n4. 等待无关（wait-free）：慢的或者失效的client不得干预快速的client的请求，使得每个client都能有效的等待。\n5. 原子性：更新只能成功或者失败，没有中间状态。\n6. 顺序性：包括全局有序和偏序两种：全局有序是指如果在一台服务器上消息a在消息b前发布，则在所有Server上消息a都将在消息b前被发布；偏序是指如果一个消息b在消息a后被同一个发送者发布，a必将排在b前面。\n\n## 2 ZooKeeper的工作原理\n##### Zookeeper的核心是原子广播，这个机制保证了各个Server之间的同步。实现这个机制的协议叫做Zab协议。Zab协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数Server完成了和leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和Server具有相同的系统状态。\n##### 为了保证事务的顺序一致性，zookeeper采用了递增的事务id号（zxid）来标识事务。所有的提议（proposal）都在被提出的时候加上了zxid。实现中zxid是一个64位的数字，它高32位是epoch用来标识leader关系是否改变，每次一个leader被选出来，它都会有一个新的epoch，标识当前属于那个leader的统治时期。低32位用于递增计数。\n##### 每个Server在工作过程中有三种状态：\n* LOOKING：当前Server不知道leader是谁，正在搜寻\n* LEADING：当前Server即为选举出来的leader\n* FOLLOWING：leader已经选举出来，当前Server与之同步\n\n### 2.1 选主流程\n\n##### 当leader崩溃或者leader失去大多数的follower，这时候zk进入恢复模式，恢复模式需要重新选举出一个新的leader，让所有的Server都恢复到一个正确的状态。Zk的选举算法有两种：一种是基于basic paxos实现的，另外一种是基于fast paxos算法实现的。系统默认的选举算法为fast paxos。先介绍basic paxos流程：\n1. 选举线程由当前Server发起选举的线程担任，其主要功能是对投票结果进行统计，并选出推荐的Server；\n2. 选举线程首先向所有Server发起一次询问(包括自己)；\n3. 选举线程收到回复后，验证是否是自己发起的询问(验证zxid是否一致)，然后获取对方的id(myid)，并存储到当前询问对象列表中，最后获取对方提议的leader相关信息(id,zxid)，并将这些信息存储到当次选举的投票记录表中；\n4. 收到所有Server回复以后，就计算出zxid最大的那个Server，并将这个Server相关信息设置成下一次要投票的Server；\n5. 线程将当前zxid最大的Server设置为当前Server要推荐的Leader，如果此时获胜的Server获得n/2 + 1的Server票数， 设置当前推荐的leader为获胜的Server，将根据获胜的Server相关信息设置自己的状态，否则，继续这个过程，直到leader被选举出来。\n\n##### 通过流程分析我们可以得出：要使Leader获得多数Server的支持，则Server总数必须是奇数2n+1，且存活的Server的数目不得少于n+1.\n##### 每个Server启动后都会重复以上流程。在恢复模式下，如果是刚从崩溃状态恢复的或者刚启动的server还会从磁盘快照中恢复数据和会话信息，zk会记录事务日志并定期进行快照，方便在恢复时进行状态恢复。选主的具体流程图如下所示：\n![zookeeper流程图](../../img/zookeeper/zookeeperLc.jpg)\n\n##### fast paxos流程是在选举过程中，某Server首先向所有Server提议自己要成为leader，当其它Server收到提议以后，解决epoch和zxid的冲突，并接受对方的提议，然后向对方发送接受提议完成的消息，重复这个流程，最后一定能选举出Leader。其流程图如下所示：\n![zookeeper流程图](../../img/zookeeper/zookeeperLc2.jpg)\n\n### 2.2 同步流程\n##### 选完leader以后，zk就进入状态同步过程。\n1. leader等待server连接；\n2. Follower连接leader，将最大的zxid发送给leader；\n3. Leader根据follower的zxid确定同步点；\n4. 完成同步后通知follower 已经成为uptodate状态；\n5. Follower收到uptodate消息后，又可以重新接受client的请求进行服务了。\n\n##### 流程图如下所示：\n![zookeeper流程图](../../img/zookeeper/zookeeperLc3.jpg)\n\n### 2.3 工作流程\n#### 2.3.1 Leader工作流程\n##### Leader主要有三个功能：\n1. 恢复数据；\n2. 维持与Learner的心跳，接收Learner请求并判断Learner的请求消息类型；\n3. Learner的消息类型主要有PING消息、REQUEST消息、ACK消息、REVALIDATE消息，根据不同的消息类型，进行不同的处理。\n\n##### PING消息是指Learner的心跳信息；REQUEST消息是Follower发送的提议信息，包括写请求及同步请求；ACK消息是Follower的对提议的回复，超过半数的Follower通过，则commit该提议；REVALIDATE消息是用来延长SESSION有效时间。\n##### Leader的工作流程简图如下所示，在实际实现中，流程要比下图复杂得多，启动了三个线程来实现功能。\n![zookeeper流程图](../../img/zookeeper/zookeeperLc4.jpg)\n\n#### 2.3.2 Follower工作流程\n##### Follower主要有四个功能：\n1. 向Leader发送请求（PING消息、REQUEST消息、ACK消息、REVALIDATE消息）；\n2. 接收Leader消息并进行处理；\n3. 接收Client的请求，如果为写请求，发送给Leader进行投票；\n4. 返回Client结果。\n\n##### Follower的消息循环处理如下几种来自Leader的消息：\n1. PING消息： 心跳消息；\n2. PROPOSAL消息：Leader发起的提案，要求Follower投票；\n3. COMMIT消息：服务器端最新一次提案的信息；\n4. UPTODATE消息：表明同步完成；\n5. REVALIDATE消息：根据Leader的REVALIDATE结果，关闭待revalidate的session还是允许其接受消息；\n6. SYNC消息：返回SYNC结果到客户端，这个消息最初由客户端发起，用来强制得到最新的更新。\n\n##### Follower的工作流程简图如下所示，在实际实现中，Follower是通过5个线程来实现功能的。\n![zookeeper流程图](../../img/zookeeper/zookeeperLc5.jpg)\n\n##### 对于observer的流程不再叙述，observer流程和Follower的唯一不同的地方就是observer不会参加leader发起的投票。\n##### 主流应用场景：\n##### __Zookeeper的主流应用场景实现思路（除去官方示例）__ \n\n#### (1)配置管理\n##### 集中式的配置管理在应用集群中是非常常见的，一般商业公司内部都会实现一套集中的配置管理中心，应对不同的应用集群对于共享各自配置的需求，并且在配置变更时能够通知到集群中的每一个机器。\n##### Zookeeper很容易实现这种集中式的配置管理，比如将APP1的所有配置配置到/APP1 znode下，APP1所有机器一启动就对/APP1这个节点进行监控(zk.exist(\"/APP1\",true)),并且实现回调方法Watcher，那么在zookeeper上/APP1 znode节点下数据发生变化的时候，每个机器都会收到通知，Watcher方法将会被执行，那么应用再取下数据即可(zk.getData(\"/APP1\",false,null));\n##### 以上这个例子只是简单的粗颗粒度配置监控，细颗粒度的数据可以进行分层级监控，这一切都是可以设计和控制的。     \n![zookeeper流程图](../../img/zookeeper/zookeeper1.jpg)\n\n#### (2)集群管理 \n##### 应用集群中，我们常常需要让每一个机器知道集群中（或依赖的其他某一个集群）哪些机器是活着的，并且在集群机器因为宕机，网络断链等原因能够不在人工介入的情况下迅速通知到每一个机器。\n##### Zookeeper同样很容易实现这个功能，比如我在zookeeper服务器端有一个znode叫/APP1SERVERS,那么集群中每一个机器启动的时候都去这个节点下创建一个EPHEMERAL类型的节点，比如server1创建/APP1SERVERS/SERVER1(可以使用ip,保证不重复)，server2创建/APP1SERVERS/SERVER2，然后SERVER1和SERVER2都watch /APP1SERVERS这个父节点，那么也就是这个父节点下数据或者子节点变化都会通知对该节点进行watch的客户端。因为EPHEMERAL类型节点有一个很重要的特性，就是客户端和服务器端连接断掉或者session过期就会使节点消失，那么在某一个机器挂掉或者断链的时候，其对应的节点就会消失，然后集群中所有对/APP1SERVERS进行watch的客户端都会收到通知，然后取得最新列表即可。\n##### 另外有一个应用场景就是集群选master,一旦master挂掉能够马上能从slave中选出一个master,实现步骤和前者一样，只是机器在启动的时候在APP1SERVERS创建的节点类型变为EPHEMERAL_SEQUENTIAL类型，这样每个节点会自动被编号\n##### 我们默认规定编号最小的为master,所以当我们对/APP1SERVERS节点做监控的时候，得到服务器列表，只要所有集群机器逻辑认为最小编号节点为master，那么master就被选出，而这个master宕机的时候，相应的znode会消失，然后新的服务器列表就被推送到客户端，然后每个节点逻辑认为最小编号节点为master，这样就做到动态master选举。\n![zookeeper流程图](../../img/zookeeper/zookeeper2.jpg)\n\n#### Zookeeper 监视（Watches） 简介\n##### Zookeeper C API 的声明和描述在 include/zookeeper.h 中可以找到，另外大部分的 Zookeeper C API 常量、结构体声明也在 zookeeper.h 中，如果如果你在使用 C API 是遇到不明白的地方，最好看看 zookeeper.h，或者自己使用 doxygen 生成 Zookeeper C API 的帮助文档。\n##### Zookeeper 中最有特色且最不容易理解的是监视(Watches)。Zookeeper 所有的读操作——getData(), getChildren(), 和 exists() 都 可以设置监视(watch)，监视事件可以理解为一次性的触发器， 官方定义如下： a watch event is one-time trigger, sent to the client that set the watch, which occurs when the data for which the watch was set changes。对此需要作出如下理解：\n* （一次性触发）One-time trigger\n\n##### 当设置监视的数据发生改变时，该监视事件会被发送到客户端，例如，如果客户端调用了 getData(\"/znode1\", true) 并且稍后 /znode1 节点上的数据发生了改变或者被删除了，客户端将会获取到 /znode1 发生变化的监视事件，而如果 /znode1 再一次发生了变化，除非客户端再次对 /znode1 设置监视，否则客户端不会收到事件通知。\n* （发送至客户端）Sent to the client\n\n##### Zookeeper 客户端和服务端是通过 socket 进行通信的，由于网络存在故障，所以监视事件很有可能不会成功地到达客户端，监视事件是异步发送至监视者的，Zookeeper 本身提供了保序性(ordering guarantee)：即客户端只有首先看到了监视事件后，才会感知到它所设置监视的 znode 发生了变化(a client will never see a change for which it has set a watch until it first sees the watch event). 网络延迟或者其他因素可能导致不同的客户端在不同的时刻感知某一监视事件，但是不同的客户端所看到的一切具有一致的顺序。\n* （被设置 watch 的数据）The data for which the watch was set\n\n##### 这意味着 znode 节点本身具有不同的改变方式。你也可以想象 Zookeeper 维护了两条监视链表：数据监视和子节点监视(data watches and child watches) getData() and exists() 设置数据监视，getChildren() 设置子节点监视。 或者，你也可以想象 Zookeeper 设置的不同监视返回不同的数据，getData() 和 exists() 返回 znode 节点的相关信息，而 getChildren() 返回子节点列表。因此， setData() 会触发设置在某一节点上所设置的数据监视(假定数据设置成功)，而一次成功的 create() 操作则会出发当前节点上所设置的数据监视以及父节点的子节点监视。一次成功的 delete() 操作将会触发当前节点的数据监视和子节点监视事件，同时也会触发该节点父节点的child watch。\n##### Zookeeper 中的监视是轻量级的，因此容易设置、维护和分发。当客户端与 Zookeeper 服务器端失去联系时，客户端并不会收到监视事件的通知，只有当客户端重新连接后，若在必要的情况下，以前注册的监视会重新被注册并触发，对于开发人员来说 这通常是透明的。只有一种情况会导致监视事件的丢失，即：通过 exists() 设置了某个 znode 节点的监视，但是如果某个客户端在此 znode 节点被创建和删除的时间间隔内与 zookeeper 服务器失去了联系，该客户端即使稍后重新连接 zookeeper服务器后也得不到事件通知。\n\n### Zookeeper C API 常量与部分结构(struct)介绍\n\n#### 与 ACL 相关的结构与常量：\n##### struct Id 结构为：\n```\nstruct Id {     char * scheme;     char * id; };\n```\n##### struct ACL 结构为：\n```\nstruct ACL {     int32_t perms;     struct Id id; };\n```\n##### struct ACL_vector 结构为：\n```\nstruct ACL_vector {     int32_t count;     struct ACL *data; };\n```\n##### 与 znode 访问权限有关的常量\n* const int ZOO_PERM_READ; //允许客户端读取 znode 节点的值以及子节点列表。\n* const int ZOO_PERM_WRITE;// 允许客户端设置 znode 节点的值。\n* const int ZOO_PERM_CREATE; //允许客户端在该 znode 节点下创建子节点。\n* const int ZOO_PERM_DELETE;//允许客户端删除子节点。\n* const int ZOO_PERM_ADMIN; //允许客户端执行 set_acl()。\n* const int ZOO_PERM_ALL;//允许客户端执行所有操作，等价与上述所有标志的或(OR) 。\n\n##### 与 ACL IDs 相关的常量\n* struct Id ZOO_ANYONE_ID_UNSAFE; //(‘world’,’anyone’)\n* struct Id ZOO_AUTH_IDS;// (‘auth’,’’)\n\n##### 三种标准的 ACL\n* struct ACL_vector ZOO_OPEN_ACL_UNSAFE; //(ZOO_PERM_ALL,ZOO_ANYONE_ID_UNSAFE)\n* struct ACL_vector ZOO_READ_ACL_UNSAFE;// (ZOO_PERM_READ, ZOO_ANYONE_ID_UNSAFE)\n* struct ACL_vector ZOO_CREATOR_ALL_ACL; //(ZOO_PERM_ALL,ZOO_AUTH_IDS)\n\n#### 与 Interest 相关的常量：ZOOKEEPER_WRITE, ZOOKEEPER_READ\n##### 这两个常量用于标识感兴趣的事件并通知zookeeper发生了哪些事件。Interest 常量可以进行组合或（OR）来标识多种兴趣(multiple interests: write, read)，这两个常量一般用于 zookeeper_interest() 和 zookeeper_process()两个函数中。\n\n#### 与节点创建相关的常量：ZOO_EPHEMERAL, ZOO_SEQUENCE\n##### zoo_create 函数标志，ZOO_EPHEMERAL 用来标识创建临时节点，ZOO_SEQUENCE 用来标识节点命名具有递增的后缀序号(一般是节点名称后填充 10 位字符的序号，如 /xyz0000000000, /xyz0000000001, /xyz0000000002, ...)，同样地，ZOO_EPHEMERAL, ZOO_SEQUENCE 可以组合。\n\n#### 与连接状态 Stat 相关的常量\n\n##### 以下常量均与 Zookeeper 连接状态有关，他们通常用作监视器回调函数的参数。\n\n| ZOOAPI const int | ZOO_EXPIRED_SESSION_STATE |\n|:-----------------|:--------------------------|\n| ZOOAPI const int |     ZOO_AUTH_FAILED_STATE |\n| ZOOAPI const int |      ZOO_CONNECTING_STATE |\n| ZOOAPI const int |     ZOO_ASSOCIATING_STATE |\n| ZOOAPI const int |       ZOO_CONNECTED_STATE |\n\n#### 与监视类型(Watch Types)相关的常量\n\n##### 以下常量标识监视事件的类型，他们通常用作监视器回调函数的第一个参数。\n* ZOO_CREATED_EVENT; // 节点被创建(此前该节点不存在)，通过 zoo_exists() 设置监视。\n* ZOO_DELETED_EVENT; // 节点被删除，通过 zoo_exists() 和 zoo_get() 设置监视。\n* ZOO_CHANGED_EVENT; // 节点发生变化，通过 zoo_exists() 和 zoo_get() 设置监视。\n* ZOO_CHILD_EVENT; // 子节点事件，通过zoo_get_children() 和 zoo_get_children2()设置监视。\n* ZOO_SESSION_EVENT; // 会话丢失\n* ZOO_NOTWATCHING_EVENT; // 监视被移除。\n\n#### Zookeeper C API 错误码介绍 ZOO_ERRORS\n\nZOK | 正常返回\n----|--------\nZSYSTEMERROR | 系统或服务器端错误(System and server-side errors)，服务器不会抛出该错误，该错误也只是用来标识错误范围的，即大于该错误值，且小于 ZAPIERROR 都是系统错误。\nZRUNTIMEINCONSISTENCY | 运行时非一致性错误。\nZDATAINCONSISTENCY | 数据非一致性错误。\nZCONNECTIONLOSS | Zookeeper 客户端与服务器端失去连接\nZMARSHALLINGERROR | 在 marshalling 和 unmarshalling 数据时出现错误(Error while marshalling or unmarshalling data)\nZUNIMPLEMENTED | 该操作未实现(Operation is unimplemented)\nZOPERATIONTIMEOUT | 该操作超时(Operation timeout)\nZBADARGUMENTS | 非法参数错误(Invalid arguments)\nZINVALIDSTATE | 非法句柄状态(Invliad zhandle state)\nZAPIERROR | API 错误(API errors)，服务器不会抛出该错误，该错误也只是用来标识错误范围的，错误值大于该值的标识 API 错误，而小于该值的标识 ZSYSTEMERROR。\nZNONODE | 节点不存在(Node does not exist)\nZNOAUTH | 没有经过授权(Not authenticated)\nZBADVERSION | 版本冲突(Version conflict)\nZNOCHILDRENFOREPHEMERALS | 临时节点不能拥有子节点(Ephemeral nodes may not have children)\nZNODEEXISTS | 节点已经存在(The node already exists)\nZNOTEMPTY | 该节点具有自身的子节点(The node has children)\nZSESSIONEXPIRED | 会话过期(The session has been expired by the server)\nZINVALIDCALLBACK | 非法的回调函数(Invalid callback specified)\nZINVALIDACL | 非法的ACL(Invalid ACL specified)\nZAUTHFAILED | 客户端授权失败(Client authentication failed)\nZCLOSING | Zookeeper 连接关闭(ZooKeeper is closing)\nZNOTHING | 并非错误，客户端不需要处理服务器的响应(not error, no server responses to process)\nZSESSIONMOVED | 会话转移至其他服务器，所以操作被忽略(session moved to another server, so operation is ignored) \n\n##### Watch事件类型：\n* ZOO_CREATED_EVENT：节点创建事件，需要watch一个不存在的节点，当节点被创建时触发，此watch通过zoo_exists()设置\n* ZOO_DELETED_EVENT：节点删除事件，此watch通过zoo_exists()或zoo_get()设置\n* ZOO_CHANGED_EVENT：节点数据改变事件，此watch通过zoo_exists()或zoo_get()设置\n* ZOO_CHILD_EVENT：子节点列表改变事件，此watch通过zoo_get_children()或zoo_get_children2()设置\n* ZOO_SESSION_EVENT：会话失效事件，客户端与服务端断开或重连时触发\n* ZOO_NOTWATCHING_EVENT：watch移除事件，服务端出于某些原因不再为客户端watch节点时触发","slug":"note/zookeeper","published":1,"updated":"2017-01-06T09:54:43.000Z","comments":1,"photos":[],"link":"","_id":"cizbemkmb0008sebfsl5he4da","content":"<h5 id=\"ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，它包含一个简单的原语集，分布式应用程序可以基于它实现同步服务，配置维护和命名服务等。Zookeeper是hadoop的一个子项目，其发展历程无需赘述。在分布式应用中，由于工程师不能很好地使用锁机制，以及基于消息的协调机制不适合在某些应用中使用，因此需要有一种可靠的、可扩展的、分布式的、可配置的协调机制来统一系统的状态。Zookeeper的目的就在于此。本文简单分析zookeeper的工作原理，对于如何使用zookeeper不是本文讨论的重点。\"><a href=\"#ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，它包含一个简单的原语集，分布式应用程序可以基于它实现同步服务，配置维护和命名服务等。Zookeeper是hadoop的一个子项目，其发展历程无需赘述。在分布式应用中，由于工程师不能很好地使用锁机制，以及基于消息的协调机制不适合在某些应用中使用，因此需要有一种可靠的、可扩展的、分布式的、可配置的协调机制来统一系统的状态。Zookeeper的目的就在于此。本文简单分析zookeeper的工作原理，对于如何使用zookeeper不是本文讨论的重点。\" class=\"headerlink\" title=\"ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，它包含一个简单的原语集，分布式应用程序可以基于它实现同步服务，配置维护和命名服务等。Zookeeper是hadoop的一个子项目，其发展历程无需赘述。在分布式应用中，由于工程师不能很好地使用锁机制，以及基于消息的协调机制不适合在某些应用中使用，因此需要有一种可靠的、可扩展的、分布式的、可配置的协调机制来统一系统的状态。Zookeeper的目的就在于此。本文简单分析zookeeper的工作原理，对于如何使用zookeeper不是本文讨论的重点。\"></a>ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，它包含一个简单的原语集，分布式应用程序可以基于它实现同步服务，配置维护和命名服务等。Zookeeper是hadoop的一个子项目，其发展历程无需赘述。在分布式应用中，由于工程师不能很好地使用锁机制，以及基于消息的协调机制不适合在某些应用中使用，因此需要有一种可靠的、可扩展的、分布式的、可配置的协调机制来统一系统的状态。Zookeeper的目的就在于此。本文简单分析zookeeper的工作原理，对于如何使用zookeeper不是本文讨论的重点。</h5><a id=\"more\"></a>\n<h2 id=\"1-Zookeeper的基本概念\"><a href=\"#1-Zookeeper的基本概念\" class=\"headerlink\" title=\"1 Zookeeper的基本概念\"></a>1 Zookeeper的基本概念</h2><h3 id=\"1-1-角色\"><a href=\"#1-1-角色\" class=\"headerlink\" title=\"1.1 角色\"></a>1.1 角色</h3><h5 id=\"Zookeeper中的角色主要有以下三类，如下表所示：\"><a href=\"#Zookeeper中的角色主要有以下三类，如下表所示：\" class=\"headerlink\" title=\"Zookeeper中的角色主要有以下三类，如下表所示：\"></a>Zookeeper中的角色主要有以下三类，如下表所示：</h5><p><img src=\"../../img/zookeeper/role.jpg\" alt=\"zookeeper角色\"></p>\n<h5 id=\"系统模型如图所示：\"><a href=\"#系统模型如图所示：\" class=\"headerlink\" title=\"系统模型如图所示：\"></a>系统模型如图所示：</h5><p><img src=\"../../img/zookeeper/zookeeperModel.jpg\" alt=\"zookeeper系统模型\"></p>\n<h3 id=\"1-2-设计目的\"><a href=\"#1-2-设计目的\" class=\"headerlink\" title=\"1.2 设计目的\"></a>1.2 设计目的</h3><ol>\n<li>最终一致性：client不论连接到哪个Server，展示给它都是同一个视图，这是zookeeper最重要的性能。</li>\n<li>可靠性：具有简单、健壮、良好的性能，如果消息m被到一台服务器接受，那么它将被所有的服务器接受。</li>\n<li>实时性：Zookeeper保证客户端将在一个时间间隔范围内获得服务器的更新信息，或者服务器失效的信息。但由于网络延时等原因，Zookeeper不能保证两个客户端能同时得到刚更新的数据，如果需要最新数据，应该在读数据之前调用sync()接口。</li>\n<li>等待无关（wait-free）：慢的或者失效的client不得干预快速的client的请求，使得每个client都能有效的等待。</li>\n<li>原子性：更新只能成功或者失败，没有中间状态。</li>\n<li>顺序性：包括全局有序和偏序两种：全局有序是指如果在一台服务器上消息a在消息b前发布，则在所有Server上消息a都将在消息b前被发布；偏序是指如果一个消息b在消息a后被同一个发送者发布，a必将排在b前面。</li>\n</ol>\n<h2 id=\"2-ZooKeeper的工作原理\"><a href=\"#2-ZooKeeper的工作原理\" class=\"headerlink\" title=\"2 ZooKeeper的工作原理\"></a>2 ZooKeeper的工作原理</h2><h5 id=\"Zookeeper的核心是原子广播，这个机制保证了各个Server之间的同步。实现这个机制的协议叫做Zab协议。Zab协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数Server完成了和leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和Server具有相同的系统状态。\"><a href=\"#Zookeeper的核心是原子广播，这个机制保证了各个Server之间的同步。实现这个机制的协议叫做Zab协议。Zab协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数Server完成了和leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和Server具有相同的系统状态。\" class=\"headerlink\" title=\"Zookeeper的核心是原子广播，这个机制保证了各个Server之间的同步。实现这个机制的协议叫做Zab协议。Zab协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数Server完成了和leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和Server具有相同的系统状态。\"></a>Zookeeper的核心是原子广播，这个机制保证了各个Server之间的同步。实现这个机制的协议叫做Zab协议。Zab协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数Server完成了和leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和Server具有相同的系统状态。</h5><h5 id=\"为了保证事务的顺序一致性，zookeeper采用了递增的事务id号（zxid）来标识事务。所有的提议（proposal）都在被提出的时候加上了zxid。实现中zxid是一个64位的数字，它高32位是epoch用来标识leader关系是否改变，每次一个leader被选出来，它都会有一个新的epoch，标识当前属于那个leader的统治时期。低32位用于递增计数。\"><a href=\"#为了保证事务的顺序一致性，zookeeper采用了递增的事务id号（zxid）来标识事务。所有的提议（proposal）都在被提出的时候加上了zxid。实现中zxid是一个64位的数字，它高32位是epoch用来标识leader关系是否改变，每次一个leader被选出来，它都会有一个新的epoch，标识当前属于那个leader的统治时期。低32位用于递增计数。\" class=\"headerlink\" title=\"为了保证事务的顺序一致性，zookeeper采用了递增的事务id号（zxid）来标识事务。所有的提议（proposal）都在被提出的时候加上了zxid。实现中zxid是一个64位的数字，它高32位是epoch用来标识leader关系是否改变，每次一个leader被选出来，它都会有一个新的epoch，标识当前属于那个leader的统治时期。低32位用于递增计数。\"></a>为了保证事务的顺序一致性，zookeeper采用了递增的事务id号（zxid）来标识事务。所有的提议（proposal）都在被提出的时候加上了zxid。实现中zxid是一个64位的数字，它高32位是epoch用来标识leader关系是否改变，每次一个leader被选出来，它都会有一个新的epoch，标识当前属于那个leader的统治时期。低32位用于递增计数。</h5><h5 id=\"每个Server在工作过程中有三种状态：\"><a href=\"#每个Server在工作过程中有三种状态：\" class=\"headerlink\" title=\"每个Server在工作过程中有三种状态：\"></a>每个Server在工作过程中有三种状态：</h5><ul>\n<li>LOOKING：当前Server不知道leader是谁，正在搜寻</li>\n<li>LEADING：当前Server即为选举出来的leader</li>\n<li>FOLLOWING：leader已经选举出来，当前Server与之同步</li>\n</ul>\n<h3 id=\"2-1-选主流程\"><a href=\"#2-1-选主流程\" class=\"headerlink\" title=\"2.1 选主流程\"></a>2.1 选主流程</h3><h5 id=\"当leader崩溃或者leader失去大多数的follower，这时候zk进入恢复模式，恢复模式需要重新选举出一个新的leader，让所有的Server都恢复到一个正确的状态。Zk的选举算法有两种：一种是基于basic-paxos实现的，另外一种是基于fast-paxos算法实现的。系统默认的选举算法为fast-paxos。先介绍basic-paxos流程：\"><a href=\"#当leader崩溃或者leader失去大多数的follower，这时候zk进入恢复模式，恢复模式需要重新选举出一个新的leader，让所有的Server都恢复到一个正确的状态。Zk的选举算法有两种：一种是基于basic-paxos实现的，另外一种是基于fast-paxos算法实现的。系统默认的选举算法为fast-paxos。先介绍basic-paxos流程：\" class=\"headerlink\" title=\"当leader崩溃或者leader失去大多数的follower，这时候zk进入恢复模式，恢复模式需要重新选举出一个新的leader，让所有的Server都恢复到一个正确的状态。Zk的选举算法有两种：一种是基于basic paxos实现的，另外一种是基于fast paxos算法实现的。系统默认的选举算法为fast paxos。先介绍basic paxos流程：\"></a>当leader崩溃或者leader失去大多数的follower，这时候zk进入恢复模式，恢复模式需要重新选举出一个新的leader，让所有的Server都恢复到一个正确的状态。Zk的选举算法有两种：一种是基于basic paxos实现的，另外一种是基于fast paxos算法实现的。系统默认的选举算法为fast paxos。先介绍basic paxos流程：</h5><ol>\n<li>选举线程由当前Server发起选举的线程担任，其主要功能是对投票结果进行统计，并选出推荐的Server；</li>\n<li>选举线程首先向所有Server发起一次询问(包括自己)；</li>\n<li>选举线程收到回复后，验证是否是自己发起的询问(验证zxid是否一致)，然后获取对方的id(myid)，并存储到当前询问对象列表中，最后获取对方提议的leader相关信息(id,zxid)，并将这些信息存储到当次选举的投票记录表中；</li>\n<li>收到所有Server回复以后，就计算出zxid最大的那个Server，并将这个Server相关信息设置成下一次要投票的Server；</li>\n<li>线程将当前zxid最大的Server设置为当前Server要推荐的Leader，如果此时获胜的Server获得n/2 + 1的Server票数， 设置当前推荐的leader为获胜的Server，将根据获胜的Server相关信息设置自己的状态，否则，继续这个过程，直到leader被选举出来。</li>\n</ol>\n<h5 id=\"通过流程分析我们可以得出：要使Leader获得多数Server的支持，则Server总数必须是奇数2n-1，且存活的Server的数目不得少于n-1\"><a href=\"#通过流程分析我们可以得出：要使Leader获得多数Server的支持，则Server总数必须是奇数2n-1，且存活的Server的数目不得少于n-1\" class=\"headerlink\" title=\"通过流程分析我们可以得出：要使Leader获得多数Server的支持，则Server总数必须是奇数2n+1，且存活的Server的数目不得少于n+1.\"></a>通过流程分析我们可以得出：要使Leader获得多数Server的支持，则Server总数必须是奇数2n+1，且存活的Server的数目不得少于n+1.</h5><h5 id=\"每个Server启动后都会重复以上流程。在恢复模式下，如果是刚从崩溃状态恢复的或者刚启动的server还会从磁盘快照中恢复数据和会话信息，zk会记录事务日志并定期进行快照，方便在恢复时进行状态恢复。选主的具体流程图如下所示：\"><a href=\"#每个Server启动后都会重复以上流程。在恢复模式下，如果是刚从崩溃状态恢复的或者刚启动的server还会从磁盘快照中恢复数据和会话信息，zk会记录事务日志并定期进行快照，方便在恢复时进行状态恢复。选主的具体流程图如下所示：\" class=\"headerlink\" title=\"每个Server启动后都会重复以上流程。在恢复模式下，如果是刚从崩溃状态恢复的或者刚启动的server还会从磁盘快照中恢复数据和会话信息，zk会记录事务日志并定期进行快照，方便在恢复时进行状态恢复。选主的具体流程图如下所示：\"></a>每个Server启动后都会重复以上流程。在恢复模式下，如果是刚从崩溃状态恢复的或者刚启动的server还会从磁盘快照中恢复数据和会话信息，zk会记录事务日志并定期进行快照，方便在恢复时进行状态恢复。选主的具体流程图如下所示：</h5><p><img src=\"../../img/zookeeper/zookeeperLc.jpg\" alt=\"zookeeper流程图\"></p>\n<h5 id=\"fast-paxos流程是在选举过程中，某Server首先向所有Server提议自己要成为leader，当其它Server收到提议以后，解决epoch和zxid的冲突，并接受对方的提议，然后向对方发送接受提议完成的消息，重复这个流程，最后一定能选举出Leader。其流程图如下所示：\"><a href=\"#fast-paxos流程是在选举过程中，某Server首先向所有Server提议自己要成为leader，当其它Server收到提议以后，解决epoch和zxid的冲突，并接受对方的提议，然后向对方发送接受提议完成的消息，重复这个流程，最后一定能选举出Leader。其流程图如下所示：\" class=\"headerlink\" title=\"fast paxos流程是在选举过程中，某Server首先向所有Server提议自己要成为leader，当其它Server收到提议以后，解决epoch和zxid的冲突，并接受对方的提议，然后向对方发送接受提议完成的消息，重复这个流程，最后一定能选举出Leader。其流程图如下所示：\"></a>fast paxos流程是在选举过程中，某Server首先向所有Server提议自己要成为leader，当其它Server收到提议以后，解决epoch和zxid的冲突，并接受对方的提议，然后向对方发送接受提议完成的消息，重复这个流程，最后一定能选举出Leader。其流程图如下所示：</h5><p><img src=\"../../img/zookeeper/zookeeperLc2.jpg\" alt=\"zookeeper流程图\"></p>\n<h3 id=\"2-2-同步流程\"><a href=\"#2-2-同步流程\" class=\"headerlink\" title=\"2.2 同步流程\"></a>2.2 同步流程</h3><h5 id=\"选完leader以后，zk就进入状态同步过程。\"><a href=\"#选完leader以后，zk就进入状态同步过程。\" class=\"headerlink\" title=\"选完leader以后，zk就进入状态同步过程。\"></a>选完leader以后，zk就进入状态同步过程。</h5><ol>\n<li>leader等待server连接；</li>\n<li>Follower连接leader，将最大的zxid发送给leader；</li>\n<li>Leader根据follower的zxid确定同步点；</li>\n<li>完成同步后通知follower 已经成为uptodate状态；</li>\n<li>Follower收到uptodate消息后，又可以重新接受client的请求进行服务了。</li>\n</ol>\n<h5 id=\"流程图如下所示：\"><a href=\"#流程图如下所示：\" class=\"headerlink\" title=\"流程图如下所示：\"></a>流程图如下所示：</h5><p><img src=\"../../img/zookeeper/zookeeperLc3.jpg\" alt=\"zookeeper流程图\"></p>\n<h3 id=\"2-3-工作流程\"><a href=\"#2-3-工作流程\" class=\"headerlink\" title=\"2.3 工作流程\"></a>2.3 工作流程</h3><h4 id=\"2-3-1-Leader工作流程\"><a href=\"#2-3-1-Leader工作流程\" class=\"headerlink\" title=\"2.3.1 Leader工作流程\"></a>2.3.1 Leader工作流程</h4><h5 id=\"Leader主要有三个功能：\"><a href=\"#Leader主要有三个功能：\" class=\"headerlink\" title=\"Leader主要有三个功能：\"></a>Leader主要有三个功能：</h5><ol>\n<li>恢复数据；</li>\n<li>维持与Learner的心跳，接收Learner请求并判断Learner的请求消息类型；</li>\n<li>Learner的消息类型主要有PING消息、REQUEST消息、ACK消息、REVALIDATE消息，根据不同的消息类型，进行不同的处理。</li>\n</ol>\n<h5 id=\"PING消息是指Learner的心跳信息；REQUEST消息是Follower发送的提议信息，包括写请求及同步请求；ACK消息是Follower的对提议的回复，超过半数的Follower通过，则commit该提议；REVALIDATE消息是用来延长SESSION有效时间。\"><a href=\"#PING消息是指Learner的心跳信息；REQUEST消息是Follower发送的提议信息，包括写请求及同步请求；ACK消息是Follower的对提议的回复，超过半数的Follower通过，则commit该提议；REVALIDATE消息是用来延长SESSION有效时间。\" class=\"headerlink\" title=\"PING消息是指Learner的心跳信息；REQUEST消息是Follower发送的提议信息，包括写请求及同步请求；ACK消息是Follower的对提议的回复，超过半数的Follower通过，则commit该提议；REVALIDATE消息是用来延长SESSION有效时间。\"></a>PING消息是指Learner的心跳信息；REQUEST消息是Follower发送的提议信息，包括写请求及同步请求；ACK消息是Follower的对提议的回复，超过半数的Follower通过，则commit该提议；REVALIDATE消息是用来延长SESSION有效时间。</h5><h5 id=\"Leader的工作流程简图如下所示，在实际实现中，流程要比下图复杂得多，启动了三个线程来实现功能。\"><a href=\"#Leader的工作流程简图如下所示，在实际实现中，流程要比下图复杂得多，启动了三个线程来实现功能。\" class=\"headerlink\" title=\"Leader的工作流程简图如下所示，在实际实现中，流程要比下图复杂得多，启动了三个线程来实现功能。\"></a>Leader的工作流程简图如下所示，在实际实现中，流程要比下图复杂得多，启动了三个线程来实现功能。</h5><p><img src=\"../../img/zookeeper/zookeeperLc4.jpg\" alt=\"zookeeper流程图\"></p>\n<h4 id=\"2-3-2-Follower工作流程\"><a href=\"#2-3-2-Follower工作流程\" class=\"headerlink\" title=\"2.3.2 Follower工作流程\"></a>2.3.2 Follower工作流程</h4><h5 id=\"Follower主要有四个功能：\"><a href=\"#Follower主要有四个功能：\" class=\"headerlink\" title=\"Follower主要有四个功能：\"></a>Follower主要有四个功能：</h5><ol>\n<li>向Leader发送请求（PING消息、REQUEST消息、ACK消息、REVALIDATE消息）；</li>\n<li>接收Leader消息并进行处理；</li>\n<li>接收Client的请求，如果为写请求，发送给Leader进行投票；</li>\n<li>返回Client结果。</li>\n</ol>\n<h5 id=\"Follower的消息循环处理如下几种来自Leader的消息：\"><a href=\"#Follower的消息循环处理如下几种来自Leader的消息：\" class=\"headerlink\" title=\"Follower的消息循环处理如下几种来自Leader的消息：\"></a>Follower的消息循环处理如下几种来自Leader的消息：</h5><ol>\n<li>PING消息： 心跳消息；</li>\n<li>PROPOSAL消息：Leader发起的提案，要求Follower投票；</li>\n<li>COMMIT消息：服务器端最新一次提案的信息；</li>\n<li>UPTODATE消息：表明同步完成；</li>\n<li>REVALIDATE消息：根据Leader的REVALIDATE结果，关闭待revalidate的session还是允许其接受消息；</li>\n<li>SYNC消息：返回SYNC结果到客户端，这个消息最初由客户端发起，用来强制得到最新的更新。</li>\n</ol>\n<h5 id=\"Follower的工作流程简图如下所示，在实际实现中，Follower是通过5个线程来实现功能的。\"><a href=\"#Follower的工作流程简图如下所示，在实际实现中，Follower是通过5个线程来实现功能的。\" class=\"headerlink\" title=\"Follower的工作流程简图如下所示，在实际实现中，Follower是通过5个线程来实现功能的。\"></a>Follower的工作流程简图如下所示，在实际实现中，Follower是通过5个线程来实现功能的。</h5><p><img src=\"../../img/zookeeper/zookeeperLc5.jpg\" alt=\"zookeeper流程图\"></p>\n<h5 id=\"对于observer的流程不再叙述，observer流程和Follower的唯一不同的地方就是observer不会参加leader发起的投票。\"><a href=\"#对于observer的流程不再叙述，observer流程和Follower的唯一不同的地方就是observer不会参加leader发起的投票。\" class=\"headerlink\" title=\"对于observer的流程不再叙述，observer流程和Follower的唯一不同的地方就是observer不会参加leader发起的投票。\"></a>对于observer的流程不再叙述，observer流程和Follower的唯一不同的地方就是observer不会参加leader发起的投票。</h5><h5 id=\"主流应用场景：\"><a href=\"#主流应用场景：\" class=\"headerlink\" title=\"主流应用场景：\"></a>主流应用场景：</h5><h5 id=\"Zookeeper的主流应用场景实现思路（除去官方示例）\"><a href=\"#Zookeeper的主流应用场景实现思路（除去官方示例）\" class=\"headerlink\" title=\"Zookeeper的主流应用场景实现思路（除去官方示例）\"></a><strong>Zookeeper的主流应用场景实现思路（除去官方示例）</strong></h5><h4 id=\"1-配置管理\"><a href=\"#1-配置管理\" class=\"headerlink\" title=\"(1)配置管理\"></a>(1)配置管理</h4><h5 id=\"集中式的配置管理在应用集群中是非常常见的，一般商业公司内部都会实现一套集中的配置管理中心，应对不同的应用集群对于共享各自配置的需求，并且在配置变更时能够通知到集群中的每一个机器。\"><a href=\"#集中式的配置管理在应用集群中是非常常见的，一般商业公司内部都会实现一套集中的配置管理中心，应对不同的应用集群对于共享各自配置的需求，并且在配置变更时能够通知到集群中的每一个机器。\" class=\"headerlink\" title=\"集中式的配置管理在应用集群中是非常常见的，一般商业公司内部都会实现一套集中的配置管理中心，应对不同的应用集群对于共享各自配置的需求，并且在配置变更时能够通知到集群中的每一个机器。\"></a>集中式的配置管理在应用集群中是非常常见的，一般商业公司内部都会实现一套集中的配置管理中心，应对不同的应用集群对于共享各自配置的需求，并且在配置变更时能够通知到集群中的每一个机器。</h5><h5 id=\"Zookeeper很容易实现这种集中式的配置管理，比如将APP1的所有配置配置到-APP1-znode下，APP1所有机器一启动就对-APP1这个节点进行监控-zk-exist-“-APP1”-true-并且实现回调方法Watcher，那么在zookeeper上-APP1-znode节点下数据发生变化的时候，每个机器都会收到通知，Watcher方法将会被执行，那么应用再取下数据即可-zk-getData-“-APP1”-false-null\"><a href=\"#Zookeeper很容易实现这种集中式的配置管理，比如将APP1的所有配置配置到-APP1-znode下，APP1所有机器一启动就对-APP1这个节点进行监控-zk-exist-“-APP1”-true-并且实现回调方法Watcher，那么在zookeeper上-APP1-znode节点下数据发生变化的时候，每个机器都会收到通知，Watcher方法将会被执行，那么应用再取下数据即可-zk-getData-“-APP1”-false-null\" class=\"headerlink\" title=\"Zookeeper很容易实现这种集中式的配置管理，比如将APP1的所有配置配置到/APP1 znode下，APP1所有机器一启动就对/APP1这个节点进行监控(zk.exist(“/APP1”,true)),并且实现回调方法Watcher，那么在zookeeper上/APP1 znode节点下数据发生变化的时候，每个机器都会收到通知，Watcher方法将会被执行，那么应用再取下数据即可(zk.getData(“/APP1”,false,null));\"></a>Zookeeper很容易实现这种集中式的配置管理，比如将APP1的所有配置配置到/APP1 znode下，APP1所有机器一启动就对/APP1这个节点进行监控(zk.exist(“/APP1”,true)),并且实现回调方法Watcher，那么在zookeeper上/APP1 znode节点下数据发生变化的时候，每个机器都会收到通知，Watcher方法将会被执行，那么应用再取下数据即可(zk.getData(“/APP1”,false,null));</h5><h5 id=\"以上这个例子只是简单的粗颗粒度配置监控，细颗粒度的数据可以进行分层级监控，这一切都是可以设计和控制的。\"><a href=\"#以上这个例子只是简单的粗颗粒度配置监控，细颗粒度的数据可以进行分层级监控，这一切都是可以设计和控制的。\" class=\"headerlink\" title=\"以上这个例子只是简单的粗颗粒度配置监控，细颗粒度的数据可以进行分层级监控，这一切都是可以设计和控制的。\"></a>以上这个例子只是简单的粗颗粒度配置监控，细颗粒度的数据可以进行分层级监控，这一切都是可以设计和控制的。</h5><p><img src=\"../../img/zookeeper/zookeeper1.jpg\" alt=\"zookeeper流程图\"></p>\n<h4 id=\"2-集群管理\"><a href=\"#2-集群管理\" class=\"headerlink\" title=\"(2)集群管理\"></a>(2)集群管理</h4><h5 id=\"应用集群中，我们常常需要让每一个机器知道集群中（或依赖的其他某一个集群）哪些机器是活着的，并且在集群机器因为宕机，网络断链等原因能够不在人工介入的情况下迅速通知到每一个机器。\"><a href=\"#应用集群中，我们常常需要让每一个机器知道集群中（或依赖的其他某一个集群）哪些机器是活着的，并且在集群机器因为宕机，网络断链等原因能够不在人工介入的情况下迅速通知到每一个机器。\" class=\"headerlink\" title=\"应用集群中，我们常常需要让每一个机器知道集群中（或依赖的其他某一个集群）哪些机器是活着的，并且在集群机器因为宕机，网络断链等原因能够不在人工介入的情况下迅速通知到每一个机器。\"></a>应用集群中，我们常常需要让每一个机器知道集群中（或依赖的其他某一个集群）哪些机器是活着的，并且在集群机器因为宕机，网络断链等原因能够不在人工介入的情况下迅速通知到每一个机器。</h5><h5 id=\"Zookeeper同样很容易实现这个功能，比如我在zookeeper服务器端有一个znode叫-APP1SERVERS-那么集群中每一个机器启动的时候都去这个节点下创建一个EPHEMERAL类型的节点，比如server1创建-APP1SERVERS-SERVER1-可以使用ip-保证不重复-，server2创建-APP1SERVERS-SERVER2，然后SERVER1和SERVER2都watch-APP1SERVERS这个父节点，那么也就是这个父节点下数据或者子节点变化都会通知对该节点进行watch的客户端。因为EPHEMERAL类型节点有一个很重要的特性，就是客户端和服务器端连接断掉或者session过期就会使节点消失，那么在某一个机器挂掉或者断链的时候，其对应的节点就会消失，然后集群中所有对-APP1SERVERS进行watch的客户端都会收到通知，然后取得最新列表即可。\"><a href=\"#Zookeeper同样很容易实现这个功能，比如我在zookeeper服务器端有一个znode叫-APP1SERVERS-那么集群中每一个机器启动的时候都去这个节点下创建一个EPHEMERAL类型的节点，比如server1创建-APP1SERVERS-SERVER1-可以使用ip-保证不重复-，server2创建-APP1SERVERS-SERVER2，然后SERVER1和SERVER2都watch-APP1SERVERS这个父节点，那么也就是这个父节点下数据或者子节点变化都会通知对该节点进行watch的客户端。因为EPHEMERAL类型节点有一个很重要的特性，就是客户端和服务器端连接断掉或者session过期就会使节点消失，那么在某一个机器挂掉或者断链的时候，其对应的节点就会消失，然后集群中所有对-APP1SERVERS进行watch的客户端都会收到通知，然后取得最新列表即可。\" class=\"headerlink\" title=\"Zookeeper同样很容易实现这个功能，比如我在zookeeper服务器端有一个znode叫/APP1SERVERS,那么集群中每一个机器启动的时候都去这个节点下创建一个EPHEMERAL类型的节点，比如server1创建/APP1SERVERS/SERVER1(可以使用ip,保证不重复)，server2创建/APP1SERVERS/SERVER2，然后SERVER1和SERVER2都watch /APP1SERVERS这个父节点，那么也就是这个父节点下数据或者子节点变化都会通知对该节点进行watch的客户端。因为EPHEMERAL类型节点有一个很重要的特性，就是客户端和服务器端连接断掉或者session过期就会使节点消失，那么在某一个机器挂掉或者断链的时候，其对应的节点就会消失，然后集群中所有对/APP1SERVERS进行watch的客户端都会收到通知，然后取得最新列表即可。\"></a>Zookeeper同样很容易实现这个功能，比如我在zookeeper服务器端有一个znode叫/APP1SERVERS,那么集群中每一个机器启动的时候都去这个节点下创建一个EPHEMERAL类型的节点，比如server1创建/APP1SERVERS/SERVER1(可以使用ip,保证不重复)，server2创建/APP1SERVERS/SERVER2，然后SERVER1和SERVER2都watch /APP1SERVERS这个父节点，那么也就是这个父节点下数据或者子节点变化都会通知对该节点进行watch的客户端。因为EPHEMERAL类型节点有一个很重要的特性，就是客户端和服务器端连接断掉或者session过期就会使节点消失，那么在某一个机器挂掉或者断链的时候，其对应的节点就会消失，然后集群中所有对/APP1SERVERS进行watch的客户端都会收到通知，然后取得最新列表即可。</h5><h5 id=\"另外有一个应用场景就是集群选master-一旦master挂掉能够马上能从slave中选出一个master-实现步骤和前者一样，只是机器在启动的时候在APP1SERVERS创建的节点类型变为EPHEMERAL-SEQUENTIAL类型，这样每个节点会自动被编号\"><a href=\"#另外有一个应用场景就是集群选master-一旦master挂掉能够马上能从slave中选出一个master-实现步骤和前者一样，只是机器在启动的时候在APP1SERVERS创建的节点类型变为EPHEMERAL-SEQUENTIAL类型，这样每个节点会自动被编号\" class=\"headerlink\" title=\"另外有一个应用场景就是集群选master,一旦master挂掉能够马上能从slave中选出一个master,实现步骤和前者一样，只是机器在启动的时候在APP1SERVERS创建的节点类型变为EPHEMERAL_SEQUENTIAL类型，这样每个节点会自动被编号\"></a>另外有一个应用场景就是集群选master,一旦master挂掉能够马上能从slave中选出一个master,实现步骤和前者一样，只是机器在启动的时候在APP1SERVERS创建的节点类型变为EPHEMERAL_SEQUENTIAL类型，这样每个节点会自动被编号</h5><h5 id=\"我们默认规定编号最小的为master-所以当我们对-APP1SERVERS节点做监控的时候，得到服务器列表，只要所有集群机器逻辑认为最小编号节点为master，那么master就被选出，而这个master宕机的时候，相应的znode会消失，然后新的服务器列表就被推送到客户端，然后每个节点逻辑认为最小编号节点为master，这样就做到动态master选举。\"><a href=\"#我们默认规定编号最小的为master-所以当我们对-APP1SERVERS节点做监控的时候，得到服务器列表，只要所有集群机器逻辑认为最小编号节点为master，那么master就被选出，而这个master宕机的时候，相应的znode会消失，然后新的服务器列表就被推送到客户端，然后每个节点逻辑认为最小编号节点为master，这样就做到动态master选举。\" class=\"headerlink\" title=\"我们默认规定编号最小的为master,所以当我们对/APP1SERVERS节点做监控的时候，得到服务器列表，只要所有集群机器逻辑认为最小编号节点为master，那么master就被选出，而这个master宕机的时候，相应的znode会消失，然后新的服务器列表就被推送到客户端，然后每个节点逻辑认为最小编号节点为master，这样就做到动态master选举。\"></a>我们默认规定编号最小的为master,所以当我们对/APP1SERVERS节点做监控的时候，得到服务器列表，只要所有集群机器逻辑认为最小编号节点为master，那么master就被选出，而这个master宕机的时候，相应的znode会消失，然后新的服务器列表就被推送到客户端，然后每个节点逻辑认为最小编号节点为master，这样就做到动态master选举。</h5><p><img src=\"../../img/zookeeper/zookeeper2.jpg\" alt=\"zookeeper流程图\"></p>\n<h4 id=\"Zookeeper-监视（Watches）-简介\"><a href=\"#Zookeeper-监视（Watches）-简介\" class=\"headerlink\" title=\"Zookeeper 监视（Watches） 简介\"></a>Zookeeper 监视（Watches） 简介</h4><h5 id=\"Zookeeper-C-API-的声明和描述在-include-zookeeper-h-中可以找到，另外大部分的-Zookeeper-C-API-常量、结构体声明也在-zookeeper-h-中，如果如果你在使用-C-API-是遇到不明白的地方，最好看看-zookeeper-h，或者自己使用-doxygen-生成-Zookeeper-C-API-的帮助文档。\"><a href=\"#Zookeeper-C-API-的声明和描述在-include-zookeeper-h-中可以找到，另外大部分的-Zookeeper-C-API-常量、结构体声明也在-zookeeper-h-中，如果如果你在使用-C-API-是遇到不明白的地方，最好看看-zookeeper-h，或者自己使用-doxygen-生成-Zookeeper-C-API-的帮助文档。\" class=\"headerlink\" title=\"Zookeeper C API 的声明和描述在 include/zookeeper.h 中可以找到，另外大部分的 Zookeeper C API 常量、结构体声明也在 zookeeper.h 中，如果如果你在使用 C API 是遇到不明白的地方，最好看看 zookeeper.h，或者自己使用 doxygen 生成 Zookeeper C API 的帮助文档。\"></a>Zookeeper C API 的声明和描述在 include/zookeeper.h 中可以找到，另外大部分的 Zookeeper C API 常量、结构体声明也在 zookeeper.h 中，如果如果你在使用 C API 是遇到不明白的地方，最好看看 zookeeper.h，或者自己使用 doxygen 生成 Zookeeper C API 的帮助文档。</h5><h5 id=\"Zookeeper-中最有特色且最不容易理解的是监视-Watches-。Zookeeper-所有的读操作——getData-getChildren-和-exists-都-可以设置监视-watch-，监视事件可以理解为一次性的触发器，-官方定义如下：-a-watch-event-is-one-time-trigger-sent-to-the-client-that-set-the-watch-which-occurs-when-the-data-for-which-the-watch-was-set-changes。对此需要作出如下理解：\"><a href=\"#Zookeeper-中最有特色且最不容易理解的是监视-Watches-。Zookeeper-所有的读操作——getData-getChildren-和-exists-都-可以设置监视-watch-，监视事件可以理解为一次性的触发器，-官方定义如下：-a-watch-event-is-one-time-trigger-sent-to-the-client-that-set-the-watch-which-occurs-when-the-data-for-which-the-watch-was-set-changes。对此需要作出如下理解：\" class=\"headerlink\" title=\"Zookeeper 中最有特色且最不容易理解的是监视(Watches)。Zookeeper 所有的读操作——getData(), getChildren(), 和 exists() 都 可以设置监视(watch)，监视事件可以理解为一次性的触发器， 官方定义如下： a watch event is one-time trigger, sent to the client that set the watch, which occurs when the data for which the watch was set changes。对此需要作出如下理解：\"></a>Zookeeper 中最有特色且最不容易理解的是监视(Watches)。Zookeeper 所有的读操作——getData(), getChildren(), 和 exists() 都 可以设置监视(watch)，监视事件可以理解为一次性的触发器， 官方定义如下： a watch event is one-time trigger, sent to the client that set the watch, which occurs when the data for which the watch was set changes。对此需要作出如下理解：</h5><ul>\n<li>（一次性触发）One-time trigger</li>\n</ul>\n<h5 id=\"当设置监视的数据发生改变时，该监视事件会被发送到客户端，例如，如果客户端调用了-getData-“-znode1”-true-并且稍后-znode1-节点上的数据发生了改变或者被删除了，客户端将会获取到-znode1-发生变化的监视事件，而如果-znode1-再一次发生了变化，除非客户端再次对-znode1-设置监视，否则客户端不会收到事件通知。\"><a href=\"#当设置监视的数据发生改变时，该监视事件会被发送到客户端，例如，如果客户端调用了-getData-“-znode1”-true-并且稍后-znode1-节点上的数据发生了改变或者被删除了，客户端将会获取到-znode1-发生变化的监视事件，而如果-znode1-再一次发生了变化，除非客户端再次对-znode1-设置监视，否则客户端不会收到事件通知。\" class=\"headerlink\" title=\"当设置监视的数据发生改变时，该监视事件会被发送到客户端，例如，如果客户端调用了 getData(“/znode1”, true) 并且稍后 /znode1 节点上的数据发生了改变或者被删除了，客户端将会获取到 /znode1 发生变化的监视事件，而如果 /znode1 再一次发生了变化，除非客户端再次对 /znode1 设置监视，否则客户端不会收到事件通知。\"></a>当设置监视的数据发生改变时，该监视事件会被发送到客户端，例如，如果客户端调用了 getData(“/znode1”, true) 并且稍后 /znode1 节点上的数据发生了改变或者被删除了，客户端将会获取到 /znode1 发生变化的监视事件，而如果 /znode1 再一次发生了变化，除非客户端再次对 /znode1 设置监视，否则客户端不会收到事件通知。</h5><ul>\n<li>（发送至客户端）Sent to the client</li>\n</ul>\n<h5 id=\"Zookeeper-客户端和服务端是通过-socket-进行通信的，由于网络存在故障，所以监视事件很有可能不会成功地到达客户端，监视事件是异步发送至监视者的，Zookeeper-本身提供了保序性-ordering-guarantee-：即客户端只有首先看到了监视事件后，才会感知到它所设置监视的-znode-发生了变化-a-client-will-never-see-a-change-for-which-it-has-set-a-watch-until-it-first-sees-the-watch-event-网络延迟或者其他因素可能导致不同的客户端在不同的时刻感知某一监视事件，但是不同的客户端所看到的一切具有一致的顺序。\"><a href=\"#Zookeeper-客户端和服务端是通过-socket-进行通信的，由于网络存在故障，所以监视事件很有可能不会成功地到达客户端，监视事件是异步发送至监视者的，Zookeeper-本身提供了保序性-ordering-guarantee-：即客户端只有首先看到了监视事件后，才会感知到它所设置监视的-znode-发生了变化-a-client-will-never-see-a-change-for-which-it-has-set-a-watch-until-it-first-sees-the-watch-event-网络延迟或者其他因素可能导致不同的客户端在不同的时刻感知某一监视事件，但是不同的客户端所看到的一切具有一致的顺序。\" class=\"headerlink\" title=\"Zookeeper 客户端和服务端是通过 socket 进行通信的，由于网络存在故障，所以监视事件很有可能不会成功地到达客户端，监视事件是异步发送至监视者的，Zookeeper 本身提供了保序性(ordering guarantee)：即客户端只有首先看到了监视事件后，才会感知到它所设置监视的 znode 发生了变化(a client will never see a change for which it has set a watch until it first sees the watch event). 网络延迟或者其他因素可能导致不同的客户端在不同的时刻感知某一监视事件，但是不同的客户端所看到的一切具有一致的顺序。\"></a>Zookeeper 客户端和服务端是通过 socket 进行通信的，由于网络存在故障，所以监视事件很有可能不会成功地到达客户端，监视事件是异步发送至监视者的，Zookeeper 本身提供了保序性(ordering guarantee)：即客户端只有首先看到了监视事件后，才会感知到它所设置监视的 znode 发生了变化(a client will never see a change for which it has set a watch until it first sees the watch event). 网络延迟或者其他因素可能导致不同的客户端在不同的时刻感知某一监视事件，但是不同的客户端所看到的一切具有一致的顺序。</h5><ul>\n<li>（被设置 watch 的数据）The data for which the watch was set</li>\n</ul>\n<h5 id=\"这意味着-znode-节点本身具有不同的改变方式。你也可以想象-Zookeeper-维护了两条监视链表：数据监视和子节点监视-data-watches-and-child-watches-getData-and-exists-设置数据监视，getChildren-设置子节点监视。-或者，你也可以想象-Zookeeper-设置的不同监视返回不同的数据，getData-和-exists-返回-znode-节点的相关信息，而-getChildren-返回子节点列表。因此，-setData-会触发设置在某一节点上所设置的数据监视-假定数据设置成功-，而一次成功的-create-操作则会出发当前节点上所设置的数据监视以及父节点的子节点监视。一次成功的-delete-操作将会触发当前节点的数据监视和子节点监视事件，同时也会触发该节点父节点的child-watch。\"><a href=\"#这意味着-znode-节点本身具有不同的改变方式。你也可以想象-Zookeeper-维护了两条监视链表：数据监视和子节点监视-data-watches-and-child-watches-getData-and-exists-设置数据监视，getChildren-设置子节点监视。-或者，你也可以想象-Zookeeper-设置的不同监视返回不同的数据，getData-和-exists-返回-znode-节点的相关信息，而-getChildren-返回子节点列表。因此，-setData-会触发设置在某一节点上所设置的数据监视-假定数据设置成功-，而一次成功的-create-操作则会出发当前节点上所设置的数据监视以及父节点的子节点监视。一次成功的-delete-操作将会触发当前节点的数据监视和子节点监视事件，同时也会触发该节点父节点的child-watch。\" class=\"headerlink\" title=\"这意味着 znode 节点本身具有不同的改变方式。你也可以想象 Zookeeper 维护了两条监视链表：数据监视和子节点监视(data watches and child watches) getData() and exists() 设置数据监视，getChildren() 设置子节点监视。 或者，你也可以想象 Zookeeper 设置的不同监视返回不同的数据，getData() 和 exists() 返回 znode 节点的相关信息，而 getChildren() 返回子节点列表。因此， setData() 会触发设置在某一节点上所设置的数据监视(假定数据设置成功)，而一次成功的 create() 操作则会出发当前节点上所设置的数据监视以及父节点的子节点监视。一次成功的 delete() 操作将会触发当前节点的数据监视和子节点监视事件，同时也会触发该节点父节点的child watch。\"></a>这意味着 znode 节点本身具有不同的改变方式。你也可以想象 Zookeeper 维护了两条监视链表：数据监视和子节点监视(data watches and child watches) getData() and exists() 设置数据监视，getChildren() 设置子节点监视。 或者，你也可以想象 Zookeeper 设置的不同监视返回不同的数据，getData() 和 exists() 返回 znode 节点的相关信息，而 getChildren() 返回子节点列表。因此， setData() 会触发设置在某一节点上所设置的数据监视(假定数据设置成功)，而一次成功的 create() 操作则会出发当前节点上所设置的数据监视以及父节点的子节点监视。一次成功的 delete() 操作将会触发当前节点的数据监视和子节点监视事件，同时也会触发该节点父节点的child watch。</h5><h5 id=\"Zookeeper-中的监视是轻量级的，因此容易设置、维护和分发。当客户端与-Zookeeper-服务器端失去联系时，客户端并不会收到监视事件的通知，只有当客户端重新连接后，若在必要的情况下，以前注册的监视会重新被注册并触发，对于开发人员来说-这通常是透明的。只有一种情况会导致监视事件的丢失，即：通过-exists-设置了某个-znode-节点的监视，但是如果某个客户端在此-znode-节点被创建和删除的时间间隔内与-zookeeper-服务器失去了联系，该客户端即使稍后重新连接-zookeeper服务器后也得不到事件通知。\"><a href=\"#Zookeeper-中的监视是轻量级的，因此容易设置、维护和分发。当客户端与-Zookeeper-服务器端失去联系时，客户端并不会收到监视事件的通知，只有当客户端重新连接后，若在必要的情况下，以前注册的监视会重新被注册并触发，对于开发人员来说-这通常是透明的。只有一种情况会导致监视事件的丢失，即：通过-exists-设置了某个-znode-节点的监视，但是如果某个客户端在此-znode-节点被创建和删除的时间间隔内与-zookeeper-服务器失去了联系，该客户端即使稍后重新连接-zookeeper服务器后也得不到事件通知。\" class=\"headerlink\" title=\"Zookeeper 中的监视是轻量级的，因此容易设置、维护和分发。当客户端与 Zookeeper 服务器端失去联系时，客户端并不会收到监视事件的通知，只有当客户端重新连接后，若在必要的情况下，以前注册的监视会重新被注册并触发，对于开发人员来说 这通常是透明的。只有一种情况会导致监视事件的丢失，即：通过 exists() 设置了某个 znode 节点的监视，但是如果某个客户端在此 znode 节点被创建和删除的时间间隔内与 zookeeper 服务器失去了联系，该客户端即使稍后重新连接 zookeeper服务器后也得不到事件通知。\"></a>Zookeeper 中的监视是轻量级的，因此容易设置、维护和分发。当客户端与 Zookeeper 服务器端失去联系时，客户端并不会收到监视事件的通知，只有当客户端重新连接后，若在必要的情况下，以前注册的监视会重新被注册并触发，对于开发人员来说 这通常是透明的。只有一种情况会导致监视事件的丢失，即：通过 exists() 设置了某个 znode 节点的监视，但是如果某个客户端在此 znode 节点被创建和删除的时间间隔内与 zookeeper 服务器失去了联系，该客户端即使稍后重新连接 zookeeper服务器后也得不到事件通知。</h5><h3 id=\"Zookeeper-C-API-常量与部分结构-struct-介绍\"><a href=\"#Zookeeper-C-API-常量与部分结构-struct-介绍\" class=\"headerlink\" title=\"Zookeeper C API 常量与部分结构(struct)介绍\"></a>Zookeeper C API 常量与部分结构(struct)介绍</h3><h4 id=\"与-ACL-相关的结构与常量：\"><a href=\"#与-ACL-相关的结构与常量：\" class=\"headerlink\" title=\"与 ACL 相关的结构与常量：\"></a>与 ACL 相关的结构与常量：</h4><h5 id=\"struct-Id-结构为：\"><a href=\"#struct-Id-结构为：\" class=\"headerlink\" title=\"struct Id 结构为：\"></a>struct Id 结构为：</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct Id &#123;     char * scheme;     char * id; &#125;;</div></pre></td></tr></table></figure>\n<h5 id=\"struct-ACL-结构为：\"><a href=\"#struct-ACL-结构为：\" class=\"headerlink\" title=\"struct ACL 结构为：\"></a>struct ACL 结构为：</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct ACL &#123;     int32_t perms;     struct Id id; &#125;;</div></pre></td></tr></table></figure>\n<h5 id=\"struct-ACL-vector-结构为：\"><a href=\"#struct-ACL-vector-结构为：\" class=\"headerlink\" title=\"struct ACL_vector 结构为：\"></a>struct ACL_vector 结构为：</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct ACL_vector &#123;     int32_t count;     struct ACL *data; &#125;;</div></pre></td></tr></table></figure>\n<h5 id=\"与-znode-访问权限有关的常量\"><a href=\"#与-znode-访问权限有关的常量\" class=\"headerlink\" title=\"与 znode 访问权限有关的常量\"></a>与 znode 访问权限有关的常量</h5><ul>\n<li>const int ZOO_PERM_READ; //允许客户端读取 znode 节点的值以及子节点列表。</li>\n<li>const int ZOO_PERM_WRITE;// 允许客户端设置 znode 节点的值。</li>\n<li>const int ZOO_PERM_CREATE; //允许客户端在该 znode 节点下创建子节点。</li>\n<li>const int ZOO_PERM_DELETE;//允许客户端删除子节点。</li>\n<li>const int ZOO_PERM_ADMIN; //允许客户端执行 set_acl()。</li>\n<li>const int ZOO_PERM_ALL;//允许客户端执行所有操作，等价与上述所有标志的或(OR) 。</li>\n</ul>\n<h5 id=\"与-ACL-IDs-相关的常量\"><a href=\"#与-ACL-IDs-相关的常量\" class=\"headerlink\" title=\"与 ACL IDs 相关的常量\"></a>与 ACL IDs 相关的常量</h5><ul>\n<li>struct Id ZOO_ANYONE_ID_UNSAFE; //(‘world’,’anyone’)</li>\n<li>struct Id ZOO_AUTH_IDS;// (‘auth’,’’)</li>\n</ul>\n<h5 id=\"三种标准的-ACL\"><a href=\"#三种标准的-ACL\" class=\"headerlink\" title=\"三种标准的 ACL\"></a>三种标准的 ACL</h5><ul>\n<li>struct ACL_vector ZOO_OPEN_ACL_UNSAFE; //(ZOO_PERM_ALL,ZOO_ANYONE_ID_UNSAFE)</li>\n<li>struct ACL_vector ZOO_READ_ACL_UNSAFE;// (ZOO_PERM_READ, ZOO_ANYONE_ID_UNSAFE)</li>\n<li>struct ACL_vector ZOO_CREATOR_ALL_ACL; //(ZOO_PERM_ALL,ZOO_AUTH_IDS)</li>\n</ul>\n<h4 id=\"与-Interest-相关的常量：ZOOKEEPER-WRITE-ZOOKEEPER-READ\"><a href=\"#与-Interest-相关的常量：ZOOKEEPER-WRITE-ZOOKEEPER-READ\" class=\"headerlink\" title=\"与 Interest 相关的常量：ZOOKEEPER_WRITE, ZOOKEEPER_READ\"></a>与 Interest 相关的常量：ZOOKEEPER_WRITE, ZOOKEEPER_READ</h4><h5 id=\"这两个常量用于标识感兴趣的事件并通知zookeeper发生了哪些事件。Interest-常量可以进行组合或（OR）来标识多种兴趣-multiple-interests-write-read-，这两个常量一般用于-zookeeper-interest-和-zookeeper-process-两个函数中。\"><a href=\"#这两个常量用于标识感兴趣的事件并通知zookeeper发生了哪些事件。Interest-常量可以进行组合或（OR）来标识多种兴趣-multiple-interests-write-read-，这两个常量一般用于-zookeeper-interest-和-zookeeper-process-两个函数中。\" class=\"headerlink\" title=\"这两个常量用于标识感兴趣的事件并通知zookeeper发生了哪些事件。Interest 常量可以进行组合或（OR）来标识多种兴趣(multiple interests: write, read)，这两个常量一般用于 zookeeper_interest() 和 zookeeper_process()两个函数中。\"></a>这两个常量用于标识感兴趣的事件并通知zookeeper发生了哪些事件。Interest 常量可以进行组合或（OR）来标识多种兴趣(multiple interests: write, read)，这两个常量一般用于 zookeeper_interest() 和 zookeeper_process()两个函数中。</h5><h4 id=\"与节点创建相关的常量：ZOO-EPHEMERAL-ZOO-SEQUENCE\"><a href=\"#与节点创建相关的常量：ZOO-EPHEMERAL-ZOO-SEQUENCE\" class=\"headerlink\" title=\"与节点创建相关的常量：ZOO_EPHEMERAL, ZOO_SEQUENCE\"></a>与节点创建相关的常量：ZOO_EPHEMERAL, ZOO_SEQUENCE</h4><h5 id=\"zoo-create-函数标志，ZOO-EPHEMERAL-用来标识创建临时节点，ZOO-SEQUENCE-用来标识节点命名具有递增的后缀序号-一般是节点名称后填充-10-位字符的序号，如-xyz0000000000-xyz0000000001-xyz0000000002-…-，同样地，ZOO-EPHEMERAL-ZOO-SEQUENCE-可以组合。\"><a href=\"#zoo-create-函数标志，ZOO-EPHEMERAL-用来标识创建临时节点，ZOO-SEQUENCE-用来标识节点命名具有递增的后缀序号-一般是节点名称后填充-10-位字符的序号，如-xyz0000000000-xyz0000000001-xyz0000000002-…-，同样地，ZOO-EPHEMERAL-ZOO-SEQUENCE-可以组合。\" class=\"headerlink\" title=\"zoo_create 函数标志，ZOO_EPHEMERAL 用来标识创建临时节点，ZOO_SEQUENCE 用来标识节点命名具有递增的后缀序号(一般是节点名称后填充 10 位字符的序号，如 /xyz0000000000, /xyz0000000001, /xyz0000000002, …)，同样地，ZOO_EPHEMERAL, ZOO_SEQUENCE 可以组合。\"></a>zoo_create 函数标志，ZOO_EPHEMERAL 用来标识创建临时节点，ZOO_SEQUENCE 用来标识节点命名具有递增的后缀序号(一般是节点名称后填充 10 位字符的序号，如 /xyz0000000000, /xyz0000000001, /xyz0000000002, …)，同样地，ZOO_EPHEMERAL, ZOO_SEQUENCE 可以组合。</h5><h4 id=\"与连接状态-Stat-相关的常量\"><a href=\"#与连接状态-Stat-相关的常量\" class=\"headerlink\" title=\"与连接状态 Stat 相关的常量\"></a>与连接状态 Stat 相关的常量</h4><h5 id=\"以下常量均与-Zookeeper-连接状态有关，他们通常用作监视器回调函数的参数。\"><a href=\"#以下常量均与-Zookeeper-连接状态有关，他们通常用作监视器回调函数的参数。\" class=\"headerlink\" title=\"以下常量均与 Zookeeper 连接状态有关，他们通常用作监视器回调函数的参数。\"></a>以下常量均与 Zookeeper 连接状态有关，他们通常用作监视器回调函数的参数。</h5><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">ZOOAPI const int</th>\n<th style=\"text-align:left\">ZOO_EXPIRED_SESSION_STATE</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ZOOAPI const int</td>\n<td style=\"text-align:left\">ZOO_AUTH_FAILED_STATE</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ZOOAPI const int</td>\n<td style=\"text-align:left\">ZOO_CONNECTING_STATE</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ZOOAPI const int</td>\n<td style=\"text-align:left\">ZOO_ASSOCIATING_STATE</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ZOOAPI const int</td>\n<td style=\"text-align:left\">ZOO_CONNECTED_STATE</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h4 id=\"与监视类型-Watch-Types-相关的常量\"><a href=\"#与监视类型-Watch-Types-相关的常量\" class=\"headerlink\" title=\"与监视类型(Watch Types)相关的常量\"></a>与监视类型(Watch Types)相关的常量</h4><h5 id=\"以下常量标识监视事件的类型，他们通常用作监视器回调函数的第一个参数。\"><a href=\"#以下常量标识监视事件的类型，他们通常用作监视器回调函数的第一个参数。\" class=\"headerlink\" title=\"以下常量标识监视事件的类型，他们通常用作监视器回调函数的第一个参数。\"></a>以下常量标识监视事件的类型，他们通常用作监视器回调函数的第一个参数。</h5><ul>\n<li>ZOO_CREATED_EVENT; // 节点被创建(此前该节点不存在)，通过 zoo_exists() 设置监视。</li>\n<li>ZOO_DELETED_EVENT; // 节点被删除，通过 zoo_exists() 和 zoo_get() 设置监视。</li>\n<li>ZOO_CHANGED_EVENT; // 节点发生变化，通过 zoo_exists() 和 zoo_get() 设置监视。</li>\n<li>ZOO_CHILD_EVENT; // 子节点事件，通过zoo_get_children() 和 zoo_get_children2()设置监视。</li>\n<li>ZOO_SESSION_EVENT; // 会话丢失</li>\n<li>ZOO_NOTWATCHING_EVENT; // 监视被移除。</li>\n</ul>\n<h4 id=\"Zookeeper-C-API-错误码介绍-ZOO-ERRORS\"><a href=\"#Zookeeper-C-API-错误码介绍-ZOO-ERRORS\" class=\"headerlink\" title=\"Zookeeper C API 错误码介绍 ZOO_ERRORS\"></a>Zookeeper C API 错误码介绍 ZOO_ERRORS</h4><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>ZOK</th>\n<th>正常返回</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ZSYSTEMERROR</td>\n<td>系统或服务器端错误(System and server-side errors)，服务器不会抛出该错误，该错误也只是用来标识错误范围的，即大于该错误值，且小于 ZAPIERROR 都是系统错误。</td>\n</tr>\n<tr>\n<td>ZRUNTIMEINCONSISTENCY</td>\n<td>运行时非一致性错误。</td>\n</tr>\n<tr>\n<td>ZDATAINCONSISTENCY</td>\n<td>数据非一致性错误。</td>\n</tr>\n<tr>\n<td>ZCONNECTIONLOSS</td>\n<td>Zookeeper 客户端与服务器端失去连接</td>\n</tr>\n<tr>\n<td>ZMARSHALLINGERROR</td>\n<td>在 marshalling 和 unmarshalling 数据时出现错误(Error while marshalling or unmarshalling data)</td>\n</tr>\n<tr>\n<td>ZUNIMPLEMENTED</td>\n<td>该操作未实现(Operation is unimplemented)</td>\n</tr>\n<tr>\n<td>ZOPERATIONTIMEOUT</td>\n<td>该操作超时(Operation timeout)</td>\n</tr>\n<tr>\n<td>ZBADARGUMENTS</td>\n<td>非法参数错误(Invalid arguments)</td>\n</tr>\n<tr>\n<td>ZINVALIDSTATE</td>\n<td>非法句柄状态(Invliad zhandle state)</td>\n</tr>\n<tr>\n<td>ZAPIERROR</td>\n<td>API 错误(API errors)，服务器不会抛出该错误，该错误也只是用来标识错误范围的，错误值大于该值的标识 API 错误，而小于该值的标识 ZSYSTEMERROR。</td>\n</tr>\n<tr>\n<td>ZNONODE</td>\n<td>节点不存在(Node does not exist)</td>\n</tr>\n<tr>\n<td>ZNOAUTH</td>\n<td>没有经过授权(Not authenticated)</td>\n</tr>\n<tr>\n<td>ZBADVERSION</td>\n<td>版本冲突(Version conflict)</td>\n</tr>\n<tr>\n<td>ZNOCHILDRENFOREPHEMERALS</td>\n<td>临时节点不能拥有子节点(Ephemeral nodes may not have children)</td>\n</tr>\n<tr>\n<td>ZNODEEXISTS</td>\n<td>节点已经存在(The node already exists)</td>\n</tr>\n<tr>\n<td>ZNOTEMPTY</td>\n<td>该节点具有自身的子节点(The node has children)</td>\n</tr>\n<tr>\n<td>ZSESSIONEXPIRED</td>\n<td>会话过期(The session has been expired by the server)</td>\n</tr>\n<tr>\n<td>ZINVALIDCALLBACK</td>\n<td>非法的回调函数(Invalid callback specified)</td>\n</tr>\n<tr>\n<td>ZINVALIDACL</td>\n<td>非法的ACL(Invalid ACL specified)</td>\n</tr>\n<tr>\n<td>ZAUTHFAILED</td>\n<td>客户端授权失败(Client authentication failed)</td>\n</tr>\n<tr>\n<td>ZCLOSING</td>\n<td>Zookeeper 连接关闭(ZooKeeper is closing)</td>\n</tr>\n<tr>\n<td>ZNOTHING</td>\n<td>并非错误，客户端不需要处理服务器的响应(not error, no server responses to process)</td>\n</tr>\n<tr>\n<td>ZSESSIONMOVED</td>\n<td>会话转移至其他服务器，所以操作被忽略(session moved to another server, so operation is ignored) </td>\n</tr>\n</tbody>\n</table>\n</div>\n<h5 id=\"Watch事件类型：\"><a href=\"#Watch事件类型：\" class=\"headerlink\" title=\"Watch事件类型：\"></a>Watch事件类型：</h5><ul>\n<li>ZOO_CREATED_EVENT：节点创建事件，需要watch一个不存在的节点，当节点被创建时触发，此watch通过zoo_exists()设置</li>\n<li>ZOO_DELETED_EVENT：节点删除事件，此watch通过zoo_exists()或zoo_get()设置</li>\n<li>ZOO_CHANGED_EVENT：节点数据改变事件，此watch通过zoo_exists()或zoo_get()设置</li>\n<li>ZOO_CHILD_EVENT：子节点列表改变事件，此watch通过zoo_get_children()或zoo_get_children2()设置</li>\n<li>ZOO_SESSION_EVENT：会话失效事件，客户端与服务端断开或重连时触发</li>\n<li>ZOO_NOTWATCHING_EVENT：watch移除事件，服务端出于某些原因不再为客户端watch节点时触发</li>\n</ul>\n","excerpt":"<h5 id=\"ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，它包含一个简单的原语集，分布式应用程序可以基于它实现同步服务，配置维护和命名服务等。Zookeeper是hadoop的一个子项目，其发展历程无需赘述。在分布式应用中，由于工程师不能很好地使用锁机制，以及基于消息的协调机制不适合在某些应用中使用，因此需要有一种可靠的、可扩展的、分布式的、可配置的协调机制来统一系统的状态。Zookeeper的目的就在于此。本文简单分析zookeeper的工作原理，对于如何使用zookeeper不是本文讨论的重点。\"><a href=\"#ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，它包含一个简单的原语集，分布式应用程序可以基于它实现同步服务，配置维护和命名服务等。Zookeeper是hadoop的一个子项目，其发展历程无需赘述。在分布式应用中，由于工程师不能很好地使用锁机制，以及基于消息的协调机制不适合在某些应用中使用，因此需要有一种可靠的、可扩展的、分布式的、可配置的协调机制来统一系统的状态。Zookeeper的目的就在于此。本文简单分析zookeeper的工作原理，对于如何使用zookeeper不是本文讨论的重点。\" class=\"headerlink\" title=\"ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，它包含一个简单的原语集，分布式应用程序可以基于它实现同步服务，配置维护和命名服务等。Zookeeper是hadoop的一个子项目，其发展历程无需赘述。在分布式应用中，由于工程师不能很好地使用锁机制，以及基于消息的协调机制不适合在某些应用中使用，因此需要有一种可靠的、可扩展的、分布式的、可配置的协调机制来统一系统的状态。Zookeeper的目的就在于此。本文简单分析zookeeper的工作原理，对于如何使用zookeeper不是本文讨论的重点。\"></a>ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，它包含一个简单的原语集，分布式应用程序可以基于它实现同步服务，配置维护和命名服务等。Zookeeper是hadoop的一个子项目，其发展历程无需赘述。在分布式应用中，由于工程师不能很好地使用锁机制，以及基于消息的协调机制不适合在某些应用中使用，因此需要有一种可靠的、可扩展的、分布式的、可配置的协调机制来统一系统的状态。Zookeeper的目的就在于此。本文简单分析zookeeper的工作原理，对于如何使用zookeeper不是本文讨论的重点。</h5>","more":"<h2 id=\"1-Zookeeper的基本概念\"><a href=\"#1-Zookeeper的基本概念\" class=\"headerlink\" title=\"1 Zookeeper的基本概念\"></a>1 Zookeeper的基本概念</h2><h3 id=\"1-1-角色\"><a href=\"#1-1-角色\" class=\"headerlink\" title=\"1.1 角色\"></a>1.1 角色</h3><h5 id=\"Zookeeper中的角色主要有以下三类，如下表所示：\"><a href=\"#Zookeeper中的角色主要有以下三类，如下表所示：\" class=\"headerlink\" title=\"Zookeeper中的角色主要有以下三类，如下表所示：\"></a>Zookeeper中的角色主要有以下三类，如下表所示：</h5><p><img src=\"../../img/zookeeper/role.jpg\" alt=\"zookeeper角色\"></p>\n<h5 id=\"系统模型如图所示：\"><a href=\"#系统模型如图所示：\" class=\"headerlink\" title=\"系统模型如图所示：\"></a>系统模型如图所示：</h5><p><img src=\"../../img/zookeeper/zookeeperModel.jpg\" alt=\"zookeeper系统模型\"></p>\n<h3 id=\"1-2-设计目的\"><a href=\"#1-2-设计目的\" class=\"headerlink\" title=\"1.2 设计目的\"></a>1.2 设计目的</h3><ol>\n<li>最终一致性：client不论连接到哪个Server，展示给它都是同一个视图，这是zookeeper最重要的性能。</li>\n<li>可靠性：具有简单、健壮、良好的性能，如果消息m被到一台服务器接受，那么它将被所有的服务器接受。</li>\n<li>实时性：Zookeeper保证客户端将在一个时间间隔范围内获得服务器的更新信息，或者服务器失效的信息。但由于网络延时等原因，Zookeeper不能保证两个客户端能同时得到刚更新的数据，如果需要最新数据，应该在读数据之前调用sync()接口。</li>\n<li>等待无关（wait-free）：慢的或者失效的client不得干预快速的client的请求，使得每个client都能有效的等待。</li>\n<li>原子性：更新只能成功或者失败，没有中间状态。</li>\n<li>顺序性：包括全局有序和偏序两种：全局有序是指如果在一台服务器上消息a在消息b前发布，则在所有Server上消息a都将在消息b前被发布；偏序是指如果一个消息b在消息a后被同一个发送者发布，a必将排在b前面。</li>\n</ol>\n<h2 id=\"2-ZooKeeper的工作原理\"><a href=\"#2-ZooKeeper的工作原理\" class=\"headerlink\" title=\"2 ZooKeeper的工作原理\"></a>2 ZooKeeper的工作原理</h2><h5 id=\"Zookeeper的核心是原子广播，这个机制保证了各个Server之间的同步。实现这个机制的协议叫做Zab协议。Zab协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数Server完成了和leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和Server具有相同的系统状态。\"><a href=\"#Zookeeper的核心是原子广播，这个机制保证了各个Server之间的同步。实现这个机制的协议叫做Zab协议。Zab协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数Server完成了和leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和Server具有相同的系统状态。\" class=\"headerlink\" title=\"Zookeeper的核心是原子广播，这个机制保证了各个Server之间的同步。实现这个机制的协议叫做Zab协议。Zab协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数Server完成了和leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和Server具有相同的系统状态。\"></a>Zookeeper的核心是原子广播，这个机制保证了各个Server之间的同步。实现这个机制的协议叫做Zab协议。Zab协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数Server完成了和leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和Server具有相同的系统状态。</h5><h5 id=\"为了保证事务的顺序一致性，zookeeper采用了递增的事务id号（zxid）来标识事务。所有的提议（proposal）都在被提出的时候加上了zxid。实现中zxid是一个64位的数字，它高32位是epoch用来标识leader关系是否改变，每次一个leader被选出来，它都会有一个新的epoch，标识当前属于那个leader的统治时期。低32位用于递增计数。\"><a href=\"#为了保证事务的顺序一致性，zookeeper采用了递增的事务id号（zxid）来标识事务。所有的提议（proposal）都在被提出的时候加上了zxid。实现中zxid是一个64位的数字，它高32位是epoch用来标识leader关系是否改变，每次一个leader被选出来，它都会有一个新的epoch，标识当前属于那个leader的统治时期。低32位用于递增计数。\" class=\"headerlink\" title=\"为了保证事务的顺序一致性，zookeeper采用了递增的事务id号（zxid）来标识事务。所有的提议（proposal）都在被提出的时候加上了zxid。实现中zxid是一个64位的数字，它高32位是epoch用来标识leader关系是否改变，每次一个leader被选出来，它都会有一个新的epoch，标识当前属于那个leader的统治时期。低32位用于递增计数。\"></a>为了保证事务的顺序一致性，zookeeper采用了递增的事务id号（zxid）来标识事务。所有的提议（proposal）都在被提出的时候加上了zxid。实现中zxid是一个64位的数字，它高32位是epoch用来标识leader关系是否改变，每次一个leader被选出来，它都会有一个新的epoch，标识当前属于那个leader的统治时期。低32位用于递增计数。</h5><h5 id=\"每个Server在工作过程中有三种状态：\"><a href=\"#每个Server在工作过程中有三种状态：\" class=\"headerlink\" title=\"每个Server在工作过程中有三种状态：\"></a>每个Server在工作过程中有三种状态：</h5><ul>\n<li>LOOKING：当前Server不知道leader是谁，正在搜寻</li>\n<li>LEADING：当前Server即为选举出来的leader</li>\n<li>FOLLOWING：leader已经选举出来，当前Server与之同步</li>\n</ul>\n<h3 id=\"2-1-选主流程\"><a href=\"#2-1-选主流程\" class=\"headerlink\" title=\"2.1 选主流程\"></a>2.1 选主流程</h3><h5 id=\"当leader崩溃或者leader失去大多数的follower，这时候zk进入恢复模式，恢复模式需要重新选举出一个新的leader，让所有的Server都恢复到一个正确的状态。Zk的选举算法有两种：一种是基于basic-paxos实现的，另外一种是基于fast-paxos算法实现的。系统默认的选举算法为fast-paxos。先介绍basic-paxos流程：\"><a href=\"#当leader崩溃或者leader失去大多数的follower，这时候zk进入恢复模式，恢复模式需要重新选举出一个新的leader，让所有的Server都恢复到一个正确的状态。Zk的选举算法有两种：一种是基于basic-paxos实现的，另外一种是基于fast-paxos算法实现的。系统默认的选举算法为fast-paxos。先介绍basic-paxos流程：\" class=\"headerlink\" title=\"当leader崩溃或者leader失去大多数的follower，这时候zk进入恢复模式，恢复模式需要重新选举出一个新的leader，让所有的Server都恢复到一个正确的状态。Zk的选举算法有两种：一种是基于basic paxos实现的，另外一种是基于fast paxos算法实现的。系统默认的选举算法为fast paxos。先介绍basic paxos流程：\"></a>当leader崩溃或者leader失去大多数的follower，这时候zk进入恢复模式，恢复模式需要重新选举出一个新的leader，让所有的Server都恢复到一个正确的状态。Zk的选举算法有两种：一种是基于basic paxos实现的，另外一种是基于fast paxos算法实现的。系统默认的选举算法为fast paxos。先介绍basic paxos流程：</h5><ol>\n<li>选举线程由当前Server发起选举的线程担任，其主要功能是对投票结果进行统计，并选出推荐的Server；</li>\n<li>选举线程首先向所有Server发起一次询问(包括自己)；</li>\n<li>选举线程收到回复后，验证是否是自己发起的询问(验证zxid是否一致)，然后获取对方的id(myid)，并存储到当前询问对象列表中，最后获取对方提议的leader相关信息(id,zxid)，并将这些信息存储到当次选举的投票记录表中；</li>\n<li>收到所有Server回复以后，就计算出zxid最大的那个Server，并将这个Server相关信息设置成下一次要投票的Server；</li>\n<li>线程将当前zxid最大的Server设置为当前Server要推荐的Leader，如果此时获胜的Server获得n/2 + 1的Server票数， 设置当前推荐的leader为获胜的Server，将根据获胜的Server相关信息设置自己的状态，否则，继续这个过程，直到leader被选举出来。</li>\n</ol>\n<h5 id=\"通过流程分析我们可以得出：要使Leader获得多数Server的支持，则Server总数必须是奇数2n-1，且存活的Server的数目不得少于n-1\"><a href=\"#通过流程分析我们可以得出：要使Leader获得多数Server的支持，则Server总数必须是奇数2n-1，且存活的Server的数目不得少于n-1\" class=\"headerlink\" title=\"通过流程分析我们可以得出：要使Leader获得多数Server的支持，则Server总数必须是奇数2n+1，且存活的Server的数目不得少于n+1.\"></a>通过流程分析我们可以得出：要使Leader获得多数Server的支持，则Server总数必须是奇数2n+1，且存活的Server的数目不得少于n+1.</h5><h5 id=\"每个Server启动后都会重复以上流程。在恢复模式下，如果是刚从崩溃状态恢复的或者刚启动的server还会从磁盘快照中恢复数据和会话信息，zk会记录事务日志并定期进行快照，方便在恢复时进行状态恢复。选主的具体流程图如下所示：\"><a href=\"#每个Server启动后都会重复以上流程。在恢复模式下，如果是刚从崩溃状态恢复的或者刚启动的server还会从磁盘快照中恢复数据和会话信息，zk会记录事务日志并定期进行快照，方便在恢复时进行状态恢复。选主的具体流程图如下所示：\" class=\"headerlink\" title=\"每个Server启动后都会重复以上流程。在恢复模式下，如果是刚从崩溃状态恢复的或者刚启动的server还会从磁盘快照中恢复数据和会话信息，zk会记录事务日志并定期进行快照，方便在恢复时进行状态恢复。选主的具体流程图如下所示：\"></a>每个Server启动后都会重复以上流程。在恢复模式下，如果是刚从崩溃状态恢复的或者刚启动的server还会从磁盘快照中恢复数据和会话信息，zk会记录事务日志并定期进行快照，方便在恢复时进行状态恢复。选主的具体流程图如下所示：</h5><p><img src=\"../../img/zookeeper/zookeeperLc.jpg\" alt=\"zookeeper流程图\"></p>\n<h5 id=\"fast-paxos流程是在选举过程中，某Server首先向所有Server提议自己要成为leader，当其它Server收到提议以后，解决epoch和zxid的冲突，并接受对方的提议，然后向对方发送接受提议完成的消息，重复这个流程，最后一定能选举出Leader。其流程图如下所示：\"><a href=\"#fast-paxos流程是在选举过程中，某Server首先向所有Server提议自己要成为leader，当其它Server收到提议以后，解决epoch和zxid的冲突，并接受对方的提议，然后向对方发送接受提议完成的消息，重复这个流程，最后一定能选举出Leader。其流程图如下所示：\" class=\"headerlink\" title=\"fast paxos流程是在选举过程中，某Server首先向所有Server提议自己要成为leader，当其它Server收到提议以后，解决epoch和zxid的冲突，并接受对方的提议，然后向对方发送接受提议完成的消息，重复这个流程，最后一定能选举出Leader。其流程图如下所示：\"></a>fast paxos流程是在选举过程中，某Server首先向所有Server提议自己要成为leader，当其它Server收到提议以后，解决epoch和zxid的冲突，并接受对方的提议，然后向对方发送接受提议完成的消息，重复这个流程，最后一定能选举出Leader。其流程图如下所示：</h5><p><img src=\"../../img/zookeeper/zookeeperLc2.jpg\" alt=\"zookeeper流程图\"></p>\n<h3 id=\"2-2-同步流程\"><a href=\"#2-2-同步流程\" class=\"headerlink\" title=\"2.2 同步流程\"></a>2.2 同步流程</h3><h5 id=\"选完leader以后，zk就进入状态同步过程。\"><a href=\"#选完leader以后，zk就进入状态同步过程。\" class=\"headerlink\" title=\"选完leader以后，zk就进入状态同步过程。\"></a>选完leader以后，zk就进入状态同步过程。</h5><ol>\n<li>leader等待server连接；</li>\n<li>Follower连接leader，将最大的zxid发送给leader；</li>\n<li>Leader根据follower的zxid确定同步点；</li>\n<li>完成同步后通知follower 已经成为uptodate状态；</li>\n<li>Follower收到uptodate消息后，又可以重新接受client的请求进行服务了。</li>\n</ol>\n<h5 id=\"流程图如下所示：\"><a href=\"#流程图如下所示：\" class=\"headerlink\" title=\"流程图如下所示：\"></a>流程图如下所示：</h5><p><img src=\"../../img/zookeeper/zookeeperLc3.jpg\" alt=\"zookeeper流程图\"></p>\n<h3 id=\"2-3-工作流程\"><a href=\"#2-3-工作流程\" class=\"headerlink\" title=\"2.3 工作流程\"></a>2.3 工作流程</h3><h4 id=\"2-3-1-Leader工作流程\"><a href=\"#2-3-1-Leader工作流程\" class=\"headerlink\" title=\"2.3.1 Leader工作流程\"></a>2.3.1 Leader工作流程</h4><h5 id=\"Leader主要有三个功能：\"><a href=\"#Leader主要有三个功能：\" class=\"headerlink\" title=\"Leader主要有三个功能：\"></a>Leader主要有三个功能：</h5><ol>\n<li>恢复数据；</li>\n<li>维持与Learner的心跳，接收Learner请求并判断Learner的请求消息类型；</li>\n<li>Learner的消息类型主要有PING消息、REQUEST消息、ACK消息、REVALIDATE消息，根据不同的消息类型，进行不同的处理。</li>\n</ol>\n<h5 id=\"PING消息是指Learner的心跳信息；REQUEST消息是Follower发送的提议信息，包括写请求及同步请求；ACK消息是Follower的对提议的回复，超过半数的Follower通过，则commit该提议；REVALIDATE消息是用来延长SESSION有效时间。\"><a href=\"#PING消息是指Learner的心跳信息；REQUEST消息是Follower发送的提议信息，包括写请求及同步请求；ACK消息是Follower的对提议的回复，超过半数的Follower通过，则commit该提议；REVALIDATE消息是用来延长SESSION有效时间。\" class=\"headerlink\" title=\"PING消息是指Learner的心跳信息；REQUEST消息是Follower发送的提议信息，包括写请求及同步请求；ACK消息是Follower的对提议的回复，超过半数的Follower通过，则commit该提议；REVALIDATE消息是用来延长SESSION有效时间。\"></a>PING消息是指Learner的心跳信息；REQUEST消息是Follower发送的提议信息，包括写请求及同步请求；ACK消息是Follower的对提议的回复，超过半数的Follower通过，则commit该提议；REVALIDATE消息是用来延长SESSION有效时间。</h5><h5 id=\"Leader的工作流程简图如下所示，在实际实现中，流程要比下图复杂得多，启动了三个线程来实现功能。\"><a href=\"#Leader的工作流程简图如下所示，在实际实现中，流程要比下图复杂得多，启动了三个线程来实现功能。\" class=\"headerlink\" title=\"Leader的工作流程简图如下所示，在实际实现中，流程要比下图复杂得多，启动了三个线程来实现功能。\"></a>Leader的工作流程简图如下所示，在实际实现中，流程要比下图复杂得多，启动了三个线程来实现功能。</h5><p><img src=\"../../img/zookeeper/zookeeperLc4.jpg\" alt=\"zookeeper流程图\"></p>\n<h4 id=\"2-3-2-Follower工作流程\"><a href=\"#2-3-2-Follower工作流程\" class=\"headerlink\" title=\"2.3.2 Follower工作流程\"></a>2.3.2 Follower工作流程</h4><h5 id=\"Follower主要有四个功能：\"><a href=\"#Follower主要有四个功能：\" class=\"headerlink\" title=\"Follower主要有四个功能：\"></a>Follower主要有四个功能：</h5><ol>\n<li>向Leader发送请求（PING消息、REQUEST消息、ACK消息、REVALIDATE消息）；</li>\n<li>接收Leader消息并进行处理；</li>\n<li>接收Client的请求，如果为写请求，发送给Leader进行投票；</li>\n<li>返回Client结果。</li>\n</ol>\n<h5 id=\"Follower的消息循环处理如下几种来自Leader的消息：\"><a href=\"#Follower的消息循环处理如下几种来自Leader的消息：\" class=\"headerlink\" title=\"Follower的消息循环处理如下几种来自Leader的消息：\"></a>Follower的消息循环处理如下几种来自Leader的消息：</h5><ol>\n<li>PING消息： 心跳消息；</li>\n<li>PROPOSAL消息：Leader发起的提案，要求Follower投票；</li>\n<li>COMMIT消息：服务器端最新一次提案的信息；</li>\n<li>UPTODATE消息：表明同步完成；</li>\n<li>REVALIDATE消息：根据Leader的REVALIDATE结果，关闭待revalidate的session还是允许其接受消息；</li>\n<li>SYNC消息：返回SYNC结果到客户端，这个消息最初由客户端发起，用来强制得到最新的更新。</li>\n</ol>\n<h5 id=\"Follower的工作流程简图如下所示，在实际实现中，Follower是通过5个线程来实现功能的。\"><a href=\"#Follower的工作流程简图如下所示，在实际实现中，Follower是通过5个线程来实现功能的。\" class=\"headerlink\" title=\"Follower的工作流程简图如下所示，在实际实现中，Follower是通过5个线程来实现功能的。\"></a>Follower的工作流程简图如下所示，在实际实现中，Follower是通过5个线程来实现功能的。</h5><p><img src=\"../../img/zookeeper/zookeeperLc5.jpg\" alt=\"zookeeper流程图\"></p>\n<h5 id=\"对于observer的流程不再叙述，observer流程和Follower的唯一不同的地方就是observer不会参加leader发起的投票。\"><a href=\"#对于observer的流程不再叙述，observer流程和Follower的唯一不同的地方就是observer不会参加leader发起的投票。\" class=\"headerlink\" title=\"对于observer的流程不再叙述，observer流程和Follower的唯一不同的地方就是observer不会参加leader发起的投票。\"></a>对于observer的流程不再叙述，observer流程和Follower的唯一不同的地方就是observer不会参加leader发起的投票。</h5><h5 id=\"主流应用场景：\"><a href=\"#主流应用场景：\" class=\"headerlink\" title=\"主流应用场景：\"></a>主流应用场景：</h5><h5 id=\"Zookeeper的主流应用场景实现思路（除去官方示例）\"><a href=\"#Zookeeper的主流应用场景实现思路（除去官方示例）\" class=\"headerlink\" title=\"Zookeeper的主流应用场景实现思路（除去官方示例）\"></a><strong>Zookeeper的主流应用场景实现思路（除去官方示例）</strong></h5><h4 id=\"1-配置管理\"><a href=\"#1-配置管理\" class=\"headerlink\" title=\"(1)配置管理\"></a>(1)配置管理</h4><h5 id=\"集中式的配置管理在应用集群中是非常常见的，一般商业公司内部都会实现一套集中的配置管理中心，应对不同的应用集群对于共享各自配置的需求，并且在配置变更时能够通知到集群中的每一个机器。\"><a href=\"#集中式的配置管理在应用集群中是非常常见的，一般商业公司内部都会实现一套集中的配置管理中心，应对不同的应用集群对于共享各自配置的需求，并且在配置变更时能够通知到集群中的每一个机器。\" class=\"headerlink\" title=\"集中式的配置管理在应用集群中是非常常见的，一般商业公司内部都会实现一套集中的配置管理中心，应对不同的应用集群对于共享各自配置的需求，并且在配置变更时能够通知到集群中的每一个机器。\"></a>集中式的配置管理在应用集群中是非常常见的，一般商业公司内部都会实现一套集中的配置管理中心，应对不同的应用集群对于共享各自配置的需求，并且在配置变更时能够通知到集群中的每一个机器。</h5><h5 id=\"Zookeeper很容易实现这种集中式的配置管理，比如将APP1的所有配置配置到-APP1-znode下，APP1所有机器一启动就对-APP1这个节点进行监控-zk-exist-“-APP1”-true-并且实现回调方法Watcher，那么在zookeeper上-APP1-znode节点下数据发生变化的时候，每个机器都会收到通知，Watcher方法将会被执行，那么应用再取下数据即可-zk-getData-“-APP1”-false-null\"><a href=\"#Zookeeper很容易实现这种集中式的配置管理，比如将APP1的所有配置配置到-APP1-znode下，APP1所有机器一启动就对-APP1这个节点进行监控-zk-exist-“-APP1”-true-并且实现回调方法Watcher，那么在zookeeper上-APP1-znode节点下数据发生变化的时候，每个机器都会收到通知，Watcher方法将会被执行，那么应用再取下数据即可-zk-getData-“-APP1”-false-null\" class=\"headerlink\" title=\"Zookeeper很容易实现这种集中式的配置管理，比如将APP1的所有配置配置到/APP1 znode下，APP1所有机器一启动就对/APP1这个节点进行监控(zk.exist(“/APP1”,true)),并且实现回调方法Watcher，那么在zookeeper上/APP1 znode节点下数据发生变化的时候，每个机器都会收到通知，Watcher方法将会被执行，那么应用再取下数据即可(zk.getData(“/APP1”,false,null));\"></a>Zookeeper很容易实现这种集中式的配置管理，比如将APP1的所有配置配置到/APP1 znode下，APP1所有机器一启动就对/APP1这个节点进行监控(zk.exist(“/APP1”,true)),并且实现回调方法Watcher，那么在zookeeper上/APP1 znode节点下数据发生变化的时候，每个机器都会收到通知，Watcher方法将会被执行，那么应用再取下数据即可(zk.getData(“/APP1”,false,null));</h5><h5 id=\"以上这个例子只是简单的粗颗粒度配置监控，细颗粒度的数据可以进行分层级监控，这一切都是可以设计和控制的。\"><a href=\"#以上这个例子只是简单的粗颗粒度配置监控，细颗粒度的数据可以进行分层级监控，这一切都是可以设计和控制的。\" class=\"headerlink\" title=\"以上这个例子只是简单的粗颗粒度配置监控，细颗粒度的数据可以进行分层级监控，这一切都是可以设计和控制的。\"></a>以上这个例子只是简单的粗颗粒度配置监控，细颗粒度的数据可以进行分层级监控，这一切都是可以设计和控制的。</h5><p><img src=\"../../img/zookeeper/zookeeper1.jpg\" alt=\"zookeeper流程图\"></p>\n<h4 id=\"2-集群管理\"><a href=\"#2-集群管理\" class=\"headerlink\" title=\"(2)集群管理\"></a>(2)集群管理</h4><h5 id=\"应用集群中，我们常常需要让每一个机器知道集群中（或依赖的其他某一个集群）哪些机器是活着的，并且在集群机器因为宕机，网络断链等原因能够不在人工介入的情况下迅速通知到每一个机器。\"><a href=\"#应用集群中，我们常常需要让每一个机器知道集群中（或依赖的其他某一个集群）哪些机器是活着的，并且在集群机器因为宕机，网络断链等原因能够不在人工介入的情况下迅速通知到每一个机器。\" class=\"headerlink\" title=\"应用集群中，我们常常需要让每一个机器知道集群中（或依赖的其他某一个集群）哪些机器是活着的，并且在集群机器因为宕机，网络断链等原因能够不在人工介入的情况下迅速通知到每一个机器。\"></a>应用集群中，我们常常需要让每一个机器知道集群中（或依赖的其他某一个集群）哪些机器是活着的，并且在集群机器因为宕机，网络断链等原因能够不在人工介入的情况下迅速通知到每一个机器。</h5><h5 id=\"Zookeeper同样很容易实现这个功能，比如我在zookeeper服务器端有一个znode叫-APP1SERVERS-那么集群中每一个机器启动的时候都去这个节点下创建一个EPHEMERAL类型的节点，比如server1创建-APP1SERVERS-SERVER1-可以使用ip-保证不重复-，server2创建-APP1SERVERS-SERVER2，然后SERVER1和SERVER2都watch-APP1SERVERS这个父节点，那么也就是这个父节点下数据或者子节点变化都会通知对该节点进行watch的客户端。因为EPHEMERAL类型节点有一个很重要的特性，就是客户端和服务器端连接断掉或者session过期就会使节点消失，那么在某一个机器挂掉或者断链的时候，其对应的节点就会消失，然后集群中所有对-APP1SERVERS进行watch的客户端都会收到通知，然后取得最新列表即可。\"><a href=\"#Zookeeper同样很容易实现这个功能，比如我在zookeeper服务器端有一个znode叫-APP1SERVERS-那么集群中每一个机器启动的时候都去这个节点下创建一个EPHEMERAL类型的节点，比如server1创建-APP1SERVERS-SERVER1-可以使用ip-保证不重复-，server2创建-APP1SERVERS-SERVER2，然后SERVER1和SERVER2都watch-APP1SERVERS这个父节点，那么也就是这个父节点下数据或者子节点变化都会通知对该节点进行watch的客户端。因为EPHEMERAL类型节点有一个很重要的特性，就是客户端和服务器端连接断掉或者session过期就会使节点消失，那么在某一个机器挂掉或者断链的时候，其对应的节点就会消失，然后集群中所有对-APP1SERVERS进行watch的客户端都会收到通知，然后取得最新列表即可。\" class=\"headerlink\" title=\"Zookeeper同样很容易实现这个功能，比如我在zookeeper服务器端有一个znode叫/APP1SERVERS,那么集群中每一个机器启动的时候都去这个节点下创建一个EPHEMERAL类型的节点，比如server1创建/APP1SERVERS/SERVER1(可以使用ip,保证不重复)，server2创建/APP1SERVERS/SERVER2，然后SERVER1和SERVER2都watch /APP1SERVERS这个父节点，那么也就是这个父节点下数据或者子节点变化都会通知对该节点进行watch的客户端。因为EPHEMERAL类型节点有一个很重要的特性，就是客户端和服务器端连接断掉或者session过期就会使节点消失，那么在某一个机器挂掉或者断链的时候，其对应的节点就会消失，然后集群中所有对/APP1SERVERS进行watch的客户端都会收到通知，然后取得最新列表即可。\"></a>Zookeeper同样很容易实现这个功能，比如我在zookeeper服务器端有一个znode叫/APP1SERVERS,那么集群中每一个机器启动的时候都去这个节点下创建一个EPHEMERAL类型的节点，比如server1创建/APP1SERVERS/SERVER1(可以使用ip,保证不重复)，server2创建/APP1SERVERS/SERVER2，然后SERVER1和SERVER2都watch /APP1SERVERS这个父节点，那么也就是这个父节点下数据或者子节点变化都会通知对该节点进行watch的客户端。因为EPHEMERAL类型节点有一个很重要的特性，就是客户端和服务器端连接断掉或者session过期就会使节点消失，那么在某一个机器挂掉或者断链的时候，其对应的节点就会消失，然后集群中所有对/APP1SERVERS进行watch的客户端都会收到通知，然后取得最新列表即可。</h5><h5 id=\"另外有一个应用场景就是集群选master-一旦master挂掉能够马上能从slave中选出一个master-实现步骤和前者一样，只是机器在启动的时候在APP1SERVERS创建的节点类型变为EPHEMERAL-SEQUENTIAL类型，这样每个节点会自动被编号\"><a href=\"#另外有一个应用场景就是集群选master-一旦master挂掉能够马上能从slave中选出一个master-实现步骤和前者一样，只是机器在启动的时候在APP1SERVERS创建的节点类型变为EPHEMERAL-SEQUENTIAL类型，这样每个节点会自动被编号\" class=\"headerlink\" title=\"另外有一个应用场景就是集群选master,一旦master挂掉能够马上能从slave中选出一个master,实现步骤和前者一样，只是机器在启动的时候在APP1SERVERS创建的节点类型变为EPHEMERAL_SEQUENTIAL类型，这样每个节点会自动被编号\"></a>另外有一个应用场景就是集群选master,一旦master挂掉能够马上能从slave中选出一个master,实现步骤和前者一样，只是机器在启动的时候在APP1SERVERS创建的节点类型变为EPHEMERAL_SEQUENTIAL类型，这样每个节点会自动被编号</h5><h5 id=\"我们默认规定编号最小的为master-所以当我们对-APP1SERVERS节点做监控的时候，得到服务器列表，只要所有集群机器逻辑认为最小编号节点为master，那么master就被选出，而这个master宕机的时候，相应的znode会消失，然后新的服务器列表就被推送到客户端，然后每个节点逻辑认为最小编号节点为master，这样就做到动态master选举。\"><a href=\"#我们默认规定编号最小的为master-所以当我们对-APP1SERVERS节点做监控的时候，得到服务器列表，只要所有集群机器逻辑认为最小编号节点为master，那么master就被选出，而这个master宕机的时候，相应的znode会消失，然后新的服务器列表就被推送到客户端，然后每个节点逻辑认为最小编号节点为master，这样就做到动态master选举。\" class=\"headerlink\" title=\"我们默认规定编号最小的为master,所以当我们对/APP1SERVERS节点做监控的时候，得到服务器列表，只要所有集群机器逻辑认为最小编号节点为master，那么master就被选出，而这个master宕机的时候，相应的znode会消失，然后新的服务器列表就被推送到客户端，然后每个节点逻辑认为最小编号节点为master，这样就做到动态master选举。\"></a>我们默认规定编号最小的为master,所以当我们对/APP1SERVERS节点做监控的时候，得到服务器列表，只要所有集群机器逻辑认为最小编号节点为master，那么master就被选出，而这个master宕机的时候，相应的znode会消失，然后新的服务器列表就被推送到客户端，然后每个节点逻辑认为最小编号节点为master，这样就做到动态master选举。</h5><p><img src=\"../../img/zookeeper/zookeeper2.jpg\" alt=\"zookeeper流程图\"></p>\n<h4 id=\"Zookeeper-监视（Watches）-简介\"><a href=\"#Zookeeper-监视（Watches）-简介\" class=\"headerlink\" title=\"Zookeeper 监视（Watches） 简介\"></a>Zookeeper 监视（Watches） 简介</h4><h5 id=\"Zookeeper-C-API-的声明和描述在-include-zookeeper-h-中可以找到，另外大部分的-Zookeeper-C-API-常量、结构体声明也在-zookeeper-h-中，如果如果你在使用-C-API-是遇到不明白的地方，最好看看-zookeeper-h，或者自己使用-doxygen-生成-Zookeeper-C-API-的帮助文档。\"><a href=\"#Zookeeper-C-API-的声明和描述在-include-zookeeper-h-中可以找到，另外大部分的-Zookeeper-C-API-常量、结构体声明也在-zookeeper-h-中，如果如果你在使用-C-API-是遇到不明白的地方，最好看看-zookeeper-h，或者自己使用-doxygen-生成-Zookeeper-C-API-的帮助文档。\" class=\"headerlink\" title=\"Zookeeper C API 的声明和描述在 include/zookeeper.h 中可以找到，另外大部分的 Zookeeper C API 常量、结构体声明也在 zookeeper.h 中，如果如果你在使用 C API 是遇到不明白的地方，最好看看 zookeeper.h，或者自己使用 doxygen 生成 Zookeeper C API 的帮助文档。\"></a>Zookeeper C API 的声明和描述在 include/zookeeper.h 中可以找到，另外大部分的 Zookeeper C API 常量、结构体声明也在 zookeeper.h 中，如果如果你在使用 C API 是遇到不明白的地方，最好看看 zookeeper.h，或者自己使用 doxygen 生成 Zookeeper C API 的帮助文档。</h5><h5 id=\"Zookeeper-中最有特色且最不容易理解的是监视-Watches-。Zookeeper-所有的读操作——getData-getChildren-和-exists-都-可以设置监视-watch-，监视事件可以理解为一次性的触发器，-官方定义如下：-a-watch-event-is-one-time-trigger-sent-to-the-client-that-set-the-watch-which-occurs-when-the-data-for-which-the-watch-was-set-changes。对此需要作出如下理解：\"><a href=\"#Zookeeper-中最有特色且最不容易理解的是监视-Watches-。Zookeeper-所有的读操作——getData-getChildren-和-exists-都-可以设置监视-watch-，监视事件可以理解为一次性的触发器，-官方定义如下：-a-watch-event-is-one-time-trigger-sent-to-the-client-that-set-the-watch-which-occurs-when-the-data-for-which-the-watch-was-set-changes。对此需要作出如下理解：\" class=\"headerlink\" title=\"Zookeeper 中最有特色且最不容易理解的是监视(Watches)。Zookeeper 所有的读操作——getData(), getChildren(), 和 exists() 都 可以设置监视(watch)，监视事件可以理解为一次性的触发器， 官方定义如下： a watch event is one-time trigger, sent to the client that set the watch, which occurs when the data for which the watch was set changes。对此需要作出如下理解：\"></a>Zookeeper 中最有特色且最不容易理解的是监视(Watches)。Zookeeper 所有的读操作——getData(), getChildren(), 和 exists() 都 可以设置监视(watch)，监视事件可以理解为一次性的触发器， 官方定义如下： a watch event is one-time trigger, sent to the client that set the watch, which occurs when the data for which the watch was set changes。对此需要作出如下理解：</h5><ul>\n<li>（一次性触发）One-time trigger</li>\n</ul>\n<h5 id=\"当设置监视的数据发生改变时，该监视事件会被发送到客户端，例如，如果客户端调用了-getData-“-znode1”-true-并且稍后-znode1-节点上的数据发生了改变或者被删除了，客户端将会获取到-znode1-发生变化的监视事件，而如果-znode1-再一次发生了变化，除非客户端再次对-znode1-设置监视，否则客户端不会收到事件通知。\"><a href=\"#当设置监视的数据发生改变时，该监视事件会被发送到客户端，例如，如果客户端调用了-getData-“-znode1”-true-并且稍后-znode1-节点上的数据发生了改变或者被删除了，客户端将会获取到-znode1-发生变化的监视事件，而如果-znode1-再一次发生了变化，除非客户端再次对-znode1-设置监视，否则客户端不会收到事件通知。\" class=\"headerlink\" title=\"当设置监视的数据发生改变时，该监视事件会被发送到客户端，例如，如果客户端调用了 getData(“/znode1”, true) 并且稍后 /znode1 节点上的数据发生了改变或者被删除了，客户端将会获取到 /znode1 发生变化的监视事件，而如果 /znode1 再一次发生了变化，除非客户端再次对 /znode1 设置监视，否则客户端不会收到事件通知。\"></a>当设置监视的数据发生改变时，该监视事件会被发送到客户端，例如，如果客户端调用了 getData(“/znode1”, true) 并且稍后 /znode1 节点上的数据发生了改变或者被删除了，客户端将会获取到 /znode1 发生变化的监视事件，而如果 /znode1 再一次发生了变化，除非客户端再次对 /znode1 设置监视，否则客户端不会收到事件通知。</h5><ul>\n<li>（发送至客户端）Sent to the client</li>\n</ul>\n<h5 id=\"Zookeeper-客户端和服务端是通过-socket-进行通信的，由于网络存在故障，所以监视事件很有可能不会成功地到达客户端，监视事件是异步发送至监视者的，Zookeeper-本身提供了保序性-ordering-guarantee-：即客户端只有首先看到了监视事件后，才会感知到它所设置监视的-znode-发生了变化-a-client-will-never-see-a-change-for-which-it-has-set-a-watch-until-it-first-sees-the-watch-event-网络延迟或者其他因素可能导致不同的客户端在不同的时刻感知某一监视事件，但是不同的客户端所看到的一切具有一致的顺序。\"><a href=\"#Zookeeper-客户端和服务端是通过-socket-进行通信的，由于网络存在故障，所以监视事件很有可能不会成功地到达客户端，监视事件是异步发送至监视者的，Zookeeper-本身提供了保序性-ordering-guarantee-：即客户端只有首先看到了监视事件后，才会感知到它所设置监视的-znode-发生了变化-a-client-will-never-see-a-change-for-which-it-has-set-a-watch-until-it-first-sees-the-watch-event-网络延迟或者其他因素可能导致不同的客户端在不同的时刻感知某一监视事件，但是不同的客户端所看到的一切具有一致的顺序。\" class=\"headerlink\" title=\"Zookeeper 客户端和服务端是通过 socket 进行通信的，由于网络存在故障，所以监视事件很有可能不会成功地到达客户端，监视事件是异步发送至监视者的，Zookeeper 本身提供了保序性(ordering guarantee)：即客户端只有首先看到了监视事件后，才会感知到它所设置监视的 znode 发生了变化(a client will never see a change for which it has set a watch until it first sees the watch event). 网络延迟或者其他因素可能导致不同的客户端在不同的时刻感知某一监视事件，但是不同的客户端所看到的一切具有一致的顺序。\"></a>Zookeeper 客户端和服务端是通过 socket 进行通信的，由于网络存在故障，所以监视事件很有可能不会成功地到达客户端，监视事件是异步发送至监视者的，Zookeeper 本身提供了保序性(ordering guarantee)：即客户端只有首先看到了监视事件后，才会感知到它所设置监视的 znode 发生了变化(a client will never see a change for which it has set a watch until it first sees the watch event). 网络延迟或者其他因素可能导致不同的客户端在不同的时刻感知某一监视事件，但是不同的客户端所看到的一切具有一致的顺序。</h5><ul>\n<li>（被设置 watch 的数据）The data for which the watch was set</li>\n</ul>\n<h5 id=\"这意味着-znode-节点本身具有不同的改变方式。你也可以想象-Zookeeper-维护了两条监视链表：数据监视和子节点监视-data-watches-and-child-watches-getData-and-exists-设置数据监视，getChildren-设置子节点监视。-或者，你也可以想象-Zookeeper-设置的不同监视返回不同的数据，getData-和-exists-返回-znode-节点的相关信息，而-getChildren-返回子节点列表。因此，-setData-会触发设置在某一节点上所设置的数据监视-假定数据设置成功-，而一次成功的-create-操作则会出发当前节点上所设置的数据监视以及父节点的子节点监视。一次成功的-delete-操作将会触发当前节点的数据监视和子节点监视事件，同时也会触发该节点父节点的child-watch。\"><a href=\"#这意味着-znode-节点本身具有不同的改变方式。你也可以想象-Zookeeper-维护了两条监视链表：数据监视和子节点监视-data-watches-and-child-watches-getData-and-exists-设置数据监视，getChildren-设置子节点监视。-或者，你也可以想象-Zookeeper-设置的不同监视返回不同的数据，getData-和-exists-返回-znode-节点的相关信息，而-getChildren-返回子节点列表。因此，-setData-会触发设置在某一节点上所设置的数据监视-假定数据设置成功-，而一次成功的-create-操作则会出发当前节点上所设置的数据监视以及父节点的子节点监视。一次成功的-delete-操作将会触发当前节点的数据监视和子节点监视事件，同时也会触发该节点父节点的child-watch。\" class=\"headerlink\" title=\"这意味着 znode 节点本身具有不同的改变方式。你也可以想象 Zookeeper 维护了两条监视链表：数据监视和子节点监视(data watches and child watches) getData() and exists() 设置数据监视，getChildren() 设置子节点监视。 或者，你也可以想象 Zookeeper 设置的不同监视返回不同的数据，getData() 和 exists() 返回 znode 节点的相关信息，而 getChildren() 返回子节点列表。因此， setData() 会触发设置在某一节点上所设置的数据监视(假定数据设置成功)，而一次成功的 create() 操作则会出发当前节点上所设置的数据监视以及父节点的子节点监视。一次成功的 delete() 操作将会触发当前节点的数据监视和子节点监视事件，同时也会触发该节点父节点的child watch。\"></a>这意味着 znode 节点本身具有不同的改变方式。你也可以想象 Zookeeper 维护了两条监视链表：数据监视和子节点监视(data watches and child watches) getData() and exists() 设置数据监视，getChildren() 设置子节点监视。 或者，你也可以想象 Zookeeper 设置的不同监视返回不同的数据，getData() 和 exists() 返回 znode 节点的相关信息，而 getChildren() 返回子节点列表。因此， setData() 会触发设置在某一节点上所设置的数据监视(假定数据设置成功)，而一次成功的 create() 操作则会出发当前节点上所设置的数据监视以及父节点的子节点监视。一次成功的 delete() 操作将会触发当前节点的数据监视和子节点监视事件，同时也会触发该节点父节点的child watch。</h5><h5 id=\"Zookeeper-中的监视是轻量级的，因此容易设置、维护和分发。当客户端与-Zookeeper-服务器端失去联系时，客户端并不会收到监视事件的通知，只有当客户端重新连接后，若在必要的情况下，以前注册的监视会重新被注册并触发，对于开发人员来说-这通常是透明的。只有一种情况会导致监视事件的丢失，即：通过-exists-设置了某个-znode-节点的监视，但是如果某个客户端在此-znode-节点被创建和删除的时间间隔内与-zookeeper-服务器失去了联系，该客户端即使稍后重新连接-zookeeper服务器后也得不到事件通知。\"><a href=\"#Zookeeper-中的监视是轻量级的，因此容易设置、维护和分发。当客户端与-Zookeeper-服务器端失去联系时，客户端并不会收到监视事件的通知，只有当客户端重新连接后，若在必要的情况下，以前注册的监视会重新被注册并触发，对于开发人员来说-这通常是透明的。只有一种情况会导致监视事件的丢失，即：通过-exists-设置了某个-znode-节点的监视，但是如果某个客户端在此-znode-节点被创建和删除的时间间隔内与-zookeeper-服务器失去了联系，该客户端即使稍后重新连接-zookeeper服务器后也得不到事件通知。\" class=\"headerlink\" title=\"Zookeeper 中的监视是轻量级的，因此容易设置、维护和分发。当客户端与 Zookeeper 服务器端失去联系时，客户端并不会收到监视事件的通知，只有当客户端重新连接后，若在必要的情况下，以前注册的监视会重新被注册并触发，对于开发人员来说 这通常是透明的。只有一种情况会导致监视事件的丢失，即：通过 exists() 设置了某个 znode 节点的监视，但是如果某个客户端在此 znode 节点被创建和删除的时间间隔内与 zookeeper 服务器失去了联系，该客户端即使稍后重新连接 zookeeper服务器后也得不到事件通知。\"></a>Zookeeper 中的监视是轻量级的，因此容易设置、维护和分发。当客户端与 Zookeeper 服务器端失去联系时，客户端并不会收到监视事件的通知，只有当客户端重新连接后，若在必要的情况下，以前注册的监视会重新被注册并触发，对于开发人员来说 这通常是透明的。只有一种情况会导致监视事件的丢失，即：通过 exists() 设置了某个 znode 节点的监视，但是如果某个客户端在此 znode 节点被创建和删除的时间间隔内与 zookeeper 服务器失去了联系，该客户端即使稍后重新连接 zookeeper服务器后也得不到事件通知。</h5><h3 id=\"Zookeeper-C-API-常量与部分结构-struct-介绍\"><a href=\"#Zookeeper-C-API-常量与部分结构-struct-介绍\" class=\"headerlink\" title=\"Zookeeper C API 常量与部分结构(struct)介绍\"></a>Zookeeper C API 常量与部分结构(struct)介绍</h3><h4 id=\"与-ACL-相关的结构与常量：\"><a href=\"#与-ACL-相关的结构与常量：\" class=\"headerlink\" title=\"与 ACL 相关的结构与常量：\"></a>与 ACL 相关的结构与常量：</h4><h5 id=\"struct-Id-结构为：\"><a href=\"#struct-Id-结构为：\" class=\"headerlink\" title=\"struct Id 结构为：\"></a>struct Id 结构为：</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct Id &#123;     char * scheme;     char * id; &#125;;</div></pre></td></tr></table></figure>\n<h5 id=\"struct-ACL-结构为：\"><a href=\"#struct-ACL-结构为：\" class=\"headerlink\" title=\"struct ACL 结构为：\"></a>struct ACL 结构为：</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct ACL &#123;     int32_t perms;     struct Id id; &#125;;</div></pre></td></tr></table></figure>\n<h5 id=\"struct-ACL-vector-结构为：\"><a href=\"#struct-ACL-vector-结构为：\" class=\"headerlink\" title=\"struct ACL_vector 结构为：\"></a>struct ACL_vector 结构为：</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct ACL_vector &#123;     int32_t count;     struct ACL *data; &#125;;</div></pre></td></tr></table></figure>\n<h5 id=\"与-znode-访问权限有关的常量\"><a href=\"#与-znode-访问权限有关的常量\" class=\"headerlink\" title=\"与 znode 访问权限有关的常量\"></a>与 znode 访问权限有关的常量</h5><ul>\n<li>const int ZOO_PERM_READ; //允许客户端读取 znode 节点的值以及子节点列表。</li>\n<li>const int ZOO_PERM_WRITE;// 允许客户端设置 znode 节点的值。</li>\n<li>const int ZOO_PERM_CREATE; //允许客户端在该 znode 节点下创建子节点。</li>\n<li>const int ZOO_PERM_DELETE;//允许客户端删除子节点。</li>\n<li>const int ZOO_PERM_ADMIN; //允许客户端执行 set_acl()。</li>\n<li>const int ZOO_PERM_ALL;//允许客户端执行所有操作，等价与上述所有标志的或(OR) 。</li>\n</ul>\n<h5 id=\"与-ACL-IDs-相关的常量\"><a href=\"#与-ACL-IDs-相关的常量\" class=\"headerlink\" title=\"与 ACL IDs 相关的常量\"></a>与 ACL IDs 相关的常量</h5><ul>\n<li>struct Id ZOO_ANYONE_ID_UNSAFE; //(‘world’,’anyone’)</li>\n<li>struct Id ZOO_AUTH_IDS;// (‘auth’,’’)</li>\n</ul>\n<h5 id=\"三种标准的-ACL\"><a href=\"#三种标准的-ACL\" class=\"headerlink\" title=\"三种标准的 ACL\"></a>三种标准的 ACL</h5><ul>\n<li>struct ACL_vector ZOO_OPEN_ACL_UNSAFE; //(ZOO_PERM_ALL,ZOO_ANYONE_ID_UNSAFE)</li>\n<li>struct ACL_vector ZOO_READ_ACL_UNSAFE;// (ZOO_PERM_READ, ZOO_ANYONE_ID_UNSAFE)</li>\n<li>struct ACL_vector ZOO_CREATOR_ALL_ACL; //(ZOO_PERM_ALL,ZOO_AUTH_IDS)</li>\n</ul>\n<h4 id=\"与-Interest-相关的常量：ZOOKEEPER-WRITE-ZOOKEEPER-READ\"><a href=\"#与-Interest-相关的常量：ZOOKEEPER-WRITE-ZOOKEEPER-READ\" class=\"headerlink\" title=\"与 Interest 相关的常量：ZOOKEEPER_WRITE, ZOOKEEPER_READ\"></a>与 Interest 相关的常量：ZOOKEEPER_WRITE, ZOOKEEPER_READ</h4><h5 id=\"这两个常量用于标识感兴趣的事件并通知zookeeper发生了哪些事件。Interest-常量可以进行组合或（OR）来标识多种兴趣-multiple-interests-write-read-，这两个常量一般用于-zookeeper-interest-和-zookeeper-process-两个函数中。\"><a href=\"#这两个常量用于标识感兴趣的事件并通知zookeeper发生了哪些事件。Interest-常量可以进行组合或（OR）来标识多种兴趣-multiple-interests-write-read-，这两个常量一般用于-zookeeper-interest-和-zookeeper-process-两个函数中。\" class=\"headerlink\" title=\"这两个常量用于标识感兴趣的事件并通知zookeeper发生了哪些事件。Interest 常量可以进行组合或（OR）来标识多种兴趣(multiple interests: write, read)，这两个常量一般用于 zookeeper_interest() 和 zookeeper_process()两个函数中。\"></a>这两个常量用于标识感兴趣的事件并通知zookeeper发生了哪些事件。Interest 常量可以进行组合或（OR）来标识多种兴趣(multiple interests: write, read)，这两个常量一般用于 zookeeper_interest() 和 zookeeper_process()两个函数中。</h5><h4 id=\"与节点创建相关的常量：ZOO-EPHEMERAL-ZOO-SEQUENCE\"><a href=\"#与节点创建相关的常量：ZOO-EPHEMERAL-ZOO-SEQUENCE\" class=\"headerlink\" title=\"与节点创建相关的常量：ZOO_EPHEMERAL, ZOO_SEQUENCE\"></a>与节点创建相关的常量：ZOO_EPHEMERAL, ZOO_SEQUENCE</h4><h5 id=\"zoo-create-函数标志，ZOO-EPHEMERAL-用来标识创建临时节点，ZOO-SEQUENCE-用来标识节点命名具有递增的后缀序号-一般是节点名称后填充-10-位字符的序号，如-xyz0000000000-xyz0000000001-xyz0000000002-…-，同样地，ZOO-EPHEMERAL-ZOO-SEQUENCE-可以组合。\"><a href=\"#zoo-create-函数标志，ZOO-EPHEMERAL-用来标识创建临时节点，ZOO-SEQUENCE-用来标识节点命名具有递增的后缀序号-一般是节点名称后填充-10-位字符的序号，如-xyz0000000000-xyz0000000001-xyz0000000002-…-，同样地，ZOO-EPHEMERAL-ZOO-SEQUENCE-可以组合。\" class=\"headerlink\" title=\"zoo_create 函数标志，ZOO_EPHEMERAL 用来标识创建临时节点，ZOO_SEQUENCE 用来标识节点命名具有递增的后缀序号(一般是节点名称后填充 10 位字符的序号，如 /xyz0000000000, /xyz0000000001, /xyz0000000002, …)，同样地，ZOO_EPHEMERAL, ZOO_SEQUENCE 可以组合。\"></a>zoo_create 函数标志，ZOO_EPHEMERAL 用来标识创建临时节点，ZOO_SEQUENCE 用来标识节点命名具有递增的后缀序号(一般是节点名称后填充 10 位字符的序号，如 /xyz0000000000, /xyz0000000001, /xyz0000000002, …)，同样地，ZOO_EPHEMERAL, ZOO_SEQUENCE 可以组合。</h5><h4 id=\"与连接状态-Stat-相关的常量\"><a href=\"#与连接状态-Stat-相关的常量\" class=\"headerlink\" title=\"与连接状态 Stat 相关的常量\"></a>与连接状态 Stat 相关的常量</h4><h5 id=\"以下常量均与-Zookeeper-连接状态有关，他们通常用作监视器回调函数的参数。\"><a href=\"#以下常量均与-Zookeeper-连接状态有关，他们通常用作监视器回调函数的参数。\" class=\"headerlink\" title=\"以下常量均与 Zookeeper 连接状态有关，他们通常用作监视器回调函数的参数。\"></a>以下常量均与 Zookeeper 连接状态有关，他们通常用作监视器回调函数的参数。</h5><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">ZOOAPI const int</th>\n<th style=\"text-align:left\">ZOO_EXPIRED_SESSION_STATE</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ZOOAPI const int</td>\n<td style=\"text-align:left\">ZOO_AUTH_FAILED_STATE</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ZOOAPI const int</td>\n<td style=\"text-align:left\">ZOO_CONNECTING_STATE</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ZOOAPI const int</td>\n<td style=\"text-align:left\">ZOO_ASSOCIATING_STATE</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ZOOAPI const int</td>\n<td style=\"text-align:left\">ZOO_CONNECTED_STATE</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h4 id=\"与监视类型-Watch-Types-相关的常量\"><a href=\"#与监视类型-Watch-Types-相关的常量\" class=\"headerlink\" title=\"与监视类型(Watch Types)相关的常量\"></a>与监视类型(Watch Types)相关的常量</h4><h5 id=\"以下常量标识监视事件的类型，他们通常用作监视器回调函数的第一个参数。\"><a href=\"#以下常量标识监视事件的类型，他们通常用作监视器回调函数的第一个参数。\" class=\"headerlink\" title=\"以下常量标识监视事件的类型，他们通常用作监视器回调函数的第一个参数。\"></a>以下常量标识监视事件的类型，他们通常用作监视器回调函数的第一个参数。</h5><ul>\n<li>ZOO_CREATED_EVENT; // 节点被创建(此前该节点不存在)，通过 zoo_exists() 设置监视。</li>\n<li>ZOO_DELETED_EVENT; // 节点被删除，通过 zoo_exists() 和 zoo_get() 设置监视。</li>\n<li>ZOO_CHANGED_EVENT; // 节点发生变化，通过 zoo_exists() 和 zoo_get() 设置监视。</li>\n<li>ZOO_CHILD_EVENT; // 子节点事件，通过zoo_get_children() 和 zoo_get_children2()设置监视。</li>\n<li>ZOO_SESSION_EVENT; // 会话丢失</li>\n<li>ZOO_NOTWATCHING_EVENT; // 监视被移除。</li>\n</ul>\n<h4 id=\"Zookeeper-C-API-错误码介绍-ZOO-ERRORS\"><a href=\"#Zookeeper-C-API-错误码介绍-ZOO-ERRORS\" class=\"headerlink\" title=\"Zookeeper C API 错误码介绍 ZOO_ERRORS\"></a>Zookeeper C API 错误码介绍 ZOO_ERRORS</h4><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>ZOK</th>\n<th>正常返回</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ZSYSTEMERROR</td>\n<td>系统或服务器端错误(System and server-side errors)，服务器不会抛出该错误，该错误也只是用来标识错误范围的，即大于该错误值，且小于 ZAPIERROR 都是系统错误。</td>\n</tr>\n<tr>\n<td>ZRUNTIMEINCONSISTENCY</td>\n<td>运行时非一致性错误。</td>\n</tr>\n<tr>\n<td>ZDATAINCONSISTENCY</td>\n<td>数据非一致性错误。</td>\n</tr>\n<tr>\n<td>ZCONNECTIONLOSS</td>\n<td>Zookeeper 客户端与服务器端失去连接</td>\n</tr>\n<tr>\n<td>ZMARSHALLINGERROR</td>\n<td>在 marshalling 和 unmarshalling 数据时出现错误(Error while marshalling or unmarshalling data)</td>\n</tr>\n<tr>\n<td>ZUNIMPLEMENTED</td>\n<td>该操作未实现(Operation is unimplemented)</td>\n</tr>\n<tr>\n<td>ZOPERATIONTIMEOUT</td>\n<td>该操作超时(Operation timeout)</td>\n</tr>\n<tr>\n<td>ZBADARGUMENTS</td>\n<td>非法参数错误(Invalid arguments)</td>\n</tr>\n<tr>\n<td>ZINVALIDSTATE</td>\n<td>非法句柄状态(Invliad zhandle state)</td>\n</tr>\n<tr>\n<td>ZAPIERROR</td>\n<td>API 错误(API errors)，服务器不会抛出该错误，该错误也只是用来标识错误范围的，错误值大于该值的标识 API 错误，而小于该值的标识 ZSYSTEMERROR。</td>\n</tr>\n<tr>\n<td>ZNONODE</td>\n<td>节点不存在(Node does not exist)</td>\n</tr>\n<tr>\n<td>ZNOAUTH</td>\n<td>没有经过授权(Not authenticated)</td>\n</tr>\n<tr>\n<td>ZBADVERSION</td>\n<td>版本冲突(Version conflict)</td>\n</tr>\n<tr>\n<td>ZNOCHILDRENFOREPHEMERALS</td>\n<td>临时节点不能拥有子节点(Ephemeral nodes may not have children)</td>\n</tr>\n<tr>\n<td>ZNODEEXISTS</td>\n<td>节点已经存在(The node already exists)</td>\n</tr>\n<tr>\n<td>ZNOTEMPTY</td>\n<td>该节点具有自身的子节点(The node has children)</td>\n</tr>\n<tr>\n<td>ZSESSIONEXPIRED</td>\n<td>会话过期(The session has been expired by the server)</td>\n</tr>\n<tr>\n<td>ZINVALIDCALLBACK</td>\n<td>非法的回调函数(Invalid callback specified)</td>\n</tr>\n<tr>\n<td>ZINVALIDACL</td>\n<td>非法的ACL(Invalid ACL specified)</td>\n</tr>\n<tr>\n<td>ZAUTHFAILED</td>\n<td>客户端授权失败(Client authentication failed)</td>\n</tr>\n<tr>\n<td>ZCLOSING</td>\n<td>Zookeeper 连接关闭(ZooKeeper is closing)</td>\n</tr>\n<tr>\n<td>ZNOTHING</td>\n<td>并非错误，客户端不需要处理服务器的响应(not error, no server responses to process)</td>\n</tr>\n<tr>\n<td>ZSESSIONMOVED</td>\n<td>会话转移至其他服务器，所以操作被忽略(session moved to another server, so operation is ignored) </td>\n</tr>\n</tbody>\n</table>\n</div>\n<h5 id=\"Watch事件类型：\"><a href=\"#Watch事件类型：\" class=\"headerlink\" title=\"Watch事件类型：\"></a>Watch事件类型：</h5><ul>\n<li>ZOO_CREATED_EVENT：节点创建事件，需要watch一个不存在的节点，当节点被创建时触发，此watch通过zoo_exists()设置</li>\n<li>ZOO_DELETED_EVENT：节点删除事件，此watch通过zoo_exists()或zoo_get()设置</li>\n<li>ZOO_CHANGED_EVENT：节点数据改变事件，此watch通过zoo_exists()或zoo_get()设置</li>\n<li>ZOO_CHILD_EVENT：子节点列表改变事件，此watch通过zoo_get_children()或zoo_get_children2()设置</li>\n<li>ZOO_SESSION_EVENT：会话失效事件，客户端与服务端断开或重连时触发</li>\n<li>ZOO_NOTWATCHING_EVENT：watch移除事件，服务端出于某些原因不再为客户端watch节点时触发</li>\n</ul>"},{"layout":"book","title":"java核心技术 卷I","date":"2016-12-31T16:00:00.000Z","cover":"coreJavaVolume1.jpeg","word":false,"_content":"","source":"_posts/read/coreJava.md","raw":"---\nlayout: book\ntitle: java核心技术 卷I\ndate: 2017/01/01\ncover: coreJavaVolume1.jpeg\nword: false\ncategories: [read]\n---\n","slug":"read/coreJava","published":1,"updated":"2017-02-05T02:18:41.000Z","comments":1,"photos":[],"link":"","_id":"cizbemkmd0009sebfxy4zq0uz","content":"","excerpt":"","more":""},{"layout":"book","title":"牛奶可乐经济学","date":"2016-12-14T16:00:00.000Z","cover":"milk.jpeg","word":false,"_content":"","source":"_posts/read/economics.md","raw":"---\nlayout: book\ntitle: 牛奶可乐经济学\ndate: 2016/12/15\ncover: milk.jpeg\nword: false\ncategories: [read]\n---\n","slug":"read/economics","published":1,"updated":"2017-02-05T02:21:25.000Z","comments":1,"photos":[],"link":"","_id":"cizbemkmi000bsebfh4pqbesj","content":"","excerpt":"","more":""},{"layout":"book","title":"乌合之众","date":"2016-12-31T16:00:00.000Z","cover":"crowd.png","word":false,"_content":"","source":"_posts/read/crowd.md","raw":"---\nlayout: book\ntitle: 乌合之众\ndate: 2017/01/01\ncover: crowd.png\nword: false\ncategories: [read]\n---\n","slug":"read/crowd","published":1,"updated":"2017-02-05T02:38:29.000Z","comments":1,"photos":[],"link":"","_id":"cizbemkmk000esebf9434cfkc","content":"","excerpt":"","more":""},{"layout":"book","title":"当我们谈论爱情时，我们在谈论什么","date":"2016-12-14T16:00:00.000Z","cover":"love.jpeg","word":false,"_content":"","source":"_posts/read/love.md","raw":"---\nlayout: book\ntitle: 当我们谈论爱情时，我们在谈论什么\ndate: 2016/12/15\ncover: love.jpeg\nword: false\ncategories: [read]\n---\n","slug":"read/love","published":1,"updated":"2017-02-05T02:17:12.000Z","comments":1,"photos":[],"link":"","_id":"cizbemkmm000hsebfufp4xh5f","content":"","excerpt":"","more":""},{"layout":"book","title":"父与子","date":"2016-12-31T16:00:00.000Z","cover":"fatherAndSon.jpeg","word":false,"_content":"","source":"_posts/read/fatherAndSon.md","raw":"---\nlayout: book\ntitle: 父与子\ndate: 2017/01/01\ncover: fatherAndSon.jpeg\nword: false\ncategories: [read]\n---\n","slug":"read/fatherAndSon","published":1,"updated":"2017-02-05T02:19:32.000Z","comments":1,"photos":[],"link":"","_id":"cizbemkmn000isebfngddp3qv","content":"","excerpt":"","more":""},{"layout":"book","title":"解忧杂货铺","date":"2016-12-14T16:00:00.000Z","cover":"varietyShop.jpeg","word":false,"_content":"","source":"_posts/read/love0.md","raw":"---\nlayout: book\ntitle: 解忧杂货铺\ndate: 2016/12/15\ncover: varietyShop.jpeg\nword: false\ncategories: [read]\n---\n","slug":"read/love0","published":1,"updated":"2017-02-05T02:23:41.000Z","comments":1,"photos":[],"link":"","_id":"cizbemkmq000lsebfukkfxjpx","content":"","excerpt":"","more":""},{"layout":"book","title":"爱你就像爱生命","date":"2016-12-14T16:00:00.000Z","cover":"loveYou.jpeg","word":false,"_content":"","source":"_posts/read/loveYou.md","raw":"---\nlayout: book\ntitle: 爱你就像爱生命\ndate: 2016/12/15\ncover: loveYou.jpeg\nword: false\ncategories: [read]\n---\n","slug":"read/loveYou","published":1,"updated":"2017-02-05T02:20:49.000Z","comments":1,"photos":[],"link":"","_id":"cizbemkmr000osebfv942zx00","content":"","excerpt":"","more":""},{"layout":"book","title":"Java编程思想","date":"2016-12-14T16:00:00.000Z","cover":"thinkingInJava.jpeg","word":false,"_content":"","source":"_posts/read/thinkInJava.md","raw":"---\nlayout: book\ntitle: Java编程思想\ndate: 2016/12/15\ncover: thinkingInJava.jpeg\nword: false\ncategories: [read]\n---\n","slug":"read/thinkInJava","published":1,"updated":"2017-02-05T02:25:06.000Z","comments":1,"photos":[],"link":"","_id":"cizbemkmu000tsebfvei5ozh0","content":"","excerpt":"","more":""}],"PostAsset":[],"PostCategory":[{"post_id":"cizbemkmm000hsebfufp4xh5f","category_id":"cizbemkmk000dsebfd9865xpj","_id":"cizbemkmr000nsebf80u0bonn"},{"post_id":"cizbemkmd0009sebfxy4zq0uz","category_id":"cizbemkmk000dsebfd9865xpj","_id":"cizbemkmu000ssebfgk7hruze"},{"post_id":"cizbemkmn000isebfngddp3qv","category_id":"cizbemkmk000dsebfd9865xpj","_id":"cizbemkmv000usebfa1jn47o4"},{"post_id":"cizbemkmq000lsebfukkfxjpx","category_id":"cizbemkmk000dsebfd9865xpj","_id":"cizbemkmw000wsebflumlxky3"},{"post_id":"cizbemkmi000bsebfh4pqbesj","category_id":"cizbemkmk000dsebfd9865xpj","_id":"cizbemkmw000ysebfmeuiiadz"},{"post_id":"cizbemkmr000osebfv942zx00","category_id":"cizbemkmk000dsebfd9865xpj","_id":"cizbemkmw0011sebf5jc8rzx9"},{"post_id":"cizbemkmu000tsebfvei5ozh0","category_id":"cizbemkmk000dsebfd9865xpj","_id":"cizbemkmy0012sebfga2khaek"},{"post_id":"cizbemkmk000esebf9434cfkc","category_id":"cizbemkmk000dsebfd9865xpj","_id":"cizbemkmy0014sebfj08dcayp"}],"PostTag":[{"post_id":"cizbemklt0001sebfk6qkyv1k","tag_id":"cizbemkm00003sebf1df39dsl","_id":"cizbemkmj000csebfzsnnspkw"},{"post_id":"cizbemklt0001sebfk6qkyv1k","tag_id":"cizbemkma0007sebfy2zhtd7u","_id":"cizbemkml000fsebfka79qsob"},{"post_id":"cizbemklw0002sebf4jctsb5y","tag_id":"cizbemkm00003sebf1df39dsl","_id":"cizbemkmr000msebffhsv3qmd"},{"post_id":"cizbemklw0002sebf4jctsb5y","tag_id":"cizbemkma0007sebfy2zhtd7u","_id":"cizbemkmt000qsebfcq6wbidg"},{"post_id":"cizbemkm60004sebfchxxnug6","tag_id":"cizbemkm00003sebf1df39dsl","_id":"cizbemkmw000xsebfg6qtxsk7"},{"post_id":"cizbemkm60004sebfchxxnug6","tag_id":"cizbemkma0007sebfy2zhtd7u","_id":"cizbemkmw000zsebf5u4s3xf0"},{"post_id":"cizbemkm80005sebfgz6sqw91","tag_id":"cizbemkmv000vsebfdrgrj25b","_id":"cizbemkmy0015sebf8b7vpyf2"},{"post_id":"cizbemkm80005sebfgz6sqw91","tag_id":"cizbemkma0007sebfy2zhtd7u","_id":"cizbemkmz0016sebfl1x3wf0w"},{"post_id":"cizbemkm90006sebfklli44rl","tag_id":"cizbemkmy0013sebfumv3493q","_id":"cizbemkn00019sebfu6epwgq6"},{"post_id":"cizbemkm90006sebfklli44rl","tag_id":"cizbemkma0007sebfy2zhtd7u","_id":"cizbemkn0001asebf0346g7i5"},{"post_id":"cizbemkmb0008sebfsl5he4da","tag_id":"cizbemkmy0013sebfumv3493q","_id":"cizbemkn1001bsebfx8jadx32"},{"post_id":"cizbemkmb0008sebfsl5he4da","tag_id":"cizbemkma0007sebfy2zhtd7u","_id":"cizbemkn1001csebfblprjdo9"}],"Tag":[{"name":"arithmetic","_id":"cizbemkm00003sebf1df39dsl"},{"name":"index","_id":"cizbemkma0007sebfy2zhtd7u"},{"name":"life","_id":"cizbemkmv000vsebfdrgrj25b"},{"name":"note","_id":"cizbemkmy0013sebfumv3493q"}]}}