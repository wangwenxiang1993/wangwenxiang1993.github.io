{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/img/arithmetic/BinaryTree.png","path":"img/arithmetic/BinaryTree.png","modified":0,"renderable":0},{"_id":"source/img/arithmetic/WeightedRound.png","path":"img/arithmetic/WeightedRound.png","modified":0,"renderable":0},{"_id":"source/img/arithmetic/linked.jpg","path":"img/arithmetic/linked.jpg","modified":0,"renderable":0},{"_id":"source/img/arithmetic/dbscanR.png","path":"img/arithmetic/dbscanR.png","modified":0,"renderable":0},{"_id":"source/img/arithmetic/linked2.jpg","path":"img/arithmetic/linked2.jpg","modified":0,"renderable":0},{"_id":"source/img/book/1984.jpg","path":"img/book/1984.jpg","modified":0,"renderable":0},{"_id":"source/img/book/6hats.jpg","path":"img/book/6hats.jpg","modified":0,"renderable":0},{"_id":"source/img/book/AWidowforOneYear.jpg","path":"img/book/AWidowforOneYear.jpg","modified":0,"renderable":0},{"_id":"source/img/book/TangledSkein.jpg","path":"img/book/TangledSkein.jpg","modified":0,"renderable":0},{"_id":"source/img/book/coreJavaVolume1.jpeg","path":"img/book/coreJavaVolume1.jpeg","modified":0,"renderable":0},{"_id":"source/img/book/crowd.png","path":"img/book/crowd.png","modified":0,"renderable":0},{"_id":"source/img/book/dssd.jpg","path":"img/book/dssd.jpg","modified":0,"renderable":0},{"_id":"source/img/book/fatherAndSon.jpeg","path":"img/book/fatherAndSon.jpeg","modified":0,"renderable":0},{"_id":"source/img/book/goddess.jpg","path":"img/book/goddess.jpg","modified":0,"renderable":0},{"_id":"source/img/book/jiabiangou.jpg","path":"img/book/jiabiangou.jpg","modified":0,"renderable":0},{"_id":"source/img/book/goldenAge.jpg","path":"img/book/goldenAge.jpg","modified":0,"renderable":0},{"_id":"source/img/book/love.jpeg","path":"img/book/love.jpeg","modified":0,"renderable":0},{"_id":"source/img/book/loveYou.jpeg","path":"img/book/loveYou.jpeg","modified":0,"renderable":0},{"_id":"source/img/book/milk.jpeg","path":"img/book/milk.jpeg","modified":0,"renderable":0},{"_id":"source/img/book/redisinaction.jpg","path":"img/book/redisinaction.jpg","modified":0,"renderable":0},{"_id":"source/img/book/silentMajority.jpeg","path":"img/book/silentMajority.jpeg","modified":0,"renderable":0},{"_id":"source/img/book/thinkingInJava.jpeg","path":"img/book/thinkingInJava.jpeg","modified":0,"renderable":0},{"_id":"source/img/book/town.jpg","path":"img/book/town.jpg","modified":0,"renderable":0},{"_id":"source/img/book/walkAtNight.jpeg","path":"img/book/walkAtNight.jpeg","modified":0,"renderable":0},{"_id":"source/img/book/x.jpeg","path":"img/book/x.jpeg","modified":0,"renderable":0},{"_id":"source/img/note/javaClassLoading.png","path":"img/note/javaClassLoading.png","modified":0,"renderable":0},{"_id":"source/img/note/proxy.png","path":"img/note/proxy.png","modified":0,"renderable":0},{"_id":"source/img/note/redisString.png","path":"img/note/redisString.png","modified":0,"renderable":0},{"_id":"source/img/note/secretkey1.png","path":"img/note/secretkey1.png","modified":0,"renderable":0},{"_id":"source/img/note/secretkey10.png","path":"img/note/secretkey10.png","modified":0,"renderable":0},{"_id":"source/img/note/secretkey11.png","path":"img/note/secretkey11.png","modified":0,"renderable":0},{"_id":"source/img/note/secretkey13.png","path":"img/note/secretkey13.png","modified":0,"renderable":0},{"_id":"source/img/note/secretkey14.jpg","path":"img/note/secretkey14.jpg","modified":0,"renderable":0},{"_id":"source/img/note/secretkey15.png","path":"img/note/secretkey15.png","modified":0,"renderable":0},{"_id":"source/img/note/secretkey16.png","path":"img/note/secretkey16.png","modified":0,"renderable":0},{"_id":"source/img/note/secretkey18.png","path":"img/note/secretkey18.png","modified":0,"renderable":0},{"_id":"source/img/note/secretkey19.jpg","path":"img/note/secretkey19.jpg","modified":0,"renderable":0},{"_id":"source/img/note/secretkey2.png","path":"img/note/secretkey2.png","modified":0,"renderable":0},{"_id":"source/img/note/secretkey20.png","path":"img/note/secretkey20.png","modified":0,"renderable":0},{"_id":"source/img/note/secretkey3.png","path":"img/note/secretkey3.png","modified":0,"renderable":0},{"_id":"source/img/note/secretkey4.png","path":"img/note/secretkey4.png","modified":0,"renderable":0},{"_id":"source/img/note/secretkey5.png","path":"img/note/secretkey5.png","modified":0,"renderable":0},{"_id":"source/img/note/secretkey6.png","path":"img/note/secretkey6.png","modified":0,"renderable":0},{"_id":"source/img/note/secretkey8.png","path":"img/note/secretkey8.png","modified":0,"renderable":0},{"_id":"source/img/note/sso.png","path":"img/note/sso.png","modified":0,"renderable":0},{"_id":"source/img/pvalue/pvalue7.png","path":"img/pvalue/pvalue7.png","modified":0,"renderable":0},{"_id":"source/img/zookeeper/role.jpg","path":"img/zookeeper/role.jpg","modified":0,"renderable":0},{"_id":"source/img/zookeeper/zookeeper1.jpg","path":"img/zookeeper/zookeeper1.jpg","modified":0,"renderable":0},{"_id":"source/img/zookeeper/zookeeper2.jpg","path":"img/zookeeper/zookeeper2.jpg","modified":0,"renderable":0},{"_id":"source/img/zookeeper/zookeeperLc.jpg","path":"img/zookeeper/zookeeperLc.jpg","modified":0,"renderable":0},{"_id":"source/img/zookeeper/zookeeperLc2.jpg","path":"img/zookeeper/zookeeperLc2.jpg","modified":0,"renderable":0},{"_id":"source/img/zookeeper/zookeeperLc3.jpg","path":"img/zookeeper/zookeeperLc3.jpg","modified":0,"renderable":0},{"_id":"source/img/zookeeper/zookeeperLc4.jpg","path":"img/zookeeper/zookeeperLc4.jpg","modified":0,"renderable":0},{"_id":"source/img/zookeeper/zookeeperLc5.jpg","path":"img/zookeeper/zookeeperLc5.jpg","modified":0,"renderable":0},{"_id":"source/img/zookeeper/zookeeperModel.jpg","path":"img/zookeeper/zookeeperModel.jpg","modified":0,"renderable":0},{"_id":"themes/maybe/source/css/font-awesome.min.css","path":"css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/maybe/source/css/highlight.css","path":"css/highlight.css","modified":0,"renderable":1},{"_id":"themes/maybe/source/css/style.css","path":"css/style.css","modified":1,"renderable":1},{"_id":"themes/maybe/source/img/photo.png","path":"img/photo.png","modified":0,"renderable":1},{"_id":"themes/maybe/source/js/base.js","path":"js/base.js","modified":0,"renderable":1},{"_id":"themes/maybe/source/js/canvas-nest.min.js","path":"js/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/maybe/source/js/highlight.pack.js","path":"js/highlight.pack.js","modified":0,"renderable":1},{"_id":"themes/maybe/source/js/jquery.tagcloud.js","path":"js/jquery.tagcloud.js","modified":0,"renderable":1},{"_id":"source/img/arithmetic/dbscan.png","path":"img/arithmetic/dbscan.png","modified":0,"renderable":0},{"_id":"source/img/life/chongqing-bg.jpeg","path":"img/life/chongqing-bg.jpeg","modified":0,"renderable":0},{"_id":"source/img/life/chongqing.jpeg","path":"img/life/chongqing.jpeg","modified":0,"renderable":0},{"_id":"source/img/life/yllh.jpeg","path":"img/life/yllh.jpeg","modified":0,"renderable":0},{"_id":"source/img/note/javassist.png","path":"img/note/javassist.png","modified":0,"renderable":0},{"_id":"source/img/note/secretkey7.png","path":"img/note/secretkey7.png","modified":0,"renderable":0},{"_id":"source/img/note/secretkey9.png","path":"img/note/secretkey9.png","modified":0,"renderable":0},{"_id":"source/img/pvalue/pvalue1.png","path":"img/pvalue/pvalue1.png","modified":0,"renderable":0},{"_id":"source/img/pvalue/pvalue2.png","path":"img/pvalue/pvalue2.png","modified":0,"renderable":0},{"_id":"themes/maybe/source/fonts/FontAwesome.otf","path":"fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/maybe/source/fonts/fontawesome-webfont.eot","path":"fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/maybe/source/fonts/fontawesome-webfont.woff","path":"fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/maybe/source/fonts/fontawesome-webfont.woff2","path":"fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/maybe/source/img/favicon.ico","path":"img/favicon.ico","modified":0,"renderable":1},{"_id":"themes/maybe/source/img/guide.jpeg","path":"img/guide.jpeg","modified":0,"renderable":1},{"_id":"themes/maybe/source/js/jquery-1.7.1.min.js","path":"js/jquery-1.7.1.min.js","modified":0,"renderable":1},{"_id":"source/img/book/jvm.jpeg","path":"img/book/jvm.jpeg","modified":0,"renderable":0},{"_id":"source/img/book/silverage.jpeg","path":"img/book/silverage.jpeg","modified":0,"renderable":0},{"_id":"source/img/book/varietyShop.jpeg","path":"img/book/varietyShop.jpeg","modified":0,"renderable":0},{"_id":"source/img/life/2016-bg.jpg","path":"img/life/2016-bg.jpg","modified":0,"renderable":0},{"_id":"source/img/life/2016-roommate.jpeg","path":"img/life/2016-roommate.jpeg","modified":0,"renderable":0},{"_id":"source/img/life/cqupt.jpeg","path":"img/life/cqupt.jpeg","modified":0,"renderable":0},{"_id":"source/img/life/fish.jpeg","path":"img/life/fish.jpeg","modified":0,"renderable":0},{"_id":"source/img/life/myself.jpeg","path":"img/life/myself.jpeg","modified":0,"renderable":0},{"_id":"source/img/life/qiuwei.jpeg","path":"img/life/qiuwei.jpeg","modified":0,"renderable":0},{"_id":"source/img/note/dubbo/dubbo1.png","path":"img/note/dubbo/dubbo1.png","modified":0,"renderable":0},{"_id":"source/img/note/dubbo/dubbo2.png","path":"img/note/dubbo/dubbo2.png","modified":0,"renderable":0},{"_id":"source/img/note/dubbo/dubbo3.png","path":"img/note/dubbo/dubbo3.png","modified":0,"renderable":0},{"_id":"source/img/note/jdk/aqs.png","path":"img/note/jdk/aqs.png","modified":0,"renderable":0},{"_id":"source/img/note/jdk/aqs1.png","path":"img/note/jdk/aqs1.png","modified":0,"renderable":0},{"_id":"source/img/note/jdk/blockingqueue.png","path":"img/note/jdk/blockingqueue.png","modified":0,"renderable":0},{"_id":"source/img/note/secretkey12.png","path":"img/note/secretkey12.png","modified":0,"renderable":0},{"_id":"source/img/note/secretkey17.png","path":"img/note/secretkey17.png","modified":0,"renderable":0},{"_id":"source/img/pvalue/pvalue3.jpeg","path":"img/pvalue/pvalue3.jpeg","modified":0,"renderable":0},{"_id":"source/img/pvalue/pvalue4.png","path":"img/pvalue/pvalue4.png","modified":0,"renderable":0},{"_id":"source/img/pvalue/pvalue5.png","path":"img/pvalue/pvalue5.png","modified":0,"renderable":0},{"_id":"source/img/pvalue/pvalue6.png","path":"img/pvalue/pvalue6.png","modified":0,"renderable":0},{"_id":"themes/maybe/source/fonts/fontawesome-webfont.ttf","path":"fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/maybe/source/img/home-bg.jpg","path":"img/home-bg.jpg","modified":0,"renderable":1},{"_id":"themes/maybe/source/img/note-bg.jpg","path":"img/note-bg.jpg","modified":0,"renderable":1},{"_id":"themes/maybe/source/img/read-bg.jpg","path":"img/read-bg.jpg","modified":0,"renderable":1},{"_id":"themes/maybe/source/img/river-bg.jpg","path":"img/river-bg.jpg","modified":0,"renderable":1},{"_id":"source/img/life/2016-qunar.jpeg","path":"img/life/2016-qunar.jpeg","modified":0,"renderable":0},{"_id":"source/img/note/ThreadLocal.png","path":"img/note/ThreadLocal.png","modified":0,"renderable":0},{"_id":"themes/maybe/source/img/life-bg.jpg","path":"img/life-bg.jpg","modified":0,"renderable":1},{"_id":"source/img/book/pestis.jpeg","path":"img/book/pestis.jpeg","modified":0,"renderable":0},{"_id":"source/img/note/dubbo/dubbo-framework.jpg","path":"img/note/dubbo/dubbo-framework.jpg","modified":0,"renderable":0},{"_id":"themes/maybe/source/fonts/fontawesome-webfont.svg","path":"fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/maybe/source/img/project-bg.jpg","path":"img/project-bg.jpg","modified":0,"renderable":1},{"_id":"themes/maybe/source/img/guide.png","path":"img/guide.png","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/resume.md","hash":"d3d3ef1aed3e740036e35e97243d5fce1342b8ae","modified":1525784414292},{"_id":"themes/maybe/layout/book.ejs","hash":"1984cec69d4bc8bf58a2d66d01348f3d5ee3a077","modified":1525784414375},{"_id":"themes/maybe/layout/category.ejs","hash":"38d62125a1e0c9a8ea602a03b6d27949aea98162","modified":1525784414375},{"_id":"themes/maybe/layout/layout.ejs","hash":"bbbd28c8cf82e79b0f97f8cdedc993ed9e174440","modified":1525784414376},{"_id":"themes/maybe/layout/index.ejs","hash":"1e14b73b3d56be216921ceae2c927a70978961ad","modified":1525784414376},{"_id":"themes/maybe/layout/post.ejs","hash":"7894bb0c10b9767d5bce302cdffcaaa2b1446379","modified":1525784414376},{"_id":"themes/maybe/layout/tag.ejs","hash":"64ecf63ea41b010efd6db9f85a541ce9f4c02044","modified":1525784414377},{"_id":"source/_posts/life/chongqing.md","hash":"27b772537b8514a4378d7c032e4d56cc6f260fc6","modified":1525789462675},{"_id":"source/_posts/life/failure.md","hash":"77eb902602bca56cfd866cfe70b8c8e4ce35f36b","modified":1525789462678},{"_id":"source/_posts/life/interview.md","hash":"9090302ad9ed0a5233d11ea3528b118897acc8c1","modified":1525784414270},{"_id":"source/_posts/life/summary-2016.md","hash":"1e82d38cbd903c42439894f3255a07336197cfd5","modified":1525789490860},{"_id":"source/_posts/life/yunnan.md","hash":"813f8e443480ea308b1ba957c54166ebf3f760f8","modified":1525784414271},{"_id":"source/_posts/note/fastjson.md","hash":"0ad3a3979d22773eb0dd00bb53bb5b1a4ef25c24","modified":1525784414277},{"_id":"source/_posts/note/secretKey.md","hash":"939c329b2c6179e4256ff6f9330c3fcacc912564","modified":1525784414283},{"_id":"source/_posts/note/sso.md","hash":"c4f32bdefa9f2e759914d83ba139e63e0ec974b8","modified":1525784414284},{"_id":"source/_posts/note/vimNotes.md","hash":"560fe13b651165ebaa2e104c1fcb944e277118fd","modified":1525784414285},{"_id":"source/_posts/note/zookeeper.md","hash":"afc684320a8be129fe00e32475756faf1e5018af","modified":1525784414285},{"_id":"source/_posts/read/1984.md","hash":"19a787490266891fcec9c5d1eee899f04682db0e","modified":1525784414286},{"_id":"source/_posts/read/6hats.md","hash":"b14d34157d8d4f128ac61f9c6bd1e5686084c69a","modified":1525784414286},{"_id":"source/_posts/read/GriefGroceryStore.md","hash":"5e270b760dbad759dce89c327e09e0d5b8c9da3e","modified":1525784414286},{"_id":"source/_posts/read/aWidowforOneYear.md","hash":"900c453b32407630bb71d4a2865d0f4a2bc7d2dc","modified":1525784414287},{"_id":"source/_posts/read/coreJava.md","hash":"2955b82a0e95153737331a498a3e690d005be470","modified":1525784414287},{"_id":"source/_posts/read/crowd.md","hash":"88d77eb906123f1047e63ece096d03ab6e1b6735","modified":1525784414287},{"_id":"source/_posts/read/dssd.md","hash":"a74d3212230511aedf24b7f2699c23e98db79b11","modified":1525784414287},{"_id":"source/_posts/read/economics.md","hash":"446508ffe4a3625daf833deb32e1b83e344270d3","modified":1525784414288},{"_id":"source/_posts/read/fatherAndSon.md","hash":"30a52dee9d63b61c5cb5cc2365e68ec9ebffc6b5","modified":1525784414288},{"_id":"source/_posts/read/goddess.md","hash":"b75c641cdb2b9ec2e4a42a54f1384deeeff2c2a9","modified":1525784414288},{"_id":"source/_posts/read/goldenAge.md","hash":"c96420022e590e61c73cb17e41662d73c007408b","modified":1525784414289},{"_id":"source/_posts/read/jiabiangou.md","hash":"f6af8a8e279dd30f60b738a0716e31bd1f21f080","modified":1525784414289},{"_id":"source/_posts/read/jvm.md","hash":"6623aff4905fe0e8156fcad16933962a215cec10","modified":1525784414289},{"_id":"source/_posts/read/love.md","hash":"0f557c57a5a51d4d2734a9cfa145d4d057625acb","modified":1525784414289},{"_id":"source/_posts/read/loveYou.md","hash":"f212c22013f27962bf1ab9194b6187c0c787c190","modified":1525784414290},{"_id":"source/_posts/read/pestis.md","hash":"03e4adf7dce4a47442f43065bbb9b17b285a91ae","modified":1525784414290},{"_id":"source/_posts/read/redisinaction.md","hash":"937d3227076bcd2cbb1fe68364ff60c50149eb7f","modified":1525784414290},{"_id":"source/_posts/read/silentMajority.md","hash":"75a72bdf136de653876bd8907f9ea8b1f8b09d4d","modified":1525784414291},{"_id":"source/_posts/read/silverage.md","hash":"c23874c553a8e347e62d3a74b7fdbaed401b4570","modified":1525784414291},{"_id":"source/_posts/read/tangledSkein.md","hash":"cee997c94a2eadfb48aaa2ed0a8f34450222e508","modified":1525784414291},{"_id":"source/_posts/read/thinkInJava.md","hash":"d9c5c8b3d4ab522f72e8c2b2a88e07bfda0daf32","modified":1525784414291},{"_id":"source/_posts/read/town.md","hash":"37b5889fe2055d597eba94812d5324be820b70e1","modified":1525784414292},{"_id":"source/_posts/read/walkAtNight.md","hash":"315f16f86963923a66a6b038333e5632aa03de70","modified":1525784414292},{"_id":"source/_posts/read/x.md","hash":"08e0ad45fc0f0fe899501da5ff3db0e5cd0f9ba5","modified":1525784414292},{"_id":"source/img/arithmetic/BinaryTree.png","hash":"d9ef674ba717242f55c9c5decf2aae551e207069","modified":1525784414293},{"_id":"source/img/arithmetic/WeightedRound.png","hash":"c2605f118f2a294b7202bab619f2fad30a712dd4","modified":1525784414294},{"_id":"source/img/arithmetic/linked.jpg","hash":"df3837050ce67ed7aedfda7a6454e4dedbe3af67","modified":1525784414296},{"_id":"source/img/arithmetic/dbscanR.png","hash":"2e1f8bc77c25f4b011679b0c95c5abd5d1bb7451","modified":1525784414296},{"_id":"source/img/arithmetic/linked2.jpg","hash":"8f1a60ba2b8a52ce2523601e74876f73535d5ee5","modified":1525784414297},{"_id":"source/img/book/1984.jpg","hash":"657d7f593bd28718d87dfe696463958431e4588d","modified":1525784414298},{"_id":"source/img/book/6hats.jpg","hash":"4bfdc0838cf94daaefbdb70d0d2daa2b3bb71611","modified":1525784414298},{"_id":"source/img/book/AWidowforOneYear.jpg","hash":"b646711e99224bb305f8451c369fc7f56ee831e3","modified":1525784414299},{"_id":"source/img/book/TangledSkein.jpg","hash":"5411c3b479d8a41427d123f45f8b68faf5cf2725","modified":1525784414299},{"_id":"source/img/book/coreJavaVolume1.jpeg","hash":"8ac34b32089baa4b522bd353339e79f74a807ca2","modified":1525784414300},{"_id":"source/img/book/crowd.png","hash":"c361d7acab3ce2677fe3a36ee7e60a72798ed0b8","modified":1525784414300},{"_id":"source/img/book/dssd.jpg","hash":"f53c8adc6c593617561decee55eb53c37dbffb70","modified":1525784414301},{"_id":"source/img/book/fatherAndSon.jpeg","hash":"9e646337ead2f99132e452c8b1d2990ff5bcea6e","modified":1525784414301},{"_id":"source/img/book/goddess.jpg","hash":"d9ff3c5168db65bda987bc582ade71e472ea2602","modified":1525784414302},{"_id":"source/img/book/jiabiangou.jpg","hash":"7a03678b82ab1a92bd4c0feffa5ee4ff72d116e1","modified":1525784414303},{"_id":"source/img/book/goldenAge.jpg","hash":"d74779434ac03d77554ad6b12d2e60c8ab7c42b9","modified":1525784414302},{"_id":"source/img/book/love.jpeg","hash":"10370ec4f714a1db9e039eccb697f3755ac51012","modified":1525784414305},{"_id":"source/img/book/loveYou.jpeg","hash":"b8b1df875965e3064b30cbdeecb507e3c4355371","modified":1525784414305},{"_id":"source/img/book/milk.jpeg","hash":"8689c651dbb9f897e3a5071c4c49c43050a1cae4","modified":1525784414306},{"_id":"source/img/book/redisinaction.jpg","hash":"3ad881d22c5c5bb3096c433538fad8fcd00783eb","modified":1525784414309},{"_id":"source/img/book/silentMajority.jpeg","hash":"154a59d24ff8c9c4fc7dfe69fd1bd3afad05aa26","modified":1525784414309},{"_id":"source/img/book/thinkingInJava.jpeg","hash":"d06ecc2cc3ed14957e01383288588b83368de1b5","modified":1525784414311},{"_id":"source/img/book/town.jpg","hash":"b4b00fda9d63d31b7e60528bbfec5b042c84594e","modified":1525784414312},{"_id":"source/img/book/walkAtNight.jpeg","hash":"c8cc896b67e7757c831896416a16516fdc34edc9","modified":1525784414313},{"_id":"source/img/book/x.jpeg","hash":"31be6f9347ff7c554df017e0e5587afd7a54a1bf","modified":1525784414314},{"_id":"source/img/note/javaClassLoading.png","hash":"16591e43fda9e6d4ceb1da5f35ebcd72378618ea","modified":1525784414336},{"_id":"source/img/note/proxy.png","hash":"860ded823ee18e895678707406c140c5a0dd1a4f","modified":1525784414340},{"_id":"source/img/note/redisString.png","hash":"a1ecd38c51481ad56ce9378505e9c734df9b25e8","modified":1525784414340},{"_id":"source/img/note/secretkey1.png","hash":"be22f8d379a64a49d2dffa72f4010d5bb6a69e2c","modified":1525784414341},{"_id":"source/img/note/secretkey10.png","hash":"a9e6a93bf9fbb48378c094f15c8a0d57368f178c","modified":1525784414342},{"_id":"source/img/note/secretkey11.png","hash":"4e36aad5297b9510ee140a49c264648f08ff05e8","modified":1525784414342},{"_id":"source/img/note/secretkey13.png","hash":"bd844fe0071827fe03fe41a12fd952db0fc80cac","modified":1525784414344},{"_id":"source/img/note/secretkey14.jpg","hash":"ca2f64a3efe33a0dc67c757d21c187895c5f3d43","modified":1525784414345},{"_id":"source/img/note/secretkey15.png","hash":"c72a7c54229fc249b24deb9febdd734e89cac89c","modified":1525784414346},{"_id":"source/img/note/secretkey16.png","hash":"9752d983379cdd21b2075fd01c8868946fcf9035","modified":1525784414346},{"_id":"source/img/note/secretkey18.png","hash":"52900b1460bd2d4732483bcb5a48d6ea6082eb88","modified":1525784414349},{"_id":"source/img/note/secretkey19.jpg","hash":"67ae9db1b2c2b6b67477ed98e0b3a826a2b3aeaf","modified":1525784414349},{"_id":"source/img/note/secretkey2.png","hash":"439d5fd8256f90701519052557d56b122bcb2592","modified":1525784414350},{"_id":"source/img/note/secretkey20.png","hash":"50bf4bf5ff3c6eb026c82978b18eb3f5d9af9acd","modified":1525784414351},{"_id":"source/img/note/secretkey3.png","hash":"699bc451171e1be86d7b5319c2000967954d00fe","modified":1525784414351},{"_id":"source/img/note/secretkey4.png","hash":"ff2a98019333df6697a12b4a84c970a2c007e8a8","modified":1525784414352},{"_id":"source/img/note/secretkey5.png","hash":"d630a0577a4e8a3c4ad09127272e33888ae2bb43","modified":1525784414353},{"_id":"source/img/note/secretkey6.png","hash":"9403bfe3f2780ea99f387a0eb04c725083959c0a","modified":1525784414353},{"_id":"source/img/note/secretkey8.png","hash":"82d1fc38824a2df7daab49f0e342ccb0d3e704f4","modified":1525784414355},{"_id":"source/img/note/sso.png","hash":"b44870bf2a57ba957b97726417c749ba5b4cf51b","modified":1525784414357},{"_id":"source/img/pvalue/pvalue7.png","hash":"bfc9e87c820598e35401f3e526f6f57101efe170","modified":1525784414366},{"_id":"source/img/zookeeper/role.jpg","hash":"d122fcac106bc7683d39df78e0cdfd9872ffdce2","modified":1525784414366},{"_id":"source/img/zookeeper/zookeeper1.jpg","hash":"a0fc99c61a07863e1e2e6578644b9b4c8d7e9a9d","modified":1525784414367},{"_id":"source/img/zookeeper/zookeeper2.jpg","hash":"90d4398129d68d137a308b9b2af2cd85777f5daf","modified":1525784414367},{"_id":"source/img/zookeeper/zookeeperLc.jpg","hash":"f0c2c035130233d388a1d5339b9796182e890223","modified":1525784414368},{"_id":"source/img/zookeeper/zookeeperLc2.jpg","hash":"97825787eebfb7f5076792a0022911d45808f24a","modified":1525784414368},{"_id":"source/img/zookeeper/zookeeperLc3.jpg","hash":"3279498c50ea972f1e5abbad70c0cb634faa2284","modified":1525784414369},{"_id":"source/img/zookeeper/zookeeperLc4.jpg","hash":"83582be653544a3717b8a67199fae5a2e5f871a9","modified":1525784414369},{"_id":"source/img/zookeeper/zookeeperLc5.jpg","hash":"da3a39de610f48d2eba48eb72105b0b11dbb34f3","modified":1525784414370},{"_id":"source/img/zookeeper/zookeeperModel.jpg","hash":"004e3d74e27234ca7a74ac15af37a3bbeac8331d","modified":1525784414370},{"_id":"themes/maybe/layout/_partial/article.ejs","hash":"821b4217e69e633d68749cbdc5e5edf4b2328498","modified":1525784414372},{"_id":"themes/maybe/layout/_partial/books.ejs","hash":"d1f7ad1d231c5890a0448c619e3206172f11da6b","modified":1525784414373},{"_id":"themes/maybe/layout/_partial/footer.ejs","hash":"672aab472f9d362e49b56ce44f3b1dd8a975541b","modified":1525784414373},{"_id":"themes/maybe/layout/_partial/info.ejs","hash":"a14ab3735947f3f9696f5371bdbdb17733bfcff8","modified":1525784414373},{"_id":"themes/maybe/layout/_partial/info_min.ejs","hash":"b07bf6f24231fc2165cb9cea437ee35ca8754cc7","modified":1525784414374},{"_id":"themes/maybe/layout/_partial/posts.ejs","hash":"40107c5b66386eac974e5f74c69d4c77fd2db0c6","modified":1525784414374},{"_id":"themes/maybe/layout/_partial/resume.ejs","hash":"bd559022a17bf00520e5dee65deb1317338bbf02","modified":1525784414375},{"_id":"themes/maybe/layout/_partial/title.ejs","hash":"b4c6a4211513ae837a923847fef107d5787d40a7","modified":1525784414375},{"_id":"themes/maybe/source/css/font-awesome.min.css","hash":"a3ee202873390015bbebdce1d4a150c8208043c5","modified":1525784414377},{"_id":"themes/maybe/source/css/highlight.css","hash":"b89f3798b9fdce33ba7618077cfc35a95a20ffe3","modified":1525784414378},{"_id":"themes/maybe/source/css/style.css","hash":"59a787bfb316fc11555ce7bdc273f402d4e0989c","modified":1525790938863},{"_id":"themes/maybe/source/img/photo.png","hash":"dab7b9e06f7a1321ad178288d17ac0cf474e17df","modified":1525784414403},{"_id":"themes/maybe/source/js/base.js","hash":"e1360046dca6b9693822922e1040335a0c13f55c","modified":1525784414409},{"_id":"themes/maybe/source/js/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1525784414409},{"_id":"themes/maybe/source/js/highlight.pack.js","hash":"c65d53d610fd48e1fbac66ac096699a4be8860fe","modified":1525784414410},{"_id":"themes/maybe/source/js/jquery.tagcloud.js","hash":"6d20fd10cc7ac4c2c94f206ac3285334b297cbf9","modified":1525784414411},{"_id":"source/img/arithmetic/dbscan.png","hash":"eaa2a99a49376840becdb2249b98a2d0bd42a819","modified":1525784414295},{"_id":"source/img/life/chongqing-bg.jpeg","hash":"c928c23fec7b87485d8452b421ec6e97dcfd153d","modified":1525784414320},{"_id":"source/img/life/chongqing.jpeg","hash":"1dbd3cc765e8647f2c8212885c1f92b7d5fe0da7","modified":1525784414321},{"_id":"source/img/life/yllh.jpeg","hash":"f5d37b61cece1507fff6f3161f9ce37c45d9c732","modified":1525784414330},{"_id":"source/img/note/javassist.png","hash":"68b5305aaf70acb1f4d8c4ea3482c8691ac1b228","modified":1525784414337},{"_id":"source/img/note/secretkey7.png","hash":"8e0af9de4f099d317045936ec87d9ac54e204af0","modified":1525784414354},{"_id":"source/img/note/secretkey9.png","hash":"fbe2d5f8d7adefd99d85b23e2ad50cd3f67bcfcc","modified":1525784414356},{"_id":"source/img/pvalue/pvalue1.png","hash":"cee2568e455fd434c2255f9aea92b045c598fd1c","modified":1525784414358},{"_id":"source/img/pvalue/pvalue2.png","hash":"8a4671f34809d8c4fe55a015dc8da626e58d581e","modified":1525784414359},{"_id":"themes/maybe/source/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1525784414380},{"_id":"themes/maybe/source/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1525784414380},{"_id":"themes/maybe/source/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1525784414386},{"_id":"themes/maybe/source/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1525784414387},{"_id":"themes/maybe/source/img/favicon.ico","hash":"306c23de9697d77d5a123ecb10eb4b3cf1ac3b49","modified":1525784414388},{"_id":"themes/maybe/source/img/guide.jpeg","hash":"5f82a588eef9afb72264df0e9ea68fe17911dfef","modified":1525784414388},{"_id":"themes/maybe/source/js/jquery-1.7.1.min.js","hash":"d1e1f3f0828fa66fb5744f42bc912694e06300f9","modified":1525784414411},{"_id":"source/_posts/note/arithmetic/JAVA-pValue.md","hash":"8a8351f49bd68ad1d61c84f2cf1796ce96d08fbd","modified":1525784414271},{"_id":"source/_posts/note/arithmetic/array.md","hash":"cd90d728717dd377c52e315d2c4a884849dc50f2","modified":1525784414272},{"_id":"source/_posts/note/arithmetic/array1.md","hash":"c072bc2e81fb610f028aea54334778416cd9757d","modified":1525784414272},{"_id":"source/_posts/note/arithmetic/binaryTree.md","hash":"576985dd2888d792483aff525668920cdd58d51e","modified":1525789462671},{"_id":"source/_posts/note/arithmetic/canopy.md","hash":"e78d4437387ee8d54d4536e778e760c203a5df05","modified":1525784414273},{"_id":"source/_posts/note/arithmetic/dbscan.md","hash":"413997705690e2db93400dc4312b11ebeee3b1ea","modified":1525784414273},{"_id":"source/_posts/note/arithmetic/glodBars.md","hash":"c28d485b12fbcd9917b400cbadef49b5bf40109d","modified":1525784414273},{"_id":"source/_posts/note/arithmetic/kmeans.md","hash":"907511285cea5cb52308f8d1cb53ee4af86c7caf","modified":1525784414274},{"_id":"source/_posts/note/arithmetic/leftString.md","hash":"2d69f74be139b49b8b34724a9fe0845166cae9f3","modified":1525784414274},{"_id":"source/_posts/note/arithmetic/linkedList.md","hash":"a2d2cdde851b59368cdbb5b0444ae6f6c3ef3240","modified":1525789462683},{"_id":"source/_posts/note/arithmetic/point2area.md","hash":"00c9c9ba1f7202d2fcec854c8681a024cfc0e004","modified":1525784414275},{"_id":"source/_posts/note/arithmetic/roundrobinWeight.md","hash":"d3566eb323425a96177928bf08715535381b33db","modified":1525784414275},{"_id":"source/_posts/note/arithmetic/stringContains.md","hash":"31386bf5ddb4cc328da8e726ab92f34f86de8ac6","modified":1525784414275},{"_id":"source/_posts/note/dubbo/loadBalance.md","hash":"0032a5ffcfdfbda3025726fda379fb47593c90c6","modified":1525784414276},{"_id":"source/_posts/note/dubbo/proxy.md","hash":"3068e2ccf3ed0804010684f47cabbfd05bc08690","modified":1525784414276},{"_id":"source/_posts/note/dubbo/serializable.md","hash":"c57806183e41416daf61b4a35490d6493c0e5d30","modified":1525784414277},{"_id":"source/_posts/note/dubbo/summarize.md","hash":"5849a62f26c9181f131a6a3b9620d880b5a8a276","modified":1525784414277},{"_id":"source/_posts/note/jdk/blockingQueue.md","hash":"8e55c67007e0a13099ac06b12405f60c5748bf2b","modified":1525784414278},{"_id":"source/_posts/note/jdk/javaAQS.md","hash":"23c14be6bde601dd7a35cfb0a94024fb6362c644","modified":1525784414278},{"_id":"source/_posts/note/jdk/javaClassLoading.md","hash":"0eefc32b022ecd58a67ef7d8f74e1a5d8b6cc04b","modified":1525784414279},{"_id":"source/_posts/note/jdk/javaDynamicProxy.md","hash":"59f30fc8704cdd1478f5f437346a44379f816513","modified":1525784414279},{"_id":"source/_posts/note/jdk/javaReenTrantLock.md","hash":"cb52a0df0f70dceedf316a45d54c02ab0e89f1a6","modified":1525784414279},{"_id":"source/_posts/note/jdk/threadLocal.md","hash":"8ac29e62ea25479b3894fb6c0b95a1d98b88ceba","modified":1525784414280},{"_id":"source/_posts/note/jdk/threadPoolExecutor.md","hash":"8fc8c61d837d3392e13c0f2fb2e26acda31e1643","modified":1525790991937},{"_id":"source/_posts/note/redis/redisPersistence.md","hash":"ff270674e028b6c794f21381a2468d729820cdfb","modified":1525784414281},{"_id":"source/_posts/note/redis/redisString.md","hash":"8e6c5b1bc697dc3a05e86d0088f092cac4acb626","modified":1525784414281},{"_id":"source/_posts/note/redis/redisTransaction.md","hash":"4da6da7cc285fe163f10168035ec393a16236b09","modified":1525784414281},{"_id":"source/_posts/note/river/RiverIntroduce.md","hash":"99479c466fc993b026de6c5bd237624cf24cbaef","modified":1525784414282},{"_id":"source/_posts/note/river/aop.md","hash":"ff8ea8de47b476e4a079ef07ce445ca8a303c886","modified":1525784414282},{"_id":"source/_posts/note/river/cache.md","hash":"3f7d7797b471e83dc23bcccdf1bf6aca1cd96307","modified":1525784414282},{"_id":"source/_posts/note/spring/springIoc.md","hash":"031ffd8fbda37c6899b8ba809a900443e2482b9d","modified":1525784414283},{"_id":"source/_posts/note/spring/springbootDynamic.md","hash":"7b8633a54a5f26a0110db102b00682e2f54524a1","modified":1525784414284},{"_id":"source/img/book/jvm.jpeg","hash":"eafe917dbaf8bbe60c5b62fb1ffd0f37525121b3","modified":1525784414304},{"_id":"source/img/book/silverage.jpeg","hash":"83af0fdc489c79d9cd56d8a68e4181e9621f0bbf","modified":1525784414310},{"_id":"source/img/book/varietyShop.jpeg","hash":"0198030d9d492b101a5deec63621d9746961aad8","modified":1525784414313},{"_id":"source/img/life/2016-bg.jpg","hash":"6710230ec17d4bebaaf0f8a457512433abf0dc97","modified":1525784414316},{"_id":"source/img/life/2016-roommate.jpeg","hash":"4e5a47e2d9aef492184e19b93a6b2aa93e029c8e","modified":1525784414319},{"_id":"source/img/life/cqupt.jpeg","hash":"e110e3ef0807b93d2549f2ef1b35e66323704cd1","modified":1525784414323},{"_id":"source/img/life/fish.jpeg","hash":"b36c84444a40f658a6d5a112989722e925f303fc","modified":1525784414324},{"_id":"source/img/life/jianshui.jpeg","hash":"9bdbec0a2d39c8e92d4f3dff1ce764f2a751b2b2","modified":1525784414326},{"_id":"source/img/life/myself.jpeg","hash":"2389e4b8d634824404b6a16ac6382f4cd367d180","modified":1525784414328},{"_id":"source/img/life/qiuwei.jpeg","hash":"fe3f9b98e3a75f067d835c29adc37fc0e32bac5e","modified":1525784414329},{"_id":"source/img/note/dubbo/dubbo1.png","hash":"2a358c2482c6cca4a5c532364f5f7d9e716a9d0d","modified":1525784414335},{"_id":"source/img/note/dubbo/dubbo2.png","hash":"f0f2bea084ecf4e84a8ed05539c828a4bf92d427","modified":1525784414335},{"_id":"source/img/note/dubbo/dubbo3.png","hash":"af1da2f0c89a252fa7aa3dc81d56c6eda11410ed","modified":1525784414336},{"_id":"source/img/note/jdk/aqs.png","hash":"d01eebe435cc53fd539818975ea4663ccad4338d","modified":1525784414338},{"_id":"source/img/note/jdk/aqs1.png","hash":"b9e6fbf0a215a1e101db47aa2381a85662705227","modified":1525784414339},{"_id":"source/img/note/jdk/blockingqueue.png","hash":"0bbb66087b0dc682beea53233885c0d3d0af51ba","modified":1525784414339},{"_id":"source/img/note/secretkey12.png","hash":"83346c36207aa6533fe4d85afd5855ce702214ce","modified":1525784414344},{"_id":"source/img/note/secretkey17.png","hash":"336ccad5e6a52fbba0577c3f607a65c27e23ddba","modified":1525784414348},{"_id":"source/img/pvalue/pvalue3.jpeg","hash":"8f7a050e342907a74e3ad35c3e52076eba5ac2f1","modified":1525784414361},{"_id":"source/img/pvalue/pvalue4.png","hash":"bae37ceaaa098f40ac342af9dc676e7dc00e0411","modified":1525784414362},{"_id":"source/img/pvalue/pvalue5.png","hash":"39a6690b579ee31d1ab6dab8dcc32456aaf787f8","modified":1525784414364},{"_id":"source/img/pvalue/pvalue6.png","hash":"5231c3636459437c1b3e9493dcaa3e82f7e9cb1d","modified":1525784414365},{"_id":"themes/maybe/layout/_partial/_widget/author.ejs","hash":"136dcaa261490bd94ce5b2543e2a517ecbc72e2e","modified":1525784414371},{"_id":"themes/maybe/layout/_partial/_widget/color.ejs","hash":"3b14d409ab84f375db489ce0657498971f425257","modified":1525784414372},{"_id":"themes/maybe/layout/_partial/_widget/url.ejs","hash":"87ec086d3544a2bafa0d47e0e8995317ef3b748c","modified":1525784414372},{"_id":"themes/maybe/layout/_partial/post/date.ejs","hash":"1a35973ab623f279b073ca6c526f547afb250906","modified":1525784414374},{"_id":"themes/maybe/source/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1525784414386},{"_id":"themes/maybe/source/img/home-bg.jpg","hash":"990f6f9dd0ecb5348bfcc47305553d58c0d8f326","modified":1525784414398},{"_id":"themes/maybe/source/img/note-bg.jpg","hash":"3e03d6c9590ea59075c7f5538d7da389f640fab6","modified":1525784414402},{"_id":"themes/maybe/source/img/read-bg.jpg","hash":"7fa2822cf1ae346c77f2fbb1a2aecb44899f0178","modified":1525784414407},{"_id":"themes/maybe/source/img/river-bg.jpg","hash":"0e60e28189fff882c534c946b1df6a3f8c164eb1","modified":1525784414408},{"_id":"source/img/life/2016-qunar.jpeg","hash":"076fc1b0b7008e0e183853ebbc5fe8160c704406","modified":1525784414317},{"_id":"source/img/note/ThreadLocal.png","hash":"6b61c575fea70117183e6a9ca554a19d69b2b423","modified":1525784414332},{"_id":"themes/maybe/source/img/life-bg.jpg","hash":"967bc3a78eaf83b9f27fd7e02618083b2446d45c","modified":1525784414401},{"_id":"source/img/book/pestis.jpeg","hash":"ce70a2c5cb44a584dc6ffa256029714d2aad36b7","modified":1525784414308},{"_id":"source/img/note/dubbo/dubbo-framework.jpg","hash":"956b54b92bc5c11635909a706fedde850930b89c","modified":1525784414334},{"_id":"themes/maybe/source/fonts/fontawesome-webfont.svg","hash":"c0522272bbaef2acb3d341912754d6ea2d0ecfc0","modified":1525784414383},{"_id":"themes/maybe/source/img/project-bg.jpg","hash":"309aa99f6db30ab07caeeb620e5b3d0f22f326b3","modified":1525784414406},{"_id":"themes/maybe/source/img/guide.png","hash":"01385d1071ee75c9e7eb358ec113b9eaaf097bf3","modified":1525784414396},{"_id":"source/_posts/note/arithmetic/bloomfilter.md","hash":"3e7e16010b8ce67acfabb6c730e3ef4bbf411f57","modified":1525790826551}],"Category":[{"name":"read","_id":"cjgxop3ld000jjah1vb7qi9an"}],"Data":[],"Page":[],"Post":[{"layout":"post","title":"王文祥的简历","date":"2017-02-12T16:00:00.000Z","type":"resume","_content":"","source":"_posts/resume.md","raw":"---\nlayout: post\ntitle: 王文祥的简历\ndate: 2017/02/13\ntype: resume\n---\n","slug":"resume","published":1,"updated":"2018-05-08T13:00:14.292Z","comments":1,"photos":[],"link":"","_id":"cjgxop3jb0000jah122dcxuue","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"post","title":"又到重庆","date":"2017-03-05T16:00:00.000Z","original":true,"img":"life/chongqing-bg.jpeg","_content":"\n##### 去年6月份毕业之后，怎么也没有先到这么快又回到的重庆。之前想过很多次，再到重庆的时候会是什么时候，可能是几年后的同学聚会，可能是工作休假去重庆游玩。但是无论怎样，也没有想到仅仅隔了半年就又到了重庆。\n<!--more-->\n\n##### 这次去重庆是因为部门的团建，原本计划去韩国或者是成都，投票之后就决定去重庆了（醉了）。其实我去重庆读书的时候，对重庆是没有多少感情的，觉得这个城市很陌生，没有家里好，这种感觉一直持续到大四，直到我离开重庆去北京工作和实习，才发现我已经对重庆有了一种莫名的情感在里面，虽然我没有在这里恋爱。这种情感在我下了飞机以后则更加明显。\n\n##### 到达重庆江北机场是在3月3号的凌晨1点，之前的一天我们还在公司卖力的工作。下了飞机以后便往预定的青年旅社赶，但是我们根本不是去休息的，因为我们的重庆之旅才刚刚开始，没有人想早早的睡觉。凌晨1点的重庆已经没有平时的拥堵，但是走在路上，我还是有一种特别熟悉的感觉，我对秋薇说，我好想还是一个学生。\n\n![青年旅舍合影](/img/life/chongqing.jpeg)    <div class='img-note'>青年旅舍合影</div>\n\n##### 我确实变成了一个学生，在我第二天来到重邮之后。公司没有组织大家集体活动，都是各自行动。第二天在离开青舍，找到酒店之后，我和秋薇便直奔重邮。说来很巧，我们住的酒店在解放碑，这里正好有346路公交车直达重邮。一路上的风景还是没有变，路过了南坪，路过了会展中心。其实大学期间我并没有去过重庆的多少地方，因为本身比较宅，加上整天和几个大老爷们待在一起，所以重庆的路我认识的实在不多，这点也被同事们吐槽了。\n\n##### 重邮在我眼里几乎就没有变，除了千喜鹤食堂。我顺着数图、老操场、篮球场、千喜鹤来到28栋。不知道是因为这条路太过于熟悉，还是学校变化实在不大，我没有了之前的激动，心情也慢慢平复下来。这一圈走完之后，竟然想着快点离开。当然，离开之前又去了一次\"火山石烫鱼\"。\n\n![重邮新食堂](/img/life/cqupt.jpeg)    <div class='img-note'>重邮新食堂</div>\n![火山石烫鱼](/img/life/fish.jpeg)    <div class='img-note'>火山石烫鱼</div>\n\n##### 如果说我为什么在离开重邮的时候又喜欢上了重庆，一定是因为那些人，那些同学和朋友。第二天我就见到了磊哥，还是原来的样子，几乎没有变。我们都是性格含蓄的人。因为时间比较紧，只和磊哥聊了一个小时左右，我们说了很多毕业后的感受，没有装逼，没有浮夸，说的都是真心话。磊哥确实变了，变成熟了，不再那么放荡不羁了。直到现在我都在想，我应该和磊哥去喝上几杯的。哎，不知道下次见面是什么时候。\n\n![余磊和刘航](/img/life/yllh.jpeg)    <div class='img-note'>余磊和刘航</div>\n\n##### 按道理来说，重庆应该是比北京更加湿润的。但我的症状却恰恰相反，因为没有唇膏，加上女朋友\"舍不得\"给我买新的，我的嘴唇周围已经干到龟裂。这实在是难受。后来分析可能是因为酒店的房间里面太干燥了。女朋友则比我更惨一些，亲戚来了，加上肚子疼，再加上感冒发烧导致声音沙哑，已经到了不能说话的地步。实在是好过不到哪里去。不过幸好有我的悉心照顾，最后安全返回北京。\n\n![秋薇和我](/img/life/qiuwei.jpeg)    <div class='img-note'>秋薇和我</div>\n","source":"_posts/life/chongqing.md","raw":"---\nlayout: post\ntitle: 又到重庆\ndate: 2017/03/06\ntags: [life, index]\noriginal: true\nimg: life/chongqing-bg.jpeg\n---\n\n##### 去年6月份毕业之后，怎么也没有先到这么快又回到的重庆。之前想过很多次，再到重庆的时候会是什么时候，可能是几年后的同学聚会，可能是工作休假去重庆游玩。但是无论怎样，也没有想到仅仅隔了半年就又到了重庆。\n<!--more-->\n\n##### 这次去重庆是因为部门的团建，原本计划去韩国或者是成都，投票之后就决定去重庆了（醉了）。其实我去重庆读书的时候，对重庆是没有多少感情的，觉得这个城市很陌生，没有家里好，这种感觉一直持续到大四，直到我离开重庆去北京工作和实习，才发现我已经对重庆有了一种莫名的情感在里面，虽然我没有在这里恋爱。这种情感在我下了飞机以后则更加明显。\n\n##### 到达重庆江北机场是在3月3号的凌晨1点，之前的一天我们还在公司卖力的工作。下了飞机以后便往预定的青年旅社赶，但是我们根本不是去休息的，因为我们的重庆之旅才刚刚开始，没有人想早早的睡觉。凌晨1点的重庆已经没有平时的拥堵，但是走在路上，我还是有一种特别熟悉的感觉，我对秋薇说，我好想还是一个学生。\n\n![青年旅舍合影](/img/life/chongqing.jpeg)    <div class='img-note'>青年旅舍合影</div>\n\n##### 我确实变成了一个学生，在我第二天来到重邮之后。公司没有组织大家集体活动，都是各自行动。第二天在离开青舍，找到酒店之后，我和秋薇便直奔重邮。说来很巧，我们住的酒店在解放碑，这里正好有346路公交车直达重邮。一路上的风景还是没有变，路过了南坪，路过了会展中心。其实大学期间我并没有去过重庆的多少地方，因为本身比较宅，加上整天和几个大老爷们待在一起，所以重庆的路我认识的实在不多，这点也被同事们吐槽了。\n\n##### 重邮在我眼里几乎就没有变，除了千喜鹤食堂。我顺着数图、老操场、篮球场、千喜鹤来到28栋。不知道是因为这条路太过于熟悉，还是学校变化实在不大，我没有了之前的激动，心情也慢慢平复下来。这一圈走完之后，竟然想着快点离开。当然，离开之前又去了一次\"火山石烫鱼\"。\n\n![重邮新食堂](/img/life/cqupt.jpeg)    <div class='img-note'>重邮新食堂</div>\n![火山石烫鱼](/img/life/fish.jpeg)    <div class='img-note'>火山石烫鱼</div>\n\n##### 如果说我为什么在离开重邮的时候又喜欢上了重庆，一定是因为那些人，那些同学和朋友。第二天我就见到了磊哥，还是原来的样子，几乎没有变。我们都是性格含蓄的人。因为时间比较紧，只和磊哥聊了一个小时左右，我们说了很多毕业后的感受，没有装逼，没有浮夸，说的都是真心话。磊哥确实变了，变成熟了，不再那么放荡不羁了。直到现在我都在想，我应该和磊哥去喝上几杯的。哎，不知道下次见面是什么时候。\n\n![余磊和刘航](/img/life/yllh.jpeg)    <div class='img-note'>余磊和刘航</div>\n\n##### 按道理来说，重庆应该是比北京更加湿润的。但我的症状却恰恰相反，因为没有唇膏，加上女朋友\"舍不得\"给我买新的，我的嘴唇周围已经干到龟裂。这实在是难受。后来分析可能是因为酒店的房间里面太干燥了。女朋友则比我更惨一些，亲戚来了，加上肚子疼，再加上感冒发烧导致声音沙哑，已经到了不能说话的地步。实在是好过不到哪里去。不过幸好有我的悉心照顾，最后安全返回北京。\n\n![秋薇和我](/img/life/qiuwei.jpeg)    <div class='img-note'>秋薇和我</div>\n","slug":"life/chongqing","published":1,"updated":"2018-05-08T14:51:18.331Z","_id":"cjgxop3kt0001jah1pnmtencg","comments":1,"photos":[],"link":"","content":"<h5 id=\"去年6月份毕业之后，怎么也没有先到这么快又回到的重庆。之前想过很多次，再到重庆的时候会是什么时候，可能是几年后的同学聚会，可能是工作休假去重庆游玩。但是无论怎样，也没有想到仅仅隔了半年就又到了重庆。\"><a href=\"#去年6月份毕业之后，怎么也没有先到这么快又回到的重庆。之前想过很多次，再到重庆的时候会是什么时候，可能是几年后的同学聚会，可能是工作休假去重庆游玩。但是无论怎样，也没有想到仅仅隔了半年就又到了重庆。\" class=\"headerlink\" title=\"去年6月份毕业之后，怎么也没有先到这么快又回到的重庆。之前想过很多次，再到重庆的时候会是什么时候，可能是几年后的同学聚会，可能是工作休假去重庆游玩。但是无论怎样，也没有想到仅仅隔了半年就又到了重庆。\"></a>去年6月份毕业之后，怎么也没有先到这么快又回到的重庆。之前想过很多次，再到重庆的时候会是什么时候，可能是几年后的同学聚会，可能是工作休假去重庆游玩。但是无论怎样，也没有想到仅仅隔了半年就又到了重庆。</h5><a id=\"more\"></a>\n<h5 id=\"这次去重庆是因为部门的团建，原本计划去韩国或者是成都，投票之后就决定去重庆了（醉了）。其实我去重庆读书的时候，对重庆是没有多少感情的，觉得这个城市很陌生，没有家里好，这种感觉一直持续到大四，直到我离开重庆去北京工作和实习，才发现我已经对重庆有了一种莫名的情感在里面，虽然我没有在这里恋爱。这种情感在我下了飞机以后则更加明显。\"><a href=\"#这次去重庆是因为部门的团建，原本计划去韩国或者是成都，投票之后就决定去重庆了（醉了）。其实我去重庆读书的时候，对重庆是没有多少感情的，觉得这个城市很陌生，没有家里好，这种感觉一直持续到大四，直到我离开重庆去北京工作和实习，才发现我已经对重庆有了一种莫名的情感在里面，虽然我没有在这里恋爱。这种情感在我下了飞机以后则更加明显。\" class=\"headerlink\" title=\"这次去重庆是因为部门的团建，原本计划去韩国或者是成都，投票之后就决定去重庆了（醉了）。其实我去重庆读书的时候，对重庆是没有多少感情的，觉得这个城市很陌生，没有家里好，这种感觉一直持续到大四，直到我离开重庆去北京工作和实习，才发现我已经对重庆有了一种莫名的情感在里面，虽然我没有在这里恋爱。这种情感在我下了飞机以后则更加明显。\"></a>这次去重庆是因为部门的团建，原本计划去韩国或者是成都，投票之后就决定去重庆了（醉了）。其实我去重庆读书的时候，对重庆是没有多少感情的，觉得这个城市很陌生，没有家里好，这种感觉一直持续到大四，直到我离开重庆去北京工作和实习，才发现我已经对重庆有了一种莫名的情感在里面，虽然我没有在这里恋爱。这种情感在我下了飞机以后则更加明显。</h5><h5 id=\"到达重庆江北机场是在3月3号的凌晨1点，之前的一天我们还在公司卖力的工作。下了飞机以后便往预定的青年旅社赶，但是我们根本不是去休息的，因为我们的重庆之旅才刚刚开始，没有人想早早的睡觉。凌晨1点的重庆已经没有平时的拥堵，但是走在路上，我还是有一种特别熟悉的感觉，我对秋薇说，我好想还是一个学生。\"><a href=\"#到达重庆江北机场是在3月3号的凌晨1点，之前的一天我们还在公司卖力的工作。下了飞机以后便往预定的青年旅社赶，但是我们根本不是去休息的，因为我们的重庆之旅才刚刚开始，没有人想早早的睡觉。凌晨1点的重庆已经没有平时的拥堵，但是走在路上，我还是有一种特别熟悉的感觉，我对秋薇说，我好想还是一个学生。\" class=\"headerlink\" title=\"到达重庆江北机场是在3月3号的凌晨1点，之前的一天我们还在公司卖力的工作。下了飞机以后便往预定的青年旅社赶，但是我们根本不是去休息的，因为我们的重庆之旅才刚刚开始，没有人想早早的睡觉。凌晨1点的重庆已经没有平时的拥堵，但是走在路上，我还是有一种特别熟悉的感觉，我对秋薇说，我好想还是一个学生。\"></a>到达重庆江北机场是在3月3号的凌晨1点，之前的一天我们还在公司卖力的工作。下了飞机以后便往预定的青年旅社赶，但是我们根本不是去休息的，因为我们的重庆之旅才刚刚开始，没有人想早早的睡觉。凌晨1点的重庆已经没有平时的拥堵，但是走在路上，我还是有一种特别熟悉的感觉，我对秋薇说，我好想还是一个学生。</h5><p><img src=\"/img/life/chongqing.jpeg\" alt=\"青年旅舍合影\">    <div class=\"img-note\">青年旅舍合影</div></p>\n<h5 id=\"我确实变成了一个学生，在我第二天来到重邮之后。公司没有组织大家集体活动，都是各自行动。第二天在离开青舍，找到酒店之后，我和秋薇便直奔重邮。说来很巧，我们住的酒店在解放碑，这里正好有346路公交车直达重邮。一路上的风景还是没有变，路过了南坪，路过了会展中心。其实大学期间我并没有去过重庆的多少地方，因为本身比较宅，加上整天和几个大老爷们待在一起，所以重庆的路我认识的实在不多，这点也被同事们吐槽了。\"><a href=\"#我确实变成了一个学生，在我第二天来到重邮之后。公司没有组织大家集体活动，都是各自行动。第二天在离开青舍，找到酒店之后，我和秋薇便直奔重邮。说来很巧，我们住的酒店在解放碑，这里正好有346路公交车直达重邮。一路上的风景还是没有变，路过了南坪，路过了会展中心。其实大学期间我并没有去过重庆的多少地方，因为本身比较宅，加上整天和几个大老爷们待在一起，所以重庆的路我认识的实在不多，这点也被同事们吐槽了。\" class=\"headerlink\" title=\"我确实变成了一个学生，在我第二天来到重邮之后。公司没有组织大家集体活动，都是各自行动。第二天在离开青舍，找到酒店之后，我和秋薇便直奔重邮。说来很巧，我们住的酒店在解放碑，这里正好有346路公交车直达重邮。一路上的风景还是没有变，路过了南坪，路过了会展中心。其实大学期间我并没有去过重庆的多少地方，因为本身比较宅，加上整天和几个大老爷们待在一起，所以重庆的路我认识的实在不多，这点也被同事们吐槽了。\"></a>我确实变成了一个学生，在我第二天来到重邮之后。公司没有组织大家集体活动，都是各自行动。第二天在离开青舍，找到酒店之后，我和秋薇便直奔重邮。说来很巧，我们住的酒店在解放碑，这里正好有346路公交车直达重邮。一路上的风景还是没有变，路过了南坪，路过了会展中心。其实大学期间我并没有去过重庆的多少地方，因为本身比较宅，加上整天和几个大老爷们待在一起，所以重庆的路我认识的实在不多，这点也被同事们吐槽了。</h5><h5 id=\"重邮在我眼里几乎就没有变，除了千喜鹤食堂。我顺着数图、老操场、篮球场、千喜鹤来到28栋。不知道是因为这条路太过于熟悉，还是学校变化实在不大，我没有了之前的激动，心情也慢慢平复下来。这一圈走完之后，竟然想着快点离开。当然，离开之前又去了一次”火山石烫鱼”。\"><a href=\"#重邮在我眼里几乎就没有变，除了千喜鹤食堂。我顺着数图、老操场、篮球场、千喜鹤来到28栋。不知道是因为这条路太过于熟悉，还是学校变化实在不大，我没有了之前的激动，心情也慢慢平复下来。这一圈走完之后，竟然想着快点离开。当然，离开之前又去了一次”火山石烫鱼”。\" class=\"headerlink\" title=\"重邮在我眼里几乎就没有变，除了千喜鹤食堂。我顺着数图、老操场、篮球场、千喜鹤来到28栋。不知道是因为这条路太过于熟悉，还是学校变化实在不大，我没有了之前的激动，心情也慢慢平复下来。这一圈走完之后，竟然想着快点离开。当然，离开之前又去了一次”火山石烫鱼”。\"></a>重邮在我眼里几乎就没有变，除了千喜鹤食堂。我顺着数图、老操场、篮球场、千喜鹤来到28栋。不知道是因为这条路太过于熟悉，还是学校变化实在不大，我没有了之前的激动，心情也慢慢平复下来。这一圈走完之后，竟然想着快点离开。当然，离开之前又去了一次”火山石烫鱼”。</h5><p><img src=\"/img/life/cqupt.jpeg\" alt=\"重邮新食堂\">    <div class=\"img-note\">重邮新食堂</div><br><img src=\"/img/life/fish.jpeg\" alt=\"火山石烫鱼\">    <div class=\"img-note\">火山石烫鱼</div></p>\n<h5 id=\"如果说我为什么在离开重邮的时候又喜欢上了重庆，一定是因为那些人，那些同学和朋友。第二天我就见到了磊哥，还是原来的样子，几乎没有变。我们都是性格含蓄的人。因为时间比较紧，只和磊哥聊了一个小时左右，我们说了很多毕业后的感受，没有装逼，没有浮夸，说的都是真心话。磊哥确实变了，变成熟了，不再那么放荡不羁了。直到现在我都在想，我应该和磊哥去喝上几杯的。哎，不知道下次见面是什么时候。\"><a href=\"#如果说我为什么在离开重邮的时候又喜欢上了重庆，一定是因为那些人，那些同学和朋友。第二天我就见到了磊哥，还是原来的样子，几乎没有变。我们都是性格含蓄的人。因为时间比较紧，只和磊哥聊了一个小时左右，我们说了很多毕业后的感受，没有装逼，没有浮夸，说的都是真心话。磊哥确实变了，变成熟了，不再那么放荡不羁了。直到现在我都在想，我应该和磊哥去喝上几杯的。哎，不知道下次见面是什么时候。\" class=\"headerlink\" title=\"如果说我为什么在离开重邮的时候又喜欢上了重庆，一定是因为那些人，那些同学和朋友。第二天我就见到了磊哥，还是原来的样子，几乎没有变。我们都是性格含蓄的人。因为时间比较紧，只和磊哥聊了一个小时左右，我们说了很多毕业后的感受，没有装逼，没有浮夸，说的都是真心话。磊哥确实变了，变成熟了，不再那么放荡不羁了。直到现在我都在想，我应该和磊哥去喝上几杯的。哎，不知道下次见面是什么时候。\"></a>如果说我为什么在离开重邮的时候又喜欢上了重庆，一定是因为那些人，那些同学和朋友。第二天我就见到了磊哥，还是原来的样子，几乎没有变。我们都是性格含蓄的人。因为时间比较紧，只和磊哥聊了一个小时左右，我们说了很多毕业后的感受，没有装逼，没有浮夸，说的都是真心话。磊哥确实变了，变成熟了，不再那么放荡不羁了。直到现在我都在想，我应该和磊哥去喝上几杯的。哎，不知道下次见面是什么时候。</h5><p><img src=\"/img/life/yllh.jpeg\" alt=\"余磊和刘航\">    <div class=\"img-note\">余磊和刘航</div></p>\n<h5 id=\"按道理来说，重庆应该是比北京更加湿润的。但我的症状却恰恰相反，因为没有唇膏，加上女朋友”舍不得”给我买新的，我的嘴唇周围已经干到龟裂。这实在是难受。后来分析可能是因为酒店的房间里面太干燥了。女朋友则比我更惨一些，亲戚来了，加上肚子疼，再加上感冒发烧导致声音沙哑，已经到了不能说话的地步。实在是好过不到哪里去。不过幸好有我的悉心照顾，最后安全返回北京。\"><a href=\"#按道理来说，重庆应该是比北京更加湿润的。但我的症状却恰恰相反，因为没有唇膏，加上女朋友”舍不得”给我买新的，我的嘴唇周围已经干到龟裂。这实在是难受。后来分析可能是因为酒店的房间里面太干燥了。女朋友则比我更惨一些，亲戚来了，加上肚子疼，再加上感冒发烧导致声音沙哑，已经到了不能说话的地步。实在是好过不到哪里去。不过幸好有我的悉心照顾，最后安全返回北京。\" class=\"headerlink\" title=\"按道理来说，重庆应该是比北京更加湿润的。但我的症状却恰恰相反，因为没有唇膏，加上女朋友”舍不得”给我买新的，我的嘴唇周围已经干到龟裂。这实在是难受。后来分析可能是因为酒店的房间里面太干燥了。女朋友则比我更惨一些，亲戚来了，加上肚子疼，再加上感冒发烧导致声音沙哑，已经到了不能说话的地步。实在是好过不到哪里去。不过幸好有我的悉心照顾，最后安全返回北京。\"></a>按道理来说，重庆应该是比北京更加湿润的。但我的症状却恰恰相反，因为没有唇膏，加上女朋友”舍不得”给我买新的，我的嘴唇周围已经干到龟裂。这实在是难受。后来分析可能是因为酒店的房间里面太干燥了。女朋友则比我更惨一些，亲戚来了，加上肚子疼，再加上感冒发烧导致声音沙哑，已经到了不能说话的地步。实在是好过不到哪里去。不过幸好有我的悉心照顾，最后安全返回北京。</h5><p><img src=\"/img/life/qiuwei.jpeg\" alt=\"秋薇和我\">    <div class=\"img-note\">秋薇和我</div></p>\n","site":{"data":{}},"excerpt":"<h5 id=\"去年6月份毕业之后，怎么也没有先到这么快又回到的重庆。之前想过很多次，再到重庆的时候会是什么时候，可能是几年后的同学聚会，可能是工作休假去重庆游玩。但是无论怎样，也没有想到仅仅隔了半年就又到了重庆。\"><a href=\"#去年6月份毕业之后，怎么也没有先到这么快又回到的重庆。之前想过很多次，再到重庆的时候会是什么时候，可能是几年后的同学聚会，可能是工作休假去重庆游玩。但是无论怎样，也没有想到仅仅隔了半年就又到了重庆。\" class=\"headerlink\" title=\"去年6月份毕业之后，怎么也没有先到这么快又回到的重庆。之前想过很多次，再到重庆的时候会是什么时候，可能是几年后的同学聚会，可能是工作休假去重庆游玩。但是无论怎样，也没有想到仅仅隔了半年就又到了重庆。\"></a>去年6月份毕业之后，怎么也没有先到这么快又回到的重庆。之前想过很多次，再到重庆的时候会是什么时候，可能是几年后的同学聚会，可能是工作休假去重庆游玩。但是无论怎样，也没有想到仅仅隔了半年就又到了重庆。</h5>","more":"<h5 id=\"这次去重庆是因为部门的团建，原本计划去韩国或者是成都，投票之后就决定去重庆了（醉了）。其实我去重庆读书的时候，对重庆是没有多少感情的，觉得这个城市很陌生，没有家里好，这种感觉一直持续到大四，直到我离开重庆去北京工作和实习，才发现我已经对重庆有了一种莫名的情感在里面，虽然我没有在这里恋爱。这种情感在我下了飞机以后则更加明显。\"><a href=\"#这次去重庆是因为部门的团建，原本计划去韩国或者是成都，投票之后就决定去重庆了（醉了）。其实我去重庆读书的时候，对重庆是没有多少感情的，觉得这个城市很陌生，没有家里好，这种感觉一直持续到大四，直到我离开重庆去北京工作和实习，才发现我已经对重庆有了一种莫名的情感在里面，虽然我没有在这里恋爱。这种情感在我下了飞机以后则更加明显。\" class=\"headerlink\" title=\"这次去重庆是因为部门的团建，原本计划去韩国或者是成都，投票之后就决定去重庆了（醉了）。其实我去重庆读书的时候，对重庆是没有多少感情的，觉得这个城市很陌生，没有家里好，这种感觉一直持续到大四，直到我离开重庆去北京工作和实习，才发现我已经对重庆有了一种莫名的情感在里面，虽然我没有在这里恋爱。这种情感在我下了飞机以后则更加明显。\"></a>这次去重庆是因为部门的团建，原本计划去韩国或者是成都，投票之后就决定去重庆了（醉了）。其实我去重庆读书的时候，对重庆是没有多少感情的，觉得这个城市很陌生，没有家里好，这种感觉一直持续到大四，直到我离开重庆去北京工作和实习，才发现我已经对重庆有了一种莫名的情感在里面，虽然我没有在这里恋爱。这种情感在我下了飞机以后则更加明显。</h5><h5 id=\"到达重庆江北机场是在3月3号的凌晨1点，之前的一天我们还在公司卖力的工作。下了飞机以后便往预定的青年旅社赶，但是我们根本不是去休息的，因为我们的重庆之旅才刚刚开始，没有人想早早的睡觉。凌晨1点的重庆已经没有平时的拥堵，但是走在路上，我还是有一种特别熟悉的感觉，我对秋薇说，我好想还是一个学生。\"><a href=\"#到达重庆江北机场是在3月3号的凌晨1点，之前的一天我们还在公司卖力的工作。下了飞机以后便往预定的青年旅社赶，但是我们根本不是去休息的，因为我们的重庆之旅才刚刚开始，没有人想早早的睡觉。凌晨1点的重庆已经没有平时的拥堵，但是走在路上，我还是有一种特别熟悉的感觉，我对秋薇说，我好想还是一个学生。\" class=\"headerlink\" title=\"到达重庆江北机场是在3月3号的凌晨1点，之前的一天我们还在公司卖力的工作。下了飞机以后便往预定的青年旅社赶，但是我们根本不是去休息的，因为我们的重庆之旅才刚刚开始，没有人想早早的睡觉。凌晨1点的重庆已经没有平时的拥堵，但是走在路上，我还是有一种特别熟悉的感觉，我对秋薇说，我好想还是一个学生。\"></a>到达重庆江北机场是在3月3号的凌晨1点，之前的一天我们还在公司卖力的工作。下了飞机以后便往预定的青年旅社赶，但是我们根本不是去休息的，因为我们的重庆之旅才刚刚开始，没有人想早早的睡觉。凌晨1点的重庆已经没有平时的拥堵，但是走在路上，我还是有一种特别熟悉的感觉，我对秋薇说，我好想还是一个学生。</h5><p><img src=\"/img/life/chongqing.jpeg\" alt=\"青年旅舍合影\">    <div class=\"img-note\">青年旅舍合影</div></p>\n<h5 id=\"我确实变成了一个学生，在我第二天来到重邮之后。公司没有组织大家集体活动，都是各自行动。第二天在离开青舍，找到酒店之后，我和秋薇便直奔重邮。说来很巧，我们住的酒店在解放碑，这里正好有346路公交车直达重邮。一路上的风景还是没有变，路过了南坪，路过了会展中心。其实大学期间我并没有去过重庆的多少地方，因为本身比较宅，加上整天和几个大老爷们待在一起，所以重庆的路我认识的实在不多，这点也被同事们吐槽了。\"><a href=\"#我确实变成了一个学生，在我第二天来到重邮之后。公司没有组织大家集体活动，都是各自行动。第二天在离开青舍，找到酒店之后，我和秋薇便直奔重邮。说来很巧，我们住的酒店在解放碑，这里正好有346路公交车直达重邮。一路上的风景还是没有变，路过了南坪，路过了会展中心。其实大学期间我并没有去过重庆的多少地方，因为本身比较宅，加上整天和几个大老爷们待在一起，所以重庆的路我认识的实在不多，这点也被同事们吐槽了。\" class=\"headerlink\" title=\"我确实变成了一个学生，在我第二天来到重邮之后。公司没有组织大家集体活动，都是各自行动。第二天在离开青舍，找到酒店之后，我和秋薇便直奔重邮。说来很巧，我们住的酒店在解放碑，这里正好有346路公交车直达重邮。一路上的风景还是没有变，路过了南坪，路过了会展中心。其实大学期间我并没有去过重庆的多少地方，因为本身比较宅，加上整天和几个大老爷们待在一起，所以重庆的路我认识的实在不多，这点也被同事们吐槽了。\"></a>我确实变成了一个学生，在我第二天来到重邮之后。公司没有组织大家集体活动，都是各自行动。第二天在离开青舍，找到酒店之后，我和秋薇便直奔重邮。说来很巧，我们住的酒店在解放碑，这里正好有346路公交车直达重邮。一路上的风景还是没有变，路过了南坪，路过了会展中心。其实大学期间我并没有去过重庆的多少地方，因为本身比较宅，加上整天和几个大老爷们待在一起，所以重庆的路我认识的实在不多，这点也被同事们吐槽了。</h5><h5 id=\"重邮在我眼里几乎就没有变，除了千喜鹤食堂。我顺着数图、老操场、篮球场、千喜鹤来到28栋。不知道是因为这条路太过于熟悉，还是学校变化实在不大，我没有了之前的激动，心情也慢慢平复下来。这一圈走完之后，竟然想着快点离开。当然，离开之前又去了一次”火山石烫鱼”。\"><a href=\"#重邮在我眼里几乎就没有变，除了千喜鹤食堂。我顺着数图、老操场、篮球场、千喜鹤来到28栋。不知道是因为这条路太过于熟悉，还是学校变化实在不大，我没有了之前的激动，心情也慢慢平复下来。这一圈走完之后，竟然想着快点离开。当然，离开之前又去了一次”火山石烫鱼”。\" class=\"headerlink\" title=\"重邮在我眼里几乎就没有变，除了千喜鹤食堂。我顺着数图、老操场、篮球场、千喜鹤来到28栋。不知道是因为这条路太过于熟悉，还是学校变化实在不大，我没有了之前的激动，心情也慢慢平复下来。这一圈走完之后，竟然想着快点离开。当然，离开之前又去了一次”火山石烫鱼”。\"></a>重邮在我眼里几乎就没有变，除了千喜鹤食堂。我顺着数图、老操场、篮球场、千喜鹤来到28栋。不知道是因为这条路太过于熟悉，还是学校变化实在不大，我没有了之前的激动，心情也慢慢平复下来。这一圈走完之后，竟然想着快点离开。当然，离开之前又去了一次”火山石烫鱼”。</h5><p><img src=\"/img/life/cqupt.jpeg\" alt=\"重邮新食堂\">    <div class=\"img-note\">重邮新食堂</div><br><img src=\"/img/life/fish.jpeg\" alt=\"火山石烫鱼\">    <div class=\"img-note\">火山石烫鱼</div></p>\n<h5 id=\"如果说我为什么在离开重邮的时候又喜欢上了重庆，一定是因为那些人，那些同学和朋友。第二天我就见到了磊哥，还是原来的样子，几乎没有变。我们都是性格含蓄的人。因为时间比较紧，只和磊哥聊了一个小时左右，我们说了很多毕业后的感受，没有装逼，没有浮夸，说的都是真心话。磊哥确实变了，变成熟了，不再那么放荡不羁了。直到现在我都在想，我应该和磊哥去喝上几杯的。哎，不知道下次见面是什么时候。\"><a href=\"#如果说我为什么在离开重邮的时候又喜欢上了重庆，一定是因为那些人，那些同学和朋友。第二天我就见到了磊哥，还是原来的样子，几乎没有变。我们都是性格含蓄的人。因为时间比较紧，只和磊哥聊了一个小时左右，我们说了很多毕业后的感受，没有装逼，没有浮夸，说的都是真心话。磊哥确实变了，变成熟了，不再那么放荡不羁了。直到现在我都在想，我应该和磊哥去喝上几杯的。哎，不知道下次见面是什么时候。\" class=\"headerlink\" title=\"如果说我为什么在离开重邮的时候又喜欢上了重庆，一定是因为那些人，那些同学和朋友。第二天我就见到了磊哥，还是原来的样子，几乎没有变。我们都是性格含蓄的人。因为时间比较紧，只和磊哥聊了一个小时左右，我们说了很多毕业后的感受，没有装逼，没有浮夸，说的都是真心话。磊哥确实变了，变成熟了，不再那么放荡不羁了。直到现在我都在想，我应该和磊哥去喝上几杯的。哎，不知道下次见面是什么时候。\"></a>如果说我为什么在离开重邮的时候又喜欢上了重庆，一定是因为那些人，那些同学和朋友。第二天我就见到了磊哥，还是原来的样子，几乎没有变。我们都是性格含蓄的人。因为时间比较紧，只和磊哥聊了一个小时左右，我们说了很多毕业后的感受，没有装逼，没有浮夸，说的都是真心话。磊哥确实变了，变成熟了，不再那么放荡不羁了。直到现在我都在想，我应该和磊哥去喝上几杯的。哎，不知道下次见面是什么时候。</h5><p><img src=\"/img/life/yllh.jpeg\" alt=\"余磊和刘航\">    <div class=\"img-note\">余磊和刘航</div></p>\n<h5 id=\"按道理来说，重庆应该是比北京更加湿润的。但我的症状却恰恰相反，因为没有唇膏，加上女朋友”舍不得”给我买新的，我的嘴唇周围已经干到龟裂。这实在是难受。后来分析可能是因为酒店的房间里面太干燥了。女朋友则比我更惨一些，亲戚来了，加上肚子疼，再加上感冒发烧导致声音沙哑，已经到了不能说话的地步。实在是好过不到哪里去。不过幸好有我的悉心照顾，最后安全返回北京。\"><a href=\"#按道理来说，重庆应该是比北京更加湿润的。但我的症状却恰恰相反，因为没有唇膏，加上女朋友”舍不得”给我买新的，我的嘴唇周围已经干到龟裂。这实在是难受。后来分析可能是因为酒店的房间里面太干燥了。女朋友则比我更惨一些，亲戚来了，加上肚子疼，再加上感冒发烧导致声音沙哑，已经到了不能说话的地步。实在是好过不到哪里去。不过幸好有我的悉心照顾，最后安全返回北京。\" class=\"headerlink\" title=\"按道理来说，重庆应该是比北京更加湿润的。但我的症状却恰恰相反，因为没有唇膏，加上女朋友”舍不得”给我买新的，我的嘴唇周围已经干到龟裂。这实在是难受。后来分析可能是因为酒店的房间里面太干燥了。女朋友则比我更惨一些，亲戚来了，加上肚子疼，再加上感冒发烧导致声音沙哑，已经到了不能说话的地步。实在是好过不到哪里去。不过幸好有我的悉心照顾，最后安全返回北京。\"></a>按道理来说，重庆应该是比北京更加湿润的。但我的症状却恰恰相反，因为没有唇膏，加上女朋友”舍不得”给我买新的，我的嘴唇周围已经干到龟裂。这实在是难受。后来分析可能是因为酒店的房间里面太干燥了。女朋友则比我更惨一些，亲戚来了，加上肚子疼，再加上感冒发烧导致声音沙哑，已经到了不能说话的地步。实在是好过不到哪里去。不过幸好有我的悉心照顾，最后安全返回北京。</h5><p><img src=\"/img/life/qiuwei.jpeg\" alt=\"秋薇和我\">    <div class=\"img-note\">秋薇和我</div></p>"},{"layout":"post","title":"人生需要失败","date":"2017-03-17T16:00:00.000Z","original":true,"_content":"\n##### 其实今天的事情远没有标题说的这么严重，但是我确实很重视这次面试。快手的第一次面试。\n\n##### 面试的前半部分非常顺利，聊了一些在去哪儿的工作以及系统。直到面试官问我来快手希望做哪方面的工作。身为一个java开发，居然说最想作算法方面的工作，虽然我极力强调我只是对算法比较感兴趣，实在没有多专业，如果可以我很希望可以往这方面发展。但是面试官还是给了我一道比较专业的算法题。加上后面的一些表现。导致这次面试的失败。\n\n<!--more-->\n\n##### 快手确实是一个我很想去的公司，但是我却没有为这次面试做足够的准备。面试出来以后说不难过是假的。\n##### 人生十有八九都是不如意的，失败也是为了更好的前进。整装待发，继续前进吧。\n#### 附上一张女朋友拍的面试背影\n![面试背影](/img/life/myself.jpeg)\n\n## 面试算法题\n### 不输入任何参数，尽量精确的计算p值\n##### 解题过程现在还不是很会，和概率论和积分有关，好好看看再记录下来吧。\n### 偶数的数组里面有一些正数，分成两个大小一样的子数组，两个数组之和尽量相等\n##### [解题思路](/arithmetic/array1/)","source":"_posts/life/failure.md","raw":"---\nlayout: post\ntitle: 人生需要失败\ndate: 2017/03/18\noriginal: true\ntags: [life, index]\n---\n\n##### 其实今天的事情远没有标题说的这么严重，但是我确实很重视这次面试。快手的第一次面试。\n\n##### 面试的前半部分非常顺利，聊了一些在去哪儿的工作以及系统。直到面试官问我来快手希望做哪方面的工作。身为一个java开发，居然说最想作算法方面的工作，虽然我极力强调我只是对算法比较感兴趣，实在没有多专业，如果可以我很希望可以往这方面发展。但是面试官还是给了我一道比较专业的算法题。加上后面的一些表现。导致这次面试的失败。\n\n<!--more-->\n\n##### 快手确实是一个我很想去的公司，但是我却没有为这次面试做足够的准备。面试出来以后说不难过是假的。\n##### 人生十有八九都是不如意的，失败也是为了更好的前进。整装待发，继续前进吧。\n#### 附上一张女朋友拍的面试背影\n![面试背影](/img/life/myself.jpeg)\n\n## 面试算法题\n### 不输入任何参数，尽量精确的计算p值\n##### 解题过程现在还不是很会，和概率论和积分有关，好好看看再记录下来吧。\n### 偶数的数组里面有一些正数，分成两个大小一样的子数组，两个数组之和尽量相等\n##### [解题思路](/arithmetic/array1/)","slug":"life/failure","published":1,"updated":"2018-05-08T14:24:22.678Z","_id":"cjgxop3ku0002jah13hqlenvn","comments":1,"photos":[],"link":"","content":"<h5 id=\"其实今天的事情远没有标题说的这么严重，但是我确实很重视这次面试。快手的第一次面试。\"><a href=\"#其实今天的事情远没有标题说的这么严重，但是我确实很重视这次面试。快手的第一次面试。\" class=\"headerlink\" title=\"其实今天的事情远没有标题说的这么严重，但是我确实很重视这次面试。快手的第一次面试。\"></a>其实今天的事情远没有标题说的这么严重，但是我确实很重视这次面试。快手的第一次面试。</h5><h5 id=\"面试的前半部分非常顺利，聊了一些在去哪儿的工作以及系统。直到面试官问我来快手希望做哪方面的工作。身为一个java开发，居然说最想作算法方面的工作，虽然我极力强调我只是对算法比较感兴趣，实在没有多专业，如果可以我很希望可以往这方面发展。但是面试官还是给了我一道比较专业的算法题。加上后面的一些表现。导致这次面试的失败。\"><a href=\"#面试的前半部分非常顺利，聊了一些在去哪儿的工作以及系统。直到面试官问我来快手希望做哪方面的工作。身为一个java开发，居然说最想作算法方面的工作，虽然我极力强调我只是对算法比较感兴趣，实在没有多专业，如果可以我很希望可以往这方面发展。但是面试官还是给了我一道比较专业的算法题。加上后面的一些表现。导致这次面试的失败。\" class=\"headerlink\" title=\"面试的前半部分非常顺利，聊了一些在去哪儿的工作以及系统。直到面试官问我来快手希望做哪方面的工作。身为一个java开发，居然说最想作算法方面的工作，虽然我极力强调我只是对算法比较感兴趣，实在没有多专业，如果可以我很希望可以往这方面发展。但是面试官还是给了我一道比较专业的算法题。加上后面的一些表现。导致这次面试的失败。\"></a>面试的前半部分非常顺利，聊了一些在去哪儿的工作以及系统。直到面试官问我来快手希望做哪方面的工作。身为一个java开发，居然说最想作算法方面的工作，虽然我极力强调我只是对算法比较感兴趣，实在没有多专业，如果可以我很希望可以往这方面发展。但是面试官还是给了我一道比较专业的算法题。加上后面的一些表现。导致这次面试的失败。</h5><a id=\"more\"></a>\n<h5 id=\"快手确实是一个我很想去的公司，但是我却没有为这次面试做足够的准备。面试出来以后说不难过是假的。\"><a href=\"#快手确实是一个我很想去的公司，但是我却没有为这次面试做足够的准备。面试出来以后说不难过是假的。\" class=\"headerlink\" title=\"快手确实是一个我很想去的公司，但是我却没有为这次面试做足够的准备。面试出来以后说不难过是假的。\"></a>快手确实是一个我很想去的公司，但是我却没有为这次面试做足够的准备。面试出来以后说不难过是假的。</h5><h5 id=\"人生十有八九都是不如意的，失败也是为了更好的前进。整装待发，继续前进吧。\"><a href=\"#人生十有八九都是不如意的，失败也是为了更好的前进。整装待发，继续前进吧。\" class=\"headerlink\" title=\"人生十有八九都是不如意的，失败也是为了更好的前进。整装待发，继续前进吧。\"></a>人生十有八九都是不如意的，失败也是为了更好的前进。整装待发，继续前进吧。</h5><h4 id=\"附上一张女朋友拍的面试背影\"><a href=\"#附上一张女朋友拍的面试背影\" class=\"headerlink\" title=\"附上一张女朋友拍的面试背影\"></a>附上一张女朋友拍的面试背影</h4><p><img src=\"/img/life/myself.jpeg\" alt=\"面试背影\"></p>\n<h2 id=\"面试算法题\"><a href=\"#面试算法题\" class=\"headerlink\" title=\"面试算法题\"></a>面试算法题</h2><h3 id=\"不输入任何参数，尽量精确的计算p值\"><a href=\"#不输入任何参数，尽量精确的计算p值\" class=\"headerlink\" title=\"不输入任何参数，尽量精确的计算p值\"></a>不输入任何参数，尽量精确的计算p值</h3><h5 id=\"解题过程现在还不是很会，和概率论和积分有关，好好看看再记录下来吧。\"><a href=\"#解题过程现在还不是很会，和概率论和积分有关，好好看看再记录下来吧。\" class=\"headerlink\" title=\"解题过程现在还不是很会，和概率论和积分有关，好好看看再记录下来吧。\"></a>解题过程现在还不是很会，和概率论和积分有关，好好看看再记录下来吧。</h5><h3 id=\"偶数的数组里面有一些正数，分成两个大小一样的子数组，两个数组之和尽量相等\"><a href=\"#偶数的数组里面有一些正数，分成两个大小一样的子数组，两个数组之和尽量相等\" class=\"headerlink\" title=\"偶数的数组里面有一些正数，分成两个大小一样的子数组，两个数组之和尽量相等\"></a>偶数的数组里面有一些正数，分成两个大小一样的子数组，两个数组之和尽量相等</h3><h5 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a><a href=\"/arithmetic/array1/\">解题思路</a></h5>","site":{"data":{}},"excerpt":"<h5 id=\"其实今天的事情远没有标题说的这么严重，但是我确实很重视这次面试。快手的第一次面试。\"><a href=\"#其实今天的事情远没有标题说的这么严重，但是我确实很重视这次面试。快手的第一次面试。\" class=\"headerlink\" title=\"其实今天的事情远没有标题说的这么严重，但是我确实很重视这次面试。快手的第一次面试。\"></a>其实今天的事情远没有标题说的这么严重，但是我确实很重视这次面试。快手的第一次面试。</h5><h5 id=\"面试的前半部分非常顺利，聊了一些在去哪儿的工作以及系统。直到面试官问我来快手希望做哪方面的工作。身为一个java开发，居然说最想作算法方面的工作，虽然我极力强调我只是对算法比较感兴趣，实在没有多专业，如果可以我很希望可以往这方面发展。但是面试官还是给了我一道比较专业的算法题。加上后面的一些表现。导致这次面试的失败。\"><a href=\"#面试的前半部分非常顺利，聊了一些在去哪儿的工作以及系统。直到面试官问我来快手希望做哪方面的工作。身为一个java开发，居然说最想作算法方面的工作，虽然我极力强调我只是对算法比较感兴趣，实在没有多专业，如果可以我很希望可以往这方面发展。但是面试官还是给了我一道比较专业的算法题。加上后面的一些表现。导致这次面试的失败。\" class=\"headerlink\" title=\"面试的前半部分非常顺利，聊了一些在去哪儿的工作以及系统。直到面试官问我来快手希望做哪方面的工作。身为一个java开发，居然说最想作算法方面的工作，虽然我极力强调我只是对算法比较感兴趣，实在没有多专业，如果可以我很希望可以往这方面发展。但是面试官还是给了我一道比较专业的算法题。加上后面的一些表现。导致这次面试的失败。\"></a>面试的前半部分非常顺利，聊了一些在去哪儿的工作以及系统。直到面试官问我来快手希望做哪方面的工作。身为一个java开发，居然说最想作算法方面的工作，虽然我极力强调我只是对算法比较感兴趣，实在没有多专业，如果可以我很希望可以往这方面发展。但是面试官还是给了我一道比较专业的算法题。加上后面的一些表现。导致这次面试的失败。</h5>","more":"<h5 id=\"快手确实是一个我很想去的公司，但是我却没有为这次面试做足够的准备。面试出来以后说不难过是假的。\"><a href=\"#快手确实是一个我很想去的公司，但是我却没有为这次面试做足够的准备。面试出来以后说不难过是假的。\" class=\"headerlink\" title=\"快手确实是一个我很想去的公司，但是我却没有为这次面试做足够的准备。面试出来以后说不难过是假的。\"></a>快手确实是一个我很想去的公司，但是我却没有为这次面试做足够的准备。面试出来以后说不难过是假的。</h5><h5 id=\"人生十有八九都是不如意的，失败也是为了更好的前进。整装待发，继续前进吧。\"><a href=\"#人生十有八九都是不如意的，失败也是为了更好的前进。整装待发，继续前进吧。\" class=\"headerlink\" title=\"人生十有八九都是不如意的，失败也是为了更好的前进。整装待发，继续前进吧。\"></a>人生十有八九都是不如意的，失败也是为了更好的前进。整装待发，继续前进吧。</h5><h4 id=\"附上一张女朋友拍的面试背影\"><a href=\"#附上一张女朋友拍的面试背影\" class=\"headerlink\" title=\"附上一张女朋友拍的面试背影\"></a>附上一张女朋友拍的面试背影</h4><p><img src=\"/img/life/myself.jpeg\" alt=\"面试背影\"></p>\n<h2 id=\"面试算法题\"><a href=\"#面试算法题\" class=\"headerlink\" title=\"面试算法题\"></a>面试算法题</h2><h3 id=\"不输入任何参数，尽量精确的计算p值\"><a href=\"#不输入任何参数，尽量精确的计算p值\" class=\"headerlink\" title=\"不输入任何参数，尽量精确的计算p值\"></a>不输入任何参数，尽量精确的计算p值</h3><h5 id=\"解题过程现在还不是很会，和概率论和积分有关，好好看看再记录下来吧。\"><a href=\"#解题过程现在还不是很会，和概率论和积分有关，好好看看再记录下来吧。\" class=\"headerlink\" title=\"解题过程现在还不是很会，和概率论和积分有关，好好看看再记录下来吧。\"></a>解题过程现在还不是很会，和概率论和积分有关，好好看看再记录下来吧。</h5><h3 id=\"偶数的数组里面有一些正数，分成两个大小一样的子数组，两个数组之和尽量相等\"><a href=\"#偶数的数组里面有一些正数，分成两个大小一样的子数组，两个数组之和尽量相等\" class=\"headerlink\" title=\"偶数的数组里面有一些正数，分成两个大小一样的子数组，两个数组之和尽量相等\"></a>偶数的数组里面有一些正数，分成两个大小一样的子数组，两个数组之和尽量相等</h3><h5 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a><a href=\"/arithmetic/array1/\">解题思路</a></h5>"},{"layout":"post","title":"最近的一些面试感受","date":"2017-08-30T16:00:00.000Z","original":true,"_content":"\n##### 自从7月份从去哪儿出来以后，这段时间一直在陆陆续续的面试一些公司。包括58、京东、滴滴、美团、阿里。面试的过程既痛苦又开心，最近也是感受颇多。希望能够在记录下来，激励自己不断学习、前进。\n<!--more-->\n\n### 　　58、京东、滴滴、美团\n##### 这几家公司面试的时间比较早，在7月份就已经面试完成。\n##### 其中58是去哪儿出来以后面试的第一家公司，基本上投了简历以后马上就有人给我打电话通知面试。然后面试得过程其实还算正常，但是二面回去等通知（感觉三面就已经是hr面了），二面结束的时候面试官给我的评价是技术还行，但是感觉不太踏实。后等了一个星期没有结果，联系面试官告知没有通过。给我的反馈是感觉基础有点差。\n\n##### 京东的面试也是在一天之内完成了，大大小小进过了4、5轮面试。过程还算顺利。只是hr好像不太待见我们，因为京东的薪资普遍偏低，可能hr自己也感觉我不太能够接受他们给的薪资。但是因为面试官很看好我，给了我很多帮组，包括帮我去争取额外的级别和薪资。以及在我拒绝了hr的offer还给了一个星期的考虑时间。加上我之后对京东福利的一些了解，所以现在对京东的印象是非常好的。\n\n##### 滴滴是拿到offer并且接受了。企业级事业部-私车同行。还是很有挑战的。\n\n##### 美团比较遗憾，走到了3面，也和hr聊了薪资。hr也说了给我催offer。但是还是没有拿到offer。这个比较坑了。然后就是吐槽一下美团的办事效率吧。\n\n##### 阿里是最心疼的。一直从7月份面试到今天，一共面了6轮，3个部门。最终还是没有拿到offer。也是阿里的面试让我感触很多，发现自己的不足。阿里的面试过程中，最大的问题还是在于之前qunar的工作内容，系统设计，没能很好的表达清楚。对于系统的一些难点，以及遇到的一些问题，没能很好的回答清楚。其实如果抱着完成任务的心态去处理事情，会发现很多事情都很简单。但是如果你仔细去钻研的话，会发现自己有很多东西都明白其原理和过程。之前的工作可能就缺少了这份钻研，以及自己的总结能力有待提高。导致对于之前的系统的认识还是停留在很表面的层次。这是我最想改正的地方。也很感谢阿里的这几轮面试，真的是面累了，心很累，报的希望越大，失望也越大。所以还是需要静下心来好好钻研与学习。阿里来年再战！！！","source":"_posts/life/interview.md","raw":"---\nlayout: post\ntitle: 最近的一些面试感受\ndate: 2017/08/31\noriginal: true\n---\n\n##### 自从7月份从去哪儿出来以后，这段时间一直在陆陆续续的面试一些公司。包括58、京东、滴滴、美团、阿里。面试的过程既痛苦又开心，最近也是感受颇多。希望能够在记录下来，激励自己不断学习、前进。\n<!--more-->\n\n### 　　58、京东、滴滴、美团\n##### 这几家公司面试的时间比较早，在7月份就已经面试完成。\n##### 其中58是去哪儿出来以后面试的第一家公司，基本上投了简历以后马上就有人给我打电话通知面试。然后面试得过程其实还算正常，但是二面回去等通知（感觉三面就已经是hr面了），二面结束的时候面试官给我的评价是技术还行，但是感觉不太踏实。后等了一个星期没有结果，联系面试官告知没有通过。给我的反馈是感觉基础有点差。\n\n##### 京东的面试也是在一天之内完成了，大大小小进过了4、5轮面试。过程还算顺利。只是hr好像不太待见我们，因为京东的薪资普遍偏低，可能hr自己也感觉我不太能够接受他们给的薪资。但是因为面试官很看好我，给了我很多帮组，包括帮我去争取额外的级别和薪资。以及在我拒绝了hr的offer还给了一个星期的考虑时间。加上我之后对京东福利的一些了解，所以现在对京东的印象是非常好的。\n\n##### 滴滴是拿到offer并且接受了。企业级事业部-私车同行。还是很有挑战的。\n\n##### 美团比较遗憾，走到了3面，也和hr聊了薪资。hr也说了给我催offer。但是还是没有拿到offer。这个比较坑了。然后就是吐槽一下美团的办事效率吧。\n\n##### 阿里是最心疼的。一直从7月份面试到今天，一共面了6轮，3个部门。最终还是没有拿到offer。也是阿里的面试让我感触很多，发现自己的不足。阿里的面试过程中，最大的问题还是在于之前qunar的工作内容，系统设计，没能很好的表达清楚。对于系统的一些难点，以及遇到的一些问题，没能很好的回答清楚。其实如果抱着完成任务的心态去处理事情，会发现很多事情都很简单。但是如果你仔细去钻研的话，会发现自己有很多东西都明白其原理和过程。之前的工作可能就缺少了这份钻研，以及自己的总结能力有待提高。导致对于之前的系统的认识还是停留在很表面的层次。这是我最想改正的地方。也很感谢阿里的这几轮面试，真的是面累了，心很累，报的希望越大，失望也越大。所以还是需要静下心来好好钻研与学习。阿里来年再战！！！","slug":"life/interview","published":1,"updated":"2018-05-08T14:51:18.334Z","_id":"cjgxop3kz0004jah1va7mrsu2","comments":1,"photos":[],"link":"","content":"<h5 id=\"自从7月份从去哪儿出来以后，这段时间一直在陆陆续续的面试一些公司。包括58、京东、滴滴、美团、阿里。面试的过程既痛苦又开心，最近也是感受颇多。希望能够在记录下来，激励自己不断学习、前进。\"><a href=\"#自从7月份从去哪儿出来以后，这段时间一直在陆陆续续的面试一些公司。包括58、京东、滴滴、美团、阿里。面试的过程既痛苦又开心，最近也是感受颇多。希望能够在记录下来，激励自己不断学习、前进。\" class=\"headerlink\" title=\"自从7月份从去哪儿出来以后，这段时间一直在陆陆续续的面试一些公司。包括58、京东、滴滴、美团、阿里。面试的过程既痛苦又开心，最近也是感受颇多。希望能够在记录下来，激励自己不断学习、前进。\"></a>自从7月份从去哪儿出来以后，这段时间一直在陆陆续续的面试一些公司。包括58、京东、滴滴、美团、阿里。面试的过程既痛苦又开心，最近也是感受颇多。希望能够在记录下来，激励自己不断学习、前进。</h5><a id=\"more\"></a>\n<h3 id=\"58、京东、滴滴、美团\"><a href=\"#58、京东、滴滴、美团\" class=\"headerlink\" title=\"　　58、京东、滴滴、美团\"></a>　　58、京东、滴滴、美团</h3><h5 id=\"这几家公司面试的时间比较早，在7月份就已经面试完成。\"><a href=\"#这几家公司面试的时间比较早，在7月份就已经面试完成。\" class=\"headerlink\" title=\"这几家公司面试的时间比较早，在7月份就已经面试完成。\"></a>这几家公司面试的时间比较早，在7月份就已经面试完成。</h5><h5 id=\"其中58是去哪儿出来以后面试的第一家公司，基本上投了简历以后马上就有人给我打电话通知面试。然后面试得过程其实还算正常，但是二面回去等通知（感觉三面就已经是hr面了），二面结束的时候面试官给我的评价是技术还行，但是感觉不太踏实。后等了一个星期没有结果，联系面试官告知没有通过。给我的反馈是感觉基础有点差。\"><a href=\"#其中58是去哪儿出来以后面试的第一家公司，基本上投了简历以后马上就有人给我打电话通知面试。然后面试得过程其实还算正常，但是二面回去等通知（感觉三面就已经是hr面了），二面结束的时候面试官给我的评价是技术还行，但是感觉不太踏实。后等了一个星期没有结果，联系面试官告知没有通过。给我的反馈是感觉基础有点差。\" class=\"headerlink\" title=\"其中58是去哪儿出来以后面试的第一家公司，基本上投了简历以后马上就有人给我打电话通知面试。然后面试得过程其实还算正常，但是二面回去等通知（感觉三面就已经是hr面了），二面结束的时候面试官给我的评价是技术还行，但是感觉不太踏实。后等了一个星期没有结果，联系面试官告知没有通过。给我的反馈是感觉基础有点差。\"></a>其中58是去哪儿出来以后面试的第一家公司，基本上投了简历以后马上就有人给我打电话通知面试。然后面试得过程其实还算正常，但是二面回去等通知（感觉三面就已经是hr面了），二面结束的时候面试官给我的评价是技术还行，但是感觉不太踏实。后等了一个星期没有结果，联系面试官告知没有通过。给我的反馈是感觉基础有点差。</h5><h5 id=\"京东的面试也是在一天之内完成了，大大小小进过了4、5轮面试。过程还算顺利。只是hr好像不太待见我们，因为京东的薪资普遍偏低，可能hr自己也感觉我不太能够接受他们给的薪资。但是因为面试官很看好我，给了我很多帮组，包括帮我去争取额外的级别和薪资。以及在我拒绝了hr的offer还给了一个星期的考虑时间。加上我之后对京东福利的一些了解，所以现在对京东的印象是非常好的。\"><a href=\"#京东的面试也是在一天之内完成了，大大小小进过了4、5轮面试。过程还算顺利。只是hr好像不太待见我们，因为京东的薪资普遍偏低，可能hr自己也感觉我不太能够接受他们给的薪资。但是因为面试官很看好我，给了我很多帮组，包括帮我去争取额外的级别和薪资。以及在我拒绝了hr的offer还给了一个星期的考虑时间。加上我之后对京东福利的一些了解，所以现在对京东的印象是非常好的。\" class=\"headerlink\" title=\"京东的面试也是在一天之内完成了，大大小小进过了4、5轮面试。过程还算顺利。只是hr好像不太待见我们，因为京东的薪资普遍偏低，可能hr自己也感觉我不太能够接受他们给的薪资。但是因为面试官很看好我，给了我很多帮组，包括帮我去争取额外的级别和薪资。以及在我拒绝了hr的offer还给了一个星期的考虑时间。加上我之后对京东福利的一些了解，所以现在对京东的印象是非常好的。\"></a>京东的面试也是在一天之内完成了，大大小小进过了4、5轮面试。过程还算顺利。只是hr好像不太待见我们，因为京东的薪资普遍偏低，可能hr自己也感觉我不太能够接受他们给的薪资。但是因为面试官很看好我，给了我很多帮组，包括帮我去争取额外的级别和薪资。以及在我拒绝了hr的offer还给了一个星期的考虑时间。加上我之后对京东福利的一些了解，所以现在对京东的印象是非常好的。</h5><h5 id=\"滴滴是拿到offer并且接受了。企业级事业部-私车同行。还是很有挑战的。\"><a href=\"#滴滴是拿到offer并且接受了。企业级事业部-私车同行。还是很有挑战的。\" class=\"headerlink\" title=\"滴滴是拿到offer并且接受了。企业级事业部-私车同行。还是很有挑战的。\"></a>滴滴是拿到offer并且接受了。企业级事业部-私车同行。还是很有挑战的。</h5><h5 id=\"美团比较遗憾，走到了3面，也和hr聊了薪资。hr也说了给我催offer。但是还是没有拿到offer。这个比较坑了。然后就是吐槽一下美团的办事效率吧。\"><a href=\"#美团比较遗憾，走到了3面，也和hr聊了薪资。hr也说了给我催offer。但是还是没有拿到offer。这个比较坑了。然后就是吐槽一下美团的办事效率吧。\" class=\"headerlink\" title=\"美团比较遗憾，走到了3面，也和hr聊了薪资。hr也说了给我催offer。但是还是没有拿到offer。这个比较坑了。然后就是吐槽一下美团的办事效率吧。\"></a>美团比较遗憾，走到了3面，也和hr聊了薪资。hr也说了给我催offer。但是还是没有拿到offer。这个比较坑了。然后就是吐槽一下美团的办事效率吧。</h5><h5 id=\"阿里是最心疼的。一直从7月份面试到今天，一共面了6轮，3个部门。最终还是没有拿到offer。也是阿里的面试让我感触很多，发现自己的不足。阿里的面试过程中，最大的问题还是在于之前qunar的工作内容，系统设计，没能很好的表达清楚。对于系统的一些难点，以及遇到的一些问题，没能很好的回答清楚。其实如果抱着完成任务的心态去处理事情，会发现很多事情都很简单。但是如果你仔细去钻研的话，会发现自己有很多东西都明白其原理和过程。之前的工作可能就缺少了这份钻研，以及自己的总结能力有待提高。导致对于之前的系统的认识还是停留在很表面的层次。这是我最想改正的地方。也很感谢阿里的这几轮面试，真的是面累了，心很累，报的希望越大，失望也越大。所以还是需要静下心来好好钻研与学习。阿里来年再战！！！\"><a href=\"#阿里是最心疼的。一直从7月份面试到今天，一共面了6轮，3个部门。最终还是没有拿到offer。也是阿里的面试让我感触很多，发现自己的不足。阿里的面试过程中，最大的问题还是在于之前qunar的工作内容，系统设计，没能很好的表达清楚。对于系统的一些难点，以及遇到的一些问题，没能很好的回答清楚。其实如果抱着完成任务的心态去处理事情，会发现很多事情都很简单。但是如果你仔细去钻研的话，会发现自己有很多东西都明白其原理和过程。之前的工作可能就缺少了这份钻研，以及自己的总结能力有待提高。导致对于之前的系统的认识还是停留在很表面的层次。这是我最想改正的地方。也很感谢阿里的这几轮面试，真的是面累了，心很累，报的希望越大，失望也越大。所以还是需要静下心来好好钻研与学习。阿里来年再战！！！\" class=\"headerlink\" title=\"阿里是最心疼的。一直从7月份面试到今天，一共面了6轮，3个部门。最终还是没有拿到offer。也是阿里的面试让我感触很多，发现自己的不足。阿里的面试过程中，最大的问题还是在于之前qunar的工作内容，系统设计，没能很好的表达清楚。对于系统的一些难点，以及遇到的一些问题，没能很好的回答清楚。其实如果抱着完成任务的心态去处理事情，会发现很多事情都很简单。但是如果你仔细去钻研的话，会发现自己有很多东西都明白其原理和过程。之前的工作可能就缺少了这份钻研，以及自己的总结能力有待提高。导致对于之前的系统的认识还是停留在很表面的层次。这是我最想改正的地方。也很感谢阿里的这几轮面试，真的是面累了，心很累，报的希望越大，失望也越大。所以还是需要静下心来好好钻研与学习。阿里来年再战！！！\"></a>阿里是最心疼的。一直从7月份面试到今天，一共面了6轮，3个部门。最终还是没有拿到offer。也是阿里的面试让我感触很多，发现自己的不足。阿里的面试过程中，最大的问题还是在于之前qunar的工作内容，系统设计，没能很好的表达清楚。对于系统的一些难点，以及遇到的一些问题，没能很好的回答清楚。其实如果抱着完成任务的心态去处理事情，会发现很多事情都很简单。但是如果你仔细去钻研的话，会发现自己有很多东西都明白其原理和过程。之前的工作可能就缺少了这份钻研，以及自己的总结能力有待提高。导致对于之前的系统的认识还是停留在很表面的层次。这是我最想改正的地方。也很感谢阿里的这几轮面试，真的是面累了，心很累，报的希望越大，失望也越大。所以还是需要静下心来好好钻研与学习。阿里来年再战！！！</h5>","site":{"data":{}},"excerpt":"<h5 id=\"自从7月份从去哪儿出来以后，这段时间一直在陆陆续续的面试一些公司。包括58、京东、滴滴、美团、阿里。面试的过程既痛苦又开心，最近也是感受颇多。希望能够在记录下来，激励自己不断学习、前进。\"><a href=\"#自从7月份从去哪儿出来以后，这段时间一直在陆陆续续的面试一些公司。包括58、京东、滴滴、美团、阿里。面试的过程既痛苦又开心，最近也是感受颇多。希望能够在记录下来，激励自己不断学习、前进。\" class=\"headerlink\" title=\"自从7月份从去哪儿出来以后，这段时间一直在陆陆续续的面试一些公司。包括58、京东、滴滴、美团、阿里。面试的过程既痛苦又开心，最近也是感受颇多。希望能够在记录下来，激励自己不断学习、前进。\"></a>自从7月份从去哪儿出来以后，这段时间一直在陆陆续续的面试一些公司。包括58、京东、滴滴、美团、阿里。面试的过程既痛苦又开心，最近也是感受颇多。希望能够在记录下来，激励自己不断学习、前进。</h5>","more":"<h3 id=\"58、京东、滴滴、美团\"><a href=\"#58、京东、滴滴、美团\" class=\"headerlink\" title=\"　　58、京东、滴滴、美团\"></a>　　58、京东、滴滴、美团</h3><h5 id=\"这几家公司面试的时间比较早，在7月份就已经面试完成。\"><a href=\"#这几家公司面试的时间比较早，在7月份就已经面试完成。\" class=\"headerlink\" title=\"这几家公司面试的时间比较早，在7月份就已经面试完成。\"></a>这几家公司面试的时间比较早，在7月份就已经面试完成。</h5><h5 id=\"其中58是去哪儿出来以后面试的第一家公司，基本上投了简历以后马上就有人给我打电话通知面试。然后面试得过程其实还算正常，但是二面回去等通知（感觉三面就已经是hr面了），二面结束的时候面试官给我的评价是技术还行，但是感觉不太踏实。后等了一个星期没有结果，联系面试官告知没有通过。给我的反馈是感觉基础有点差。\"><a href=\"#其中58是去哪儿出来以后面试的第一家公司，基本上投了简历以后马上就有人给我打电话通知面试。然后面试得过程其实还算正常，但是二面回去等通知（感觉三面就已经是hr面了），二面结束的时候面试官给我的评价是技术还行，但是感觉不太踏实。后等了一个星期没有结果，联系面试官告知没有通过。给我的反馈是感觉基础有点差。\" class=\"headerlink\" title=\"其中58是去哪儿出来以后面试的第一家公司，基本上投了简历以后马上就有人给我打电话通知面试。然后面试得过程其实还算正常，但是二面回去等通知（感觉三面就已经是hr面了），二面结束的时候面试官给我的评价是技术还行，但是感觉不太踏实。后等了一个星期没有结果，联系面试官告知没有通过。给我的反馈是感觉基础有点差。\"></a>其中58是去哪儿出来以后面试的第一家公司，基本上投了简历以后马上就有人给我打电话通知面试。然后面试得过程其实还算正常，但是二面回去等通知（感觉三面就已经是hr面了），二面结束的时候面试官给我的评价是技术还行，但是感觉不太踏实。后等了一个星期没有结果，联系面试官告知没有通过。给我的反馈是感觉基础有点差。</h5><h5 id=\"京东的面试也是在一天之内完成了，大大小小进过了4、5轮面试。过程还算顺利。只是hr好像不太待见我们，因为京东的薪资普遍偏低，可能hr自己也感觉我不太能够接受他们给的薪资。但是因为面试官很看好我，给了我很多帮组，包括帮我去争取额外的级别和薪资。以及在我拒绝了hr的offer还给了一个星期的考虑时间。加上我之后对京东福利的一些了解，所以现在对京东的印象是非常好的。\"><a href=\"#京东的面试也是在一天之内完成了，大大小小进过了4、5轮面试。过程还算顺利。只是hr好像不太待见我们，因为京东的薪资普遍偏低，可能hr自己也感觉我不太能够接受他们给的薪资。但是因为面试官很看好我，给了我很多帮组，包括帮我去争取额外的级别和薪资。以及在我拒绝了hr的offer还给了一个星期的考虑时间。加上我之后对京东福利的一些了解，所以现在对京东的印象是非常好的。\" class=\"headerlink\" title=\"京东的面试也是在一天之内完成了，大大小小进过了4、5轮面试。过程还算顺利。只是hr好像不太待见我们，因为京东的薪资普遍偏低，可能hr自己也感觉我不太能够接受他们给的薪资。但是因为面试官很看好我，给了我很多帮组，包括帮我去争取额外的级别和薪资。以及在我拒绝了hr的offer还给了一个星期的考虑时间。加上我之后对京东福利的一些了解，所以现在对京东的印象是非常好的。\"></a>京东的面试也是在一天之内完成了，大大小小进过了4、5轮面试。过程还算顺利。只是hr好像不太待见我们，因为京东的薪资普遍偏低，可能hr自己也感觉我不太能够接受他们给的薪资。但是因为面试官很看好我，给了我很多帮组，包括帮我去争取额外的级别和薪资。以及在我拒绝了hr的offer还给了一个星期的考虑时间。加上我之后对京东福利的一些了解，所以现在对京东的印象是非常好的。</h5><h5 id=\"滴滴是拿到offer并且接受了。企业级事业部-私车同行。还是很有挑战的。\"><a href=\"#滴滴是拿到offer并且接受了。企业级事业部-私车同行。还是很有挑战的。\" class=\"headerlink\" title=\"滴滴是拿到offer并且接受了。企业级事业部-私车同行。还是很有挑战的。\"></a>滴滴是拿到offer并且接受了。企业级事业部-私车同行。还是很有挑战的。</h5><h5 id=\"美团比较遗憾，走到了3面，也和hr聊了薪资。hr也说了给我催offer。但是还是没有拿到offer。这个比较坑了。然后就是吐槽一下美团的办事效率吧。\"><a href=\"#美团比较遗憾，走到了3面，也和hr聊了薪资。hr也说了给我催offer。但是还是没有拿到offer。这个比较坑了。然后就是吐槽一下美团的办事效率吧。\" class=\"headerlink\" title=\"美团比较遗憾，走到了3面，也和hr聊了薪资。hr也说了给我催offer。但是还是没有拿到offer。这个比较坑了。然后就是吐槽一下美团的办事效率吧。\"></a>美团比较遗憾，走到了3面，也和hr聊了薪资。hr也说了给我催offer。但是还是没有拿到offer。这个比较坑了。然后就是吐槽一下美团的办事效率吧。</h5><h5 id=\"阿里是最心疼的。一直从7月份面试到今天，一共面了6轮，3个部门。最终还是没有拿到offer。也是阿里的面试让我感触很多，发现自己的不足。阿里的面试过程中，最大的问题还是在于之前qunar的工作内容，系统设计，没能很好的表达清楚。对于系统的一些难点，以及遇到的一些问题，没能很好的回答清楚。其实如果抱着完成任务的心态去处理事情，会发现很多事情都很简单。但是如果你仔细去钻研的话，会发现自己有很多东西都明白其原理和过程。之前的工作可能就缺少了这份钻研，以及自己的总结能力有待提高。导致对于之前的系统的认识还是停留在很表面的层次。这是我最想改正的地方。也很感谢阿里的这几轮面试，真的是面累了，心很累，报的希望越大，失望也越大。所以还是需要静下心来好好钻研与学习。阿里来年再战！！！\"><a href=\"#阿里是最心疼的。一直从7月份面试到今天，一共面了6轮，3个部门。最终还是没有拿到offer。也是阿里的面试让我感触很多，发现自己的不足。阿里的面试过程中，最大的问题还是在于之前qunar的工作内容，系统设计，没能很好的表达清楚。对于系统的一些难点，以及遇到的一些问题，没能很好的回答清楚。其实如果抱着完成任务的心态去处理事情，会发现很多事情都很简单。但是如果你仔细去钻研的话，会发现自己有很多东西都明白其原理和过程。之前的工作可能就缺少了这份钻研，以及自己的总结能力有待提高。导致对于之前的系统的认识还是停留在很表面的层次。这是我最想改正的地方。也很感谢阿里的这几轮面试，真的是面累了，心很累，报的希望越大，失望也越大。所以还是需要静下心来好好钻研与学习。阿里来年再战！！！\" class=\"headerlink\" title=\"阿里是最心疼的。一直从7月份面试到今天，一共面了6轮，3个部门。最终还是没有拿到offer。也是阿里的面试让我感触很多，发现自己的不足。阿里的面试过程中，最大的问题还是在于之前qunar的工作内容，系统设计，没能很好的表达清楚。对于系统的一些难点，以及遇到的一些问题，没能很好的回答清楚。其实如果抱着完成任务的心态去处理事情，会发现很多事情都很简单。但是如果你仔细去钻研的话，会发现自己有很多东西都明白其原理和过程。之前的工作可能就缺少了这份钻研，以及自己的总结能力有待提高。导致对于之前的系统的认识还是停留在很表面的层次。这是我最想改正的地方。也很感谢阿里的这几轮面试，真的是面累了，心很累，报的希望越大，失望也越大。所以还是需要静下心来好好钻研与学习。阿里来年再战！！！\"></a>阿里是最心疼的。一直从7月份面试到今天，一共面了6轮，3个部门。最终还是没有拿到offer。也是阿里的面试让我感触很多，发现自己的不足。阿里的面试过程中，最大的问题还是在于之前qunar的工作内容，系统设计，没能很好的表达清楚。对于系统的一些难点，以及遇到的一些问题，没能很好的回答清楚。其实如果抱着完成任务的心态去处理事情，会发现很多事情都很简单。但是如果你仔细去钻研的话，会发现自己有很多东西都明白其原理和过程。之前的工作可能就缺少了这份钻研，以及自己的总结能力有待提高。导致对于之前的系统的认识还是停留在很表面的层次。这是我最想改正的地方。也很感谢阿里的这几轮面试，真的是面累了，心很累，报的希望越大，失望也越大。所以还是需要静下心来好好钻研与学习。阿里来年再战！！！</h5>"},{"layout":"post","title":"2016走了","date":"2016-12-31T16:00:00.000Z","original":true,"img":"/life/2016-bg.jpg","color":"#777","_content":"\n##### 2017年1月份已经快过去了，再有两天就是春节。在这之前的春节，都是作为一个学生的身份，自然是有寒假的，这第一年工作，却要等到大年三十才能回家，多少还是有些不适应。加上北京这两天风特别大，这不，得了感冒了，今天还请了一天病假，才有时间坐在家里开始完成这一篇16年总结。其实20多天前就计划要写年终总结，但是最近很多事情都在耽误这一计划。加上需要将博客从jekyll迁移到hexo，使得每次打开博客，大部分时间都是在完成博客页面主题的编写，所以在博客文章上花的时间少了很多（其实之前好像也没花多少时间，惭愧）。\n<!--more-->\n\n##### 其实除了几篇技术文章，我几乎没有写过博客，以前倒是坚持写过一段时间的日记，但也总是断断续续。这当中一个很重要的原因就是从小作文就不太好，不太会用文字去描述身边的事情和自己的想法（比如上面这一段文字，就花了大概十分钟，删删减减才完成的），但我本身是很想去表达一些东西的。这个博客是16年10月份左右搭建起来的，大部分时间都用在了前端页面的编写上面了，起初是希望能够做一些技术上的总结，后来发现可以将生活中的一些总结也记录在此，再之后又添加了read版块。有点偏题了，已经不像是年终总结了。下面开始回到正题。\n\n##### 去年这一年是我从一个面向学校的学生转变为面向社会的工作者的一年。和很多毕业生一样，有一点迷茫，也有对未来的无限向往，我们就像一个个梦想家，有着无限的期望。但是我现在更希望做一个实干家，或者说行动大于空想。我是在15年的9月21号左右通过qunar面试的，这之前也参加过其他公司的校招，但是我之前的校招经历比较坎坷。因此我对qunar是非常感激的，加上面试的两位面试官也给我很好的感觉。所以在拿到qunar的offer之后，我几乎没有再考虑过其他公司。虽然随之而来的消息是qunar被携程合并，管理层的集体退出，以及多家航司对qunar的联合打击。\n\n##### 16年春节后，来到北京参加qunar的技术培训，和另外几个qunar的小伙伴，一起合租，一个房间睡了三个人，当时算了下，那一套房子有5个房间，一共住了14个人，当时最大的愿望就是，转正之后一定要有自己房间。期间公司培训的内容就是java后端开发那一套，个人觉得那是面向初学者的，所以我一有时间就去写毕业设计了，现在想起来多少有一些后悔。这可以算是我第一次参加工作，之前在学校很少出去兼职赚钱，大多数时间都是在团队或者实验室写代码做项目，感觉自己确实很契合程序员这个职业-够宅够闷骚。\n![2016-qunar技术培训照片](/img/life/2016-qunar.jpeg)\n\n##### 5月初的时候，趁着劳动节就回学校了，因为马上就要做毕业答辩，但是论文什么都还没写。记得离开北京的时候，还是挺高兴的，毕竟学校还有一大堆的同学和朋友在等着我回去。期间和几个好朋友去了一趟云南，这是第一次去云南，我们先是坐飞机来到了昆明，然后去了大理、丽江、香格里拉。那边的风景实在是很漂亮，特别是从大理的苍山上俯瞰整个大理。说来也是缘分，之后我在qunar工作认识的，也就是我现在的女朋友，就是来自云南的，因此我觉得我和云南还是挺有缘分的。回到学校，便是答辩，合照，聚会。有些细节现在已经忘记，记得最清楚的是毕业季真的很难过。可能是因为大家都舍不得，室友们几乎都是同一天走的。\n![2016-室友毕业小聚](/img/life/2016-roommate.jpeg)\n\n##### 兜兜转转，现在已经是2017年1月26号凌晨1点半，我正在火车站的候车室内席地而坐，等候回家的列车，车需要等到3点半才行，但是我现在已经有点困了。说到回家，虽然已经工作，但是今年回家的次数还真不少。除掉办领身份证、办理护照回去两次，另外还回去了大概两三次。可能是因为要工作了，想到以后没有了暑假，只有过年才有时间回家，所以一有时间便往家里赶。幸运的是，父母现在身体还算好,能够照顾好自己。希望他们永远健康。\n\n##### 继续说说2016吧，其实也没什么好说的了。对了，我和我的女朋友就是这一年在公司认识的，和她在一起4个多月了，吵了无数次架，我们的感情却越来越深，她真的是一个好女孩，希望在我今后的道路当中，都有她的陪伴。至于2016年这一年的工作情况，就不在这里总结了，总之希望新的一年越来越好。我也需要更加努力。这一年对我来说有一个大的变化就是，之前我是一个悲观主义者，对很多东西都不看好，认为那都是命中注定，我们改变不了什么，我们太渺小了。现在，我依然认为我们改变不了任何事情，但是我坚信我们可以改变自己。这个世界不是你想象中的那个样子，你也没有办法将它改变成你想要的样子，那就改变你自己，改变你看这个世界的角度和观点，那世界将是一个崭新的世界。\n","source":"_posts/life/summary-2016.md","raw":"---\nlayout: post\ntitle: 2016走了\ndate: 2017/01/01\ntags: [life, index]\noriginal: true\nimg: /life/2016-bg.jpg\ncolor: \"#777\"\n---\n\n##### 2017年1月份已经快过去了，再有两天就是春节。在这之前的春节，都是作为一个学生的身份，自然是有寒假的，这第一年工作，却要等到大年三十才能回家，多少还是有些不适应。加上北京这两天风特别大，这不，得了感冒了，今天还请了一天病假，才有时间坐在家里开始完成这一篇16年总结。其实20多天前就计划要写年终总结，但是最近很多事情都在耽误这一计划。加上需要将博客从jekyll迁移到hexo，使得每次打开博客，大部分时间都是在完成博客页面主题的编写，所以在博客文章上花的时间少了很多（其实之前好像也没花多少时间，惭愧）。\n<!--more-->\n\n##### 其实除了几篇技术文章，我几乎没有写过博客，以前倒是坚持写过一段时间的日记，但也总是断断续续。这当中一个很重要的原因就是从小作文就不太好，不太会用文字去描述身边的事情和自己的想法（比如上面这一段文字，就花了大概十分钟，删删减减才完成的），但我本身是很想去表达一些东西的。这个博客是16年10月份左右搭建起来的，大部分时间都用在了前端页面的编写上面了，起初是希望能够做一些技术上的总结，后来发现可以将生活中的一些总结也记录在此，再之后又添加了read版块。有点偏题了，已经不像是年终总结了。下面开始回到正题。\n\n##### 去年这一年是我从一个面向学校的学生转变为面向社会的工作者的一年。和很多毕业生一样，有一点迷茫，也有对未来的无限向往，我们就像一个个梦想家，有着无限的期望。但是我现在更希望做一个实干家，或者说行动大于空想。我是在15年的9月21号左右通过qunar面试的，这之前也参加过其他公司的校招，但是我之前的校招经历比较坎坷。因此我对qunar是非常感激的，加上面试的两位面试官也给我很好的感觉。所以在拿到qunar的offer之后，我几乎没有再考虑过其他公司。虽然随之而来的消息是qunar被携程合并，管理层的集体退出，以及多家航司对qunar的联合打击。\n\n##### 16年春节后，来到北京参加qunar的技术培训，和另外几个qunar的小伙伴，一起合租，一个房间睡了三个人，当时算了下，那一套房子有5个房间，一共住了14个人，当时最大的愿望就是，转正之后一定要有自己房间。期间公司培训的内容就是java后端开发那一套，个人觉得那是面向初学者的，所以我一有时间就去写毕业设计了，现在想起来多少有一些后悔。这可以算是我第一次参加工作，之前在学校很少出去兼职赚钱，大多数时间都是在团队或者实验室写代码做项目，感觉自己确实很契合程序员这个职业-够宅够闷骚。\n![2016-qunar技术培训照片](/img/life/2016-qunar.jpeg)\n\n##### 5月初的时候，趁着劳动节就回学校了，因为马上就要做毕业答辩，但是论文什么都还没写。记得离开北京的时候，还是挺高兴的，毕竟学校还有一大堆的同学和朋友在等着我回去。期间和几个好朋友去了一趟云南，这是第一次去云南，我们先是坐飞机来到了昆明，然后去了大理、丽江、香格里拉。那边的风景实在是很漂亮，特别是从大理的苍山上俯瞰整个大理。说来也是缘分，之后我在qunar工作认识的，也就是我现在的女朋友，就是来自云南的，因此我觉得我和云南还是挺有缘分的。回到学校，便是答辩，合照，聚会。有些细节现在已经忘记，记得最清楚的是毕业季真的很难过。可能是因为大家都舍不得，室友们几乎都是同一天走的。\n![2016-室友毕业小聚](/img/life/2016-roommate.jpeg)\n\n##### 兜兜转转，现在已经是2017年1月26号凌晨1点半，我正在火车站的候车室内席地而坐，等候回家的列车，车需要等到3点半才行，但是我现在已经有点困了。说到回家，虽然已经工作，但是今年回家的次数还真不少。除掉办领身份证、办理护照回去两次，另外还回去了大概两三次。可能是因为要工作了，想到以后没有了暑假，只有过年才有时间回家，所以一有时间便往家里赶。幸运的是，父母现在身体还算好,能够照顾好自己。希望他们永远健康。\n\n##### 继续说说2016吧，其实也没什么好说的了。对了，我和我的女朋友就是这一年在公司认识的，和她在一起4个多月了，吵了无数次架，我们的感情却越来越深，她真的是一个好女孩，希望在我今后的道路当中，都有她的陪伴。至于2016年这一年的工作情况，就不在这里总结了，总之希望新的一年越来越好。我也需要更加努力。这一年对我来说有一个大的变化就是，之前我是一个悲观主义者，对很多东西都不看好，认为那都是命中注定，我们改变不了什么，我们太渺小了。现在，我依然认为我们改变不了任何事情，但是我坚信我们可以改变自己。这个世界不是你想象中的那个样子，你也没有办法将它改变成你想要的样子，那就改变你自己，改变你看这个世界的角度和观点，那世界将是一个崭新的世界。\n","slug":"life/summary-2016","published":1,"updated":"2018-05-08T14:51:18.368Z","_id":"cjgxop3l00005jah1i4hxvxar","comments":1,"photos":[],"link":"","content":"<h5 id=\"2017年1月份已经快过去了，再有两天就是春节。在这之前的春节，都是作为一个学生的身份，自然是有寒假的，这第一年工作，却要等到大年三十才能回家，多少还是有些不适应。加上北京这两天风特别大，这不，得了感冒了，今天还请了一天病假，才有时间坐在家里开始完成这一篇16年总结。其实20多天前就计划要写年终总结，但是最近很多事情都在耽误这一计划。加上需要将博客从jekyll迁移到hexo，使得每次打开博客，大部分时间都是在完成博客页面主题的编写，所以在博客文章上花的时间少了很多（其实之前好像也没花多少时间，惭愧）。\"><a href=\"#2017年1月份已经快过去了，再有两天就是春节。在这之前的春节，都是作为一个学生的身份，自然是有寒假的，这第一年工作，却要等到大年三十才能回家，多少还是有些不适应。加上北京这两天风特别大，这不，得了感冒了，今天还请了一天病假，才有时间坐在家里开始完成这一篇16年总结。其实20多天前就计划要写年终总结，但是最近很多事情都在耽误这一计划。加上需要将博客从jekyll迁移到hexo，使得每次打开博客，大部分时间都是在完成博客页面主题的编写，所以在博客文章上花的时间少了很多（其实之前好像也没花多少时间，惭愧）。\" class=\"headerlink\" title=\"2017年1月份已经快过去了，再有两天就是春节。在这之前的春节，都是作为一个学生的身份，自然是有寒假的，这第一年工作，却要等到大年三十才能回家，多少还是有些不适应。加上北京这两天风特别大，这不，得了感冒了，今天还请了一天病假，才有时间坐在家里开始完成这一篇16年总结。其实20多天前就计划要写年终总结，但是最近很多事情都在耽误这一计划。加上需要将博客从jekyll迁移到hexo，使得每次打开博客，大部分时间都是在完成博客页面主题的编写，所以在博客文章上花的时间少了很多（其实之前好像也没花多少时间，惭愧）。\"></a>2017年1月份已经快过去了，再有两天就是春节。在这之前的春节，都是作为一个学生的身份，自然是有寒假的，这第一年工作，却要等到大年三十才能回家，多少还是有些不适应。加上北京这两天风特别大，这不，得了感冒了，今天还请了一天病假，才有时间坐在家里开始完成这一篇16年总结。其实20多天前就计划要写年终总结，但是最近很多事情都在耽误这一计划。加上需要将博客从jekyll迁移到hexo，使得每次打开博客，大部分时间都是在完成博客页面主题的编写，所以在博客文章上花的时间少了很多（其实之前好像也没花多少时间，惭愧）。</h5><a id=\"more\"></a>\n<h5 id=\"其实除了几篇技术文章，我几乎没有写过博客，以前倒是坚持写过一段时间的日记，但也总是断断续续。这当中一个很重要的原因就是从小作文就不太好，不太会用文字去描述身边的事情和自己的想法（比如上面这一段文字，就花了大概十分钟，删删减减才完成的），但我本身是很想去表达一些东西的。这个博客是16年10月份左右搭建起来的，大部分时间都用在了前端页面的编写上面了，起初是希望能够做一些技术上的总结，后来发现可以将生活中的一些总结也记录在此，再之后又添加了read版块。有点偏题了，已经不像是年终总结了。下面开始回到正题。\"><a href=\"#其实除了几篇技术文章，我几乎没有写过博客，以前倒是坚持写过一段时间的日记，但也总是断断续续。这当中一个很重要的原因就是从小作文就不太好，不太会用文字去描述身边的事情和自己的想法（比如上面这一段文字，就花了大概十分钟，删删减减才完成的），但我本身是很想去表达一些东西的。这个博客是16年10月份左右搭建起来的，大部分时间都用在了前端页面的编写上面了，起初是希望能够做一些技术上的总结，后来发现可以将生活中的一些总结也记录在此，再之后又添加了read版块。有点偏题了，已经不像是年终总结了。下面开始回到正题。\" class=\"headerlink\" title=\"其实除了几篇技术文章，我几乎没有写过博客，以前倒是坚持写过一段时间的日记，但也总是断断续续。这当中一个很重要的原因就是从小作文就不太好，不太会用文字去描述身边的事情和自己的想法（比如上面这一段文字，就花了大概十分钟，删删减减才完成的），但我本身是很想去表达一些东西的。这个博客是16年10月份左右搭建起来的，大部分时间都用在了前端页面的编写上面了，起初是希望能够做一些技术上的总结，后来发现可以将生活中的一些总结也记录在此，再之后又添加了read版块。有点偏题了，已经不像是年终总结了。下面开始回到正题。\"></a>其实除了几篇技术文章，我几乎没有写过博客，以前倒是坚持写过一段时间的日记，但也总是断断续续。这当中一个很重要的原因就是从小作文就不太好，不太会用文字去描述身边的事情和自己的想法（比如上面这一段文字，就花了大概十分钟，删删减减才完成的），但我本身是很想去表达一些东西的。这个博客是16年10月份左右搭建起来的，大部分时间都用在了前端页面的编写上面了，起初是希望能够做一些技术上的总结，后来发现可以将生活中的一些总结也记录在此，再之后又添加了read版块。有点偏题了，已经不像是年终总结了。下面开始回到正题。</h5><h5 id=\"去年这一年是我从一个面向学校的学生转变为面向社会的工作者的一年。和很多毕业生一样，有一点迷茫，也有对未来的无限向往，我们就像一个个梦想家，有着无限的期望。但是我现在更希望做一个实干家，或者说行动大于空想。我是在15年的9月21号左右通过qunar面试的，这之前也参加过其他公司的校招，但是我之前的校招经历比较坎坷。因此我对qunar是非常感激的，加上面试的两位面试官也给我很好的感觉。所以在拿到qunar的offer之后，我几乎没有再考虑过其他公司。虽然随之而来的消息是qunar被携程合并，管理层的集体退出，以及多家航司对qunar的联合打击。\"><a href=\"#去年这一年是我从一个面向学校的学生转变为面向社会的工作者的一年。和很多毕业生一样，有一点迷茫，也有对未来的无限向往，我们就像一个个梦想家，有着无限的期望。但是我现在更希望做一个实干家，或者说行动大于空想。我是在15年的9月21号左右通过qunar面试的，这之前也参加过其他公司的校招，但是我之前的校招经历比较坎坷。因此我对qunar是非常感激的，加上面试的两位面试官也给我很好的感觉。所以在拿到qunar的offer之后，我几乎没有再考虑过其他公司。虽然随之而来的消息是qunar被携程合并，管理层的集体退出，以及多家航司对qunar的联合打击。\" class=\"headerlink\" title=\"去年这一年是我从一个面向学校的学生转变为面向社会的工作者的一年。和很多毕业生一样，有一点迷茫，也有对未来的无限向往，我们就像一个个梦想家，有着无限的期望。但是我现在更希望做一个实干家，或者说行动大于空想。我是在15年的9月21号左右通过qunar面试的，这之前也参加过其他公司的校招，但是我之前的校招经历比较坎坷。因此我对qunar是非常感激的，加上面试的两位面试官也给我很好的感觉。所以在拿到qunar的offer之后，我几乎没有再考虑过其他公司。虽然随之而来的消息是qunar被携程合并，管理层的集体退出，以及多家航司对qunar的联合打击。\"></a>去年这一年是我从一个面向学校的学生转变为面向社会的工作者的一年。和很多毕业生一样，有一点迷茫，也有对未来的无限向往，我们就像一个个梦想家，有着无限的期望。但是我现在更希望做一个实干家，或者说行动大于空想。我是在15年的9月21号左右通过qunar面试的，这之前也参加过其他公司的校招，但是我之前的校招经历比较坎坷。因此我对qunar是非常感激的，加上面试的两位面试官也给我很好的感觉。所以在拿到qunar的offer之后，我几乎没有再考虑过其他公司。虽然随之而来的消息是qunar被携程合并，管理层的集体退出，以及多家航司对qunar的联合打击。</h5><h5 id=\"16年春节后，来到北京参加qunar的技术培训，和另外几个qunar的小伙伴，一起合租，一个房间睡了三个人，当时算了下，那一套房子有5个房间，一共住了14个人，当时最大的愿望就是，转正之后一定要有自己房间。期间公司培训的内容就是java后端开发那一套，个人觉得那是面向初学者的，所以我一有时间就去写毕业设计了，现在想起来多少有一些后悔。这可以算是我第一次参加工作，之前在学校很少出去兼职赚钱，大多数时间都是在团队或者实验室写代码做项目，感觉自己确实很契合程序员这个职业-够宅够闷骚。\"><a href=\"#16年春节后，来到北京参加qunar的技术培训，和另外几个qunar的小伙伴，一起合租，一个房间睡了三个人，当时算了下，那一套房子有5个房间，一共住了14个人，当时最大的愿望就是，转正之后一定要有自己房间。期间公司培训的内容就是java后端开发那一套，个人觉得那是面向初学者的，所以我一有时间就去写毕业设计了，现在想起来多少有一些后悔。这可以算是我第一次参加工作，之前在学校很少出去兼职赚钱，大多数时间都是在团队或者实验室写代码做项目，感觉自己确实很契合程序员这个职业-够宅够闷骚。\" class=\"headerlink\" title=\"16年春节后，来到北京参加qunar的技术培训，和另外几个qunar的小伙伴，一起合租，一个房间睡了三个人，当时算了下，那一套房子有5个房间，一共住了14个人，当时最大的愿望就是，转正之后一定要有自己房间。期间公司培训的内容就是java后端开发那一套，个人觉得那是面向初学者的，所以我一有时间就去写毕业设计了，现在想起来多少有一些后悔。这可以算是我第一次参加工作，之前在学校很少出去兼职赚钱，大多数时间都是在团队或者实验室写代码做项目，感觉自己确实很契合程序员这个职业-够宅够闷骚。\"></a>16年春节后，来到北京参加qunar的技术培训，和另外几个qunar的小伙伴，一起合租，一个房间睡了三个人，当时算了下，那一套房子有5个房间，一共住了14个人，当时最大的愿望就是，转正之后一定要有自己房间。期间公司培训的内容就是java后端开发那一套，个人觉得那是面向初学者的，所以我一有时间就去写毕业设计了，现在想起来多少有一些后悔。这可以算是我第一次参加工作，之前在学校很少出去兼职赚钱，大多数时间都是在团队或者实验室写代码做项目，感觉自己确实很契合程序员这个职业-够宅够闷骚。</h5><p><img src=\"/img/life/2016-qunar.jpeg\" alt=\"2016-qunar技术培训照片\"></p>\n<h5 id=\"5月初的时候，趁着劳动节就回学校了，因为马上就要做毕业答辩，但是论文什么都还没写。记得离开北京的时候，还是挺高兴的，毕竟学校还有一大堆的同学和朋友在等着我回去。期间和几个好朋友去了一趟云南，这是第一次去云南，我们先是坐飞机来到了昆明，然后去了大理、丽江、香格里拉。那边的风景实在是很漂亮，特别是从大理的苍山上俯瞰整个大理。说来也是缘分，之后我在qunar工作认识的，也就是我现在的女朋友，就是来自云南的，因此我觉得我和云南还是挺有缘分的。回到学校，便是答辩，合照，聚会。有些细节现在已经忘记，记得最清楚的是毕业季真的很难过。可能是因为大家都舍不得，室友们几乎都是同一天走的。\"><a href=\"#5月初的时候，趁着劳动节就回学校了，因为马上就要做毕业答辩，但是论文什么都还没写。记得离开北京的时候，还是挺高兴的，毕竟学校还有一大堆的同学和朋友在等着我回去。期间和几个好朋友去了一趟云南，这是第一次去云南，我们先是坐飞机来到了昆明，然后去了大理、丽江、香格里拉。那边的风景实在是很漂亮，特别是从大理的苍山上俯瞰整个大理。说来也是缘分，之后我在qunar工作认识的，也就是我现在的女朋友，就是来自云南的，因此我觉得我和云南还是挺有缘分的。回到学校，便是答辩，合照，聚会。有些细节现在已经忘记，记得最清楚的是毕业季真的很难过。可能是因为大家都舍不得，室友们几乎都是同一天走的。\" class=\"headerlink\" title=\"5月初的时候，趁着劳动节就回学校了，因为马上就要做毕业答辩，但是论文什么都还没写。记得离开北京的时候，还是挺高兴的，毕竟学校还有一大堆的同学和朋友在等着我回去。期间和几个好朋友去了一趟云南，这是第一次去云南，我们先是坐飞机来到了昆明，然后去了大理、丽江、香格里拉。那边的风景实在是很漂亮，特别是从大理的苍山上俯瞰整个大理。说来也是缘分，之后我在qunar工作认识的，也就是我现在的女朋友，就是来自云南的，因此我觉得我和云南还是挺有缘分的。回到学校，便是答辩，合照，聚会。有些细节现在已经忘记，记得最清楚的是毕业季真的很难过。可能是因为大家都舍不得，室友们几乎都是同一天走的。\"></a>5月初的时候，趁着劳动节就回学校了，因为马上就要做毕业答辩，但是论文什么都还没写。记得离开北京的时候，还是挺高兴的，毕竟学校还有一大堆的同学和朋友在等着我回去。期间和几个好朋友去了一趟云南，这是第一次去云南，我们先是坐飞机来到了昆明，然后去了大理、丽江、香格里拉。那边的风景实在是很漂亮，特别是从大理的苍山上俯瞰整个大理。说来也是缘分，之后我在qunar工作认识的，也就是我现在的女朋友，就是来自云南的，因此我觉得我和云南还是挺有缘分的。回到学校，便是答辩，合照，聚会。有些细节现在已经忘记，记得最清楚的是毕业季真的很难过。可能是因为大家都舍不得，室友们几乎都是同一天走的。</h5><p><img src=\"/img/life/2016-roommate.jpeg\" alt=\"2016-室友毕业小聚\"></p>\n<h5 id=\"兜兜转转，现在已经是2017年1月26号凌晨1点半，我正在火车站的候车室内席地而坐，等候回家的列车，车需要等到3点半才行，但是我现在已经有点困了。说到回家，虽然已经工作，但是今年回家的次数还真不少。除掉办领身份证、办理护照回去两次，另外还回去了大概两三次。可能是因为要工作了，想到以后没有了暑假，只有过年才有时间回家，所以一有时间便往家里赶。幸运的是，父母现在身体还算好-能够照顾好自己。希望他们永远健康。\"><a href=\"#兜兜转转，现在已经是2017年1月26号凌晨1点半，我正在火车站的候车室内席地而坐，等候回家的列车，车需要等到3点半才行，但是我现在已经有点困了。说到回家，虽然已经工作，但是今年回家的次数还真不少。除掉办领身份证、办理护照回去两次，另外还回去了大概两三次。可能是因为要工作了，想到以后没有了暑假，只有过年才有时间回家，所以一有时间便往家里赶。幸运的是，父母现在身体还算好-能够照顾好自己。希望他们永远健康。\" class=\"headerlink\" title=\"兜兜转转，现在已经是2017年1月26号凌晨1点半，我正在火车站的候车室内席地而坐，等候回家的列车，车需要等到3点半才行，但是我现在已经有点困了。说到回家，虽然已经工作，但是今年回家的次数还真不少。除掉办领身份证、办理护照回去两次，另外还回去了大概两三次。可能是因为要工作了，想到以后没有了暑假，只有过年才有时间回家，所以一有时间便往家里赶。幸运的是，父母现在身体还算好,能够照顾好自己。希望他们永远健康。\"></a>兜兜转转，现在已经是2017年1月26号凌晨1点半，我正在火车站的候车室内席地而坐，等候回家的列车，车需要等到3点半才行，但是我现在已经有点困了。说到回家，虽然已经工作，但是今年回家的次数还真不少。除掉办领身份证、办理护照回去两次，另外还回去了大概两三次。可能是因为要工作了，想到以后没有了暑假，只有过年才有时间回家，所以一有时间便往家里赶。幸运的是，父母现在身体还算好,能够照顾好自己。希望他们永远健康。</h5><h5 id=\"继续说说2016吧，其实也没什么好说的了。对了，我和我的女朋友就是这一年在公司认识的，和她在一起4个多月了，吵了无数次架，我们的感情却越来越深，她真的是一个好女孩，希望在我今后的道路当中，都有她的陪伴。至于2016年这一年的工作情况，就不在这里总结了，总之希望新的一年越来越好。我也需要更加努力。这一年对我来说有一个大的变化就是，之前我是一个悲观主义者，对很多东西都不看好，认为那都是命中注定，我们改变不了什么，我们太渺小了。现在，我依然认为我们改变不了任何事情，但是我坚信我们可以改变自己。这个世界不是你想象中的那个样子，你也没有办法将它改变成你想要的样子，那就改变你自己，改变你看这个世界的角度和观点，那世界将是一个崭新的世界。\"><a href=\"#继续说说2016吧，其实也没什么好说的了。对了，我和我的女朋友就是这一年在公司认识的，和她在一起4个多月了，吵了无数次架，我们的感情却越来越深，她真的是一个好女孩，希望在我今后的道路当中，都有她的陪伴。至于2016年这一年的工作情况，就不在这里总结了，总之希望新的一年越来越好。我也需要更加努力。这一年对我来说有一个大的变化就是，之前我是一个悲观主义者，对很多东西都不看好，认为那都是命中注定，我们改变不了什么，我们太渺小了。现在，我依然认为我们改变不了任何事情，但是我坚信我们可以改变自己。这个世界不是你想象中的那个样子，你也没有办法将它改变成你想要的样子，那就改变你自己，改变你看这个世界的角度和观点，那世界将是一个崭新的世界。\" class=\"headerlink\" title=\"继续说说2016吧，其实也没什么好说的了。对了，我和我的女朋友就是这一年在公司认识的，和她在一起4个多月了，吵了无数次架，我们的感情却越来越深，她真的是一个好女孩，希望在我今后的道路当中，都有她的陪伴。至于2016年这一年的工作情况，就不在这里总结了，总之希望新的一年越来越好。我也需要更加努力。这一年对我来说有一个大的变化就是，之前我是一个悲观主义者，对很多东西都不看好，认为那都是命中注定，我们改变不了什么，我们太渺小了。现在，我依然认为我们改变不了任何事情，但是我坚信我们可以改变自己。这个世界不是你想象中的那个样子，你也没有办法将它改变成你想要的样子，那就改变你自己，改变你看这个世界的角度和观点，那世界将是一个崭新的世界。\"></a>继续说说2016吧，其实也没什么好说的了。对了，我和我的女朋友就是这一年在公司认识的，和她在一起4个多月了，吵了无数次架，我们的感情却越来越深，她真的是一个好女孩，希望在我今后的道路当中，都有她的陪伴。至于2016年这一年的工作情况，就不在这里总结了，总之希望新的一年越来越好。我也需要更加努力。这一年对我来说有一个大的变化就是，之前我是一个悲观主义者，对很多东西都不看好，认为那都是命中注定，我们改变不了什么，我们太渺小了。现在，我依然认为我们改变不了任何事情，但是我坚信我们可以改变自己。这个世界不是你想象中的那个样子，你也没有办法将它改变成你想要的样子，那就改变你自己，改变你看这个世界的角度和观点，那世界将是一个崭新的世界。</h5>","site":{"data":{}},"excerpt":"<h5 id=\"2017年1月份已经快过去了，再有两天就是春节。在这之前的春节，都是作为一个学生的身份，自然是有寒假的，这第一年工作，却要等到大年三十才能回家，多少还是有些不适应。加上北京这两天风特别大，这不，得了感冒了，今天还请了一天病假，才有时间坐在家里开始完成这一篇16年总结。其实20多天前就计划要写年终总结，但是最近很多事情都在耽误这一计划。加上需要将博客从jekyll迁移到hexo，使得每次打开博客，大部分时间都是在完成博客页面主题的编写，所以在博客文章上花的时间少了很多（其实之前好像也没花多少时间，惭愧）。\"><a href=\"#2017年1月份已经快过去了，再有两天就是春节。在这之前的春节，都是作为一个学生的身份，自然是有寒假的，这第一年工作，却要等到大年三十才能回家，多少还是有些不适应。加上北京这两天风特别大，这不，得了感冒了，今天还请了一天病假，才有时间坐在家里开始完成这一篇16年总结。其实20多天前就计划要写年终总结，但是最近很多事情都在耽误这一计划。加上需要将博客从jekyll迁移到hexo，使得每次打开博客，大部分时间都是在完成博客页面主题的编写，所以在博客文章上花的时间少了很多（其实之前好像也没花多少时间，惭愧）。\" class=\"headerlink\" title=\"2017年1月份已经快过去了，再有两天就是春节。在这之前的春节，都是作为一个学生的身份，自然是有寒假的，这第一年工作，却要等到大年三十才能回家，多少还是有些不适应。加上北京这两天风特别大，这不，得了感冒了，今天还请了一天病假，才有时间坐在家里开始完成这一篇16年总结。其实20多天前就计划要写年终总结，但是最近很多事情都在耽误这一计划。加上需要将博客从jekyll迁移到hexo，使得每次打开博客，大部分时间都是在完成博客页面主题的编写，所以在博客文章上花的时间少了很多（其实之前好像也没花多少时间，惭愧）。\"></a>2017年1月份已经快过去了，再有两天就是春节。在这之前的春节，都是作为一个学生的身份，自然是有寒假的，这第一年工作，却要等到大年三十才能回家，多少还是有些不适应。加上北京这两天风特别大，这不，得了感冒了，今天还请了一天病假，才有时间坐在家里开始完成这一篇16年总结。其实20多天前就计划要写年终总结，但是最近很多事情都在耽误这一计划。加上需要将博客从jekyll迁移到hexo，使得每次打开博客，大部分时间都是在完成博客页面主题的编写，所以在博客文章上花的时间少了很多（其实之前好像也没花多少时间，惭愧）。</h5>","more":"<h5 id=\"其实除了几篇技术文章，我几乎没有写过博客，以前倒是坚持写过一段时间的日记，但也总是断断续续。这当中一个很重要的原因就是从小作文就不太好，不太会用文字去描述身边的事情和自己的想法（比如上面这一段文字，就花了大概十分钟，删删减减才完成的），但我本身是很想去表达一些东西的。这个博客是16年10月份左右搭建起来的，大部分时间都用在了前端页面的编写上面了，起初是希望能够做一些技术上的总结，后来发现可以将生活中的一些总结也记录在此，再之后又添加了read版块。有点偏题了，已经不像是年终总结了。下面开始回到正题。\"><a href=\"#其实除了几篇技术文章，我几乎没有写过博客，以前倒是坚持写过一段时间的日记，但也总是断断续续。这当中一个很重要的原因就是从小作文就不太好，不太会用文字去描述身边的事情和自己的想法（比如上面这一段文字，就花了大概十分钟，删删减减才完成的），但我本身是很想去表达一些东西的。这个博客是16年10月份左右搭建起来的，大部分时间都用在了前端页面的编写上面了，起初是希望能够做一些技术上的总结，后来发现可以将生活中的一些总结也记录在此，再之后又添加了read版块。有点偏题了，已经不像是年终总结了。下面开始回到正题。\" class=\"headerlink\" title=\"其实除了几篇技术文章，我几乎没有写过博客，以前倒是坚持写过一段时间的日记，但也总是断断续续。这当中一个很重要的原因就是从小作文就不太好，不太会用文字去描述身边的事情和自己的想法（比如上面这一段文字，就花了大概十分钟，删删减减才完成的），但我本身是很想去表达一些东西的。这个博客是16年10月份左右搭建起来的，大部分时间都用在了前端页面的编写上面了，起初是希望能够做一些技术上的总结，后来发现可以将生活中的一些总结也记录在此，再之后又添加了read版块。有点偏题了，已经不像是年终总结了。下面开始回到正题。\"></a>其实除了几篇技术文章，我几乎没有写过博客，以前倒是坚持写过一段时间的日记，但也总是断断续续。这当中一个很重要的原因就是从小作文就不太好，不太会用文字去描述身边的事情和自己的想法（比如上面这一段文字，就花了大概十分钟，删删减减才完成的），但我本身是很想去表达一些东西的。这个博客是16年10月份左右搭建起来的，大部分时间都用在了前端页面的编写上面了，起初是希望能够做一些技术上的总结，后来发现可以将生活中的一些总结也记录在此，再之后又添加了read版块。有点偏题了，已经不像是年终总结了。下面开始回到正题。</h5><h5 id=\"去年这一年是我从一个面向学校的学生转变为面向社会的工作者的一年。和很多毕业生一样，有一点迷茫，也有对未来的无限向往，我们就像一个个梦想家，有着无限的期望。但是我现在更希望做一个实干家，或者说行动大于空想。我是在15年的9月21号左右通过qunar面试的，这之前也参加过其他公司的校招，但是我之前的校招经历比较坎坷。因此我对qunar是非常感激的，加上面试的两位面试官也给我很好的感觉。所以在拿到qunar的offer之后，我几乎没有再考虑过其他公司。虽然随之而来的消息是qunar被携程合并，管理层的集体退出，以及多家航司对qunar的联合打击。\"><a href=\"#去年这一年是我从一个面向学校的学生转变为面向社会的工作者的一年。和很多毕业生一样，有一点迷茫，也有对未来的无限向往，我们就像一个个梦想家，有着无限的期望。但是我现在更希望做一个实干家，或者说行动大于空想。我是在15年的9月21号左右通过qunar面试的，这之前也参加过其他公司的校招，但是我之前的校招经历比较坎坷。因此我对qunar是非常感激的，加上面试的两位面试官也给我很好的感觉。所以在拿到qunar的offer之后，我几乎没有再考虑过其他公司。虽然随之而来的消息是qunar被携程合并，管理层的集体退出，以及多家航司对qunar的联合打击。\" class=\"headerlink\" title=\"去年这一年是我从一个面向学校的学生转变为面向社会的工作者的一年。和很多毕业生一样，有一点迷茫，也有对未来的无限向往，我们就像一个个梦想家，有着无限的期望。但是我现在更希望做一个实干家，或者说行动大于空想。我是在15年的9月21号左右通过qunar面试的，这之前也参加过其他公司的校招，但是我之前的校招经历比较坎坷。因此我对qunar是非常感激的，加上面试的两位面试官也给我很好的感觉。所以在拿到qunar的offer之后，我几乎没有再考虑过其他公司。虽然随之而来的消息是qunar被携程合并，管理层的集体退出，以及多家航司对qunar的联合打击。\"></a>去年这一年是我从一个面向学校的学生转变为面向社会的工作者的一年。和很多毕业生一样，有一点迷茫，也有对未来的无限向往，我们就像一个个梦想家，有着无限的期望。但是我现在更希望做一个实干家，或者说行动大于空想。我是在15年的9月21号左右通过qunar面试的，这之前也参加过其他公司的校招，但是我之前的校招经历比较坎坷。因此我对qunar是非常感激的，加上面试的两位面试官也给我很好的感觉。所以在拿到qunar的offer之后，我几乎没有再考虑过其他公司。虽然随之而来的消息是qunar被携程合并，管理层的集体退出，以及多家航司对qunar的联合打击。</h5><h5 id=\"16年春节后，来到北京参加qunar的技术培训，和另外几个qunar的小伙伴，一起合租，一个房间睡了三个人，当时算了下，那一套房子有5个房间，一共住了14个人，当时最大的愿望就是，转正之后一定要有自己房间。期间公司培训的内容就是java后端开发那一套，个人觉得那是面向初学者的，所以我一有时间就去写毕业设计了，现在想起来多少有一些后悔。这可以算是我第一次参加工作，之前在学校很少出去兼职赚钱，大多数时间都是在团队或者实验室写代码做项目，感觉自己确实很契合程序员这个职业-够宅够闷骚。\"><a href=\"#16年春节后，来到北京参加qunar的技术培训，和另外几个qunar的小伙伴，一起合租，一个房间睡了三个人，当时算了下，那一套房子有5个房间，一共住了14个人，当时最大的愿望就是，转正之后一定要有自己房间。期间公司培训的内容就是java后端开发那一套，个人觉得那是面向初学者的，所以我一有时间就去写毕业设计了，现在想起来多少有一些后悔。这可以算是我第一次参加工作，之前在学校很少出去兼职赚钱，大多数时间都是在团队或者实验室写代码做项目，感觉自己确实很契合程序员这个职业-够宅够闷骚。\" class=\"headerlink\" title=\"16年春节后，来到北京参加qunar的技术培训，和另外几个qunar的小伙伴，一起合租，一个房间睡了三个人，当时算了下，那一套房子有5个房间，一共住了14个人，当时最大的愿望就是，转正之后一定要有自己房间。期间公司培训的内容就是java后端开发那一套，个人觉得那是面向初学者的，所以我一有时间就去写毕业设计了，现在想起来多少有一些后悔。这可以算是我第一次参加工作，之前在学校很少出去兼职赚钱，大多数时间都是在团队或者实验室写代码做项目，感觉自己确实很契合程序员这个职业-够宅够闷骚。\"></a>16年春节后，来到北京参加qunar的技术培训，和另外几个qunar的小伙伴，一起合租，一个房间睡了三个人，当时算了下，那一套房子有5个房间，一共住了14个人，当时最大的愿望就是，转正之后一定要有自己房间。期间公司培训的内容就是java后端开发那一套，个人觉得那是面向初学者的，所以我一有时间就去写毕业设计了，现在想起来多少有一些后悔。这可以算是我第一次参加工作，之前在学校很少出去兼职赚钱，大多数时间都是在团队或者实验室写代码做项目，感觉自己确实很契合程序员这个职业-够宅够闷骚。</h5><p><img src=\"/img/life/2016-qunar.jpeg\" alt=\"2016-qunar技术培训照片\"></p>\n<h5 id=\"5月初的时候，趁着劳动节就回学校了，因为马上就要做毕业答辩，但是论文什么都还没写。记得离开北京的时候，还是挺高兴的，毕竟学校还有一大堆的同学和朋友在等着我回去。期间和几个好朋友去了一趟云南，这是第一次去云南，我们先是坐飞机来到了昆明，然后去了大理、丽江、香格里拉。那边的风景实在是很漂亮，特别是从大理的苍山上俯瞰整个大理。说来也是缘分，之后我在qunar工作认识的，也就是我现在的女朋友，就是来自云南的，因此我觉得我和云南还是挺有缘分的。回到学校，便是答辩，合照，聚会。有些细节现在已经忘记，记得最清楚的是毕业季真的很难过。可能是因为大家都舍不得，室友们几乎都是同一天走的。\"><a href=\"#5月初的时候，趁着劳动节就回学校了，因为马上就要做毕业答辩，但是论文什么都还没写。记得离开北京的时候，还是挺高兴的，毕竟学校还有一大堆的同学和朋友在等着我回去。期间和几个好朋友去了一趟云南，这是第一次去云南，我们先是坐飞机来到了昆明，然后去了大理、丽江、香格里拉。那边的风景实在是很漂亮，特别是从大理的苍山上俯瞰整个大理。说来也是缘分，之后我在qunar工作认识的，也就是我现在的女朋友，就是来自云南的，因此我觉得我和云南还是挺有缘分的。回到学校，便是答辩，合照，聚会。有些细节现在已经忘记，记得最清楚的是毕业季真的很难过。可能是因为大家都舍不得，室友们几乎都是同一天走的。\" class=\"headerlink\" title=\"5月初的时候，趁着劳动节就回学校了，因为马上就要做毕业答辩，但是论文什么都还没写。记得离开北京的时候，还是挺高兴的，毕竟学校还有一大堆的同学和朋友在等着我回去。期间和几个好朋友去了一趟云南，这是第一次去云南，我们先是坐飞机来到了昆明，然后去了大理、丽江、香格里拉。那边的风景实在是很漂亮，特别是从大理的苍山上俯瞰整个大理。说来也是缘分，之后我在qunar工作认识的，也就是我现在的女朋友，就是来自云南的，因此我觉得我和云南还是挺有缘分的。回到学校，便是答辩，合照，聚会。有些细节现在已经忘记，记得最清楚的是毕业季真的很难过。可能是因为大家都舍不得，室友们几乎都是同一天走的。\"></a>5月初的时候，趁着劳动节就回学校了，因为马上就要做毕业答辩，但是论文什么都还没写。记得离开北京的时候，还是挺高兴的，毕竟学校还有一大堆的同学和朋友在等着我回去。期间和几个好朋友去了一趟云南，这是第一次去云南，我们先是坐飞机来到了昆明，然后去了大理、丽江、香格里拉。那边的风景实在是很漂亮，特别是从大理的苍山上俯瞰整个大理。说来也是缘分，之后我在qunar工作认识的，也就是我现在的女朋友，就是来自云南的，因此我觉得我和云南还是挺有缘分的。回到学校，便是答辩，合照，聚会。有些细节现在已经忘记，记得最清楚的是毕业季真的很难过。可能是因为大家都舍不得，室友们几乎都是同一天走的。</h5><p><img src=\"/img/life/2016-roommate.jpeg\" alt=\"2016-室友毕业小聚\"></p>\n<h5 id=\"兜兜转转，现在已经是2017年1月26号凌晨1点半，我正在火车站的候车室内席地而坐，等候回家的列车，车需要等到3点半才行，但是我现在已经有点困了。说到回家，虽然已经工作，但是今年回家的次数还真不少。除掉办领身份证、办理护照回去两次，另外还回去了大概两三次。可能是因为要工作了，想到以后没有了暑假，只有过年才有时间回家，所以一有时间便往家里赶。幸运的是，父母现在身体还算好-能够照顾好自己。希望他们永远健康。\"><a href=\"#兜兜转转，现在已经是2017年1月26号凌晨1点半，我正在火车站的候车室内席地而坐，等候回家的列车，车需要等到3点半才行，但是我现在已经有点困了。说到回家，虽然已经工作，但是今年回家的次数还真不少。除掉办领身份证、办理护照回去两次，另外还回去了大概两三次。可能是因为要工作了，想到以后没有了暑假，只有过年才有时间回家，所以一有时间便往家里赶。幸运的是，父母现在身体还算好-能够照顾好自己。希望他们永远健康。\" class=\"headerlink\" title=\"兜兜转转，现在已经是2017年1月26号凌晨1点半，我正在火车站的候车室内席地而坐，等候回家的列车，车需要等到3点半才行，但是我现在已经有点困了。说到回家，虽然已经工作，但是今年回家的次数还真不少。除掉办领身份证、办理护照回去两次，另外还回去了大概两三次。可能是因为要工作了，想到以后没有了暑假，只有过年才有时间回家，所以一有时间便往家里赶。幸运的是，父母现在身体还算好,能够照顾好自己。希望他们永远健康。\"></a>兜兜转转，现在已经是2017年1月26号凌晨1点半，我正在火车站的候车室内席地而坐，等候回家的列车，车需要等到3点半才行，但是我现在已经有点困了。说到回家，虽然已经工作，但是今年回家的次数还真不少。除掉办领身份证、办理护照回去两次，另外还回去了大概两三次。可能是因为要工作了，想到以后没有了暑假，只有过年才有时间回家，所以一有时间便往家里赶。幸运的是，父母现在身体还算好,能够照顾好自己。希望他们永远健康。</h5><h5 id=\"继续说说2016吧，其实也没什么好说的了。对了，我和我的女朋友就是这一年在公司认识的，和她在一起4个多月了，吵了无数次架，我们的感情却越来越深，她真的是一个好女孩，希望在我今后的道路当中，都有她的陪伴。至于2016年这一年的工作情况，就不在这里总结了，总之希望新的一年越来越好。我也需要更加努力。这一年对我来说有一个大的变化就是，之前我是一个悲观主义者，对很多东西都不看好，认为那都是命中注定，我们改变不了什么，我们太渺小了。现在，我依然认为我们改变不了任何事情，但是我坚信我们可以改变自己。这个世界不是你想象中的那个样子，你也没有办法将它改变成你想要的样子，那就改变你自己，改变你看这个世界的角度和观点，那世界将是一个崭新的世界。\"><a href=\"#继续说说2016吧，其实也没什么好说的了。对了，我和我的女朋友就是这一年在公司认识的，和她在一起4个多月了，吵了无数次架，我们的感情却越来越深，她真的是一个好女孩，希望在我今后的道路当中，都有她的陪伴。至于2016年这一年的工作情况，就不在这里总结了，总之希望新的一年越来越好。我也需要更加努力。这一年对我来说有一个大的变化就是，之前我是一个悲观主义者，对很多东西都不看好，认为那都是命中注定，我们改变不了什么，我们太渺小了。现在，我依然认为我们改变不了任何事情，但是我坚信我们可以改变自己。这个世界不是你想象中的那个样子，你也没有办法将它改变成你想要的样子，那就改变你自己，改变你看这个世界的角度和观点，那世界将是一个崭新的世界。\" class=\"headerlink\" title=\"继续说说2016吧，其实也没什么好说的了。对了，我和我的女朋友就是这一年在公司认识的，和她在一起4个多月了，吵了无数次架，我们的感情却越来越深，她真的是一个好女孩，希望在我今后的道路当中，都有她的陪伴。至于2016年这一年的工作情况，就不在这里总结了，总之希望新的一年越来越好。我也需要更加努力。这一年对我来说有一个大的变化就是，之前我是一个悲观主义者，对很多东西都不看好，认为那都是命中注定，我们改变不了什么，我们太渺小了。现在，我依然认为我们改变不了任何事情，但是我坚信我们可以改变自己。这个世界不是你想象中的那个样子，你也没有办法将它改变成你想要的样子，那就改变你自己，改变你看这个世界的角度和观点，那世界将是一个崭新的世界。\"></a>继续说说2016吧，其实也没什么好说的了。对了，我和我的女朋友就是这一年在公司认识的，和她在一起4个多月了，吵了无数次架，我们的感情却越来越深，她真的是一个好女孩，希望在我今后的道路当中，都有她的陪伴。至于2016年这一年的工作情况，就不在这里总结了，总之希望新的一年越来越好。我也需要更加努力。这一年对我来说有一个大的变化就是，之前我是一个悲观主义者，对很多东西都不看好，认为那都是命中注定，我们改变不了什么，我们太渺小了。现在，我依然认为我们改变不了任何事情，但是我坚信我们可以改变自己。这个世界不是你想象中的那个样子，你也没有办法将它改变成你想要的样子，那就改变你自己，改变你看这个世界的角度和观点，那世界将是一个崭新的世界。</h5>"},{"layout":"post","title":"fastJson为什么这么快","date":"2018-03-25T16:00:00.000Z","tag":[["java","java"]],"_content":"\n##### JSON处理主要包括两个部分，serialize和deserialize。serialize就是把Java对象变成JSON String或者JSON Bytes。Deserialize是把JSON String或者Json Bytes变成java对象。其实这个过程有些JSON库是分三部分的，json string <－-> json tree <－-> java object。Fastjson也支持这种转换方式，但是这种转换方式因为有多余的步骤，性能不好，不推荐使用。\n\n<!--more-->\n\n## 为什么Fastjson能够做到这么快？\n### Fastjson中Serialzie的优化实现\n#### 1.自行编写类似StringBuilder的工具类**SerializeWriter**。\n##### 把java对象序列化成json文本，是不可能使用字符串直接拼接的，因为这样性能很差。比字符串拼接更好的办法是使用`java.lang.StringBuilder`。StringBuilder虽然速度很好了，但还能够进一步提升性能的，fastjson中提供了一个类似StringBuilder的类`com.alibaba.fastjson.serializer.SerializeWriter`。\n\n##### **SerializeWriter**提供一些针对性的方法减少数组越界检查。例如`public void writeIntAndChar(int i, char c) {}`，这样的方法一次性把两个值写到buf中去，能够减少一次越界检查。目前SerializeWriter还有一些关键的方法能够减少越界检查的，我还没实现。也就是说，如果实现了，能够进一步提升serialize的性能。\n\n#### 2、使用ThreadLocal来缓存buf。\n##### 这个办法能够减少对象分配和gc，从而提升性能。SerializeWriter中包含了一个char[] buf，每序列化一次，都要做一次分配，使用ThreadLocal优化，能够提升性能。\n\n#### 3、使用asm避免反射\n##### 获取java bean的属性值，需要调用反射，fastjson引入了asm的来避免反射导致的开销。fastjson内置的asm是基于objectweb asm 3.3.1改造的，只保留必要的部分，fastjson asm部分不到1000行代码，引入了asm的同时不导致大小变大太多。\n\n#### 4、使用一个特殊的IdentityHashMap优化性能。\n##### fastjson对每种类型使用一种serializer，于是就存在class -> JavaBeanSerizlier的映射。fastjson使用IdentityHashMap而不是HashMap，避免equals操作。我们知道HashMap的算法的transfer操作，并发时可能导致死循环，但是ConcurrentHashMap比HashMap系列会慢，因为其使用volatile和lock。fastjson自己实现了一个特别的IdentityHashMap，去掉transfer操作的IdentityHashMap，能够在并发时工作，但是不会导致死循环。\n\n#### 5、缺省启用sort field输出\n##### json的object是一种key/value结构，正常的hashmap是无序的，fastjson缺省是排序输出的，这是为deserialize优化做准备。\n\n#### 6、集成jdk实现的一些优化算法\n##### 在优化fastjson的过程中，参考了jdk内部实现的算法，比如int to char[]算法等等。\n\n### fastjson的deserializer的主要优化算法\n##### deserializer也称为parser或者decoder，fastjson在这方面投入的优化精力最多。\n#### 1、读取token基于预测。\n##### 所有的parser基本上都需要做词法处理，json也不例外。fastjson词法处理的时候，使用了基于预测的优化算法。比如key之后，最大的可能是冒号\":\"，value之后，可能是有两个，逗号\",\"或者右括号\"}\"。在com.alibaba.fastjson.parser.JSONScanner中提供了这样的方法：\n```java\npublic void nextToken(int expect) {\n    for (;;) {\n        switch (expect) {\n            case JSONToken.COMMA: //\n                if (ch == ',') {\n                    token = JSONToken.COMMA;\n                    ch = buf[++bp];\n                    return;\n                }\n\n                if (ch == '}') {\n                    token = JSONToken.RBRACE;\n                    ch = buf[++bp];\n                    return;\n                }\n\n                if (ch == ']') {\n                    token = JSONToken.RBRACKET;\n                    ch = buf[++bp];\n                    return;\n                }\n\n                if (ch == EOI) {\n                    token = JSONToken.EOF;\n                    return;\n                }\n                break;\n        // ... ...\n    }\n}\n```\n\n##### 从上面摘抄下来的代码看，基于预测能够做更少的处理就能够读取到token。\n#### 2、sort field fast match算法\n##### fastjson的serialize是按照key的顺序进行的，于是fastjson做deserializer时候，采用一种优化算法，就是假设key/value的内容是有序的，读取的时候只需要做key的匹配，而不需要把key从输入中读取出来。通过这个优化，使得fastjson在处理json文本的时候，少读取超过50%的token，这个是一个十分关键的优化算法。基于这个算法，使用asm实现，性能提升十分明显，超过300％的性能提升。\n```java\n{ \"id\" : 123, \"name\" : \"魏加流\", \"salary\" : 56789.79}\n```\n\n##### 在上面例子看，三个部分的key，如果key_id、key_name、key_salary这三个key是顺序的，就可以做优化处理，这三个key不需要被读取出来，只需要比较就可以了。\n\n##### 这种算法分两种模式，一种是快速模式，一种是常规模式。快速模式是假定key是顺序的，能快速处理，如果发现不能够快速处理，则退回常规模式。保证性能的同时，不会影响功能。\n\n##### 在这个例子中，常规模式需要处理13个token，快速模式只需要处理6个token。\n\n##### 实现sort field fast match算法的代码在这个类\n\n##### [com.alibaba.fastjson.parser.deserializer.ASMDeserializerFactory|http://code.alibabatech.com/svn/fastjson/trunk/fastjson/src/main/java/com/alibaba/fastjson/parser/deserializer/ASMDeserializerFactory.java]，是使用asm针对每种类型的VO动态创建一个类实现的。\n\n##### 这里是有一个用于演示sort field fast match算法的代码：\n```java\n// 用于快速匹配的每个字段的前缀\nchar[] size_   = \"\\\"size\\\":\".toCharArray();\nchar[] uri_    = \"\\\"uri\\\":\".toCharArray();\nchar[] titile_ = \"\\\"title\\\":\".toCharArray();\nchar[] width_  = \"\\\"width\\\":\".toCharArray();\nchar[] height_ = \"\\\"height\\\":\".toCharArray();\n\n// 保存parse开始时的lexer状态信息\nint mark = lexer.getBufferPosition();\nchar mark_ch = lexer.getCurrent();\nint mark_token = lexer.token();\n\nint height = lexer.scanFieldInt(height_);\nif (lexer.matchStat == JSONScanner.NOT_MATCH) {\n    // 退出快速模式, 进入常规模式\n    lexer.reset(mark, mark_ch, mark_token);\n    return (T) super.deserialze(parser, clazz);\n}\n\nString value = lexer.scanFieldString(size_);\nif (lexer.matchStat == JSONScanner.NOT_MATCH) {\n    // 退出快速模式, 进入常规模式\n    lexer.reset(mark, mark_ch, mark_token);\n    return (T) super.deserialze(parser, clazz);\n}\nSize size = Size.valueOf(value);\n\n// ... ...\n\n// batch set\nImage image = new Image();\nimage.setSize(size);\nimage.setUri(uri);\nimage.setTitle(title);\nimage.setWidth(width);\nimage.setHeight(height);\n\nreturn (T) image;\n```\n\n#### 3、使用asm避免反射\n##### deserialize的时候，会使用asm来构造对象，并且做batch set，也就是说合并连续调用多个setter方法，而不是分散调用，这个能够提升性能。\n\n#### 4、对utf-8的json bytes，针对性使用优化的版本来转换编码。\n##### 这个类是com.alibaba.fastjson.util.UTF8Decoder，来源于JDK中的UTF8Decoder，但是它使用ThreadLocal Cache Buffer，避免转换时分配char[]的开销。\n##### ThreadLocal Cache的实现是这个类com.alibaba.fastjson.util.ThreadLocalCache。第一次1k，如果不够，会增长，最多增长到128k。\n\n```java\n//代码摘抄自com.alibaba.fastjson.JSON\npublic static final <T> T parseObject(byte[] input, int off, int len, CharsetDecoder charsetDecoder, Type clazz,\n                                      Feature... features) {\n    charsetDecoder.reset();\n\n    int scaleLength = (int) (len * (double) charsetDecoder.maxCharsPerByte());\n    char[] chars = ThreadLocalCache.getChars(scaleLength); // 使用ThreadLocalCache，避免频繁分配内存\n\n    ByteBuffer byteBuf = ByteBuffer.wrap(input, off, len);\n    CharBuffer charByte = CharBuffer.wrap(chars);\n    IOUtils.decode(charsetDecoder, byteBuf, charByte);\n\n    int position = charByte.position();\n\n    return (T) parseObject(chars, position, clazz, features);\n}\n```\n\n#### 5、symbolTable算法。\n##### 我们看xml或者javac的parser实现，经常会看到有一个这样的东西symbol table，它就是把一些经常使用的关键字缓存起来，在遍历char[]的时候，同时把hash计算好，通过这个hash值在hashtable中来获取缓存好的symbol，避免创建新的字符串对象。这种优化在fastjson里面用在key的读取，以及enum value的读取。这是也是parse性能优化的关键算法之一。\n\n##### 以下是摘抄自JSONScanner类中的代码，这段代码用于读取类型为enum的value。\n```java\nint hash = 0;\nfor (;;) {\n    ch = buf[index++];\n    if (ch == '\\\"') {\n        bp = index;\n        this.ch = ch = buf[bp];\n        strVal = symbolTable.addSymbol(buf, start, index - start - 1, hash); // 通过symbolTable来获得缓存好的symbol，包括fieldName、enumValue\n        break;\n    }\n\n    hash = 31 * hash + ch; // 在token scan的过程中计算好hash\n\n    // ... ...\n}\n```\n\n### 我们能用fastjson来作什么？\n1. 替换其他所有的json库，java世界里没有其他的json库能够和fastjson可相比了。\n2. 使用fastjson的序列化和反序列化替换java serialize，java serialize不单性能慢，而且体制大。\n3. 使用fastjson替换hessian，json协议和hessian协议大小差不多一样，而且fastjson性能优越，10倍于hessian\n4. 把fastjson用于redis、memached缓存对象数据。\n\n##### 转载自：[http://wenshao.iteye.com/blog/1142031/](http://wenshao.iteye.com/blog/1142031/)","source":"_posts/note/fastjson.md","raw":"---\nlayout: post\ntitle: fastJson为什么这么快\ndate: 2018/03/26\ntags: [tech, index]\ntag: [[java, java]]\n---\n\n##### JSON处理主要包括两个部分，serialize和deserialize。serialize就是把Java对象变成JSON String或者JSON Bytes。Deserialize是把JSON String或者Json Bytes变成java对象。其实这个过程有些JSON库是分三部分的，json string <－-> json tree <－-> java object。Fastjson也支持这种转换方式，但是这种转换方式因为有多余的步骤，性能不好，不推荐使用。\n\n<!--more-->\n\n## 为什么Fastjson能够做到这么快？\n### Fastjson中Serialzie的优化实现\n#### 1.自行编写类似StringBuilder的工具类**SerializeWriter**。\n##### 把java对象序列化成json文本，是不可能使用字符串直接拼接的，因为这样性能很差。比字符串拼接更好的办法是使用`java.lang.StringBuilder`。StringBuilder虽然速度很好了，但还能够进一步提升性能的，fastjson中提供了一个类似StringBuilder的类`com.alibaba.fastjson.serializer.SerializeWriter`。\n\n##### **SerializeWriter**提供一些针对性的方法减少数组越界检查。例如`public void writeIntAndChar(int i, char c) {}`，这样的方法一次性把两个值写到buf中去，能够减少一次越界检查。目前SerializeWriter还有一些关键的方法能够减少越界检查的，我还没实现。也就是说，如果实现了，能够进一步提升serialize的性能。\n\n#### 2、使用ThreadLocal来缓存buf。\n##### 这个办法能够减少对象分配和gc，从而提升性能。SerializeWriter中包含了一个char[] buf，每序列化一次，都要做一次分配，使用ThreadLocal优化，能够提升性能。\n\n#### 3、使用asm避免反射\n##### 获取java bean的属性值，需要调用反射，fastjson引入了asm的来避免反射导致的开销。fastjson内置的asm是基于objectweb asm 3.3.1改造的，只保留必要的部分，fastjson asm部分不到1000行代码，引入了asm的同时不导致大小变大太多。\n\n#### 4、使用一个特殊的IdentityHashMap优化性能。\n##### fastjson对每种类型使用一种serializer，于是就存在class -> JavaBeanSerizlier的映射。fastjson使用IdentityHashMap而不是HashMap，避免equals操作。我们知道HashMap的算法的transfer操作，并发时可能导致死循环，但是ConcurrentHashMap比HashMap系列会慢，因为其使用volatile和lock。fastjson自己实现了一个特别的IdentityHashMap，去掉transfer操作的IdentityHashMap，能够在并发时工作，但是不会导致死循环。\n\n#### 5、缺省启用sort field输出\n##### json的object是一种key/value结构，正常的hashmap是无序的，fastjson缺省是排序输出的，这是为deserialize优化做准备。\n\n#### 6、集成jdk实现的一些优化算法\n##### 在优化fastjson的过程中，参考了jdk内部实现的算法，比如int to char[]算法等等。\n\n### fastjson的deserializer的主要优化算法\n##### deserializer也称为parser或者decoder，fastjson在这方面投入的优化精力最多。\n#### 1、读取token基于预测。\n##### 所有的parser基本上都需要做词法处理，json也不例外。fastjson词法处理的时候，使用了基于预测的优化算法。比如key之后，最大的可能是冒号\":\"，value之后，可能是有两个，逗号\",\"或者右括号\"}\"。在com.alibaba.fastjson.parser.JSONScanner中提供了这样的方法：\n```java\npublic void nextToken(int expect) {\n    for (;;) {\n        switch (expect) {\n            case JSONToken.COMMA: //\n                if (ch == ',') {\n                    token = JSONToken.COMMA;\n                    ch = buf[++bp];\n                    return;\n                }\n\n                if (ch == '}') {\n                    token = JSONToken.RBRACE;\n                    ch = buf[++bp];\n                    return;\n                }\n\n                if (ch == ']') {\n                    token = JSONToken.RBRACKET;\n                    ch = buf[++bp];\n                    return;\n                }\n\n                if (ch == EOI) {\n                    token = JSONToken.EOF;\n                    return;\n                }\n                break;\n        // ... ...\n    }\n}\n```\n\n##### 从上面摘抄下来的代码看，基于预测能够做更少的处理就能够读取到token。\n#### 2、sort field fast match算法\n##### fastjson的serialize是按照key的顺序进行的，于是fastjson做deserializer时候，采用一种优化算法，就是假设key/value的内容是有序的，读取的时候只需要做key的匹配，而不需要把key从输入中读取出来。通过这个优化，使得fastjson在处理json文本的时候，少读取超过50%的token，这个是一个十分关键的优化算法。基于这个算法，使用asm实现，性能提升十分明显，超过300％的性能提升。\n```java\n{ \"id\" : 123, \"name\" : \"魏加流\", \"salary\" : 56789.79}\n```\n\n##### 在上面例子看，三个部分的key，如果key_id、key_name、key_salary这三个key是顺序的，就可以做优化处理，这三个key不需要被读取出来，只需要比较就可以了。\n\n##### 这种算法分两种模式，一种是快速模式，一种是常规模式。快速模式是假定key是顺序的，能快速处理，如果发现不能够快速处理，则退回常规模式。保证性能的同时，不会影响功能。\n\n##### 在这个例子中，常规模式需要处理13个token，快速模式只需要处理6个token。\n\n##### 实现sort field fast match算法的代码在这个类\n\n##### [com.alibaba.fastjson.parser.deserializer.ASMDeserializerFactory|http://code.alibabatech.com/svn/fastjson/trunk/fastjson/src/main/java/com/alibaba/fastjson/parser/deserializer/ASMDeserializerFactory.java]，是使用asm针对每种类型的VO动态创建一个类实现的。\n\n##### 这里是有一个用于演示sort field fast match算法的代码：\n```java\n// 用于快速匹配的每个字段的前缀\nchar[] size_   = \"\\\"size\\\":\".toCharArray();\nchar[] uri_    = \"\\\"uri\\\":\".toCharArray();\nchar[] titile_ = \"\\\"title\\\":\".toCharArray();\nchar[] width_  = \"\\\"width\\\":\".toCharArray();\nchar[] height_ = \"\\\"height\\\":\".toCharArray();\n\n// 保存parse开始时的lexer状态信息\nint mark = lexer.getBufferPosition();\nchar mark_ch = lexer.getCurrent();\nint mark_token = lexer.token();\n\nint height = lexer.scanFieldInt(height_);\nif (lexer.matchStat == JSONScanner.NOT_MATCH) {\n    // 退出快速模式, 进入常规模式\n    lexer.reset(mark, mark_ch, mark_token);\n    return (T) super.deserialze(parser, clazz);\n}\n\nString value = lexer.scanFieldString(size_);\nif (lexer.matchStat == JSONScanner.NOT_MATCH) {\n    // 退出快速模式, 进入常规模式\n    lexer.reset(mark, mark_ch, mark_token);\n    return (T) super.deserialze(parser, clazz);\n}\nSize size = Size.valueOf(value);\n\n// ... ...\n\n// batch set\nImage image = new Image();\nimage.setSize(size);\nimage.setUri(uri);\nimage.setTitle(title);\nimage.setWidth(width);\nimage.setHeight(height);\n\nreturn (T) image;\n```\n\n#### 3、使用asm避免反射\n##### deserialize的时候，会使用asm来构造对象，并且做batch set，也就是说合并连续调用多个setter方法，而不是分散调用，这个能够提升性能。\n\n#### 4、对utf-8的json bytes，针对性使用优化的版本来转换编码。\n##### 这个类是com.alibaba.fastjson.util.UTF8Decoder，来源于JDK中的UTF8Decoder，但是它使用ThreadLocal Cache Buffer，避免转换时分配char[]的开销。\n##### ThreadLocal Cache的实现是这个类com.alibaba.fastjson.util.ThreadLocalCache。第一次1k，如果不够，会增长，最多增长到128k。\n\n```java\n//代码摘抄自com.alibaba.fastjson.JSON\npublic static final <T> T parseObject(byte[] input, int off, int len, CharsetDecoder charsetDecoder, Type clazz,\n                                      Feature... features) {\n    charsetDecoder.reset();\n\n    int scaleLength = (int) (len * (double) charsetDecoder.maxCharsPerByte());\n    char[] chars = ThreadLocalCache.getChars(scaleLength); // 使用ThreadLocalCache，避免频繁分配内存\n\n    ByteBuffer byteBuf = ByteBuffer.wrap(input, off, len);\n    CharBuffer charByte = CharBuffer.wrap(chars);\n    IOUtils.decode(charsetDecoder, byteBuf, charByte);\n\n    int position = charByte.position();\n\n    return (T) parseObject(chars, position, clazz, features);\n}\n```\n\n#### 5、symbolTable算法。\n##### 我们看xml或者javac的parser实现，经常会看到有一个这样的东西symbol table，它就是把一些经常使用的关键字缓存起来，在遍历char[]的时候，同时把hash计算好，通过这个hash值在hashtable中来获取缓存好的symbol，避免创建新的字符串对象。这种优化在fastjson里面用在key的读取，以及enum value的读取。这是也是parse性能优化的关键算法之一。\n\n##### 以下是摘抄自JSONScanner类中的代码，这段代码用于读取类型为enum的value。\n```java\nint hash = 0;\nfor (;;) {\n    ch = buf[index++];\n    if (ch == '\\\"') {\n        bp = index;\n        this.ch = ch = buf[bp];\n        strVal = symbolTable.addSymbol(buf, start, index - start - 1, hash); // 通过symbolTable来获得缓存好的symbol，包括fieldName、enumValue\n        break;\n    }\n\n    hash = 31 * hash + ch; // 在token scan的过程中计算好hash\n\n    // ... ...\n}\n```\n\n### 我们能用fastjson来作什么？\n1. 替换其他所有的json库，java世界里没有其他的json库能够和fastjson可相比了。\n2. 使用fastjson的序列化和反序列化替换java serialize，java serialize不单性能慢，而且体制大。\n3. 使用fastjson替换hessian，json协议和hessian协议大小差不多一样，而且fastjson性能优越，10倍于hessian\n4. 把fastjson用于redis、memached缓存对象数据。\n\n##### 转载自：[http://wenshao.iteye.com/blog/1142031/](http://wenshao.iteye.com/blog/1142031/)","slug":"note/fastjson","published":1,"updated":"2018-05-08T13:00:14.277Z","comments":1,"photos":[],"link":"","_id":"cjgxop3l30008jah1e8la3lkj","content":"<h5 id=\"JSON处理主要包括两个部分，serialize和deserialize。serialize就是把Java对象变成JSON-String或者JSON-Bytes。Deserialize是把JSON-String或者Json-Bytes变成java对象。其实这个过程有些JSON库是分三部分的，json-string-lt-－-gt-json-tree-lt-－-gt-java-object。Fastjson也支持这种转换方式，但是这种转换方式因为有多余的步骤，性能不好，不推荐使用。\"><a href=\"#JSON处理主要包括两个部分，serialize和deserialize。serialize就是把Java对象变成JSON-String或者JSON-Bytes。Deserialize是把JSON-String或者Json-Bytes变成java对象。其实这个过程有些JSON库是分三部分的，json-string-lt-－-gt-json-tree-lt-－-gt-java-object。Fastjson也支持这种转换方式，但是这种转换方式因为有多余的步骤，性能不好，不推荐使用。\" class=\"headerlink\" title=\"JSON处理主要包括两个部分，serialize和deserialize。serialize就是把Java对象变成JSON String或者JSON Bytes。Deserialize是把JSON String或者Json Bytes变成java对象。其实这个过程有些JSON库是分三部分的，json string &lt;－-&gt; json tree &lt;－-&gt; java object。Fastjson也支持这种转换方式，但是这种转换方式因为有多余的步骤，性能不好，不推荐使用。\"></a>JSON处理主要包括两个部分，serialize和deserialize。serialize就是把Java对象变成JSON String或者JSON Bytes。Deserialize是把JSON String或者Json Bytes变成java对象。其实这个过程有些JSON库是分三部分的，json string &lt;－-&gt; json tree &lt;－-&gt; java object。Fastjson也支持这种转换方式，但是这种转换方式因为有多余的步骤，性能不好，不推荐使用。</h5><a id=\"more\"></a>\n<h2 id=\"为什么Fastjson能够做到这么快？\"><a href=\"#为什么Fastjson能够做到这么快？\" class=\"headerlink\" title=\"为什么Fastjson能够做到这么快？\"></a>为什么Fastjson能够做到这么快？</h2><h3 id=\"Fastjson中Serialzie的优化实现\"><a href=\"#Fastjson中Serialzie的优化实现\" class=\"headerlink\" title=\"Fastjson中Serialzie的优化实现\"></a>Fastjson中Serialzie的优化实现</h3><h4 id=\"1-自行编写类似StringBuilder的工具类SerializeWriter。\"><a href=\"#1-自行编写类似StringBuilder的工具类SerializeWriter。\" class=\"headerlink\" title=\"1.自行编写类似StringBuilder的工具类SerializeWriter。\"></a>1.自行编写类似StringBuilder的工具类<strong>SerializeWriter</strong>。</h4><h5 id=\"把java对象序列化成json文本，是不可能使用字符串直接拼接的，因为这样性能很差。比字符串拼接更好的办法是使用java-lang-StringBuilder。StringBuilder虽然速度很好了，但还能够进一步提升性能的，fastjson中提供了一个类似StringBuilder的类com-alibaba-fastjson-serializer-SerializeWriter。\"><a href=\"#把java对象序列化成json文本，是不可能使用字符串直接拼接的，因为这样性能很差。比字符串拼接更好的办法是使用java-lang-StringBuilder。StringBuilder虽然速度很好了，但还能够进一步提升性能的，fastjson中提供了一个类似StringBuilder的类com-alibaba-fastjson-serializer-SerializeWriter。\" class=\"headerlink\" title=\"把java对象序列化成json文本，是不可能使用字符串直接拼接的，因为这样性能很差。比字符串拼接更好的办法是使用java.lang.StringBuilder。StringBuilder虽然速度很好了，但还能够进一步提升性能的，fastjson中提供了一个类似StringBuilder的类com.alibaba.fastjson.serializer.SerializeWriter。\"></a>把java对象序列化成json文本，是不可能使用字符串直接拼接的，因为这样性能很差。比字符串拼接更好的办法是使用<code>java.lang.StringBuilder</code>。StringBuilder虽然速度很好了，但还能够进一步提升性能的，fastjson中提供了一个类似StringBuilder的类<code>com.alibaba.fastjson.serializer.SerializeWriter</code>。</h5><h5 id=\"SerializeWriter提供一些针对性的方法减少数组越界检查。例如public-void-writeIntAndChar-int-i-char-c-，这样的方法一次性把两个值写到buf中去，能够减少一次越界检查。目前SerializeWriter还有一些关键的方法能够减少越界检查的，我还没实现。也就是说，如果实现了，能够进一步提升serialize的性能。\"><a href=\"#SerializeWriter提供一些针对性的方法减少数组越界检查。例如public-void-writeIntAndChar-int-i-char-c-，这样的方法一次性把两个值写到buf中去，能够减少一次越界检查。目前SerializeWriter还有一些关键的方法能够减少越界检查的，我还没实现。也就是说，如果实现了，能够进一步提升serialize的性能。\" class=\"headerlink\" title=\"SerializeWriter提供一些针对性的方法减少数组越界检查。例如public void writeIntAndChar(int i, char c) {}，这样的方法一次性把两个值写到buf中去，能够减少一次越界检查。目前SerializeWriter还有一些关键的方法能够减少越界检查的，我还没实现。也就是说，如果实现了，能够进一步提升serialize的性能。\"></a><strong>SerializeWriter</strong>提供一些针对性的方法减少数组越界检查。例如<code>public void writeIntAndChar(int i, char c) {}</code>，这样的方法一次性把两个值写到buf中去，能够减少一次越界检查。目前SerializeWriter还有一些关键的方法能够减少越界检查的，我还没实现。也就是说，如果实现了，能够进一步提升serialize的性能。</h5><h4 id=\"2、使用ThreadLocal来缓存buf。\"><a href=\"#2、使用ThreadLocal来缓存buf。\" class=\"headerlink\" title=\"2、使用ThreadLocal来缓存buf。\"></a>2、使用ThreadLocal来缓存buf。</h4><h5 id=\"这个办法能够减少对象分配和gc，从而提升性能。SerializeWriter中包含了一个char-buf，每序列化一次，都要做一次分配，使用ThreadLocal优化，能够提升性能。\"><a href=\"#这个办法能够减少对象分配和gc，从而提升性能。SerializeWriter中包含了一个char-buf，每序列化一次，都要做一次分配，使用ThreadLocal优化，能够提升性能。\" class=\"headerlink\" title=\"这个办法能够减少对象分配和gc，从而提升性能。SerializeWriter中包含了一个char[] buf，每序列化一次，都要做一次分配，使用ThreadLocal优化，能够提升性能。\"></a>这个办法能够减少对象分配和gc，从而提升性能。SerializeWriter中包含了一个char[] buf，每序列化一次，都要做一次分配，使用ThreadLocal优化，能够提升性能。</h5><h4 id=\"3、使用asm避免反射\"><a href=\"#3、使用asm避免反射\" class=\"headerlink\" title=\"3、使用asm避免反射\"></a>3、使用asm避免反射</h4><h5 id=\"获取java-bean的属性值，需要调用反射，fastjson引入了asm的来避免反射导致的开销。fastjson内置的asm是基于objectweb-asm-3-3-1改造的，只保留必要的部分，fastjson-asm部分不到1000行代码，引入了asm的同时不导致大小变大太多。\"><a href=\"#获取java-bean的属性值，需要调用反射，fastjson引入了asm的来避免反射导致的开销。fastjson内置的asm是基于objectweb-asm-3-3-1改造的，只保留必要的部分，fastjson-asm部分不到1000行代码，引入了asm的同时不导致大小变大太多。\" class=\"headerlink\" title=\"获取java bean的属性值，需要调用反射，fastjson引入了asm的来避免反射导致的开销。fastjson内置的asm是基于objectweb asm 3.3.1改造的，只保留必要的部分，fastjson asm部分不到1000行代码，引入了asm的同时不导致大小变大太多。\"></a>获取java bean的属性值，需要调用反射，fastjson引入了asm的来避免反射导致的开销。fastjson内置的asm是基于objectweb asm 3.3.1改造的，只保留必要的部分，fastjson asm部分不到1000行代码，引入了asm的同时不导致大小变大太多。</h5><h4 id=\"4、使用一个特殊的IdentityHashMap优化性能。\"><a href=\"#4、使用一个特殊的IdentityHashMap优化性能。\" class=\"headerlink\" title=\"4、使用一个特殊的IdentityHashMap优化性能。\"></a>4、使用一个特殊的IdentityHashMap优化性能。</h4><h5 id=\"fastjson对每种类型使用一种serializer，于是就存在class-gt-JavaBeanSerizlier的映射。fastjson使用IdentityHashMap而不是HashMap，避免equals操作。我们知道HashMap的算法的transfer操作，并发时可能导致死循环，但是ConcurrentHashMap比HashMap系列会慢，因为其使用volatile和lock。fastjson自己实现了一个特别的IdentityHashMap，去掉transfer操作的IdentityHashMap，能够在并发时工作，但是不会导致死循环。\"><a href=\"#fastjson对每种类型使用一种serializer，于是就存在class-gt-JavaBeanSerizlier的映射。fastjson使用IdentityHashMap而不是HashMap，避免equals操作。我们知道HashMap的算法的transfer操作，并发时可能导致死循环，但是ConcurrentHashMap比HashMap系列会慢，因为其使用volatile和lock。fastjson自己实现了一个特别的IdentityHashMap，去掉transfer操作的IdentityHashMap，能够在并发时工作，但是不会导致死循环。\" class=\"headerlink\" title=\"fastjson对每种类型使用一种serializer，于是就存在class -&gt; JavaBeanSerizlier的映射。fastjson使用IdentityHashMap而不是HashMap，避免equals操作。我们知道HashMap的算法的transfer操作，并发时可能导致死循环，但是ConcurrentHashMap比HashMap系列会慢，因为其使用volatile和lock。fastjson自己实现了一个特别的IdentityHashMap，去掉transfer操作的IdentityHashMap，能够在并发时工作，但是不会导致死循环。\"></a>fastjson对每种类型使用一种serializer，于是就存在class -&gt; JavaBeanSerizlier的映射。fastjson使用IdentityHashMap而不是HashMap，避免equals操作。我们知道HashMap的算法的transfer操作，并发时可能导致死循环，但是ConcurrentHashMap比HashMap系列会慢，因为其使用volatile和lock。fastjson自己实现了一个特别的IdentityHashMap，去掉transfer操作的IdentityHashMap，能够在并发时工作，但是不会导致死循环。</h5><h4 id=\"5、缺省启用sort-field输出\"><a href=\"#5、缺省启用sort-field输出\" class=\"headerlink\" title=\"5、缺省启用sort field输出\"></a>5、缺省启用sort field输出</h4><h5 id=\"json的object是一种key-value结构，正常的hashmap是无序的，fastjson缺省是排序输出的，这是为deserialize优化做准备。\"><a href=\"#json的object是一种key-value结构，正常的hashmap是无序的，fastjson缺省是排序输出的，这是为deserialize优化做准备。\" class=\"headerlink\" title=\"json的object是一种key/value结构，正常的hashmap是无序的，fastjson缺省是排序输出的，这是为deserialize优化做准备。\"></a>json的object是一种key/value结构，正常的hashmap是无序的，fastjson缺省是排序输出的，这是为deserialize优化做准备。</h5><h4 id=\"6、集成jdk实现的一些优化算法\"><a href=\"#6、集成jdk实现的一些优化算法\" class=\"headerlink\" title=\"6、集成jdk实现的一些优化算法\"></a>6、集成jdk实现的一些优化算法</h4><h5 id=\"在优化fastjson的过程中，参考了jdk内部实现的算法，比如int-to-char-算法等等。\"><a href=\"#在优化fastjson的过程中，参考了jdk内部实现的算法，比如int-to-char-算法等等。\" class=\"headerlink\" title=\"在优化fastjson的过程中，参考了jdk内部实现的算法，比如int to char[]算法等等。\"></a>在优化fastjson的过程中，参考了jdk内部实现的算法，比如int to char[]算法等等。</h5><h3 id=\"fastjson的deserializer的主要优化算法\"><a href=\"#fastjson的deserializer的主要优化算法\" class=\"headerlink\" title=\"fastjson的deserializer的主要优化算法\"></a>fastjson的deserializer的主要优化算法</h3><h5 id=\"deserializer也称为parser或者decoder，fastjson在这方面投入的优化精力最多。\"><a href=\"#deserializer也称为parser或者decoder，fastjson在这方面投入的优化精力最多。\" class=\"headerlink\" title=\"deserializer也称为parser或者decoder，fastjson在这方面投入的优化精力最多。\"></a>deserializer也称为parser或者decoder，fastjson在这方面投入的优化精力最多。</h5><h4 id=\"1、读取token基于预测。\"><a href=\"#1、读取token基于预测。\" class=\"headerlink\" title=\"1、读取token基于预测。\"></a>1、读取token基于预测。</h4><h5 id=\"所有的parser基本上都需要做词法处理，json也不例外。fastjson词法处理的时候，使用了基于预测的优化算法。比如key之后，最大的可能是冒号”-”，value之后，可能是有两个，逗号”-”或者右括号”-”。在com-alibaba-fastjson-parser-JSONScanner中提供了这样的方法：\"><a href=\"#所有的parser基本上都需要做词法处理，json也不例外。fastjson词法处理的时候，使用了基于预测的优化算法。比如key之后，最大的可能是冒号”-”，value之后，可能是有两个，逗号”-”或者右括号”-”。在com-alibaba-fastjson-parser-JSONScanner中提供了这样的方法：\" class=\"headerlink\" title=\"所有的parser基本上都需要做词法处理，json也不例外。fastjson词法处理的时候，使用了基于预测的优化算法。比如key之后，最大的可能是冒号”:”，value之后，可能是有两个，逗号”,”或者右括号”}”。在com.alibaba.fastjson.parser.JSONScanner中提供了这样的方法：\"></a>所有的parser基本上都需要做词法处理，json也不例外。fastjson词法处理的时候，使用了基于预测的优化算法。比如key之后，最大的可能是冒号”:”，value之后，可能是有两个，逗号”,”或者右括号”}”。在com.alibaba.fastjson.parser.JSONScanner中提供了这样的方法：</h5><pre><code class=\"lang-java\">public void nextToken(int expect) {\n    for (;;) {\n        switch (expect) {\n            case JSONToken.COMMA: //\n                if (ch == &#39;,&#39;) {\n                    token = JSONToken.COMMA;\n                    ch = buf[++bp];\n                    return;\n                }\n\n                if (ch == &#39;}&#39;) {\n                    token = JSONToken.RBRACE;\n                    ch = buf[++bp];\n                    return;\n                }\n\n                if (ch == &#39;]&#39;) {\n                    token = JSONToken.RBRACKET;\n                    ch = buf[++bp];\n                    return;\n                }\n\n                if (ch == EOI) {\n                    token = JSONToken.EOF;\n                    return;\n                }\n                break;\n        // ... ...\n    }\n}\n</code></pre>\n<h5 id=\"从上面摘抄下来的代码看，基于预测能够做更少的处理就能够读取到token。\"><a href=\"#从上面摘抄下来的代码看，基于预测能够做更少的处理就能够读取到token。\" class=\"headerlink\" title=\"从上面摘抄下来的代码看，基于预测能够做更少的处理就能够读取到token。\"></a>从上面摘抄下来的代码看，基于预测能够做更少的处理就能够读取到token。</h5><h4 id=\"2、sort-field-fast-match算法\"><a href=\"#2、sort-field-fast-match算法\" class=\"headerlink\" title=\"2、sort field fast match算法\"></a>2、sort field fast match算法</h4><h5 id=\"fastjson的serialize是按照key的顺序进行的，于是fastjson做deserializer时候，采用一种优化算法，就是假设key-value的内容是有序的，读取的时候只需要做key的匹配，而不需要把key从输入中读取出来。通过这个优化，使得fastjson在处理json文本的时候，少读取超过50-的token，这个是一个十分关键的优化算法。基于这个算法，使用asm实现，性能提升十分明显，超过300％的性能提升。\"><a href=\"#fastjson的serialize是按照key的顺序进行的，于是fastjson做deserializer时候，采用一种优化算法，就是假设key-value的内容是有序的，读取的时候只需要做key的匹配，而不需要把key从输入中读取出来。通过这个优化，使得fastjson在处理json文本的时候，少读取超过50-的token，这个是一个十分关键的优化算法。基于这个算法，使用asm实现，性能提升十分明显，超过300％的性能提升。\" class=\"headerlink\" title=\"fastjson的serialize是按照key的顺序进行的，于是fastjson做deserializer时候，采用一种优化算法，就是假设key/value的内容是有序的，读取的时候只需要做key的匹配，而不需要把key从输入中读取出来。通过这个优化，使得fastjson在处理json文本的时候，少读取超过50%的token，这个是一个十分关键的优化算法。基于这个算法，使用asm实现，性能提升十分明显，超过300％的性能提升。\"></a>fastjson的serialize是按照key的顺序进行的，于是fastjson做deserializer时候，采用一种优化算法，就是假设key/value的内容是有序的，读取的时候只需要做key的匹配，而不需要把key从输入中读取出来。通过这个优化，使得fastjson在处理json文本的时候，少读取超过50%的token，这个是一个十分关键的优化算法。基于这个算法，使用asm实现，性能提升十分明显，超过300％的性能提升。</h5><pre><code class=\"lang-java\">{ &quot;id&quot; : 123, &quot;name&quot; : &quot;魏加流&quot;, &quot;salary&quot; : 56789.79}\n</code></pre>\n<h5 id=\"在上面例子看，三个部分的key，如果key-id、key-name、key-salary这三个key是顺序的，就可以做优化处理，这三个key不需要被读取出来，只需要比较就可以了。\"><a href=\"#在上面例子看，三个部分的key，如果key-id、key-name、key-salary这三个key是顺序的，就可以做优化处理，这三个key不需要被读取出来，只需要比较就可以了。\" class=\"headerlink\" title=\"在上面例子看，三个部分的key，如果key_id、key_name、key_salary这三个key是顺序的，就可以做优化处理，这三个key不需要被读取出来，只需要比较就可以了。\"></a>在上面例子看，三个部分的key，如果key_id、key_name、key_salary这三个key是顺序的，就可以做优化处理，这三个key不需要被读取出来，只需要比较就可以了。</h5><h5 id=\"这种算法分两种模式，一种是快速模式，一种是常规模式。快速模式是假定key是顺序的，能快速处理，如果发现不能够快速处理，则退回常规模式。保证性能的同时，不会影响功能。\"><a href=\"#这种算法分两种模式，一种是快速模式，一种是常规模式。快速模式是假定key是顺序的，能快速处理，如果发现不能够快速处理，则退回常规模式。保证性能的同时，不会影响功能。\" class=\"headerlink\" title=\"这种算法分两种模式，一种是快速模式，一种是常规模式。快速模式是假定key是顺序的，能快速处理，如果发现不能够快速处理，则退回常规模式。保证性能的同时，不会影响功能。\"></a>这种算法分两种模式，一种是快速模式，一种是常规模式。快速模式是假定key是顺序的，能快速处理，如果发现不能够快速处理，则退回常规模式。保证性能的同时，不会影响功能。</h5><h5 id=\"在这个例子中，常规模式需要处理13个token，快速模式只需要处理6个token。\"><a href=\"#在这个例子中，常规模式需要处理13个token，快速模式只需要处理6个token。\" class=\"headerlink\" title=\"在这个例子中，常规模式需要处理13个token，快速模式只需要处理6个token。\"></a>在这个例子中，常规模式需要处理13个token，快速模式只需要处理6个token。</h5><h5 id=\"实现sort-field-fast-match算法的代码在这个类\"><a href=\"#实现sort-field-fast-match算法的代码在这个类\" class=\"headerlink\" title=\"实现sort field fast match算法的代码在这个类\"></a>实现sort field fast match算法的代码在这个类</h5><h5 id=\"com-alibaba-fastjson-parser-deserializer-ASMDeserializerFactory-http-code-alibabatech-com-svn-fastjson-trunk-fastjson-src-main-java-com-alibaba-fastjson-parser-deserializer-ASMDeserializerFactory-java-，是使用asm针对每种类型的VO动态创建一个类实现的。\"><a href=\"#com-alibaba-fastjson-parser-deserializer-ASMDeserializerFactory-http-code-alibabatech-com-svn-fastjson-trunk-fastjson-src-main-java-com-alibaba-fastjson-parser-deserializer-ASMDeserializerFactory-java-，是使用asm针对每种类型的VO动态创建一个类实现的。\" class=\"headerlink\" title=\"[com.alibaba.fastjson.parser.deserializer.ASMDeserializerFactory|http://code.alibabatech.com/svn/fastjson/trunk/fastjson/src/main/java/com/alibaba/fastjson/parser/deserializer/ASMDeserializerFactory.java]，是使用asm针对每种类型的VO动态创建一个类实现的。\"></a>[com.alibaba.fastjson.parser.deserializer.ASMDeserializerFactory|<a href=\"http://code.alibabatech.com/svn/fastjson/trunk/fastjson/src/main/java/com/alibaba/fastjson/parser/deserializer/ASMDeserializerFactory.java]，是使用asm针对每种类型的VO动态创建一个类实现的。\" target=\"_blank\" rel=\"external\">http://code.alibabatech.com/svn/fastjson/trunk/fastjson/src/main/java/com/alibaba/fastjson/parser/deserializer/ASMDeserializerFactory.java]，是使用asm针对每种类型的VO动态创建一个类实现的。</a></h5><h5 id=\"这里是有一个用于演示sort-field-fast-match算法的代码：\"><a href=\"#这里是有一个用于演示sort-field-fast-match算法的代码：\" class=\"headerlink\" title=\"这里是有一个用于演示sort field fast match算法的代码：\"></a>这里是有一个用于演示sort field fast match算法的代码：</h5><pre><code class=\"lang-java\">// 用于快速匹配的每个字段的前缀\nchar[] size_   = &quot;\\&quot;size\\&quot;:&quot;.toCharArray();\nchar[] uri_    = &quot;\\&quot;uri\\&quot;:&quot;.toCharArray();\nchar[] titile_ = &quot;\\&quot;title\\&quot;:&quot;.toCharArray();\nchar[] width_  = &quot;\\&quot;width\\&quot;:&quot;.toCharArray();\nchar[] height_ = &quot;\\&quot;height\\&quot;:&quot;.toCharArray();\n\n// 保存parse开始时的lexer状态信息\nint mark = lexer.getBufferPosition();\nchar mark_ch = lexer.getCurrent();\nint mark_token = lexer.token();\n\nint height = lexer.scanFieldInt(height_);\nif (lexer.matchStat == JSONScanner.NOT_MATCH) {\n    // 退出快速模式, 进入常规模式\n    lexer.reset(mark, mark_ch, mark_token);\n    return (T) super.deserialze(parser, clazz);\n}\n\nString value = lexer.scanFieldString(size_);\nif (lexer.matchStat == JSONScanner.NOT_MATCH) {\n    // 退出快速模式, 进入常规模式\n    lexer.reset(mark, mark_ch, mark_token);\n    return (T) super.deserialze(parser, clazz);\n}\nSize size = Size.valueOf(value);\n\n// ... ...\n\n// batch set\nImage image = new Image();\nimage.setSize(size);\nimage.setUri(uri);\nimage.setTitle(title);\nimage.setWidth(width);\nimage.setHeight(height);\n\nreturn (T) image;\n</code></pre>\n<h4 id=\"3、使用asm避免反射-1\"><a href=\"#3、使用asm避免反射-1\" class=\"headerlink\" title=\"3、使用asm避免反射\"></a>3、使用asm避免反射</h4><h5 id=\"deserialize的时候，会使用asm来构造对象，并且做batch-set，也就是说合并连续调用多个setter方法，而不是分散调用，这个能够提升性能。\"><a href=\"#deserialize的时候，会使用asm来构造对象，并且做batch-set，也就是说合并连续调用多个setter方法，而不是分散调用，这个能够提升性能。\" class=\"headerlink\" title=\"deserialize的时候，会使用asm来构造对象，并且做batch set，也就是说合并连续调用多个setter方法，而不是分散调用，这个能够提升性能。\"></a>deserialize的时候，会使用asm来构造对象，并且做batch set，也就是说合并连续调用多个setter方法，而不是分散调用，这个能够提升性能。</h5><h4 id=\"4、对utf-8的json-bytes，针对性使用优化的版本来转换编码。\"><a href=\"#4、对utf-8的json-bytes，针对性使用优化的版本来转换编码。\" class=\"headerlink\" title=\"4、对utf-8的json bytes，针对性使用优化的版本来转换编码。\"></a>4、对utf-8的json bytes，针对性使用优化的版本来转换编码。</h4><h5 id=\"这个类是com-alibaba-fastjson-util-UTF8Decoder，来源于JDK中的UTF8Decoder，但是它使用ThreadLocal-Cache-Buffer，避免转换时分配char-的开销。\"><a href=\"#这个类是com-alibaba-fastjson-util-UTF8Decoder，来源于JDK中的UTF8Decoder，但是它使用ThreadLocal-Cache-Buffer，避免转换时分配char-的开销。\" class=\"headerlink\" title=\"这个类是com.alibaba.fastjson.util.UTF8Decoder，来源于JDK中的UTF8Decoder，但是它使用ThreadLocal Cache Buffer，避免转换时分配char[]的开销。\"></a>这个类是com.alibaba.fastjson.util.UTF8Decoder，来源于JDK中的UTF8Decoder，但是它使用ThreadLocal Cache Buffer，避免转换时分配char[]的开销。</h5><h5 id=\"ThreadLocal-Cache的实现是这个类com-alibaba-fastjson-util-ThreadLocalCache。第一次1k，如果不够，会增长，最多增长到128k。\"><a href=\"#ThreadLocal-Cache的实现是这个类com-alibaba-fastjson-util-ThreadLocalCache。第一次1k，如果不够，会增长，最多增长到128k。\" class=\"headerlink\" title=\"ThreadLocal Cache的实现是这个类com.alibaba.fastjson.util.ThreadLocalCache。第一次1k，如果不够，会增长，最多增长到128k。\"></a>ThreadLocal Cache的实现是这个类com.alibaba.fastjson.util.ThreadLocalCache。第一次1k，如果不够，会增长，最多增长到128k。</h5><pre><code class=\"lang-java\">//代码摘抄自com.alibaba.fastjson.JSON\npublic static final &lt;T&gt; T parseObject(byte[] input, int off, int len, CharsetDecoder charsetDecoder, Type clazz,\n                                      Feature... features) {\n    charsetDecoder.reset();\n\n    int scaleLength = (int) (len * (double) charsetDecoder.maxCharsPerByte());\n    char[] chars = ThreadLocalCache.getChars(scaleLength); // 使用ThreadLocalCache，避免频繁分配内存\n\n    ByteBuffer byteBuf = ByteBuffer.wrap(input, off, len);\n    CharBuffer charByte = CharBuffer.wrap(chars);\n    IOUtils.decode(charsetDecoder, byteBuf, charByte);\n\n    int position = charByte.position();\n\n    return (T) parseObject(chars, position, clazz, features);\n}\n</code></pre>\n<h4 id=\"5、symbolTable算法。\"><a href=\"#5、symbolTable算法。\" class=\"headerlink\" title=\"5、symbolTable算法。\"></a>5、symbolTable算法。</h4><h5 id=\"我们看xml或者javac的parser实现，经常会看到有一个这样的东西symbol-table，它就是把一些经常使用的关键字缓存起来，在遍历char-的时候，同时把hash计算好，通过这个hash值在hashtable中来获取缓存好的symbol，避免创建新的字符串对象。这种优化在fastjson里面用在key的读取，以及enum-value的读取。这是也是parse性能优化的关键算法之一。\"><a href=\"#我们看xml或者javac的parser实现，经常会看到有一个这样的东西symbol-table，它就是把一些经常使用的关键字缓存起来，在遍历char-的时候，同时把hash计算好，通过这个hash值在hashtable中来获取缓存好的symbol，避免创建新的字符串对象。这种优化在fastjson里面用在key的读取，以及enum-value的读取。这是也是parse性能优化的关键算法之一。\" class=\"headerlink\" title=\"我们看xml或者javac的parser实现，经常会看到有一个这样的东西symbol table，它就是把一些经常使用的关键字缓存起来，在遍历char[]的时候，同时把hash计算好，通过这个hash值在hashtable中来获取缓存好的symbol，避免创建新的字符串对象。这种优化在fastjson里面用在key的读取，以及enum value的读取。这是也是parse性能优化的关键算法之一。\"></a>我们看xml或者javac的parser实现，经常会看到有一个这样的东西symbol table，它就是把一些经常使用的关键字缓存起来，在遍历char[]的时候，同时把hash计算好，通过这个hash值在hashtable中来获取缓存好的symbol，避免创建新的字符串对象。这种优化在fastjson里面用在key的读取，以及enum value的读取。这是也是parse性能优化的关键算法之一。</h5><h5 id=\"以下是摘抄自JSONScanner类中的代码，这段代码用于读取类型为enum的value。\"><a href=\"#以下是摘抄自JSONScanner类中的代码，这段代码用于读取类型为enum的value。\" class=\"headerlink\" title=\"以下是摘抄自JSONScanner类中的代码，这段代码用于读取类型为enum的value。\"></a>以下是摘抄自JSONScanner类中的代码，这段代码用于读取类型为enum的value。</h5><pre><code class=\"lang-java\">int hash = 0;\nfor (;;) {\n    ch = buf[index++];\n    if (ch == &#39;\\&quot;&#39;) {\n        bp = index;\n        this.ch = ch = buf[bp];\n        strVal = symbolTable.addSymbol(buf, start, index - start - 1, hash); // 通过symbolTable来获得缓存好的symbol，包括fieldName、enumValue\n        break;\n    }\n\n    hash = 31 * hash + ch; // 在token scan的过程中计算好hash\n\n    // ... ...\n}\n</code></pre>\n<h3 id=\"我们能用fastjson来作什么？\"><a href=\"#我们能用fastjson来作什么？\" class=\"headerlink\" title=\"我们能用fastjson来作什么？\"></a>我们能用fastjson来作什么？</h3><ol>\n<li>替换其他所有的json库，java世界里没有其他的json库能够和fastjson可相比了。</li>\n<li>使用fastjson的序列化和反序列化替换java serialize，java serialize不单性能慢，而且体制大。</li>\n<li>使用fastjson替换hessian，json协议和hessian协议大小差不多一样，而且fastjson性能优越，10倍于hessian</li>\n<li>把fastjson用于redis、memached缓存对象数据。</li>\n</ol>\n<h5 id=\"转载自：http-wenshao-iteye-com-blog-1142031\"><a href=\"#转载自：http-wenshao-iteye-com-blog-1142031\" class=\"headerlink\" title=\"转载自：http://wenshao.iteye.com/blog/1142031/\"></a>转载自：<a href=\"http://wenshao.iteye.com/blog/1142031/\" target=\"_blank\" rel=\"external\">http://wenshao.iteye.com/blog/1142031/</a></h5>","site":{"data":{}},"excerpt":"<h5 id=\"JSON处理主要包括两个部分，serialize和deserialize。serialize就是把Java对象变成JSON-String或者JSON-Bytes。Deserialize是把JSON-String或者Json-Bytes变成java对象。其实这个过程有些JSON库是分三部分的，json-string-lt-－-gt-json-tree-lt-－-gt-java-object。Fastjson也支持这种转换方式，但是这种转换方式因为有多余的步骤，性能不好，不推荐使用。\"><a href=\"#JSON处理主要包括两个部分，serialize和deserialize。serialize就是把Java对象变成JSON-String或者JSON-Bytes。Deserialize是把JSON-String或者Json-Bytes变成java对象。其实这个过程有些JSON库是分三部分的，json-string-lt-－-gt-json-tree-lt-－-gt-java-object。Fastjson也支持这种转换方式，但是这种转换方式因为有多余的步骤，性能不好，不推荐使用。\" class=\"headerlink\" title=\"JSON处理主要包括两个部分，serialize和deserialize。serialize就是把Java对象变成JSON String或者JSON Bytes。Deserialize是把JSON String或者Json Bytes变成java对象。其实这个过程有些JSON库是分三部分的，json string &lt;－-&gt; json tree &lt;－-&gt; java object。Fastjson也支持这种转换方式，但是这种转换方式因为有多余的步骤，性能不好，不推荐使用。\"></a>JSON处理主要包括两个部分，serialize和deserialize。serialize就是把Java对象变成JSON String或者JSON Bytes。Deserialize是把JSON String或者Json Bytes变成java对象。其实这个过程有些JSON库是分三部分的，json string &lt;－-&gt; json tree &lt;－-&gt; java object。Fastjson也支持这种转换方式，但是这种转换方式因为有多余的步骤，性能不好，不推荐使用。</h5>","more":"<h2 id=\"为什么Fastjson能够做到这么快？\"><a href=\"#为什么Fastjson能够做到这么快？\" class=\"headerlink\" title=\"为什么Fastjson能够做到这么快？\"></a>为什么Fastjson能够做到这么快？</h2><h3 id=\"Fastjson中Serialzie的优化实现\"><a href=\"#Fastjson中Serialzie的优化实现\" class=\"headerlink\" title=\"Fastjson中Serialzie的优化实现\"></a>Fastjson中Serialzie的优化实现</h3><h4 id=\"1-自行编写类似StringBuilder的工具类SerializeWriter。\"><a href=\"#1-自行编写类似StringBuilder的工具类SerializeWriter。\" class=\"headerlink\" title=\"1.自行编写类似StringBuilder的工具类SerializeWriter。\"></a>1.自行编写类似StringBuilder的工具类<strong>SerializeWriter</strong>。</h4><h5 id=\"把java对象序列化成json文本，是不可能使用字符串直接拼接的，因为这样性能很差。比字符串拼接更好的办法是使用java-lang-StringBuilder。StringBuilder虽然速度很好了，但还能够进一步提升性能的，fastjson中提供了一个类似StringBuilder的类com-alibaba-fastjson-serializer-SerializeWriter。\"><a href=\"#把java对象序列化成json文本，是不可能使用字符串直接拼接的，因为这样性能很差。比字符串拼接更好的办法是使用java-lang-StringBuilder。StringBuilder虽然速度很好了，但还能够进一步提升性能的，fastjson中提供了一个类似StringBuilder的类com-alibaba-fastjson-serializer-SerializeWriter。\" class=\"headerlink\" title=\"把java对象序列化成json文本，是不可能使用字符串直接拼接的，因为这样性能很差。比字符串拼接更好的办法是使用java.lang.StringBuilder。StringBuilder虽然速度很好了，但还能够进一步提升性能的，fastjson中提供了一个类似StringBuilder的类com.alibaba.fastjson.serializer.SerializeWriter。\"></a>把java对象序列化成json文本，是不可能使用字符串直接拼接的，因为这样性能很差。比字符串拼接更好的办法是使用<code>java.lang.StringBuilder</code>。StringBuilder虽然速度很好了，但还能够进一步提升性能的，fastjson中提供了一个类似StringBuilder的类<code>com.alibaba.fastjson.serializer.SerializeWriter</code>。</h5><h5 id=\"SerializeWriter提供一些针对性的方法减少数组越界检查。例如public-void-writeIntAndChar-int-i-char-c-，这样的方法一次性把两个值写到buf中去，能够减少一次越界检查。目前SerializeWriter还有一些关键的方法能够减少越界检查的，我还没实现。也就是说，如果实现了，能够进一步提升serialize的性能。\"><a href=\"#SerializeWriter提供一些针对性的方法减少数组越界检查。例如public-void-writeIntAndChar-int-i-char-c-，这样的方法一次性把两个值写到buf中去，能够减少一次越界检查。目前SerializeWriter还有一些关键的方法能够减少越界检查的，我还没实现。也就是说，如果实现了，能够进一步提升serialize的性能。\" class=\"headerlink\" title=\"SerializeWriter提供一些针对性的方法减少数组越界检查。例如public void writeIntAndChar(int i, char c) {}，这样的方法一次性把两个值写到buf中去，能够减少一次越界检查。目前SerializeWriter还有一些关键的方法能够减少越界检查的，我还没实现。也就是说，如果实现了，能够进一步提升serialize的性能。\"></a><strong>SerializeWriter</strong>提供一些针对性的方法减少数组越界检查。例如<code>public void writeIntAndChar(int i, char c) {}</code>，这样的方法一次性把两个值写到buf中去，能够减少一次越界检查。目前SerializeWriter还有一些关键的方法能够减少越界检查的，我还没实现。也就是说，如果实现了，能够进一步提升serialize的性能。</h5><h4 id=\"2、使用ThreadLocal来缓存buf。\"><a href=\"#2、使用ThreadLocal来缓存buf。\" class=\"headerlink\" title=\"2、使用ThreadLocal来缓存buf。\"></a>2、使用ThreadLocal来缓存buf。</h4><h5 id=\"这个办法能够减少对象分配和gc，从而提升性能。SerializeWriter中包含了一个char-buf，每序列化一次，都要做一次分配，使用ThreadLocal优化，能够提升性能。\"><a href=\"#这个办法能够减少对象分配和gc，从而提升性能。SerializeWriter中包含了一个char-buf，每序列化一次，都要做一次分配，使用ThreadLocal优化，能够提升性能。\" class=\"headerlink\" title=\"这个办法能够减少对象分配和gc，从而提升性能。SerializeWriter中包含了一个char[] buf，每序列化一次，都要做一次分配，使用ThreadLocal优化，能够提升性能。\"></a>这个办法能够减少对象分配和gc，从而提升性能。SerializeWriter中包含了一个char[] buf，每序列化一次，都要做一次分配，使用ThreadLocal优化，能够提升性能。</h5><h4 id=\"3、使用asm避免反射\"><a href=\"#3、使用asm避免反射\" class=\"headerlink\" title=\"3、使用asm避免反射\"></a>3、使用asm避免反射</h4><h5 id=\"获取java-bean的属性值，需要调用反射，fastjson引入了asm的来避免反射导致的开销。fastjson内置的asm是基于objectweb-asm-3-3-1改造的，只保留必要的部分，fastjson-asm部分不到1000行代码，引入了asm的同时不导致大小变大太多。\"><a href=\"#获取java-bean的属性值，需要调用反射，fastjson引入了asm的来避免反射导致的开销。fastjson内置的asm是基于objectweb-asm-3-3-1改造的，只保留必要的部分，fastjson-asm部分不到1000行代码，引入了asm的同时不导致大小变大太多。\" class=\"headerlink\" title=\"获取java bean的属性值，需要调用反射，fastjson引入了asm的来避免反射导致的开销。fastjson内置的asm是基于objectweb asm 3.3.1改造的，只保留必要的部分，fastjson asm部分不到1000行代码，引入了asm的同时不导致大小变大太多。\"></a>获取java bean的属性值，需要调用反射，fastjson引入了asm的来避免反射导致的开销。fastjson内置的asm是基于objectweb asm 3.3.1改造的，只保留必要的部分，fastjson asm部分不到1000行代码，引入了asm的同时不导致大小变大太多。</h5><h4 id=\"4、使用一个特殊的IdentityHashMap优化性能。\"><a href=\"#4、使用一个特殊的IdentityHashMap优化性能。\" class=\"headerlink\" title=\"4、使用一个特殊的IdentityHashMap优化性能。\"></a>4、使用一个特殊的IdentityHashMap优化性能。</h4><h5 id=\"fastjson对每种类型使用一种serializer，于是就存在class-gt-JavaBeanSerizlier的映射。fastjson使用IdentityHashMap而不是HashMap，避免equals操作。我们知道HashMap的算法的transfer操作，并发时可能导致死循环，但是ConcurrentHashMap比HashMap系列会慢，因为其使用volatile和lock。fastjson自己实现了一个特别的IdentityHashMap，去掉transfer操作的IdentityHashMap，能够在并发时工作，但是不会导致死循环。\"><a href=\"#fastjson对每种类型使用一种serializer，于是就存在class-gt-JavaBeanSerizlier的映射。fastjson使用IdentityHashMap而不是HashMap，避免equals操作。我们知道HashMap的算法的transfer操作，并发时可能导致死循环，但是ConcurrentHashMap比HashMap系列会慢，因为其使用volatile和lock。fastjson自己实现了一个特别的IdentityHashMap，去掉transfer操作的IdentityHashMap，能够在并发时工作，但是不会导致死循环。\" class=\"headerlink\" title=\"fastjson对每种类型使用一种serializer，于是就存在class -&gt; JavaBeanSerizlier的映射。fastjson使用IdentityHashMap而不是HashMap，避免equals操作。我们知道HashMap的算法的transfer操作，并发时可能导致死循环，但是ConcurrentHashMap比HashMap系列会慢，因为其使用volatile和lock。fastjson自己实现了一个特别的IdentityHashMap，去掉transfer操作的IdentityHashMap，能够在并发时工作，但是不会导致死循环。\"></a>fastjson对每种类型使用一种serializer，于是就存在class -&gt; JavaBeanSerizlier的映射。fastjson使用IdentityHashMap而不是HashMap，避免equals操作。我们知道HashMap的算法的transfer操作，并发时可能导致死循环，但是ConcurrentHashMap比HashMap系列会慢，因为其使用volatile和lock。fastjson自己实现了一个特别的IdentityHashMap，去掉transfer操作的IdentityHashMap，能够在并发时工作，但是不会导致死循环。</h5><h4 id=\"5、缺省启用sort-field输出\"><a href=\"#5、缺省启用sort-field输出\" class=\"headerlink\" title=\"5、缺省启用sort field输出\"></a>5、缺省启用sort field输出</h4><h5 id=\"json的object是一种key-value结构，正常的hashmap是无序的，fastjson缺省是排序输出的，这是为deserialize优化做准备。\"><a href=\"#json的object是一种key-value结构，正常的hashmap是无序的，fastjson缺省是排序输出的，这是为deserialize优化做准备。\" class=\"headerlink\" title=\"json的object是一种key/value结构，正常的hashmap是无序的，fastjson缺省是排序输出的，这是为deserialize优化做准备。\"></a>json的object是一种key/value结构，正常的hashmap是无序的，fastjson缺省是排序输出的，这是为deserialize优化做准备。</h5><h4 id=\"6、集成jdk实现的一些优化算法\"><a href=\"#6、集成jdk实现的一些优化算法\" class=\"headerlink\" title=\"6、集成jdk实现的一些优化算法\"></a>6、集成jdk实现的一些优化算法</h4><h5 id=\"在优化fastjson的过程中，参考了jdk内部实现的算法，比如int-to-char-算法等等。\"><a href=\"#在优化fastjson的过程中，参考了jdk内部实现的算法，比如int-to-char-算法等等。\" class=\"headerlink\" title=\"在优化fastjson的过程中，参考了jdk内部实现的算法，比如int to char[]算法等等。\"></a>在优化fastjson的过程中，参考了jdk内部实现的算法，比如int to char[]算法等等。</h5><h3 id=\"fastjson的deserializer的主要优化算法\"><a href=\"#fastjson的deserializer的主要优化算法\" class=\"headerlink\" title=\"fastjson的deserializer的主要优化算法\"></a>fastjson的deserializer的主要优化算法</h3><h5 id=\"deserializer也称为parser或者decoder，fastjson在这方面投入的优化精力最多。\"><a href=\"#deserializer也称为parser或者decoder，fastjson在这方面投入的优化精力最多。\" class=\"headerlink\" title=\"deserializer也称为parser或者decoder，fastjson在这方面投入的优化精力最多。\"></a>deserializer也称为parser或者decoder，fastjson在这方面投入的优化精力最多。</h5><h4 id=\"1、读取token基于预测。\"><a href=\"#1、读取token基于预测。\" class=\"headerlink\" title=\"1、读取token基于预测。\"></a>1、读取token基于预测。</h4><h5 id=\"所有的parser基本上都需要做词法处理，json也不例外。fastjson词法处理的时候，使用了基于预测的优化算法。比如key之后，最大的可能是冒号”-”，value之后，可能是有两个，逗号”-”或者右括号”-”。在com-alibaba-fastjson-parser-JSONScanner中提供了这样的方法：\"><a href=\"#所有的parser基本上都需要做词法处理，json也不例外。fastjson词法处理的时候，使用了基于预测的优化算法。比如key之后，最大的可能是冒号”-”，value之后，可能是有两个，逗号”-”或者右括号”-”。在com-alibaba-fastjson-parser-JSONScanner中提供了这样的方法：\" class=\"headerlink\" title=\"所有的parser基本上都需要做词法处理，json也不例外。fastjson词法处理的时候，使用了基于预测的优化算法。比如key之后，最大的可能是冒号”:”，value之后，可能是有两个，逗号”,”或者右括号”}”。在com.alibaba.fastjson.parser.JSONScanner中提供了这样的方法：\"></a>所有的parser基本上都需要做词法处理，json也不例外。fastjson词法处理的时候，使用了基于预测的优化算法。比如key之后，最大的可能是冒号”:”，value之后，可能是有两个，逗号”,”或者右括号”}”。在com.alibaba.fastjson.parser.JSONScanner中提供了这样的方法：</h5><pre><code class=\"lang-java\">public void nextToken(int expect) {\n    for (;;) {\n        switch (expect) {\n            case JSONToken.COMMA: //\n                if (ch == &#39;,&#39;) {\n                    token = JSONToken.COMMA;\n                    ch = buf[++bp];\n                    return;\n                }\n\n                if (ch == &#39;}&#39;) {\n                    token = JSONToken.RBRACE;\n                    ch = buf[++bp];\n                    return;\n                }\n\n                if (ch == &#39;]&#39;) {\n                    token = JSONToken.RBRACKET;\n                    ch = buf[++bp];\n                    return;\n                }\n\n                if (ch == EOI) {\n                    token = JSONToken.EOF;\n                    return;\n                }\n                break;\n        // ... ...\n    }\n}\n</code></pre>\n<h5 id=\"从上面摘抄下来的代码看，基于预测能够做更少的处理就能够读取到token。\"><a href=\"#从上面摘抄下来的代码看，基于预测能够做更少的处理就能够读取到token。\" class=\"headerlink\" title=\"从上面摘抄下来的代码看，基于预测能够做更少的处理就能够读取到token。\"></a>从上面摘抄下来的代码看，基于预测能够做更少的处理就能够读取到token。</h5><h4 id=\"2、sort-field-fast-match算法\"><a href=\"#2、sort-field-fast-match算法\" class=\"headerlink\" title=\"2、sort field fast match算法\"></a>2、sort field fast match算法</h4><h5 id=\"fastjson的serialize是按照key的顺序进行的，于是fastjson做deserializer时候，采用一种优化算法，就是假设key-value的内容是有序的，读取的时候只需要做key的匹配，而不需要把key从输入中读取出来。通过这个优化，使得fastjson在处理json文本的时候，少读取超过50-的token，这个是一个十分关键的优化算法。基于这个算法，使用asm实现，性能提升十分明显，超过300％的性能提升。\"><a href=\"#fastjson的serialize是按照key的顺序进行的，于是fastjson做deserializer时候，采用一种优化算法，就是假设key-value的内容是有序的，读取的时候只需要做key的匹配，而不需要把key从输入中读取出来。通过这个优化，使得fastjson在处理json文本的时候，少读取超过50-的token，这个是一个十分关键的优化算法。基于这个算法，使用asm实现，性能提升十分明显，超过300％的性能提升。\" class=\"headerlink\" title=\"fastjson的serialize是按照key的顺序进行的，于是fastjson做deserializer时候，采用一种优化算法，就是假设key/value的内容是有序的，读取的时候只需要做key的匹配，而不需要把key从输入中读取出来。通过这个优化，使得fastjson在处理json文本的时候，少读取超过50%的token，这个是一个十分关键的优化算法。基于这个算法，使用asm实现，性能提升十分明显，超过300％的性能提升。\"></a>fastjson的serialize是按照key的顺序进行的，于是fastjson做deserializer时候，采用一种优化算法，就是假设key/value的内容是有序的，读取的时候只需要做key的匹配，而不需要把key从输入中读取出来。通过这个优化，使得fastjson在处理json文本的时候，少读取超过50%的token，这个是一个十分关键的优化算法。基于这个算法，使用asm实现，性能提升十分明显，超过300％的性能提升。</h5><pre><code class=\"lang-java\">{ &quot;id&quot; : 123, &quot;name&quot; : &quot;魏加流&quot;, &quot;salary&quot; : 56789.79}\n</code></pre>\n<h5 id=\"在上面例子看，三个部分的key，如果key-id、key-name、key-salary这三个key是顺序的，就可以做优化处理，这三个key不需要被读取出来，只需要比较就可以了。\"><a href=\"#在上面例子看，三个部分的key，如果key-id、key-name、key-salary这三个key是顺序的，就可以做优化处理，这三个key不需要被读取出来，只需要比较就可以了。\" class=\"headerlink\" title=\"在上面例子看，三个部分的key，如果key_id、key_name、key_salary这三个key是顺序的，就可以做优化处理，这三个key不需要被读取出来，只需要比较就可以了。\"></a>在上面例子看，三个部分的key，如果key_id、key_name、key_salary这三个key是顺序的，就可以做优化处理，这三个key不需要被读取出来，只需要比较就可以了。</h5><h5 id=\"这种算法分两种模式，一种是快速模式，一种是常规模式。快速模式是假定key是顺序的，能快速处理，如果发现不能够快速处理，则退回常规模式。保证性能的同时，不会影响功能。\"><a href=\"#这种算法分两种模式，一种是快速模式，一种是常规模式。快速模式是假定key是顺序的，能快速处理，如果发现不能够快速处理，则退回常规模式。保证性能的同时，不会影响功能。\" class=\"headerlink\" title=\"这种算法分两种模式，一种是快速模式，一种是常规模式。快速模式是假定key是顺序的，能快速处理，如果发现不能够快速处理，则退回常规模式。保证性能的同时，不会影响功能。\"></a>这种算法分两种模式，一种是快速模式，一种是常规模式。快速模式是假定key是顺序的，能快速处理，如果发现不能够快速处理，则退回常规模式。保证性能的同时，不会影响功能。</h5><h5 id=\"在这个例子中，常规模式需要处理13个token，快速模式只需要处理6个token。\"><a href=\"#在这个例子中，常规模式需要处理13个token，快速模式只需要处理6个token。\" class=\"headerlink\" title=\"在这个例子中，常规模式需要处理13个token，快速模式只需要处理6个token。\"></a>在这个例子中，常规模式需要处理13个token，快速模式只需要处理6个token。</h5><h5 id=\"实现sort-field-fast-match算法的代码在这个类\"><a href=\"#实现sort-field-fast-match算法的代码在这个类\" class=\"headerlink\" title=\"实现sort field fast match算法的代码在这个类\"></a>实现sort field fast match算法的代码在这个类</h5><h5 id=\"com-alibaba-fastjson-parser-deserializer-ASMDeserializerFactory-http-code-alibabatech-com-svn-fastjson-trunk-fastjson-src-main-java-com-alibaba-fastjson-parser-deserializer-ASMDeserializerFactory-java-，是使用asm针对每种类型的VO动态创建一个类实现的。\"><a href=\"#com-alibaba-fastjson-parser-deserializer-ASMDeserializerFactory-http-code-alibabatech-com-svn-fastjson-trunk-fastjson-src-main-java-com-alibaba-fastjson-parser-deserializer-ASMDeserializerFactory-java-，是使用asm针对每种类型的VO动态创建一个类实现的。\" class=\"headerlink\" title=\"[com.alibaba.fastjson.parser.deserializer.ASMDeserializerFactory|http://code.alibabatech.com/svn/fastjson/trunk/fastjson/src/main/java/com/alibaba/fastjson/parser/deserializer/ASMDeserializerFactory.java]，是使用asm针对每种类型的VO动态创建一个类实现的。\"></a>[com.alibaba.fastjson.parser.deserializer.ASMDeserializerFactory|<a href=\"http://code.alibabatech.com/svn/fastjson/trunk/fastjson/src/main/java/com/alibaba/fastjson/parser/deserializer/ASMDeserializerFactory.java]，是使用asm针对每种类型的VO动态创建一个类实现的。\" target=\"_blank\" rel=\"external\">http://code.alibabatech.com/svn/fastjson/trunk/fastjson/src/main/java/com/alibaba/fastjson/parser/deserializer/ASMDeserializerFactory.java]，是使用asm针对每种类型的VO动态创建一个类实现的。</a></h5><h5 id=\"这里是有一个用于演示sort-field-fast-match算法的代码：\"><a href=\"#这里是有一个用于演示sort-field-fast-match算法的代码：\" class=\"headerlink\" title=\"这里是有一个用于演示sort field fast match算法的代码：\"></a>这里是有一个用于演示sort field fast match算法的代码：</h5><pre><code class=\"lang-java\">// 用于快速匹配的每个字段的前缀\nchar[] size_   = &quot;\\&quot;size\\&quot;:&quot;.toCharArray();\nchar[] uri_    = &quot;\\&quot;uri\\&quot;:&quot;.toCharArray();\nchar[] titile_ = &quot;\\&quot;title\\&quot;:&quot;.toCharArray();\nchar[] width_  = &quot;\\&quot;width\\&quot;:&quot;.toCharArray();\nchar[] height_ = &quot;\\&quot;height\\&quot;:&quot;.toCharArray();\n\n// 保存parse开始时的lexer状态信息\nint mark = lexer.getBufferPosition();\nchar mark_ch = lexer.getCurrent();\nint mark_token = lexer.token();\n\nint height = lexer.scanFieldInt(height_);\nif (lexer.matchStat == JSONScanner.NOT_MATCH) {\n    // 退出快速模式, 进入常规模式\n    lexer.reset(mark, mark_ch, mark_token);\n    return (T) super.deserialze(parser, clazz);\n}\n\nString value = lexer.scanFieldString(size_);\nif (lexer.matchStat == JSONScanner.NOT_MATCH) {\n    // 退出快速模式, 进入常规模式\n    lexer.reset(mark, mark_ch, mark_token);\n    return (T) super.deserialze(parser, clazz);\n}\nSize size = Size.valueOf(value);\n\n// ... ...\n\n// batch set\nImage image = new Image();\nimage.setSize(size);\nimage.setUri(uri);\nimage.setTitle(title);\nimage.setWidth(width);\nimage.setHeight(height);\n\nreturn (T) image;\n</code></pre>\n<h4 id=\"3、使用asm避免反射-1\"><a href=\"#3、使用asm避免反射-1\" class=\"headerlink\" title=\"3、使用asm避免反射\"></a>3、使用asm避免反射</h4><h5 id=\"deserialize的时候，会使用asm来构造对象，并且做batch-set，也就是说合并连续调用多个setter方法，而不是分散调用，这个能够提升性能。\"><a href=\"#deserialize的时候，会使用asm来构造对象，并且做batch-set，也就是说合并连续调用多个setter方法，而不是分散调用，这个能够提升性能。\" class=\"headerlink\" title=\"deserialize的时候，会使用asm来构造对象，并且做batch set，也就是说合并连续调用多个setter方法，而不是分散调用，这个能够提升性能。\"></a>deserialize的时候，会使用asm来构造对象，并且做batch set，也就是说合并连续调用多个setter方法，而不是分散调用，这个能够提升性能。</h5><h4 id=\"4、对utf-8的json-bytes，针对性使用优化的版本来转换编码。\"><a href=\"#4、对utf-8的json-bytes，针对性使用优化的版本来转换编码。\" class=\"headerlink\" title=\"4、对utf-8的json bytes，针对性使用优化的版本来转换编码。\"></a>4、对utf-8的json bytes，针对性使用优化的版本来转换编码。</h4><h5 id=\"这个类是com-alibaba-fastjson-util-UTF8Decoder，来源于JDK中的UTF8Decoder，但是它使用ThreadLocal-Cache-Buffer，避免转换时分配char-的开销。\"><a href=\"#这个类是com-alibaba-fastjson-util-UTF8Decoder，来源于JDK中的UTF8Decoder，但是它使用ThreadLocal-Cache-Buffer，避免转换时分配char-的开销。\" class=\"headerlink\" title=\"这个类是com.alibaba.fastjson.util.UTF8Decoder，来源于JDK中的UTF8Decoder，但是它使用ThreadLocal Cache Buffer，避免转换时分配char[]的开销。\"></a>这个类是com.alibaba.fastjson.util.UTF8Decoder，来源于JDK中的UTF8Decoder，但是它使用ThreadLocal Cache Buffer，避免转换时分配char[]的开销。</h5><h5 id=\"ThreadLocal-Cache的实现是这个类com-alibaba-fastjson-util-ThreadLocalCache。第一次1k，如果不够，会增长，最多增长到128k。\"><a href=\"#ThreadLocal-Cache的实现是这个类com-alibaba-fastjson-util-ThreadLocalCache。第一次1k，如果不够，会增长，最多增长到128k。\" class=\"headerlink\" title=\"ThreadLocal Cache的实现是这个类com.alibaba.fastjson.util.ThreadLocalCache。第一次1k，如果不够，会增长，最多增长到128k。\"></a>ThreadLocal Cache的实现是这个类com.alibaba.fastjson.util.ThreadLocalCache。第一次1k，如果不够，会增长，最多增长到128k。</h5><pre><code class=\"lang-java\">//代码摘抄自com.alibaba.fastjson.JSON\npublic static final &lt;T&gt; T parseObject(byte[] input, int off, int len, CharsetDecoder charsetDecoder, Type clazz,\n                                      Feature... features) {\n    charsetDecoder.reset();\n\n    int scaleLength = (int) (len * (double) charsetDecoder.maxCharsPerByte());\n    char[] chars = ThreadLocalCache.getChars(scaleLength); // 使用ThreadLocalCache，避免频繁分配内存\n\n    ByteBuffer byteBuf = ByteBuffer.wrap(input, off, len);\n    CharBuffer charByte = CharBuffer.wrap(chars);\n    IOUtils.decode(charsetDecoder, byteBuf, charByte);\n\n    int position = charByte.position();\n\n    return (T) parseObject(chars, position, clazz, features);\n}\n</code></pre>\n<h4 id=\"5、symbolTable算法。\"><a href=\"#5、symbolTable算法。\" class=\"headerlink\" title=\"5、symbolTable算法。\"></a>5、symbolTable算法。</h4><h5 id=\"我们看xml或者javac的parser实现，经常会看到有一个这样的东西symbol-table，它就是把一些经常使用的关键字缓存起来，在遍历char-的时候，同时把hash计算好，通过这个hash值在hashtable中来获取缓存好的symbol，避免创建新的字符串对象。这种优化在fastjson里面用在key的读取，以及enum-value的读取。这是也是parse性能优化的关键算法之一。\"><a href=\"#我们看xml或者javac的parser实现，经常会看到有一个这样的东西symbol-table，它就是把一些经常使用的关键字缓存起来，在遍历char-的时候，同时把hash计算好，通过这个hash值在hashtable中来获取缓存好的symbol，避免创建新的字符串对象。这种优化在fastjson里面用在key的读取，以及enum-value的读取。这是也是parse性能优化的关键算法之一。\" class=\"headerlink\" title=\"我们看xml或者javac的parser实现，经常会看到有一个这样的东西symbol table，它就是把一些经常使用的关键字缓存起来，在遍历char[]的时候，同时把hash计算好，通过这个hash值在hashtable中来获取缓存好的symbol，避免创建新的字符串对象。这种优化在fastjson里面用在key的读取，以及enum value的读取。这是也是parse性能优化的关键算法之一。\"></a>我们看xml或者javac的parser实现，经常会看到有一个这样的东西symbol table，它就是把一些经常使用的关键字缓存起来，在遍历char[]的时候，同时把hash计算好，通过这个hash值在hashtable中来获取缓存好的symbol，避免创建新的字符串对象。这种优化在fastjson里面用在key的读取，以及enum value的读取。这是也是parse性能优化的关键算法之一。</h5><h5 id=\"以下是摘抄自JSONScanner类中的代码，这段代码用于读取类型为enum的value。\"><a href=\"#以下是摘抄自JSONScanner类中的代码，这段代码用于读取类型为enum的value。\" class=\"headerlink\" title=\"以下是摘抄自JSONScanner类中的代码，这段代码用于读取类型为enum的value。\"></a>以下是摘抄自JSONScanner类中的代码，这段代码用于读取类型为enum的value。</h5><pre><code class=\"lang-java\">int hash = 0;\nfor (;;) {\n    ch = buf[index++];\n    if (ch == &#39;\\&quot;&#39;) {\n        bp = index;\n        this.ch = ch = buf[bp];\n        strVal = symbolTable.addSymbol(buf, start, index - start - 1, hash); // 通过symbolTable来获得缓存好的symbol，包括fieldName、enumValue\n        break;\n    }\n\n    hash = 31 * hash + ch; // 在token scan的过程中计算好hash\n\n    // ... ...\n}\n</code></pre>\n<h3 id=\"我们能用fastjson来作什么？\"><a href=\"#我们能用fastjson来作什么？\" class=\"headerlink\" title=\"我们能用fastjson来作什么？\"></a>我们能用fastjson来作什么？</h3><ol>\n<li>替换其他所有的json库，java世界里没有其他的json库能够和fastjson可相比了。</li>\n<li>使用fastjson的序列化和反序列化替换java serialize，java serialize不单性能慢，而且体制大。</li>\n<li>使用fastjson替换hessian，json协议和hessian协议大小差不多一样，而且fastjson性能优越，10倍于hessian</li>\n<li>把fastjson用于redis、memached缓存对象数据。</li>\n</ol>\n<h5 id=\"转载自：http-wenshao-iteye-com-blog-1142031\"><a href=\"#转载自：http-wenshao-iteye-com-blog-1142031\" class=\"headerlink\" title=\"转载自：http://wenshao.iteye.com/blog/1142031/\"></a>转载自：<a href=\"http://wenshao.iteye.com/blog/1142031/\" target=\"_blank\" rel=\"external\">http://wenshao.iteye.com/blog/1142031/</a></h5>"},{"layout":"post","title":"密钥和数字证书","date":"2017-08-31T16:00:00.000Z","_content":"\n##### 最近因为项目要求，需要在本地环境为项目部署https服务。之前对https的密钥和证书过程都不是很清楚，所以最近恶补了一些基础知识。这是一篇对数字证书很形象的解释，所以决定记录下来，加深记忆。\n<!--more-->\n\n#### 1.鲍勃有两把钥匙，一把是公钥，另一把是私钥。\n![](/img/note/secretkey1.png)\n\n#### 2.鲍勃把公钥送给他的朋友们—-帕蒂、道格、苏珊—-每人一把。\n![](/img/note/secretkey2.png)\n\n#### 3.苏珊给鲍勃写信，写完后用鲍勃的公钥加密，达到保密的效果。\n![](/img/note/secretkey3.png)\n\n#### 4.鲍勃收信后，用私钥解密，看到信件内容。\n![](/img/note/secretkey4.png)\n\n#### 5.鲍勃给苏珊回信，写完后用Hash函数，生成信件的摘要（digest）。\n![](/img/note/secretkey5.png)\n\n#### 6.然后，鲍勃使用私钥，对这个摘要加密，生成”数字签名”（signature）。\n![](/img/note/secretkey6.png)\n\n#### 7.鲍勃将这个签名，附在信件下面，一起发给苏珊。\n![](/img/note/secretkey7.png)\n\n#### 8.苏珊收信后，取下数字签名，用鲍勃的公钥解密，得到信件的摘要。由此证明，这封信确实是鲍勃发出的。\n![](/img/note/secretkey8.png)\n\n#### 9.苏珊再对信件本身使用Hash函数，将得到的结果，与上一步得到的摘要进行对比。如果两者一致，就证明这封信未被修改过。\n![](/img/note/secretkey9.png)\n\n#### 10.复杂的情况出现了。道格想欺骗苏珊，他偷偷使用了苏珊的电脑，用自己的公钥换走了鲍勃的公钥。因此，他就可以冒充鲍勃，写信给苏珊。\n![](/img/note/secretkey10.png)\n\n#### 11.苏珊发现，自己无法确定公钥是否真的属于鲍勃。她想到了一个办法，要求鲍勃去找”证书中心”（certificate authority，简称CA），为公钥做认证。证书中心用自己的私钥，对鲍勃的公钥和一些相关信息一起加密，生成”数字证书”（Digital Certificate）。\n![](/img/note/secretkey11.png)\n\n#### 12.鲍勃拿到数字证书以后，就可以放心了。以后再给苏珊写信，只要在签名的同时，再附上数字证书就行了。\n![](/img/note/secretkey12.png)\n\n#### 13.苏珊收信后，用CA的公钥解开数字证书，就可以拿到鲍勃真实的公钥了，然后就能证明”数字签名”是否真的是鲍勃签的。\n![](/img/note/secretkey13.png)\n\n#### 14.下面，我们看一个应用”数字证书”的实例：https协议。这个协议主要用于网页加密。\n![](/img/note/secretkey14.jpg)\n\n#### 15.首先，客户端向服务器发出加密请求。\n![](/img/note/secretkey15.png)\n\n#### 16.服务器用自己的私钥加密网页以后，连同本身的数字证书，一起发送给客户端。\n![](/img/note/secretkey16.png)\n\n#### 17.客户端（浏览器）的”证书管理器”，有”受信任的根证书颁发机构”列表。客户端会根据这张列表，查看解开数字证书的公钥是否在列表之内。\n![](/img/note/secretkey17.png)\n\n#### 18.如果数字证书记载的网址，与你正在浏览的网址不一致，就说明这张证书可能被冒用，浏览器会发出警告。\n![](/img/note/secretkey18.png)\n\n#### 19.如果这张数字证书不是由受信任的机构颁发的，浏览器会发出另一种警告。\n![](/img/note/secretkey19.jpg)\n\n#### 20.如果数字证书是可靠的，客户端就可以使用证书中的服务器公钥，对信息进行加密，然后与服务器交换加密信息。\n![](/img/note/secretkey20.png)\n\n### 想更好地理解上面这篇形象生动的技术文章，你还需要理解一些概念和术语\n#### 公钥密码体制(public-key cryptography)\n##### 公钥密码体制分为三个部分，公钥、私钥、加密解密算法，它的加密解密过程如下：\n* 加密：通过加密算法和公钥对内容(或者说明文)进行加密，得到密文。加密过程需要用到公钥。\n* 解密：通过解密算法和私钥对密文进行解密，得到明文。解密过程需要用到解密算法和私钥。注意，由公钥加密的内容，只能由私钥进行解密，也就是说，由公钥加密的内容，如果不知道私钥，是无法解密的。\n##### 公钥密码体制的公钥和算法都是公开的(这是为什么叫公钥密码体制的原因)，私钥是保密的。大家都以使用公钥进行加密，但是只有私钥的持有者才能解密。在实际的使用中，有需要的人会生成一对公钥和私钥，把公钥发布出去给别人使用，自己保留私钥。\n\n#### 对称加密算法(symmetric key algorithms)\n##### 在对称加密算法中，加密使用的密钥和解密使用的密钥是相同的。也就是说，加密和解密都是使用的同一个密钥。因此对称加密算法要保证安全性的话，密钥要做好保密，只能让使用的人知道，不能对外公开。这个和上面的公钥密码体制有所不同，公钥密码体制中加密是用公钥，解密使用私钥，而对称加密算法中，加密和解密都是使用同一个密钥，不区分公钥和私钥。\n##### 密钥，一般就是一个字符串或数字，在加密或者解密时传递给加密/解密算法。前面在公钥密码体制中说到的公钥、私钥就是密钥，公钥是加密使用的密钥，私钥是解密使用的密钥\n\n\n[原文连接](http://www.youdzone.com/signature.html)\n","source":"_posts/note/secretKey.md","raw":"---\nlayout: post\ntitle: 密钥和数字证书\ndate: 2017/09/01\ntags: [tech, index, network]\n---\n\n##### 最近因为项目要求，需要在本地环境为项目部署https服务。之前对https的密钥和证书过程都不是很清楚，所以最近恶补了一些基础知识。这是一篇对数字证书很形象的解释，所以决定记录下来，加深记忆。\n<!--more-->\n\n#### 1.鲍勃有两把钥匙，一把是公钥，另一把是私钥。\n![](/img/note/secretkey1.png)\n\n#### 2.鲍勃把公钥送给他的朋友们—-帕蒂、道格、苏珊—-每人一把。\n![](/img/note/secretkey2.png)\n\n#### 3.苏珊给鲍勃写信，写完后用鲍勃的公钥加密，达到保密的效果。\n![](/img/note/secretkey3.png)\n\n#### 4.鲍勃收信后，用私钥解密，看到信件内容。\n![](/img/note/secretkey4.png)\n\n#### 5.鲍勃给苏珊回信，写完后用Hash函数，生成信件的摘要（digest）。\n![](/img/note/secretkey5.png)\n\n#### 6.然后，鲍勃使用私钥，对这个摘要加密，生成”数字签名”（signature）。\n![](/img/note/secretkey6.png)\n\n#### 7.鲍勃将这个签名，附在信件下面，一起发给苏珊。\n![](/img/note/secretkey7.png)\n\n#### 8.苏珊收信后，取下数字签名，用鲍勃的公钥解密，得到信件的摘要。由此证明，这封信确实是鲍勃发出的。\n![](/img/note/secretkey8.png)\n\n#### 9.苏珊再对信件本身使用Hash函数，将得到的结果，与上一步得到的摘要进行对比。如果两者一致，就证明这封信未被修改过。\n![](/img/note/secretkey9.png)\n\n#### 10.复杂的情况出现了。道格想欺骗苏珊，他偷偷使用了苏珊的电脑，用自己的公钥换走了鲍勃的公钥。因此，他就可以冒充鲍勃，写信给苏珊。\n![](/img/note/secretkey10.png)\n\n#### 11.苏珊发现，自己无法确定公钥是否真的属于鲍勃。她想到了一个办法，要求鲍勃去找”证书中心”（certificate authority，简称CA），为公钥做认证。证书中心用自己的私钥，对鲍勃的公钥和一些相关信息一起加密，生成”数字证书”（Digital Certificate）。\n![](/img/note/secretkey11.png)\n\n#### 12.鲍勃拿到数字证书以后，就可以放心了。以后再给苏珊写信，只要在签名的同时，再附上数字证书就行了。\n![](/img/note/secretkey12.png)\n\n#### 13.苏珊收信后，用CA的公钥解开数字证书，就可以拿到鲍勃真实的公钥了，然后就能证明”数字签名”是否真的是鲍勃签的。\n![](/img/note/secretkey13.png)\n\n#### 14.下面，我们看一个应用”数字证书”的实例：https协议。这个协议主要用于网页加密。\n![](/img/note/secretkey14.jpg)\n\n#### 15.首先，客户端向服务器发出加密请求。\n![](/img/note/secretkey15.png)\n\n#### 16.服务器用自己的私钥加密网页以后，连同本身的数字证书，一起发送给客户端。\n![](/img/note/secretkey16.png)\n\n#### 17.客户端（浏览器）的”证书管理器”，有”受信任的根证书颁发机构”列表。客户端会根据这张列表，查看解开数字证书的公钥是否在列表之内。\n![](/img/note/secretkey17.png)\n\n#### 18.如果数字证书记载的网址，与你正在浏览的网址不一致，就说明这张证书可能被冒用，浏览器会发出警告。\n![](/img/note/secretkey18.png)\n\n#### 19.如果这张数字证书不是由受信任的机构颁发的，浏览器会发出另一种警告。\n![](/img/note/secretkey19.jpg)\n\n#### 20.如果数字证书是可靠的，客户端就可以使用证书中的服务器公钥，对信息进行加密，然后与服务器交换加密信息。\n![](/img/note/secretkey20.png)\n\n### 想更好地理解上面这篇形象生动的技术文章，你还需要理解一些概念和术语\n#### 公钥密码体制(public-key cryptography)\n##### 公钥密码体制分为三个部分，公钥、私钥、加密解密算法，它的加密解密过程如下：\n* 加密：通过加密算法和公钥对内容(或者说明文)进行加密，得到密文。加密过程需要用到公钥。\n* 解密：通过解密算法和私钥对密文进行解密，得到明文。解密过程需要用到解密算法和私钥。注意，由公钥加密的内容，只能由私钥进行解密，也就是说，由公钥加密的内容，如果不知道私钥，是无法解密的。\n##### 公钥密码体制的公钥和算法都是公开的(这是为什么叫公钥密码体制的原因)，私钥是保密的。大家都以使用公钥进行加密，但是只有私钥的持有者才能解密。在实际的使用中，有需要的人会生成一对公钥和私钥，把公钥发布出去给别人使用，自己保留私钥。\n\n#### 对称加密算法(symmetric key algorithms)\n##### 在对称加密算法中，加密使用的密钥和解密使用的密钥是相同的。也就是说，加密和解密都是使用的同一个密钥。因此对称加密算法要保证安全性的话，密钥要做好保密，只能让使用的人知道，不能对外公开。这个和上面的公钥密码体制有所不同，公钥密码体制中加密是用公钥，解密使用私钥，而对称加密算法中，加密和解密都是使用同一个密钥，不区分公钥和私钥。\n##### 密钥，一般就是一个字符串或数字，在加密或者解密时传递给加密/解密算法。前面在公钥密码体制中说到的公钥、私钥就是密钥，公钥是加密使用的密钥，私钥是解密使用的密钥\n\n\n[原文连接](http://www.youdzone.com/signature.html)\n","slug":"note/secretKey","published":1,"updated":"2018-05-08T13:00:14.283Z","comments":1,"photos":[],"link":"","_id":"cjgxop3l40009jah1gtgeiml7","content":"<h5 id=\"最近因为项目要求，需要在本地环境为项目部署https服务。之前对https的密钥和证书过程都不是很清楚，所以最近恶补了一些基础知识。这是一篇对数字证书很形象的解释，所以决定记录下来，加深记忆。\"><a href=\"#最近因为项目要求，需要在本地环境为项目部署https服务。之前对https的密钥和证书过程都不是很清楚，所以最近恶补了一些基础知识。这是一篇对数字证书很形象的解释，所以决定记录下来，加深记忆。\" class=\"headerlink\" title=\"最近因为项目要求，需要在本地环境为项目部署https服务。之前对https的密钥和证书过程都不是很清楚，所以最近恶补了一些基础知识。这是一篇对数字证书很形象的解释，所以决定记录下来，加深记忆。\"></a>最近因为项目要求，需要在本地环境为项目部署https服务。之前对https的密钥和证书过程都不是很清楚，所以最近恶补了一些基础知识。这是一篇对数字证书很形象的解释，所以决定记录下来，加深记忆。</h5><a id=\"more\"></a>\n<h4 id=\"1-鲍勃有两把钥匙，一把是公钥，另一把是私钥。\"><a href=\"#1-鲍勃有两把钥匙，一把是公钥，另一把是私钥。\" class=\"headerlink\" title=\"1.鲍勃有两把钥匙，一把是公钥，另一把是私钥。\"></a>1.鲍勃有两把钥匙，一把是公钥，另一把是私钥。</h4><p><img src=\"/img/note/secretkey1.png\" alt=\"\"></p>\n<h4 id=\"2-鲍勃把公钥送给他的朋友们—-帕蒂、道格、苏珊—-每人一把。\"><a href=\"#2-鲍勃把公钥送给他的朋友们—-帕蒂、道格、苏珊—-每人一把。\" class=\"headerlink\" title=\"2.鲍勃把公钥送给他的朋友们—-帕蒂、道格、苏珊—-每人一把。\"></a>2.鲍勃把公钥送给他的朋友们—-帕蒂、道格、苏珊—-每人一把。</h4><p><img src=\"/img/note/secretkey2.png\" alt=\"\"></p>\n<h4 id=\"3-苏珊给鲍勃写信，写完后用鲍勃的公钥加密，达到保密的效果。\"><a href=\"#3-苏珊给鲍勃写信，写完后用鲍勃的公钥加密，达到保密的效果。\" class=\"headerlink\" title=\"3.苏珊给鲍勃写信，写完后用鲍勃的公钥加密，达到保密的效果。\"></a>3.苏珊给鲍勃写信，写完后用鲍勃的公钥加密，达到保密的效果。</h4><p><img src=\"/img/note/secretkey3.png\" alt=\"\"></p>\n<h4 id=\"4-鲍勃收信后，用私钥解密，看到信件内容。\"><a href=\"#4-鲍勃收信后，用私钥解密，看到信件内容。\" class=\"headerlink\" title=\"4.鲍勃收信后，用私钥解密，看到信件内容。\"></a>4.鲍勃收信后，用私钥解密，看到信件内容。</h4><p><img src=\"/img/note/secretkey4.png\" alt=\"\"></p>\n<h4 id=\"5-鲍勃给苏珊回信，写完后用Hash函数，生成信件的摘要（digest）。\"><a href=\"#5-鲍勃给苏珊回信，写完后用Hash函数，生成信件的摘要（digest）。\" class=\"headerlink\" title=\"5.鲍勃给苏珊回信，写完后用Hash函数，生成信件的摘要（digest）。\"></a>5.鲍勃给苏珊回信，写完后用Hash函数，生成信件的摘要（digest）。</h4><p><img src=\"/img/note/secretkey5.png\" alt=\"\"></p>\n<h4 id=\"6-然后，鲍勃使用私钥，对这个摘要加密，生成”数字签名”（signature）。\"><a href=\"#6-然后，鲍勃使用私钥，对这个摘要加密，生成”数字签名”（signature）。\" class=\"headerlink\" title=\"6.然后，鲍勃使用私钥，对这个摘要加密，生成”数字签名”（signature）。\"></a>6.然后，鲍勃使用私钥，对这个摘要加密，生成”数字签名”（signature）。</h4><p><img src=\"/img/note/secretkey6.png\" alt=\"\"></p>\n<h4 id=\"7-鲍勃将这个签名，附在信件下面，一起发给苏珊。\"><a href=\"#7-鲍勃将这个签名，附在信件下面，一起发给苏珊。\" class=\"headerlink\" title=\"7.鲍勃将这个签名，附在信件下面，一起发给苏珊。\"></a>7.鲍勃将这个签名，附在信件下面，一起发给苏珊。</h4><p><img src=\"/img/note/secretkey7.png\" alt=\"\"></p>\n<h4 id=\"8-苏珊收信后，取下数字签名，用鲍勃的公钥解密，得到信件的摘要。由此证明，这封信确实是鲍勃发出的。\"><a href=\"#8-苏珊收信后，取下数字签名，用鲍勃的公钥解密，得到信件的摘要。由此证明，这封信确实是鲍勃发出的。\" class=\"headerlink\" title=\"8.苏珊收信后，取下数字签名，用鲍勃的公钥解密，得到信件的摘要。由此证明，这封信确实是鲍勃发出的。\"></a>8.苏珊收信后，取下数字签名，用鲍勃的公钥解密，得到信件的摘要。由此证明，这封信确实是鲍勃发出的。</h4><p><img src=\"/img/note/secretkey8.png\" alt=\"\"></p>\n<h4 id=\"9-苏珊再对信件本身使用Hash函数，将得到的结果，与上一步得到的摘要进行对比。如果两者一致，就证明这封信未被修改过。\"><a href=\"#9-苏珊再对信件本身使用Hash函数，将得到的结果，与上一步得到的摘要进行对比。如果两者一致，就证明这封信未被修改过。\" class=\"headerlink\" title=\"9.苏珊再对信件本身使用Hash函数，将得到的结果，与上一步得到的摘要进行对比。如果两者一致，就证明这封信未被修改过。\"></a>9.苏珊再对信件本身使用Hash函数，将得到的结果，与上一步得到的摘要进行对比。如果两者一致，就证明这封信未被修改过。</h4><p><img src=\"/img/note/secretkey9.png\" alt=\"\"></p>\n<h4 id=\"10-复杂的情况出现了。道格想欺骗苏珊，他偷偷使用了苏珊的电脑，用自己的公钥换走了鲍勃的公钥。因此，他就可以冒充鲍勃，写信给苏珊。\"><a href=\"#10-复杂的情况出现了。道格想欺骗苏珊，他偷偷使用了苏珊的电脑，用自己的公钥换走了鲍勃的公钥。因此，他就可以冒充鲍勃，写信给苏珊。\" class=\"headerlink\" title=\"10.复杂的情况出现了。道格想欺骗苏珊，他偷偷使用了苏珊的电脑，用自己的公钥换走了鲍勃的公钥。因此，他就可以冒充鲍勃，写信给苏珊。\"></a>10.复杂的情况出现了。道格想欺骗苏珊，他偷偷使用了苏珊的电脑，用自己的公钥换走了鲍勃的公钥。因此，他就可以冒充鲍勃，写信给苏珊。</h4><p><img src=\"/img/note/secretkey10.png\" alt=\"\"></p>\n<h4 id=\"11-苏珊发现，自己无法确定公钥是否真的属于鲍勃。她想到了一个办法，要求鲍勃去找”证书中心”（certificate-authority，简称CA），为公钥做认证。证书中心用自己的私钥，对鲍勃的公钥和一些相关信息一起加密，生成”数字证书”（Digital-Certificate）。\"><a href=\"#11-苏珊发现，自己无法确定公钥是否真的属于鲍勃。她想到了一个办法，要求鲍勃去找”证书中心”（certificate-authority，简称CA），为公钥做认证。证书中心用自己的私钥，对鲍勃的公钥和一些相关信息一起加密，生成”数字证书”（Digital-Certificate）。\" class=\"headerlink\" title=\"11.苏珊发现，自己无法确定公钥是否真的属于鲍勃。她想到了一个办法，要求鲍勃去找”证书中心”（certificate authority，简称CA），为公钥做认证。证书中心用自己的私钥，对鲍勃的公钥和一些相关信息一起加密，生成”数字证书”（Digital Certificate）。\"></a>11.苏珊发现，自己无法确定公钥是否真的属于鲍勃。她想到了一个办法，要求鲍勃去找”证书中心”（certificate authority，简称CA），为公钥做认证。证书中心用自己的私钥，对鲍勃的公钥和一些相关信息一起加密，生成”数字证书”（Digital Certificate）。</h4><p><img src=\"/img/note/secretkey11.png\" alt=\"\"></p>\n<h4 id=\"12-鲍勃拿到数字证书以后，就可以放心了。以后再给苏珊写信，只要在签名的同时，再附上数字证书就行了。\"><a href=\"#12-鲍勃拿到数字证书以后，就可以放心了。以后再给苏珊写信，只要在签名的同时，再附上数字证书就行了。\" class=\"headerlink\" title=\"12.鲍勃拿到数字证书以后，就可以放心了。以后再给苏珊写信，只要在签名的同时，再附上数字证书就行了。\"></a>12.鲍勃拿到数字证书以后，就可以放心了。以后再给苏珊写信，只要在签名的同时，再附上数字证书就行了。</h4><p><img src=\"/img/note/secretkey12.png\" alt=\"\"></p>\n<h4 id=\"13-苏珊收信后，用CA的公钥解开数字证书，就可以拿到鲍勃真实的公钥了，然后就能证明”数字签名”是否真的是鲍勃签的。\"><a href=\"#13-苏珊收信后，用CA的公钥解开数字证书，就可以拿到鲍勃真实的公钥了，然后就能证明”数字签名”是否真的是鲍勃签的。\" class=\"headerlink\" title=\"13.苏珊收信后，用CA的公钥解开数字证书，就可以拿到鲍勃真实的公钥了，然后就能证明”数字签名”是否真的是鲍勃签的。\"></a>13.苏珊收信后，用CA的公钥解开数字证书，就可以拿到鲍勃真实的公钥了，然后就能证明”数字签名”是否真的是鲍勃签的。</h4><p><img src=\"/img/note/secretkey13.png\" alt=\"\"></p>\n<h4 id=\"14-下面，我们看一个应用”数字证书”的实例：https协议。这个协议主要用于网页加密。\"><a href=\"#14-下面，我们看一个应用”数字证书”的实例：https协议。这个协议主要用于网页加密。\" class=\"headerlink\" title=\"14.下面，我们看一个应用”数字证书”的实例：https协议。这个协议主要用于网页加密。\"></a>14.下面，我们看一个应用”数字证书”的实例：https协议。这个协议主要用于网页加密。</h4><p><img src=\"/img/note/secretkey14.jpg\" alt=\"\"></p>\n<h4 id=\"15-首先，客户端向服务器发出加密请求。\"><a href=\"#15-首先，客户端向服务器发出加密请求。\" class=\"headerlink\" title=\"15.首先，客户端向服务器发出加密请求。\"></a>15.首先，客户端向服务器发出加密请求。</h4><p><img src=\"/img/note/secretkey15.png\" alt=\"\"></p>\n<h4 id=\"16-服务器用自己的私钥加密网页以后，连同本身的数字证书，一起发送给客户端。\"><a href=\"#16-服务器用自己的私钥加密网页以后，连同本身的数字证书，一起发送给客户端。\" class=\"headerlink\" title=\"16.服务器用自己的私钥加密网页以后，连同本身的数字证书，一起发送给客户端。\"></a>16.服务器用自己的私钥加密网页以后，连同本身的数字证书，一起发送给客户端。</h4><p><img src=\"/img/note/secretkey16.png\" alt=\"\"></p>\n<h4 id=\"17-客户端（浏览器）的”证书管理器”，有”受信任的根证书颁发机构”列表。客户端会根据这张列表，查看解开数字证书的公钥是否在列表之内。\"><a href=\"#17-客户端（浏览器）的”证书管理器”，有”受信任的根证书颁发机构”列表。客户端会根据这张列表，查看解开数字证书的公钥是否在列表之内。\" class=\"headerlink\" title=\"17.客户端（浏览器）的”证书管理器”，有”受信任的根证书颁发机构”列表。客户端会根据这张列表，查看解开数字证书的公钥是否在列表之内。\"></a>17.客户端（浏览器）的”证书管理器”，有”受信任的根证书颁发机构”列表。客户端会根据这张列表，查看解开数字证书的公钥是否在列表之内。</h4><p><img src=\"/img/note/secretkey17.png\" alt=\"\"></p>\n<h4 id=\"18-如果数字证书记载的网址，与你正在浏览的网址不一致，就说明这张证书可能被冒用，浏览器会发出警告。\"><a href=\"#18-如果数字证书记载的网址，与你正在浏览的网址不一致，就说明这张证书可能被冒用，浏览器会发出警告。\" class=\"headerlink\" title=\"18.如果数字证书记载的网址，与你正在浏览的网址不一致，就说明这张证书可能被冒用，浏览器会发出警告。\"></a>18.如果数字证书记载的网址，与你正在浏览的网址不一致，就说明这张证书可能被冒用，浏览器会发出警告。</h4><p><img src=\"/img/note/secretkey18.png\" alt=\"\"></p>\n<h4 id=\"19-如果这张数字证书不是由受信任的机构颁发的，浏览器会发出另一种警告。\"><a href=\"#19-如果这张数字证书不是由受信任的机构颁发的，浏览器会发出另一种警告。\" class=\"headerlink\" title=\"19.如果这张数字证书不是由受信任的机构颁发的，浏览器会发出另一种警告。\"></a>19.如果这张数字证书不是由受信任的机构颁发的，浏览器会发出另一种警告。</h4><p><img src=\"/img/note/secretkey19.jpg\" alt=\"\"></p>\n<h4 id=\"20-如果数字证书是可靠的，客户端就可以使用证书中的服务器公钥，对信息进行加密，然后与服务器交换加密信息。\"><a href=\"#20-如果数字证书是可靠的，客户端就可以使用证书中的服务器公钥，对信息进行加密，然后与服务器交换加密信息。\" class=\"headerlink\" title=\"20.如果数字证书是可靠的，客户端就可以使用证书中的服务器公钥，对信息进行加密，然后与服务器交换加密信息。\"></a>20.如果数字证书是可靠的，客户端就可以使用证书中的服务器公钥，对信息进行加密，然后与服务器交换加密信息。</h4><p><img src=\"/img/note/secretkey20.png\" alt=\"\"></p>\n<h3 id=\"想更好地理解上面这篇形象生动的技术文章，你还需要理解一些概念和术语\"><a href=\"#想更好地理解上面这篇形象生动的技术文章，你还需要理解一些概念和术语\" class=\"headerlink\" title=\"想更好地理解上面这篇形象生动的技术文章，你还需要理解一些概念和术语\"></a>想更好地理解上面这篇形象生动的技术文章，你还需要理解一些概念和术语</h3><h4 id=\"公钥密码体制-public-key-cryptography\"><a href=\"#公钥密码体制-public-key-cryptography\" class=\"headerlink\" title=\"公钥密码体制(public-key cryptography)\"></a>公钥密码体制(public-key cryptography)</h4><h5 id=\"公钥密码体制分为三个部分，公钥、私钥、加密解密算法，它的加密解密过程如下：\"><a href=\"#公钥密码体制分为三个部分，公钥、私钥、加密解密算法，它的加密解密过程如下：\" class=\"headerlink\" title=\"公钥密码体制分为三个部分，公钥、私钥、加密解密算法，它的加密解密过程如下：\"></a>公钥密码体制分为三个部分，公钥、私钥、加密解密算法，它的加密解密过程如下：</h5><ul>\n<li>加密：通过加密算法和公钥对内容(或者说明文)进行加密，得到密文。加密过程需要用到公钥。</li>\n<li>解密：通过解密算法和私钥对密文进行解密，得到明文。解密过程需要用到解密算法和私钥。注意，由公钥加密的内容，只能由私钥进行解密，也就是说，由公钥加密的内容，如果不知道私钥，是无法解密的。<h5 id=\"公钥密码体制的公钥和算法都是公开的-这是为什么叫公钥密码体制的原因-，私钥是保密的。大家都以使用公钥进行加密，但是只有私钥的持有者才能解密。在实际的使用中，有需要的人会生成一对公钥和私钥，把公钥发布出去给别人使用，自己保留私钥。\"><a href=\"#公钥密码体制的公钥和算法都是公开的-这是为什么叫公钥密码体制的原因-，私钥是保密的。大家都以使用公钥进行加密，但是只有私钥的持有者才能解密。在实际的使用中，有需要的人会生成一对公钥和私钥，把公钥发布出去给别人使用，自己保留私钥。\" class=\"headerlink\" title=\"公钥密码体制的公钥和算法都是公开的(这是为什么叫公钥密码体制的原因)，私钥是保密的。大家都以使用公钥进行加密，但是只有私钥的持有者才能解密。在实际的使用中，有需要的人会生成一对公钥和私钥，把公钥发布出去给别人使用，自己保留私钥。\"></a>公钥密码体制的公钥和算法都是公开的(这是为什么叫公钥密码体制的原因)，私钥是保密的。大家都以使用公钥进行加密，但是只有私钥的持有者才能解密。在实际的使用中，有需要的人会生成一对公钥和私钥，把公钥发布出去给别人使用，自己保留私钥。</h5></li>\n</ul>\n<h4 id=\"对称加密算法-symmetric-key-algorithms\"><a href=\"#对称加密算法-symmetric-key-algorithms\" class=\"headerlink\" title=\"对称加密算法(symmetric key algorithms)\"></a>对称加密算法(symmetric key algorithms)</h4><h5 id=\"在对称加密算法中，加密使用的密钥和解密使用的密钥是相同的。也就是说，加密和解密都是使用的同一个密钥。因此对称加密算法要保证安全性的话，密钥要做好保密，只能让使用的人知道，不能对外公开。这个和上面的公钥密码体制有所不同，公钥密码体制中加密是用公钥，解密使用私钥，而对称加密算法中，加密和解密都是使用同一个密钥，不区分公钥和私钥。\"><a href=\"#在对称加密算法中，加密使用的密钥和解密使用的密钥是相同的。也就是说，加密和解密都是使用的同一个密钥。因此对称加密算法要保证安全性的话，密钥要做好保密，只能让使用的人知道，不能对外公开。这个和上面的公钥密码体制有所不同，公钥密码体制中加密是用公钥，解密使用私钥，而对称加密算法中，加密和解密都是使用同一个密钥，不区分公钥和私钥。\" class=\"headerlink\" title=\"在对称加密算法中，加密使用的密钥和解密使用的密钥是相同的。也就是说，加密和解密都是使用的同一个密钥。因此对称加密算法要保证安全性的话，密钥要做好保密，只能让使用的人知道，不能对外公开。这个和上面的公钥密码体制有所不同，公钥密码体制中加密是用公钥，解密使用私钥，而对称加密算法中，加密和解密都是使用同一个密钥，不区分公钥和私钥。\"></a>在对称加密算法中，加密使用的密钥和解密使用的密钥是相同的。也就是说，加密和解密都是使用的同一个密钥。因此对称加密算法要保证安全性的话，密钥要做好保密，只能让使用的人知道，不能对外公开。这个和上面的公钥密码体制有所不同，公钥密码体制中加密是用公钥，解密使用私钥，而对称加密算法中，加密和解密都是使用同一个密钥，不区分公钥和私钥。</h5><h5 id=\"密钥，一般就是一个字符串或数字，在加密或者解密时传递给加密-解密算法。前面在公钥密码体制中说到的公钥、私钥就是密钥，公钥是加密使用的密钥，私钥是解密使用的密钥\"><a href=\"#密钥，一般就是一个字符串或数字，在加密或者解密时传递给加密-解密算法。前面在公钥密码体制中说到的公钥、私钥就是密钥，公钥是加密使用的密钥，私钥是解密使用的密钥\" class=\"headerlink\" title=\"密钥，一般就是一个字符串或数字，在加密或者解密时传递给加密/解密算法。前面在公钥密码体制中说到的公钥、私钥就是密钥，公钥是加密使用的密钥，私钥是解密使用的密钥\"></a>密钥，一般就是一个字符串或数字，在加密或者解密时传递给加密/解密算法。前面在公钥密码体制中说到的公钥、私钥就是密钥，公钥是加密使用的密钥，私钥是解密使用的密钥</h5><p><a href=\"http://www.youdzone.com/signature.html\" target=\"_blank\" rel=\"external\">原文连接</a></p>\n","site":{"data":{}},"excerpt":"<h5 id=\"最近因为项目要求，需要在本地环境为项目部署https服务。之前对https的密钥和证书过程都不是很清楚，所以最近恶补了一些基础知识。这是一篇对数字证书很形象的解释，所以决定记录下来，加深记忆。\"><a href=\"#最近因为项目要求，需要在本地环境为项目部署https服务。之前对https的密钥和证书过程都不是很清楚，所以最近恶补了一些基础知识。这是一篇对数字证书很形象的解释，所以决定记录下来，加深记忆。\" class=\"headerlink\" title=\"最近因为项目要求，需要在本地环境为项目部署https服务。之前对https的密钥和证书过程都不是很清楚，所以最近恶补了一些基础知识。这是一篇对数字证书很形象的解释，所以决定记录下来，加深记忆。\"></a>最近因为项目要求，需要在本地环境为项目部署https服务。之前对https的密钥和证书过程都不是很清楚，所以最近恶补了一些基础知识。这是一篇对数字证书很形象的解释，所以决定记录下来，加深记忆。</h5>","more":"<h4 id=\"1-鲍勃有两把钥匙，一把是公钥，另一把是私钥。\"><a href=\"#1-鲍勃有两把钥匙，一把是公钥，另一把是私钥。\" class=\"headerlink\" title=\"1.鲍勃有两把钥匙，一把是公钥，另一把是私钥。\"></a>1.鲍勃有两把钥匙，一把是公钥，另一把是私钥。</h4><p><img src=\"/img/note/secretkey1.png\" alt=\"\"></p>\n<h4 id=\"2-鲍勃把公钥送给他的朋友们—-帕蒂、道格、苏珊—-每人一把。\"><a href=\"#2-鲍勃把公钥送给他的朋友们—-帕蒂、道格、苏珊—-每人一把。\" class=\"headerlink\" title=\"2.鲍勃把公钥送给他的朋友们—-帕蒂、道格、苏珊—-每人一把。\"></a>2.鲍勃把公钥送给他的朋友们—-帕蒂、道格、苏珊—-每人一把。</h4><p><img src=\"/img/note/secretkey2.png\" alt=\"\"></p>\n<h4 id=\"3-苏珊给鲍勃写信，写完后用鲍勃的公钥加密，达到保密的效果。\"><a href=\"#3-苏珊给鲍勃写信，写完后用鲍勃的公钥加密，达到保密的效果。\" class=\"headerlink\" title=\"3.苏珊给鲍勃写信，写完后用鲍勃的公钥加密，达到保密的效果。\"></a>3.苏珊给鲍勃写信，写完后用鲍勃的公钥加密，达到保密的效果。</h4><p><img src=\"/img/note/secretkey3.png\" alt=\"\"></p>\n<h4 id=\"4-鲍勃收信后，用私钥解密，看到信件内容。\"><a href=\"#4-鲍勃收信后，用私钥解密，看到信件内容。\" class=\"headerlink\" title=\"4.鲍勃收信后，用私钥解密，看到信件内容。\"></a>4.鲍勃收信后，用私钥解密，看到信件内容。</h4><p><img src=\"/img/note/secretkey4.png\" alt=\"\"></p>\n<h4 id=\"5-鲍勃给苏珊回信，写完后用Hash函数，生成信件的摘要（digest）。\"><a href=\"#5-鲍勃给苏珊回信，写完后用Hash函数，生成信件的摘要（digest）。\" class=\"headerlink\" title=\"5.鲍勃给苏珊回信，写完后用Hash函数，生成信件的摘要（digest）。\"></a>5.鲍勃给苏珊回信，写完后用Hash函数，生成信件的摘要（digest）。</h4><p><img src=\"/img/note/secretkey5.png\" alt=\"\"></p>\n<h4 id=\"6-然后，鲍勃使用私钥，对这个摘要加密，生成”数字签名”（signature）。\"><a href=\"#6-然后，鲍勃使用私钥，对这个摘要加密，生成”数字签名”（signature）。\" class=\"headerlink\" title=\"6.然后，鲍勃使用私钥，对这个摘要加密，生成”数字签名”（signature）。\"></a>6.然后，鲍勃使用私钥，对这个摘要加密，生成”数字签名”（signature）。</h4><p><img src=\"/img/note/secretkey6.png\" alt=\"\"></p>\n<h4 id=\"7-鲍勃将这个签名，附在信件下面，一起发给苏珊。\"><a href=\"#7-鲍勃将这个签名，附在信件下面，一起发给苏珊。\" class=\"headerlink\" title=\"7.鲍勃将这个签名，附在信件下面，一起发给苏珊。\"></a>7.鲍勃将这个签名，附在信件下面，一起发给苏珊。</h4><p><img src=\"/img/note/secretkey7.png\" alt=\"\"></p>\n<h4 id=\"8-苏珊收信后，取下数字签名，用鲍勃的公钥解密，得到信件的摘要。由此证明，这封信确实是鲍勃发出的。\"><a href=\"#8-苏珊收信后，取下数字签名，用鲍勃的公钥解密，得到信件的摘要。由此证明，这封信确实是鲍勃发出的。\" class=\"headerlink\" title=\"8.苏珊收信后，取下数字签名，用鲍勃的公钥解密，得到信件的摘要。由此证明，这封信确实是鲍勃发出的。\"></a>8.苏珊收信后，取下数字签名，用鲍勃的公钥解密，得到信件的摘要。由此证明，这封信确实是鲍勃发出的。</h4><p><img src=\"/img/note/secretkey8.png\" alt=\"\"></p>\n<h4 id=\"9-苏珊再对信件本身使用Hash函数，将得到的结果，与上一步得到的摘要进行对比。如果两者一致，就证明这封信未被修改过。\"><a href=\"#9-苏珊再对信件本身使用Hash函数，将得到的结果，与上一步得到的摘要进行对比。如果两者一致，就证明这封信未被修改过。\" class=\"headerlink\" title=\"9.苏珊再对信件本身使用Hash函数，将得到的结果，与上一步得到的摘要进行对比。如果两者一致，就证明这封信未被修改过。\"></a>9.苏珊再对信件本身使用Hash函数，将得到的结果，与上一步得到的摘要进行对比。如果两者一致，就证明这封信未被修改过。</h4><p><img src=\"/img/note/secretkey9.png\" alt=\"\"></p>\n<h4 id=\"10-复杂的情况出现了。道格想欺骗苏珊，他偷偷使用了苏珊的电脑，用自己的公钥换走了鲍勃的公钥。因此，他就可以冒充鲍勃，写信给苏珊。\"><a href=\"#10-复杂的情况出现了。道格想欺骗苏珊，他偷偷使用了苏珊的电脑，用自己的公钥换走了鲍勃的公钥。因此，他就可以冒充鲍勃，写信给苏珊。\" class=\"headerlink\" title=\"10.复杂的情况出现了。道格想欺骗苏珊，他偷偷使用了苏珊的电脑，用自己的公钥换走了鲍勃的公钥。因此，他就可以冒充鲍勃，写信给苏珊。\"></a>10.复杂的情况出现了。道格想欺骗苏珊，他偷偷使用了苏珊的电脑，用自己的公钥换走了鲍勃的公钥。因此，他就可以冒充鲍勃，写信给苏珊。</h4><p><img src=\"/img/note/secretkey10.png\" alt=\"\"></p>\n<h4 id=\"11-苏珊发现，自己无法确定公钥是否真的属于鲍勃。她想到了一个办法，要求鲍勃去找”证书中心”（certificate-authority，简称CA），为公钥做认证。证书中心用自己的私钥，对鲍勃的公钥和一些相关信息一起加密，生成”数字证书”（Digital-Certificate）。\"><a href=\"#11-苏珊发现，自己无法确定公钥是否真的属于鲍勃。她想到了一个办法，要求鲍勃去找”证书中心”（certificate-authority，简称CA），为公钥做认证。证书中心用自己的私钥，对鲍勃的公钥和一些相关信息一起加密，生成”数字证书”（Digital-Certificate）。\" class=\"headerlink\" title=\"11.苏珊发现，自己无法确定公钥是否真的属于鲍勃。她想到了一个办法，要求鲍勃去找”证书中心”（certificate authority，简称CA），为公钥做认证。证书中心用自己的私钥，对鲍勃的公钥和一些相关信息一起加密，生成”数字证书”（Digital Certificate）。\"></a>11.苏珊发现，自己无法确定公钥是否真的属于鲍勃。她想到了一个办法，要求鲍勃去找”证书中心”（certificate authority，简称CA），为公钥做认证。证书中心用自己的私钥，对鲍勃的公钥和一些相关信息一起加密，生成”数字证书”（Digital Certificate）。</h4><p><img src=\"/img/note/secretkey11.png\" alt=\"\"></p>\n<h4 id=\"12-鲍勃拿到数字证书以后，就可以放心了。以后再给苏珊写信，只要在签名的同时，再附上数字证书就行了。\"><a href=\"#12-鲍勃拿到数字证书以后，就可以放心了。以后再给苏珊写信，只要在签名的同时，再附上数字证书就行了。\" class=\"headerlink\" title=\"12.鲍勃拿到数字证书以后，就可以放心了。以后再给苏珊写信，只要在签名的同时，再附上数字证书就行了。\"></a>12.鲍勃拿到数字证书以后，就可以放心了。以后再给苏珊写信，只要在签名的同时，再附上数字证书就行了。</h4><p><img src=\"/img/note/secretkey12.png\" alt=\"\"></p>\n<h4 id=\"13-苏珊收信后，用CA的公钥解开数字证书，就可以拿到鲍勃真实的公钥了，然后就能证明”数字签名”是否真的是鲍勃签的。\"><a href=\"#13-苏珊收信后，用CA的公钥解开数字证书，就可以拿到鲍勃真实的公钥了，然后就能证明”数字签名”是否真的是鲍勃签的。\" class=\"headerlink\" title=\"13.苏珊收信后，用CA的公钥解开数字证书，就可以拿到鲍勃真实的公钥了，然后就能证明”数字签名”是否真的是鲍勃签的。\"></a>13.苏珊收信后，用CA的公钥解开数字证书，就可以拿到鲍勃真实的公钥了，然后就能证明”数字签名”是否真的是鲍勃签的。</h4><p><img src=\"/img/note/secretkey13.png\" alt=\"\"></p>\n<h4 id=\"14-下面，我们看一个应用”数字证书”的实例：https协议。这个协议主要用于网页加密。\"><a href=\"#14-下面，我们看一个应用”数字证书”的实例：https协议。这个协议主要用于网页加密。\" class=\"headerlink\" title=\"14.下面，我们看一个应用”数字证书”的实例：https协议。这个协议主要用于网页加密。\"></a>14.下面，我们看一个应用”数字证书”的实例：https协议。这个协议主要用于网页加密。</h4><p><img src=\"/img/note/secretkey14.jpg\" alt=\"\"></p>\n<h4 id=\"15-首先，客户端向服务器发出加密请求。\"><a href=\"#15-首先，客户端向服务器发出加密请求。\" class=\"headerlink\" title=\"15.首先，客户端向服务器发出加密请求。\"></a>15.首先，客户端向服务器发出加密请求。</h4><p><img src=\"/img/note/secretkey15.png\" alt=\"\"></p>\n<h4 id=\"16-服务器用自己的私钥加密网页以后，连同本身的数字证书，一起发送给客户端。\"><a href=\"#16-服务器用自己的私钥加密网页以后，连同本身的数字证书，一起发送给客户端。\" class=\"headerlink\" title=\"16.服务器用自己的私钥加密网页以后，连同本身的数字证书，一起发送给客户端。\"></a>16.服务器用自己的私钥加密网页以后，连同本身的数字证书，一起发送给客户端。</h4><p><img src=\"/img/note/secretkey16.png\" alt=\"\"></p>\n<h4 id=\"17-客户端（浏览器）的”证书管理器”，有”受信任的根证书颁发机构”列表。客户端会根据这张列表，查看解开数字证书的公钥是否在列表之内。\"><a href=\"#17-客户端（浏览器）的”证书管理器”，有”受信任的根证书颁发机构”列表。客户端会根据这张列表，查看解开数字证书的公钥是否在列表之内。\" class=\"headerlink\" title=\"17.客户端（浏览器）的”证书管理器”，有”受信任的根证书颁发机构”列表。客户端会根据这张列表，查看解开数字证书的公钥是否在列表之内。\"></a>17.客户端（浏览器）的”证书管理器”，有”受信任的根证书颁发机构”列表。客户端会根据这张列表，查看解开数字证书的公钥是否在列表之内。</h4><p><img src=\"/img/note/secretkey17.png\" alt=\"\"></p>\n<h4 id=\"18-如果数字证书记载的网址，与你正在浏览的网址不一致，就说明这张证书可能被冒用，浏览器会发出警告。\"><a href=\"#18-如果数字证书记载的网址，与你正在浏览的网址不一致，就说明这张证书可能被冒用，浏览器会发出警告。\" class=\"headerlink\" title=\"18.如果数字证书记载的网址，与你正在浏览的网址不一致，就说明这张证书可能被冒用，浏览器会发出警告。\"></a>18.如果数字证书记载的网址，与你正在浏览的网址不一致，就说明这张证书可能被冒用，浏览器会发出警告。</h4><p><img src=\"/img/note/secretkey18.png\" alt=\"\"></p>\n<h4 id=\"19-如果这张数字证书不是由受信任的机构颁发的，浏览器会发出另一种警告。\"><a href=\"#19-如果这张数字证书不是由受信任的机构颁发的，浏览器会发出另一种警告。\" class=\"headerlink\" title=\"19.如果这张数字证书不是由受信任的机构颁发的，浏览器会发出另一种警告。\"></a>19.如果这张数字证书不是由受信任的机构颁发的，浏览器会发出另一种警告。</h4><p><img src=\"/img/note/secretkey19.jpg\" alt=\"\"></p>\n<h4 id=\"20-如果数字证书是可靠的，客户端就可以使用证书中的服务器公钥，对信息进行加密，然后与服务器交换加密信息。\"><a href=\"#20-如果数字证书是可靠的，客户端就可以使用证书中的服务器公钥，对信息进行加密，然后与服务器交换加密信息。\" class=\"headerlink\" title=\"20.如果数字证书是可靠的，客户端就可以使用证书中的服务器公钥，对信息进行加密，然后与服务器交换加密信息。\"></a>20.如果数字证书是可靠的，客户端就可以使用证书中的服务器公钥，对信息进行加密，然后与服务器交换加密信息。</h4><p><img src=\"/img/note/secretkey20.png\" alt=\"\"></p>\n<h3 id=\"想更好地理解上面这篇形象生动的技术文章，你还需要理解一些概念和术语\"><a href=\"#想更好地理解上面这篇形象生动的技术文章，你还需要理解一些概念和术语\" class=\"headerlink\" title=\"想更好地理解上面这篇形象生动的技术文章，你还需要理解一些概念和术语\"></a>想更好地理解上面这篇形象生动的技术文章，你还需要理解一些概念和术语</h3><h4 id=\"公钥密码体制-public-key-cryptography\"><a href=\"#公钥密码体制-public-key-cryptography\" class=\"headerlink\" title=\"公钥密码体制(public-key cryptography)\"></a>公钥密码体制(public-key cryptography)</h4><h5 id=\"公钥密码体制分为三个部分，公钥、私钥、加密解密算法，它的加密解密过程如下：\"><a href=\"#公钥密码体制分为三个部分，公钥、私钥、加密解密算法，它的加密解密过程如下：\" class=\"headerlink\" title=\"公钥密码体制分为三个部分，公钥、私钥、加密解密算法，它的加密解密过程如下：\"></a>公钥密码体制分为三个部分，公钥、私钥、加密解密算法，它的加密解密过程如下：</h5><ul>\n<li>加密：通过加密算法和公钥对内容(或者说明文)进行加密，得到密文。加密过程需要用到公钥。</li>\n<li>解密：通过解密算法和私钥对密文进行解密，得到明文。解密过程需要用到解密算法和私钥。注意，由公钥加密的内容，只能由私钥进行解密，也就是说，由公钥加密的内容，如果不知道私钥，是无法解密的。<h5 id=\"公钥密码体制的公钥和算法都是公开的-这是为什么叫公钥密码体制的原因-，私钥是保密的。大家都以使用公钥进行加密，但是只有私钥的持有者才能解密。在实际的使用中，有需要的人会生成一对公钥和私钥，把公钥发布出去给别人使用，自己保留私钥。\"><a href=\"#公钥密码体制的公钥和算法都是公开的-这是为什么叫公钥密码体制的原因-，私钥是保密的。大家都以使用公钥进行加密，但是只有私钥的持有者才能解密。在实际的使用中，有需要的人会生成一对公钥和私钥，把公钥发布出去给别人使用，自己保留私钥。\" class=\"headerlink\" title=\"公钥密码体制的公钥和算法都是公开的(这是为什么叫公钥密码体制的原因)，私钥是保密的。大家都以使用公钥进行加密，但是只有私钥的持有者才能解密。在实际的使用中，有需要的人会生成一对公钥和私钥，把公钥发布出去给别人使用，自己保留私钥。\"></a>公钥密码体制的公钥和算法都是公开的(这是为什么叫公钥密码体制的原因)，私钥是保密的。大家都以使用公钥进行加密，但是只有私钥的持有者才能解密。在实际的使用中，有需要的人会生成一对公钥和私钥，把公钥发布出去给别人使用，自己保留私钥。</h5></li>\n</ul>\n<h4 id=\"对称加密算法-symmetric-key-algorithms\"><a href=\"#对称加密算法-symmetric-key-algorithms\" class=\"headerlink\" title=\"对称加密算法(symmetric key algorithms)\"></a>对称加密算法(symmetric key algorithms)</h4><h5 id=\"在对称加密算法中，加密使用的密钥和解密使用的密钥是相同的。也就是说，加密和解密都是使用的同一个密钥。因此对称加密算法要保证安全性的话，密钥要做好保密，只能让使用的人知道，不能对外公开。这个和上面的公钥密码体制有所不同，公钥密码体制中加密是用公钥，解密使用私钥，而对称加密算法中，加密和解密都是使用同一个密钥，不区分公钥和私钥。\"><a href=\"#在对称加密算法中，加密使用的密钥和解密使用的密钥是相同的。也就是说，加密和解密都是使用的同一个密钥。因此对称加密算法要保证安全性的话，密钥要做好保密，只能让使用的人知道，不能对外公开。这个和上面的公钥密码体制有所不同，公钥密码体制中加密是用公钥，解密使用私钥，而对称加密算法中，加密和解密都是使用同一个密钥，不区分公钥和私钥。\" class=\"headerlink\" title=\"在对称加密算法中，加密使用的密钥和解密使用的密钥是相同的。也就是说，加密和解密都是使用的同一个密钥。因此对称加密算法要保证安全性的话，密钥要做好保密，只能让使用的人知道，不能对外公开。这个和上面的公钥密码体制有所不同，公钥密码体制中加密是用公钥，解密使用私钥，而对称加密算法中，加密和解密都是使用同一个密钥，不区分公钥和私钥。\"></a>在对称加密算法中，加密使用的密钥和解密使用的密钥是相同的。也就是说，加密和解密都是使用的同一个密钥。因此对称加密算法要保证安全性的话，密钥要做好保密，只能让使用的人知道，不能对外公开。这个和上面的公钥密码体制有所不同，公钥密码体制中加密是用公钥，解密使用私钥，而对称加密算法中，加密和解密都是使用同一个密钥，不区分公钥和私钥。</h5><h5 id=\"密钥，一般就是一个字符串或数字，在加密或者解密时传递给加密-解密算法。前面在公钥密码体制中说到的公钥、私钥就是密钥，公钥是加密使用的密钥，私钥是解密使用的密钥\"><a href=\"#密钥，一般就是一个字符串或数字，在加密或者解密时传递给加密-解密算法。前面在公钥密码体制中说到的公钥、私钥就是密钥，公钥是加密使用的密钥，私钥是解密使用的密钥\" class=\"headerlink\" title=\"密钥，一般就是一个字符串或数字，在加密或者解密时传递给加密/解密算法。前面在公钥密码体制中说到的公钥、私钥就是密钥，公钥是加密使用的密钥，私钥是解密使用的密钥\"></a>密钥，一般就是一个字符串或数字，在加密或者解密时传递给加密/解密算法。前面在公钥密码体制中说到的公钥、私钥就是密钥，公钥是加密使用的密钥，私钥是解密使用的密钥</h5><p><a href=\"http://www.youdzone.com/signature.html\" target=\"_blank\" rel=\"external\">原文连接</a></p>"},{"layout":"post","title":"sso接入流程和遇到的一些问题","date":"2018-03-25T16:00:00.000Z","original":true,"tag":[["java","java"]],"_content":"\n##### 前段时间为新系统接入公司的sso单点登录功能，流程不是很复杂。再加上已经有系统接入成功，依葫芦画瓢起来则更快。但是在这个过程中遇到了一些小问题，所以决定将其记录下来，顺便总结一下sso的实现原理。\n\n<!--more-->\n\n## sso登录流程\n![sso](/img/note/sso.png) <div class='img-note'>sso流程图</div>\n\n##### 当然sso的流程不一定非要这样，但是万变不离其宗，我们就以该流程来总结一下sso的原理和实现\n1. 用户通过浏览器请求子系统\n2. 子系统查看ticket\n3. 如果子系统没有拿到ticket\n    1. 携带参数重定向到sso服务器\n    2. 服务器进行自己的验证（通常为cookie）\n    3. 验证通过：\n        1. sso重新生成code，并且携带code请求子系统\n        2. 子系统拿到code后再请求sso进行code验证，sso验证code的正确性\n        3. 如果正确则生成ticket并返回，这时候子系统需要保存新的ticket\n        4. 如果code验证失败，则需要用户重新登录\n    4. 验证失败：\n        1. 用户重新登录\n4. 如果子系统存在ticket\n    1. 通过特定接口验证该ticket的合法性\n    2. 验证通过则正常处理\n    3. 验证失败用户重新登录\n4. 用户通过sso公用页面登录的时候，sso生成服务器ticket（也就是记录该用户已经成功登录了sso）并保存在自己的cookie中。\n5. 生成code，请求子系统，子系统验证code并拿到客户端ticket。保存后登录成功。\n\n#### 可看到登录的过程主要有两个核心点\n1. 子系统保存ticket，并且通过ticket来验证用户是否正常登录（通过sso给定接口验证）\n2. sso系统的登录也有自己的cookie，如果该cookie正常，则用户也是自动登录的。\n\n##### 分析以上的登录流程，子系统主要实现两个接口：\n1. 登录接口，主要是重定向到sso登录页面，当然这步重定向操作也可以通过js完成，但是需要后端确认ticket的合法性再做操作，至于是后端直接重定向还是通过返回参数让前端重定向则不是很重要。所以通常该步操作需要和拦截器一起配合使用。拦截器主要的通过sso提供的接口去验证ticket的合法性。\n2. sso系统回调子系统接口，该接口主要是接受sso系统登录后的code参数，code不是最终的ticket，只是一个中间参数。子系统需要通过code再去请求sso以拿到合法的ticket以及一些登录用户的基础信息。通常这个时候会把ticket存储在子系统的cookie中。\n```java\n@RequestMapping(value = \"/callback\", method = RequestMethod.GET)\n    public ModelAndView callback(String code, HttpServletRequest request, HttpServletResponse response){\n\n        //1.通过code调用sso/check_code接口获得ticket\n        MultiValueMap<String, String> requestBody = new LinkedMultiValueMap<String, String>();\n        requestBody.add(\"code\", code);\n        requestBody.add(\"app_id\", AuthConstant.APP_ID);\n        requestBody.add(\"app_key\", AuthConstant.APP_KEY);\n\n        String result = restTemplate.postForObject(AuthConstant.SSO_URI +\"sso/api/check_code\",requestBody, String.class);\n        logger.info(\"get result from check_code: result :{}, params:{}\", result, requestBody.toString());\n        JSONObject resultObj = JSONObject.parseObject(result);\n        if(StringUtils.equals(resultObj.getString(\"errno\"),\"0\")){\n\n            String ticket =  resultObj.getJSONObject(\"data\").getString(\"ticket\");\n            String username =  resultObj.getJSONObject(\"data\").getString(\"username\");\n            //存储获得的username和ticke,这里把用户名和ticke放到session中\n            Cookie usernameCookie = new Cookie(\"username\",username);\n            usernameCookie.setPath(\"/\");\n            Cookie ticketCookie = new Cookie(\"ticket\",ticket);\n            ticketCookie.setPath(\"/\");\n            response.addCookie(usernameCookie);\n            response.addCookie(ticketCookie);\n            return new ModelAndView(\"redirect:\" + localUri);\n        }else{\n            //打印错误信息,提示等操作\n            logger.warn(resultObj.getString(\"errmsg\"));\n            return new ModelAndView(\"redirect:\"+ localUri +\"auth/login\");\n        }\n    }\n```\n\n##### 这里有一个小疑问，为什么不直接通过回调返回ticket呢，而是返回code再去拿ticket。基于这点我问了sso的开发。他们给我的答复是：\n1. 兼容以前老的auth的原因\n2. ticket不从调转直接返回，防止被窃取，现在是在你们后端调check_code(可以理解为 拿code换ticket)。code换ticket只能调一次，缓存时间是30秒\n\n##### 个人觉得第二点理由有点牵强，可能更多的是考虑到兼容性。\n\n##### 上面说了单个子系统的登录以及验证过程，那么sso是如何实现单点登录的呢。其实很简单，原理就在上面的核心中的第二点。sso也保存了自己的cookie。当用户去到一个新的系统，会发生以下的流程（假设该用户已经在其他系统登录过）：\n1. 请求当前新系统的页面\n2. 页面拦截器验证ticket。发现没有ticket或者ticket不合法\n3. 系统将请求转发到sso登录页面\n4. 浏览器转发请求并带上该域名cookie\n5. sso通过cookie发现该用户在sso当中已经登录过。则跳过用户登录过程，直接生产code返回给该子系统\n\n## sso登出流程\n\n##### 登出流程基本上和登录流程是相对应的。按照登录的两个核心点，登出的过程也应该是相应的：\n1. 清除子系统ticket\n2. 清除sso系统cookie\n\n##### 通常清除自己系统的ticket不是必须的，因为就算你不清除，验证sso也不会通过。只是浪费了一次请求操作。\n##### 清除sso系统cookie，这步操作则是通过sso给定的登出链接。一般要带上自己系统的app_id。\n\n## 实际操作中遇到的一些问题：\n##### 前面已经把sso的登录和登出原理说了个大概。但是在实际操作当中确实遇到了一些问题\n\n### 用户登录后一直请求不到子系统页面，前端一直转菊花\n##### 用户在sso登录页面成功了，然后浏览器一直白页面，菊花一直转。查看后端接口日志，发现全是http请求超时，仔细查看后发现是ticket验证接口超时。之后在服务器上ping该接口也是超时状态，但是在本地ping则是成功状态。\n##### 最后的原因很简单，是因为线上服务器没有开通外网权限，而登录页面是重定向到浏览器后浏览器再去请求的，所以之前的流程一直是正常状态。但是验证ticket的流程是在服务端直接请求验证的，而外网域名在内网服务器上没有办法解析。\n##### 解决办法有很多，比如开通外网，或者选用内网router，或者不一定要使用http服务。我们的解决方案就是选用的第二种（内网router），其实内网和外网对我们验证ticket没有区别，最终打到他们的服务可能都是相同的。\n\n### 登出问题\n##### 这个问题也是在本地不存在，但是在线上的表现就是登出后浏览器跳转到登录页面，登录页面则直接再跳转回当前系统主页面。\n##### 通过问题描述加上前面的分析，你可能会发现问题所在，那就是sso登录页面的cookie没有被清除。至于为什么没有被清除呢，这是上一个问题留下的坑。因为是统一接口，所以登出的流程也是选择使用内网router，但是sso登出接口的重要操作就是清除cookie，cookie一般又是和域名挂钩的。sso登出接口处理cookie后，会直接重定向到登录页面。核心的问题就在于登出接口的域名和登录页面的域名不一致，导致登出过程cookie没有被清除。\n##### 解决办法也很简单，登出接口单独维护。之后则一切正常。","source":"_posts/note/sso.md","raw":"---\nlayout: post\ntitle: sso接入流程和遇到的一些问题\ndate: 2018/03/26\noriginal: true\ntags: [tech, index]\ntag: [[java, java]]\n---\n\n##### 前段时间为新系统接入公司的sso单点登录功能，流程不是很复杂。再加上已经有系统接入成功，依葫芦画瓢起来则更快。但是在这个过程中遇到了一些小问题，所以决定将其记录下来，顺便总结一下sso的实现原理。\n\n<!--more-->\n\n## sso登录流程\n![sso](/img/note/sso.png) <div class='img-note'>sso流程图</div>\n\n##### 当然sso的流程不一定非要这样，但是万变不离其宗，我们就以该流程来总结一下sso的原理和实现\n1. 用户通过浏览器请求子系统\n2. 子系统查看ticket\n3. 如果子系统没有拿到ticket\n    1. 携带参数重定向到sso服务器\n    2. 服务器进行自己的验证（通常为cookie）\n    3. 验证通过：\n        1. sso重新生成code，并且携带code请求子系统\n        2. 子系统拿到code后再请求sso进行code验证，sso验证code的正确性\n        3. 如果正确则生成ticket并返回，这时候子系统需要保存新的ticket\n        4. 如果code验证失败，则需要用户重新登录\n    4. 验证失败：\n        1. 用户重新登录\n4. 如果子系统存在ticket\n    1. 通过特定接口验证该ticket的合法性\n    2. 验证通过则正常处理\n    3. 验证失败用户重新登录\n4. 用户通过sso公用页面登录的时候，sso生成服务器ticket（也就是记录该用户已经成功登录了sso）并保存在自己的cookie中。\n5. 生成code，请求子系统，子系统验证code并拿到客户端ticket。保存后登录成功。\n\n#### 可看到登录的过程主要有两个核心点\n1. 子系统保存ticket，并且通过ticket来验证用户是否正常登录（通过sso给定接口验证）\n2. sso系统的登录也有自己的cookie，如果该cookie正常，则用户也是自动登录的。\n\n##### 分析以上的登录流程，子系统主要实现两个接口：\n1. 登录接口，主要是重定向到sso登录页面，当然这步重定向操作也可以通过js完成，但是需要后端确认ticket的合法性再做操作，至于是后端直接重定向还是通过返回参数让前端重定向则不是很重要。所以通常该步操作需要和拦截器一起配合使用。拦截器主要的通过sso提供的接口去验证ticket的合法性。\n2. sso系统回调子系统接口，该接口主要是接受sso系统登录后的code参数，code不是最终的ticket，只是一个中间参数。子系统需要通过code再去请求sso以拿到合法的ticket以及一些登录用户的基础信息。通常这个时候会把ticket存储在子系统的cookie中。\n```java\n@RequestMapping(value = \"/callback\", method = RequestMethod.GET)\n    public ModelAndView callback(String code, HttpServletRequest request, HttpServletResponse response){\n\n        //1.通过code调用sso/check_code接口获得ticket\n        MultiValueMap<String, String> requestBody = new LinkedMultiValueMap<String, String>();\n        requestBody.add(\"code\", code);\n        requestBody.add(\"app_id\", AuthConstant.APP_ID);\n        requestBody.add(\"app_key\", AuthConstant.APP_KEY);\n\n        String result = restTemplate.postForObject(AuthConstant.SSO_URI +\"sso/api/check_code\",requestBody, String.class);\n        logger.info(\"get result from check_code: result :{}, params:{}\", result, requestBody.toString());\n        JSONObject resultObj = JSONObject.parseObject(result);\n        if(StringUtils.equals(resultObj.getString(\"errno\"),\"0\")){\n\n            String ticket =  resultObj.getJSONObject(\"data\").getString(\"ticket\");\n            String username =  resultObj.getJSONObject(\"data\").getString(\"username\");\n            //存储获得的username和ticke,这里把用户名和ticke放到session中\n            Cookie usernameCookie = new Cookie(\"username\",username);\n            usernameCookie.setPath(\"/\");\n            Cookie ticketCookie = new Cookie(\"ticket\",ticket);\n            ticketCookie.setPath(\"/\");\n            response.addCookie(usernameCookie);\n            response.addCookie(ticketCookie);\n            return new ModelAndView(\"redirect:\" + localUri);\n        }else{\n            //打印错误信息,提示等操作\n            logger.warn(resultObj.getString(\"errmsg\"));\n            return new ModelAndView(\"redirect:\"+ localUri +\"auth/login\");\n        }\n    }\n```\n\n##### 这里有一个小疑问，为什么不直接通过回调返回ticket呢，而是返回code再去拿ticket。基于这点我问了sso的开发。他们给我的答复是：\n1. 兼容以前老的auth的原因\n2. ticket不从调转直接返回，防止被窃取，现在是在你们后端调check_code(可以理解为 拿code换ticket)。code换ticket只能调一次，缓存时间是30秒\n\n##### 个人觉得第二点理由有点牵强，可能更多的是考虑到兼容性。\n\n##### 上面说了单个子系统的登录以及验证过程，那么sso是如何实现单点登录的呢。其实很简单，原理就在上面的核心中的第二点。sso也保存了自己的cookie。当用户去到一个新的系统，会发生以下的流程（假设该用户已经在其他系统登录过）：\n1. 请求当前新系统的页面\n2. 页面拦截器验证ticket。发现没有ticket或者ticket不合法\n3. 系统将请求转发到sso登录页面\n4. 浏览器转发请求并带上该域名cookie\n5. sso通过cookie发现该用户在sso当中已经登录过。则跳过用户登录过程，直接生产code返回给该子系统\n\n## sso登出流程\n\n##### 登出流程基本上和登录流程是相对应的。按照登录的两个核心点，登出的过程也应该是相应的：\n1. 清除子系统ticket\n2. 清除sso系统cookie\n\n##### 通常清除自己系统的ticket不是必须的，因为就算你不清除，验证sso也不会通过。只是浪费了一次请求操作。\n##### 清除sso系统cookie，这步操作则是通过sso给定的登出链接。一般要带上自己系统的app_id。\n\n## 实际操作中遇到的一些问题：\n##### 前面已经把sso的登录和登出原理说了个大概。但是在实际操作当中确实遇到了一些问题\n\n### 用户登录后一直请求不到子系统页面，前端一直转菊花\n##### 用户在sso登录页面成功了，然后浏览器一直白页面，菊花一直转。查看后端接口日志，发现全是http请求超时，仔细查看后发现是ticket验证接口超时。之后在服务器上ping该接口也是超时状态，但是在本地ping则是成功状态。\n##### 最后的原因很简单，是因为线上服务器没有开通外网权限，而登录页面是重定向到浏览器后浏览器再去请求的，所以之前的流程一直是正常状态。但是验证ticket的流程是在服务端直接请求验证的，而外网域名在内网服务器上没有办法解析。\n##### 解决办法有很多，比如开通外网，或者选用内网router，或者不一定要使用http服务。我们的解决方案就是选用的第二种（内网router），其实内网和外网对我们验证ticket没有区别，最终打到他们的服务可能都是相同的。\n\n### 登出问题\n##### 这个问题也是在本地不存在，但是在线上的表现就是登出后浏览器跳转到登录页面，登录页面则直接再跳转回当前系统主页面。\n##### 通过问题描述加上前面的分析，你可能会发现问题所在，那就是sso登录页面的cookie没有被清除。至于为什么没有被清除呢，这是上一个问题留下的坑。因为是统一接口，所以登出的流程也是选择使用内网router，但是sso登出接口的重要操作就是清除cookie，cookie一般又是和域名挂钩的。sso登出接口处理cookie后，会直接重定向到登录页面。核心的问题就在于登出接口的域名和登录页面的域名不一致，导致登出过程cookie没有被清除。\n##### 解决办法也很简单，登出接口单独维护。之后则一切正常。","slug":"note/sso","published":1,"updated":"2018-05-08T13:00:14.284Z","comments":1,"photos":[],"link":"","_id":"cjgxop3l6000bjah1p4dpqrko","content":"<h5 id=\"前段时间为新系统接入公司的sso单点登录功能，流程不是很复杂。再加上已经有系统接入成功，依葫芦画瓢起来则更快。但是在这个过程中遇到了一些小问题，所以决定将其记录下来，顺便总结一下sso的实现原理。\"><a href=\"#前段时间为新系统接入公司的sso单点登录功能，流程不是很复杂。再加上已经有系统接入成功，依葫芦画瓢起来则更快。但是在这个过程中遇到了一些小问题，所以决定将其记录下来，顺便总结一下sso的实现原理。\" class=\"headerlink\" title=\"前段时间为新系统接入公司的sso单点登录功能，流程不是很复杂。再加上已经有系统接入成功，依葫芦画瓢起来则更快。但是在这个过程中遇到了一些小问题，所以决定将其记录下来，顺便总结一下sso的实现原理。\"></a>前段时间为新系统接入公司的sso单点登录功能，流程不是很复杂。再加上已经有系统接入成功，依葫芦画瓢起来则更快。但是在这个过程中遇到了一些小问题，所以决定将其记录下来，顺便总结一下sso的实现原理。</h5><a id=\"more\"></a>\n<h2 id=\"sso登录流程\"><a href=\"#sso登录流程\" class=\"headerlink\" title=\"sso登录流程\"></a>sso登录流程</h2><p><img src=\"/img/note/sso.png\" alt=\"sso\"> <div class=\"img-note\">sso流程图</div></p>\n<h5 id=\"当然sso的流程不一定非要这样，但是万变不离其宗，我们就以该流程来总结一下sso的原理和实现\"><a href=\"#当然sso的流程不一定非要这样，但是万变不离其宗，我们就以该流程来总结一下sso的原理和实现\" class=\"headerlink\" title=\"当然sso的流程不一定非要这样，但是万变不离其宗，我们就以该流程来总结一下sso的原理和实现\"></a>当然sso的流程不一定非要这样，但是万变不离其宗，我们就以该流程来总结一下sso的原理和实现</h5><ol>\n<li>用户通过浏览器请求子系统</li>\n<li>子系统查看ticket</li>\n<li>如果子系统没有拿到ticket<ol>\n<li>携带参数重定向到sso服务器</li>\n<li>服务器进行自己的验证（通常为cookie）</li>\n<li>验证通过：<ol>\n<li>sso重新生成code，并且携带code请求子系统</li>\n<li>子系统拿到code后再请求sso进行code验证，sso验证code的正确性</li>\n<li>如果正确则生成ticket并返回，这时候子系统需要保存新的ticket</li>\n<li>如果code验证失败，则需要用户重新登录</li>\n</ol>\n</li>\n<li>验证失败：<ol>\n<li>用户重新登录</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>如果子系统存在ticket<ol>\n<li>通过特定接口验证该ticket的合法性</li>\n<li>验证通过则正常处理</li>\n<li>验证失败用户重新登录</li>\n</ol>\n</li>\n<li>用户通过sso公用页面登录的时候，sso生成服务器ticket（也就是记录该用户已经成功登录了sso）并保存在自己的cookie中。</li>\n<li>生成code，请求子系统，子系统验证code并拿到客户端ticket。保存后登录成功。</li>\n</ol>\n<h4 id=\"可看到登录的过程主要有两个核心点\"><a href=\"#可看到登录的过程主要有两个核心点\" class=\"headerlink\" title=\"可看到登录的过程主要有两个核心点\"></a>可看到登录的过程主要有两个核心点</h4><ol>\n<li>子系统保存ticket，并且通过ticket来验证用户是否正常登录（通过sso给定接口验证）</li>\n<li>sso系统的登录也有自己的cookie，如果该cookie正常，则用户也是自动登录的。</li>\n</ol>\n<h5 id=\"分析以上的登录流程，子系统主要实现两个接口：\"><a href=\"#分析以上的登录流程，子系统主要实现两个接口：\" class=\"headerlink\" title=\"分析以上的登录流程，子系统主要实现两个接口：\"></a>分析以上的登录流程，子系统主要实现两个接口：</h5><ol>\n<li>登录接口，主要是重定向到sso登录页面，当然这步重定向操作也可以通过js完成，但是需要后端确认ticket的合法性再做操作，至于是后端直接重定向还是通过返回参数让前端重定向则不是很重要。所以通常该步操作需要和拦截器一起配合使用。拦截器主要的通过sso提供的接口去验证ticket的合法性。</li>\n<li><p>sso系统回调子系统接口，该接口主要是接受sso系统登录后的code参数，code不是最终的ticket，只是一个中间参数。子系统需要通过code再去请求sso以拿到合法的ticket以及一些登录用户的基础信息。通常这个时候会把ticket存储在子系统的cookie中。</p>\n<pre><code class=\"lang-java\">@RequestMapping(value = &quot;/callback&quot;, method = RequestMethod.GET)\n public ModelAndView callback(String code, HttpServletRequest request, HttpServletResponse response){\n\n     //1.通过code调用sso/check_code接口获得ticket\n     MultiValueMap&lt;String, String&gt; requestBody = new LinkedMultiValueMap&lt;String, String&gt;();\n     requestBody.add(&quot;code&quot;, code);\n     requestBody.add(&quot;app_id&quot;, AuthConstant.APP_ID);\n     requestBody.add(&quot;app_key&quot;, AuthConstant.APP_KEY);\n\n     String result = restTemplate.postForObject(AuthConstant.SSO_URI +&quot;sso/api/check_code&quot;,requestBody, String.class);\n     logger.info(&quot;get result from check_code: result :{}, params:{}&quot;, result, requestBody.toString());\n     JSONObject resultObj = JSONObject.parseObject(result);\n     if(StringUtils.equals(resultObj.getString(&quot;errno&quot;),&quot;0&quot;)){\n\n         String ticket =  resultObj.getJSONObject(&quot;data&quot;).getString(&quot;ticket&quot;);\n         String username =  resultObj.getJSONObject(&quot;data&quot;).getString(&quot;username&quot;);\n         //存储获得的username和ticke,这里把用户名和ticke放到session中\n         Cookie usernameCookie = new Cookie(&quot;username&quot;,username);\n         usernameCookie.setPath(&quot;/&quot;);\n         Cookie ticketCookie = new Cookie(&quot;ticket&quot;,ticket);\n         ticketCookie.setPath(&quot;/&quot;);\n         response.addCookie(usernameCookie);\n         response.addCookie(ticketCookie);\n         return new ModelAndView(&quot;redirect:&quot; + localUri);\n     }else{\n         //打印错误信息,提示等操作\n         logger.warn(resultObj.getString(&quot;errmsg&quot;));\n         return new ModelAndView(&quot;redirect:&quot;+ localUri +&quot;auth/login&quot;);\n     }\n }\n</code></pre>\n</li>\n</ol>\n<h5 id=\"这里有一个小疑问，为什么不直接通过回调返回ticket呢，而是返回code再去拿ticket。基于这点我问了sso的开发。他们给我的答复是：\"><a href=\"#这里有一个小疑问，为什么不直接通过回调返回ticket呢，而是返回code再去拿ticket。基于这点我问了sso的开发。他们给我的答复是：\" class=\"headerlink\" title=\"这里有一个小疑问，为什么不直接通过回调返回ticket呢，而是返回code再去拿ticket。基于这点我问了sso的开发。他们给我的答复是：\"></a>这里有一个小疑问，为什么不直接通过回调返回ticket呢，而是返回code再去拿ticket。基于这点我问了sso的开发。他们给我的答复是：</h5><ol>\n<li>兼容以前老的auth的原因</li>\n<li>ticket不从调转直接返回，防止被窃取，现在是在你们后端调check_code(可以理解为 拿code换ticket)。code换ticket只能调一次，缓存时间是30秒</li>\n</ol>\n<h5 id=\"个人觉得第二点理由有点牵强，可能更多的是考虑到兼容性。\"><a href=\"#个人觉得第二点理由有点牵强，可能更多的是考虑到兼容性。\" class=\"headerlink\" title=\"个人觉得第二点理由有点牵强，可能更多的是考虑到兼容性。\"></a>个人觉得第二点理由有点牵强，可能更多的是考虑到兼容性。</h5><h5 id=\"上面说了单个子系统的登录以及验证过程，那么sso是如何实现单点登录的呢。其实很简单，原理就在上面的核心中的第二点。sso也保存了自己的cookie。当用户去到一个新的系统，会发生以下的流程（假设该用户已经在其他系统登录过）：\"><a href=\"#上面说了单个子系统的登录以及验证过程，那么sso是如何实现单点登录的呢。其实很简单，原理就在上面的核心中的第二点。sso也保存了自己的cookie。当用户去到一个新的系统，会发生以下的流程（假设该用户已经在其他系统登录过）：\" class=\"headerlink\" title=\"上面说了单个子系统的登录以及验证过程，那么sso是如何实现单点登录的呢。其实很简单，原理就在上面的核心中的第二点。sso也保存了自己的cookie。当用户去到一个新的系统，会发生以下的流程（假设该用户已经在其他系统登录过）：\"></a>上面说了单个子系统的登录以及验证过程，那么sso是如何实现单点登录的呢。其实很简单，原理就在上面的核心中的第二点。sso也保存了自己的cookie。当用户去到一个新的系统，会发生以下的流程（假设该用户已经在其他系统登录过）：</h5><ol>\n<li>请求当前新系统的页面</li>\n<li>页面拦截器验证ticket。发现没有ticket或者ticket不合法</li>\n<li>系统将请求转发到sso登录页面</li>\n<li>浏览器转发请求并带上该域名cookie</li>\n<li>sso通过cookie发现该用户在sso当中已经登录过。则跳过用户登录过程，直接生产code返回给该子系统</li>\n</ol>\n<h2 id=\"sso登出流程\"><a href=\"#sso登出流程\" class=\"headerlink\" title=\"sso登出流程\"></a>sso登出流程</h2><h5 id=\"登出流程基本上和登录流程是相对应的。按照登录的两个核心点，登出的过程也应该是相应的：\"><a href=\"#登出流程基本上和登录流程是相对应的。按照登录的两个核心点，登出的过程也应该是相应的：\" class=\"headerlink\" title=\"登出流程基本上和登录流程是相对应的。按照登录的两个核心点，登出的过程也应该是相应的：\"></a>登出流程基本上和登录流程是相对应的。按照登录的两个核心点，登出的过程也应该是相应的：</h5><ol>\n<li>清除子系统ticket</li>\n<li>清除sso系统cookie</li>\n</ol>\n<h5 id=\"通常清除自己系统的ticket不是必须的，因为就算你不清除，验证sso也不会通过。只是浪费了一次请求操作。\"><a href=\"#通常清除自己系统的ticket不是必须的，因为就算你不清除，验证sso也不会通过。只是浪费了一次请求操作。\" class=\"headerlink\" title=\"通常清除自己系统的ticket不是必须的，因为就算你不清除，验证sso也不会通过。只是浪费了一次请求操作。\"></a>通常清除自己系统的ticket不是必须的，因为就算你不清除，验证sso也不会通过。只是浪费了一次请求操作。</h5><h5 id=\"清除sso系统cookie，这步操作则是通过sso给定的登出链接。一般要带上自己系统的app-id。\"><a href=\"#清除sso系统cookie，这步操作则是通过sso给定的登出链接。一般要带上自己系统的app-id。\" class=\"headerlink\" title=\"清除sso系统cookie，这步操作则是通过sso给定的登出链接。一般要带上自己系统的app_id。\"></a>清除sso系统cookie，这步操作则是通过sso给定的登出链接。一般要带上自己系统的app_id。</h5><h2 id=\"实际操作中遇到的一些问题：\"><a href=\"#实际操作中遇到的一些问题：\" class=\"headerlink\" title=\"实际操作中遇到的一些问题：\"></a>实际操作中遇到的一些问题：</h2><h5 id=\"前面已经把sso的登录和登出原理说了个大概。但是在实际操作当中确实遇到了一些问题\"><a href=\"#前面已经把sso的登录和登出原理说了个大概。但是在实际操作当中确实遇到了一些问题\" class=\"headerlink\" title=\"前面已经把sso的登录和登出原理说了个大概。但是在实际操作当中确实遇到了一些问题\"></a>前面已经把sso的登录和登出原理说了个大概。但是在实际操作当中确实遇到了一些问题</h5><h3 id=\"用户登录后一直请求不到子系统页面，前端一直转菊花\"><a href=\"#用户登录后一直请求不到子系统页面，前端一直转菊花\" class=\"headerlink\" title=\"用户登录后一直请求不到子系统页面，前端一直转菊花\"></a>用户登录后一直请求不到子系统页面，前端一直转菊花</h3><h5 id=\"用户在sso登录页面成功了，然后浏览器一直白页面，菊花一直转。查看后端接口日志，发现全是http请求超时，仔细查看后发现是ticket验证接口超时。之后在服务器上ping该接口也是超时状态，但是在本地ping则是成功状态。\"><a href=\"#用户在sso登录页面成功了，然后浏览器一直白页面，菊花一直转。查看后端接口日志，发现全是http请求超时，仔细查看后发现是ticket验证接口超时。之后在服务器上ping该接口也是超时状态，但是在本地ping则是成功状态。\" class=\"headerlink\" title=\"用户在sso登录页面成功了，然后浏览器一直白页面，菊花一直转。查看后端接口日志，发现全是http请求超时，仔细查看后发现是ticket验证接口超时。之后在服务器上ping该接口也是超时状态，但是在本地ping则是成功状态。\"></a>用户在sso登录页面成功了，然后浏览器一直白页面，菊花一直转。查看后端接口日志，发现全是http请求超时，仔细查看后发现是ticket验证接口超时。之后在服务器上ping该接口也是超时状态，但是在本地ping则是成功状态。</h5><h5 id=\"最后的原因很简单，是因为线上服务器没有开通外网权限，而登录页面是重定向到浏览器后浏览器再去请求的，所以之前的流程一直是正常状态。但是验证ticket的流程是在服务端直接请求验证的，而外网域名在内网服务器上没有办法解析。\"><a href=\"#最后的原因很简单，是因为线上服务器没有开通外网权限，而登录页面是重定向到浏览器后浏览器再去请求的，所以之前的流程一直是正常状态。但是验证ticket的流程是在服务端直接请求验证的，而外网域名在内网服务器上没有办法解析。\" class=\"headerlink\" title=\"最后的原因很简单，是因为线上服务器没有开通外网权限，而登录页面是重定向到浏览器后浏览器再去请求的，所以之前的流程一直是正常状态。但是验证ticket的流程是在服务端直接请求验证的，而外网域名在内网服务器上没有办法解析。\"></a>最后的原因很简单，是因为线上服务器没有开通外网权限，而登录页面是重定向到浏览器后浏览器再去请求的，所以之前的流程一直是正常状态。但是验证ticket的流程是在服务端直接请求验证的，而外网域名在内网服务器上没有办法解析。</h5><h5 id=\"解决办法有很多，比如开通外网，或者选用内网router，或者不一定要使用http服务。我们的解决方案就是选用的第二种（内网router），其实内网和外网对我们验证ticket没有区别，最终打到他们的服务可能都是相同的。\"><a href=\"#解决办法有很多，比如开通外网，或者选用内网router，或者不一定要使用http服务。我们的解决方案就是选用的第二种（内网router），其实内网和外网对我们验证ticket没有区别，最终打到他们的服务可能都是相同的。\" class=\"headerlink\" title=\"解决办法有很多，比如开通外网，或者选用内网router，或者不一定要使用http服务。我们的解决方案就是选用的第二种（内网router），其实内网和外网对我们验证ticket没有区别，最终打到他们的服务可能都是相同的。\"></a>解决办法有很多，比如开通外网，或者选用内网router，或者不一定要使用http服务。我们的解决方案就是选用的第二种（内网router），其实内网和外网对我们验证ticket没有区别，最终打到他们的服务可能都是相同的。</h5><h3 id=\"登出问题\"><a href=\"#登出问题\" class=\"headerlink\" title=\"登出问题\"></a>登出问题</h3><h5 id=\"这个问题也是在本地不存在，但是在线上的表现就是登出后浏览器跳转到登录页面，登录页面则直接再跳转回当前系统主页面。\"><a href=\"#这个问题也是在本地不存在，但是在线上的表现就是登出后浏览器跳转到登录页面，登录页面则直接再跳转回当前系统主页面。\" class=\"headerlink\" title=\"这个问题也是在本地不存在，但是在线上的表现就是登出后浏览器跳转到登录页面，登录页面则直接再跳转回当前系统主页面。\"></a>这个问题也是在本地不存在，但是在线上的表现就是登出后浏览器跳转到登录页面，登录页面则直接再跳转回当前系统主页面。</h5><h5 id=\"通过问题描述加上前面的分析，你可能会发现问题所在，那就是sso登录页面的cookie没有被清除。至于为什么没有被清除呢，这是上一个问题留下的坑。因为是统一接口，所以登出的流程也是选择使用内网router，但是sso登出接口的重要操作就是清除cookie，cookie一般又是和域名挂钩的。sso登出接口处理cookie后，会直接重定向到登录页面。核心的问题就在于登出接口的域名和登录页面的域名不一致，导致登出过程cookie没有被清除。\"><a href=\"#通过问题描述加上前面的分析，你可能会发现问题所在，那就是sso登录页面的cookie没有被清除。至于为什么没有被清除呢，这是上一个问题留下的坑。因为是统一接口，所以登出的流程也是选择使用内网router，但是sso登出接口的重要操作就是清除cookie，cookie一般又是和域名挂钩的。sso登出接口处理cookie后，会直接重定向到登录页面。核心的问题就在于登出接口的域名和登录页面的域名不一致，导致登出过程cookie没有被清除。\" class=\"headerlink\" title=\"通过问题描述加上前面的分析，你可能会发现问题所在，那就是sso登录页面的cookie没有被清除。至于为什么没有被清除呢，这是上一个问题留下的坑。因为是统一接口，所以登出的流程也是选择使用内网router，但是sso登出接口的重要操作就是清除cookie，cookie一般又是和域名挂钩的。sso登出接口处理cookie后，会直接重定向到登录页面。核心的问题就在于登出接口的域名和登录页面的域名不一致，导致登出过程cookie没有被清除。\"></a>通过问题描述加上前面的分析，你可能会发现问题所在，那就是sso登录页面的cookie没有被清除。至于为什么没有被清除呢，这是上一个问题留下的坑。因为是统一接口，所以登出的流程也是选择使用内网router，但是sso登出接口的重要操作就是清除cookie，cookie一般又是和域名挂钩的。sso登出接口处理cookie后，会直接重定向到登录页面。核心的问题就在于登出接口的域名和登录页面的域名不一致，导致登出过程cookie没有被清除。</h5><h5 id=\"解决办法也很简单，登出接口单独维护。之后则一切正常。\"><a href=\"#解决办法也很简单，登出接口单独维护。之后则一切正常。\" class=\"headerlink\" title=\"解决办法也很简单，登出接口单独维护。之后则一切正常。\"></a>解决办法也很简单，登出接口单独维护。之后则一切正常。</h5>","site":{"data":{}},"excerpt":"<h5 id=\"前段时间为新系统接入公司的sso单点登录功能，流程不是很复杂。再加上已经有系统接入成功，依葫芦画瓢起来则更快。但是在这个过程中遇到了一些小问题，所以决定将其记录下来，顺便总结一下sso的实现原理。\"><a href=\"#前段时间为新系统接入公司的sso单点登录功能，流程不是很复杂。再加上已经有系统接入成功，依葫芦画瓢起来则更快。但是在这个过程中遇到了一些小问题，所以决定将其记录下来，顺便总结一下sso的实现原理。\" class=\"headerlink\" title=\"前段时间为新系统接入公司的sso单点登录功能，流程不是很复杂。再加上已经有系统接入成功，依葫芦画瓢起来则更快。但是在这个过程中遇到了一些小问题，所以决定将其记录下来，顺便总结一下sso的实现原理。\"></a>前段时间为新系统接入公司的sso单点登录功能，流程不是很复杂。再加上已经有系统接入成功，依葫芦画瓢起来则更快。但是在这个过程中遇到了一些小问题，所以决定将其记录下来，顺便总结一下sso的实现原理。</h5>","more":"<h2 id=\"sso登录流程\"><a href=\"#sso登录流程\" class=\"headerlink\" title=\"sso登录流程\"></a>sso登录流程</h2><p><img src=\"/img/note/sso.png\" alt=\"sso\"> <div class=\"img-note\">sso流程图</div></p>\n<h5 id=\"当然sso的流程不一定非要这样，但是万变不离其宗，我们就以该流程来总结一下sso的原理和实现\"><a href=\"#当然sso的流程不一定非要这样，但是万变不离其宗，我们就以该流程来总结一下sso的原理和实现\" class=\"headerlink\" title=\"当然sso的流程不一定非要这样，但是万变不离其宗，我们就以该流程来总结一下sso的原理和实现\"></a>当然sso的流程不一定非要这样，但是万变不离其宗，我们就以该流程来总结一下sso的原理和实现</h5><ol>\n<li>用户通过浏览器请求子系统</li>\n<li>子系统查看ticket</li>\n<li>如果子系统没有拿到ticket<ol>\n<li>携带参数重定向到sso服务器</li>\n<li>服务器进行自己的验证（通常为cookie）</li>\n<li>验证通过：<ol>\n<li>sso重新生成code，并且携带code请求子系统</li>\n<li>子系统拿到code后再请求sso进行code验证，sso验证code的正确性</li>\n<li>如果正确则生成ticket并返回，这时候子系统需要保存新的ticket</li>\n<li>如果code验证失败，则需要用户重新登录</li>\n</ol>\n</li>\n<li>验证失败：<ol>\n<li>用户重新登录</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>如果子系统存在ticket<ol>\n<li>通过特定接口验证该ticket的合法性</li>\n<li>验证通过则正常处理</li>\n<li>验证失败用户重新登录</li>\n</ol>\n</li>\n<li>用户通过sso公用页面登录的时候，sso生成服务器ticket（也就是记录该用户已经成功登录了sso）并保存在自己的cookie中。</li>\n<li>生成code，请求子系统，子系统验证code并拿到客户端ticket。保存后登录成功。</li>\n</ol>\n<h4 id=\"可看到登录的过程主要有两个核心点\"><a href=\"#可看到登录的过程主要有两个核心点\" class=\"headerlink\" title=\"可看到登录的过程主要有两个核心点\"></a>可看到登录的过程主要有两个核心点</h4><ol>\n<li>子系统保存ticket，并且通过ticket来验证用户是否正常登录（通过sso给定接口验证）</li>\n<li>sso系统的登录也有自己的cookie，如果该cookie正常，则用户也是自动登录的。</li>\n</ol>\n<h5 id=\"分析以上的登录流程，子系统主要实现两个接口：\"><a href=\"#分析以上的登录流程，子系统主要实现两个接口：\" class=\"headerlink\" title=\"分析以上的登录流程，子系统主要实现两个接口：\"></a>分析以上的登录流程，子系统主要实现两个接口：</h5><ol>\n<li>登录接口，主要是重定向到sso登录页面，当然这步重定向操作也可以通过js完成，但是需要后端确认ticket的合法性再做操作，至于是后端直接重定向还是通过返回参数让前端重定向则不是很重要。所以通常该步操作需要和拦截器一起配合使用。拦截器主要的通过sso提供的接口去验证ticket的合法性。</li>\n<li><p>sso系统回调子系统接口，该接口主要是接受sso系统登录后的code参数，code不是最终的ticket，只是一个中间参数。子系统需要通过code再去请求sso以拿到合法的ticket以及一些登录用户的基础信息。通常这个时候会把ticket存储在子系统的cookie中。</p>\n<pre><code class=\"lang-java\">@RequestMapping(value = &quot;/callback&quot;, method = RequestMethod.GET)\n public ModelAndView callback(String code, HttpServletRequest request, HttpServletResponse response){\n\n     //1.通过code调用sso/check_code接口获得ticket\n     MultiValueMap&lt;String, String&gt; requestBody = new LinkedMultiValueMap&lt;String, String&gt;();\n     requestBody.add(&quot;code&quot;, code);\n     requestBody.add(&quot;app_id&quot;, AuthConstant.APP_ID);\n     requestBody.add(&quot;app_key&quot;, AuthConstant.APP_KEY);\n\n     String result = restTemplate.postForObject(AuthConstant.SSO_URI +&quot;sso/api/check_code&quot;,requestBody, String.class);\n     logger.info(&quot;get result from check_code: result :{}, params:{}&quot;, result, requestBody.toString());\n     JSONObject resultObj = JSONObject.parseObject(result);\n     if(StringUtils.equals(resultObj.getString(&quot;errno&quot;),&quot;0&quot;)){\n\n         String ticket =  resultObj.getJSONObject(&quot;data&quot;).getString(&quot;ticket&quot;);\n         String username =  resultObj.getJSONObject(&quot;data&quot;).getString(&quot;username&quot;);\n         //存储获得的username和ticke,这里把用户名和ticke放到session中\n         Cookie usernameCookie = new Cookie(&quot;username&quot;,username);\n         usernameCookie.setPath(&quot;/&quot;);\n         Cookie ticketCookie = new Cookie(&quot;ticket&quot;,ticket);\n         ticketCookie.setPath(&quot;/&quot;);\n         response.addCookie(usernameCookie);\n         response.addCookie(ticketCookie);\n         return new ModelAndView(&quot;redirect:&quot; + localUri);\n     }else{\n         //打印错误信息,提示等操作\n         logger.warn(resultObj.getString(&quot;errmsg&quot;));\n         return new ModelAndView(&quot;redirect:&quot;+ localUri +&quot;auth/login&quot;);\n     }\n }\n</code></pre>\n</li>\n</ol>\n<h5 id=\"这里有一个小疑问，为什么不直接通过回调返回ticket呢，而是返回code再去拿ticket。基于这点我问了sso的开发。他们给我的答复是：\"><a href=\"#这里有一个小疑问，为什么不直接通过回调返回ticket呢，而是返回code再去拿ticket。基于这点我问了sso的开发。他们给我的答复是：\" class=\"headerlink\" title=\"这里有一个小疑问，为什么不直接通过回调返回ticket呢，而是返回code再去拿ticket。基于这点我问了sso的开发。他们给我的答复是：\"></a>这里有一个小疑问，为什么不直接通过回调返回ticket呢，而是返回code再去拿ticket。基于这点我问了sso的开发。他们给我的答复是：</h5><ol>\n<li>兼容以前老的auth的原因</li>\n<li>ticket不从调转直接返回，防止被窃取，现在是在你们后端调check_code(可以理解为 拿code换ticket)。code换ticket只能调一次，缓存时间是30秒</li>\n</ol>\n<h5 id=\"个人觉得第二点理由有点牵强，可能更多的是考虑到兼容性。\"><a href=\"#个人觉得第二点理由有点牵强，可能更多的是考虑到兼容性。\" class=\"headerlink\" title=\"个人觉得第二点理由有点牵强，可能更多的是考虑到兼容性。\"></a>个人觉得第二点理由有点牵强，可能更多的是考虑到兼容性。</h5><h5 id=\"上面说了单个子系统的登录以及验证过程，那么sso是如何实现单点登录的呢。其实很简单，原理就在上面的核心中的第二点。sso也保存了自己的cookie。当用户去到一个新的系统，会发生以下的流程（假设该用户已经在其他系统登录过）：\"><a href=\"#上面说了单个子系统的登录以及验证过程，那么sso是如何实现单点登录的呢。其实很简单，原理就在上面的核心中的第二点。sso也保存了自己的cookie。当用户去到一个新的系统，会发生以下的流程（假设该用户已经在其他系统登录过）：\" class=\"headerlink\" title=\"上面说了单个子系统的登录以及验证过程，那么sso是如何实现单点登录的呢。其实很简单，原理就在上面的核心中的第二点。sso也保存了自己的cookie。当用户去到一个新的系统，会发生以下的流程（假设该用户已经在其他系统登录过）：\"></a>上面说了单个子系统的登录以及验证过程，那么sso是如何实现单点登录的呢。其实很简单，原理就在上面的核心中的第二点。sso也保存了自己的cookie。当用户去到一个新的系统，会发生以下的流程（假设该用户已经在其他系统登录过）：</h5><ol>\n<li>请求当前新系统的页面</li>\n<li>页面拦截器验证ticket。发现没有ticket或者ticket不合法</li>\n<li>系统将请求转发到sso登录页面</li>\n<li>浏览器转发请求并带上该域名cookie</li>\n<li>sso通过cookie发现该用户在sso当中已经登录过。则跳过用户登录过程，直接生产code返回给该子系统</li>\n</ol>\n<h2 id=\"sso登出流程\"><a href=\"#sso登出流程\" class=\"headerlink\" title=\"sso登出流程\"></a>sso登出流程</h2><h5 id=\"登出流程基本上和登录流程是相对应的。按照登录的两个核心点，登出的过程也应该是相应的：\"><a href=\"#登出流程基本上和登录流程是相对应的。按照登录的两个核心点，登出的过程也应该是相应的：\" class=\"headerlink\" title=\"登出流程基本上和登录流程是相对应的。按照登录的两个核心点，登出的过程也应该是相应的：\"></a>登出流程基本上和登录流程是相对应的。按照登录的两个核心点，登出的过程也应该是相应的：</h5><ol>\n<li>清除子系统ticket</li>\n<li>清除sso系统cookie</li>\n</ol>\n<h5 id=\"通常清除自己系统的ticket不是必须的，因为就算你不清除，验证sso也不会通过。只是浪费了一次请求操作。\"><a href=\"#通常清除自己系统的ticket不是必须的，因为就算你不清除，验证sso也不会通过。只是浪费了一次请求操作。\" class=\"headerlink\" title=\"通常清除自己系统的ticket不是必须的，因为就算你不清除，验证sso也不会通过。只是浪费了一次请求操作。\"></a>通常清除自己系统的ticket不是必须的，因为就算你不清除，验证sso也不会通过。只是浪费了一次请求操作。</h5><h5 id=\"清除sso系统cookie，这步操作则是通过sso给定的登出链接。一般要带上自己系统的app-id。\"><a href=\"#清除sso系统cookie，这步操作则是通过sso给定的登出链接。一般要带上自己系统的app-id。\" class=\"headerlink\" title=\"清除sso系统cookie，这步操作则是通过sso给定的登出链接。一般要带上自己系统的app_id。\"></a>清除sso系统cookie，这步操作则是通过sso给定的登出链接。一般要带上自己系统的app_id。</h5><h2 id=\"实际操作中遇到的一些问题：\"><a href=\"#实际操作中遇到的一些问题：\" class=\"headerlink\" title=\"实际操作中遇到的一些问题：\"></a>实际操作中遇到的一些问题：</h2><h5 id=\"前面已经把sso的登录和登出原理说了个大概。但是在实际操作当中确实遇到了一些问题\"><a href=\"#前面已经把sso的登录和登出原理说了个大概。但是在实际操作当中确实遇到了一些问题\" class=\"headerlink\" title=\"前面已经把sso的登录和登出原理说了个大概。但是在实际操作当中确实遇到了一些问题\"></a>前面已经把sso的登录和登出原理说了个大概。但是在实际操作当中确实遇到了一些问题</h5><h3 id=\"用户登录后一直请求不到子系统页面，前端一直转菊花\"><a href=\"#用户登录后一直请求不到子系统页面，前端一直转菊花\" class=\"headerlink\" title=\"用户登录后一直请求不到子系统页面，前端一直转菊花\"></a>用户登录后一直请求不到子系统页面，前端一直转菊花</h3><h5 id=\"用户在sso登录页面成功了，然后浏览器一直白页面，菊花一直转。查看后端接口日志，发现全是http请求超时，仔细查看后发现是ticket验证接口超时。之后在服务器上ping该接口也是超时状态，但是在本地ping则是成功状态。\"><a href=\"#用户在sso登录页面成功了，然后浏览器一直白页面，菊花一直转。查看后端接口日志，发现全是http请求超时，仔细查看后发现是ticket验证接口超时。之后在服务器上ping该接口也是超时状态，但是在本地ping则是成功状态。\" class=\"headerlink\" title=\"用户在sso登录页面成功了，然后浏览器一直白页面，菊花一直转。查看后端接口日志，发现全是http请求超时，仔细查看后发现是ticket验证接口超时。之后在服务器上ping该接口也是超时状态，但是在本地ping则是成功状态。\"></a>用户在sso登录页面成功了，然后浏览器一直白页面，菊花一直转。查看后端接口日志，发现全是http请求超时，仔细查看后发现是ticket验证接口超时。之后在服务器上ping该接口也是超时状态，但是在本地ping则是成功状态。</h5><h5 id=\"最后的原因很简单，是因为线上服务器没有开通外网权限，而登录页面是重定向到浏览器后浏览器再去请求的，所以之前的流程一直是正常状态。但是验证ticket的流程是在服务端直接请求验证的，而外网域名在内网服务器上没有办法解析。\"><a href=\"#最后的原因很简单，是因为线上服务器没有开通外网权限，而登录页面是重定向到浏览器后浏览器再去请求的，所以之前的流程一直是正常状态。但是验证ticket的流程是在服务端直接请求验证的，而外网域名在内网服务器上没有办法解析。\" class=\"headerlink\" title=\"最后的原因很简单，是因为线上服务器没有开通外网权限，而登录页面是重定向到浏览器后浏览器再去请求的，所以之前的流程一直是正常状态。但是验证ticket的流程是在服务端直接请求验证的，而外网域名在内网服务器上没有办法解析。\"></a>最后的原因很简单，是因为线上服务器没有开通外网权限，而登录页面是重定向到浏览器后浏览器再去请求的，所以之前的流程一直是正常状态。但是验证ticket的流程是在服务端直接请求验证的，而外网域名在内网服务器上没有办法解析。</h5><h5 id=\"解决办法有很多，比如开通外网，或者选用内网router，或者不一定要使用http服务。我们的解决方案就是选用的第二种（内网router），其实内网和外网对我们验证ticket没有区别，最终打到他们的服务可能都是相同的。\"><a href=\"#解决办法有很多，比如开通外网，或者选用内网router，或者不一定要使用http服务。我们的解决方案就是选用的第二种（内网router），其实内网和外网对我们验证ticket没有区别，最终打到他们的服务可能都是相同的。\" class=\"headerlink\" title=\"解决办法有很多，比如开通外网，或者选用内网router，或者不一定要使用http服务。我们的解决方案就是选用的第二种（内网router），其实内网和外网对我们验证ticket没有区别，最终打到他们的服务可能都是相同的。\"></a>解决办法有很多，比如开通外网，或者选用内网router，或者不一定要使用http服务。我们的解决方案就是选用的第二种（内网router），其实内网和外网对我们验证ticket没有区别，最终打到他们的服务可能都是相同的。</h5><h3 id=\"登出问题\"><a href=\"#登出问题\" class=\"headerlink\" title=\"登出问题\"></a>登出问题</h3><h5 id=\"这个问题也是在本地不存在，但是在线上的表现就是登出后浏览器跳转到登录页面，登录页面则直接再跳转回当前系统主页面。\"><a href=\"#这个问题也是在本地不存在，但是在线上的表现就是登出后浏览器跳转到登录页面，登录页面则直接再跳转回当前系统主页面。\" class=\"headerlink\" title=\"这个问题也是在本地不存在，但是在线上的表现就是登出后浏览器跳转到登录页面，登录页面则直接再跳转回当前系统主页面。\"></a>这个问题也是在本地不存在，但是在线上的表现就是登出后浏览器跳转到登录页面，登录页面则直接再跳转回当前系统主页面。</h5><h5 id=\"通过问题描述加上前面的分析，你可能会发现问题所在，那就是sso登录页面的cookie没有被清除。至于为什么没有被清除呢，这是上一个问题留下的坑。因为是统一接口，所以登出的流程也是选择使用内网router，但是sso登出接口的重要操作就是清除cookie，cookie一般又是和域名挂钩的。sso登出接口处理cookie后，会直接重定向到登录页面。核心的问题就在于登出接口的域名和登录页面的域名不一致，导致登出过程cookie没有被清除。\"><a href=\"#通过问题描述加上前面的分析，你可能会发现问题所在，那就是sso登录页面的cookie没有被清除。至于为什么没有被清除呢，这是上一个问题留下的坑。因为是统一接口，所以登出的流程也是选择使用内网router，但是sso登出接口的重要操作就是清除cookie，cookie一般又是和域名挂钩的。sso登出接口处理cookie后，会直接重定向到登录页面。核心的问题就在于登出接口的域名和登录页面的域名不一致，导致登出过程cookie没有被清除。\" class=\"headerlink\" title=\"通过问题描述加上前面的分析，你可能会发现问题所在，那就是sso登录页面的cookie没有被清除。至于为什么没有被清除呢，这是上一个问题留下的坑。因为是统一接口，所以登出的流程也是选择使用内网router，但是sso登出接口的重要操作就是清除cookie，cookie一般又是和域名挂钩的。sso登出接口处理cookie后，会直接重定向到登录页面。核心的问题就在于登出接口的域名和登录页面的域名不一致，导致登出过程cookie没有被清除。\"></a>通过问题描述加上前面的分析，你可能会发现问题所在，那就是sso登录页面的cookie没有被清除。至于为什么没有被清除呢，这是上一个问题留下的坑。因为是统一接口，所以登出的流程也是选择使用内网router，但是sso登出接口的重要操作就是清除cookie，cookie一般又是和域名挂钩的。sso登出接口处理cookie后，会直接重定向到登录页面。核心的问题就在于登出接口的域名和登录页面的域名不一致，导致登出过程cookie没有被清除。</h5><h5 id=\"解决办法也很简单，登出接口单独维护。之后则一切正常。\"><a href=\"#解决办法也很简单，登出接口单独维护。之后则一切正常。\" class=\"headerlink\" title=\"解决办法也很简单，登出接口单独维护。之后则一切正常。\"></a>解决办法也很简单，登出接口单独维护。之后则一切正常。</h5>"},{"layout":"post","title":"vim快捷键笔记","date":"2016-10-13T16:00:00.000Z","_content":"\n## 一. 移动光标\n1. 左移h. 右移l. 下移j. 上移k\n2. 向下翻页ctrl + f，向上翻页ctrl + b    \n3. 向下翻半页ctrl + d，向上翻半页ctrl + u\n4. 移动到行尾$，移动到行首0（数字），移动到行首第一个字符处^\n5. 移动光标到下一个句子 ），移动光标到上一个句子（\n6. 移动到段首{，移动到段尾}\n7. 移动到下一个词w，移动到上一个词b\n8. 移动到文档开始gg，移动到文档结束G\n9. 移动到匹配的{}.().[]处%\n10. 跳到第n行 ngg 或 nG 或 :n\n11. 移动光标到屏幕顶端H，移动到屏幕中间M，移动到底部L\n12. 读取当前字符，并移动到本屏幕内下一次出现的地方*\n13. 读取当前字符，并移动到本屏幕内上一次出现的地方#\n\n<!--more-->\n\n## 二. 查找替换\n1. 光标向后查找关键字 #或者g#\n2. 光标向前查找关键字 *或者g*\n3. 当前行查找字符 fx, Fx, tx, Tx\n4. 基本替换 :s/s1/s2 （将下一个s1替换为s2）\n5. 全部替换 :%s/s1/s2\n6. 只替换当前行 :s/s1/s2/g\n7. 替换某些行 :n1,n2 s/s1/s2/g\n8. 搜索模式为 /string，搜索下一处为n，搜索上一处为N\n9. 制定书签 mx, 但是看不到书签标记，而且只能用小写字母\n10. 移动到某标签处 `x，1旁边的键\n11. 移动到上次编辑文件的位置 `.\n\n##### PS：.代表一个任意字符 \\*代表一个或多个字符的重复\n\n## 三. 编辑操作\n1. 光标后插入a, 行尾插入A\n2. 后插一行插入o，前插一行插入O\n3. 删除字符插入s， 删除正行插入S\n4. 光标前插入i，行首插入I\n5. 删除一行dd，删除后进入插入模式cc或者S\n6. 删除一个单词dw，删除一个单词进入插入模式cw\n7. 删除一个字符x或者dl，删除一个字符进入插入模式s或者cl\n8. 粘贴p，交换两个字符xp，交换两行ddp\n9. 复制y，复制一行yy\n10. 撤销u，重做ctrl + r，重复.\n11. 智能提示 ctrl + n 或者 ctrl + p\n12. 删除motion跨过的字符，删除并进入插入模式 c{motion}\n13. 删除到下一个字符跨过的字符，删除并进入插入模式，不包括x字符 ctx\n14. 删除当前字符到下一个字符处的所有字符，并进入插入模式，包括x字符，cfx\n15. 删除motion跨过的字符，删除但不进入插入模式 d{motion}\n16. 删除motion跨过的字符，删除但不进入插入模式，不包括x字符 dtx\n17. 删除当前字符到下一个字符处的所有字符，包括x字符 dfx\n18. 如果只是复制的情况时，将12-17条中的c或d改为y\n19. 删除到行尾可以使用D或C\n20. 拷贝当前行 yy或者Y\n21. 删除当前字符 x\n22. 粘贴 p\n23. 可以使用多重剪切板，查看状态使用:reg，使用剪切板使用”，例如复制到w寄存器，”wyy，或者使用可视模式v”wy\n24. 重复执行上一个作用使用.\n25. 使用数字可以跨过n个区域，如y3x，会拷贝光标到第三个x之间的区域，3j向下移动3行\n26. 在编写代码的时候可以使用]p粘贴，这样可以自动进行代码缩进\n27. \\>> 缩进所有选择的代码\n28. << 反缩进所有选择的代码\n29. gd 移动到光标所处的函数或变量的定义处\n30. K 在man里搜索光标所在的词\n31. 合并两行 J\n32. 若不想保存文件，而重新打开 :e!\n33. 若想打开新文件 :e filename，然后使用ctrl + ^进行文件切换\n\n## 四. 窗口操作\n1. 分隔一个窗口:split或者:vsplit\n2. 创建一个窗口:new或者:vnew\n3. 在新窗口打开文件:sf {filename}\n4. 关闭当前窗口:close\n5. 仅保留当前窗口:only\n6. 到左边窗口 ctrl + w, h\n7. 到右边窗口 ctrl + w, l\n8. 到上边窗口 ctrl + w, k\n9. 到下边窗口 ctrl + w, j\n10. 到顶部窗口 ctrl + w, t\n11. 到底部窗口 ctrl + w, b\n\n## 五. 宏操作\n1. 开始记录宏操作q[a-z]，按q结束，保存操作到寄存器[a-z]中\n2. @[a-z]执行寄存器[a-z]中的操作\n3. @@执行最近一次记录的宏操作\n\n## 六. 可视操作\n1. 进入块可视模式 ctrl + v\n2. 进入字符可视模式 v\n3. 进入行可视模式 V\n4. 删除选定的块 d\n5. 删除选定的块然后进入插入模式 c\n6. 在选中的块同是插入相同的字符 IESC\n\n## 七. 跳到声明\n1. [[ 向前跳到顶格第一个{  \n2. [] 向前跳到顶格第一个}\n3. ]] 向后跳到顶格的第一个{\n4. ]] 向后跳到顶格的第一个}\n5. [{ 跳到本代码块的开头\n6. ]} 跳到本代码块的结尾\n\n## 八. 挂起操作\n1. 挂起Vim ctrl + z 或者 :suspend\n2. 查看任务 在shell中输入 jobs\n3. 恢复任务 fg [job number]（将后台程序放到前台）或者 bg [job number]（将前台程序放到后台）\n4. 执行shell命令 :!command\n5. 开启shell命令 :shell，退出该shell exit\n6. 保存vim状态 :mksession name.vim\n7. 恢复vim状态 :source name.vim\n8. 启动vim时恢复状态 vim -S name.vim\n","source":"_posts/note/vimNotes.md","raw":"---\nlayout: post\ntitle: vim快捷键笔记\ndate: 2016/10/14\ntags: [tech, index]\n---\n\n## 一. 移动光标\n1. 左移h. 右移l. 下移j. 上移k\n2. 向下翻页ctrl + f，向上翻页ctrl + b    \n3. 向下翻半页ctrl + d，向上翻半页ctrl + u\n4. 移动到行尾$，移动到行首0（数字），移动到行首第一个字符处^\n5. 移动光标到下一个句子 ），移动光标到上一个句子（\n6. 移动到段首{，移动到段尾}\n7. 移动到下一个词w，移动到上一个词b\n8. 移动到文档开始gg，移动到文档结束G\n9. 移动到匹配的{}.().[]处%\n10. 跳到第n行 ngg 或 nG 或 :n\n11. 移动光标到屏幕顶端H，移动到屏幕中间M，移动到底部L\n12. 读取当前字符，并移动到本屏幕内下一次出现的地方*\n13. 读取当前字符，并移动到本屏幕内上一次出现的地方#\n\n<!--more-->\n\n## 二. 查找替换\n1. 光标向后查找关键字 #或者g#\n2. 光标向前查找关键字 *或者g*\n3. 当前行查找字符 fx, Fx, tx, Tx\n4. 基本替换 :s/s1/s2 （将下一个s1替换为s2）\n5. 全部替换 :%s/s1/s2\n6. 只替换当前行 :s/s1/s2/g\n7. 替换某些行 :n1,n2 s/s1/s2/g\n8. 搜索模式为 /string，搜索下一处为n，搜索上一处为N\n9. 制定书签 mx, 但是看不到书签标记，而且只能用小写字母\n10. 移动到某标签处 `x，1旁边的键\n11. 移动到上次编辑文件的位置 `.\n\n##### PS：.代表一个任意字符 \\*代表一个或多个字符的重复\n\n## 三. 编辑操作\n1. 光标后插入a, 行尾插入A\n2. 后插一行插入o，前插一行插入O\n3. 删除字符插入s， 删除正行插入S\n4. 光标前插入i，行首插入I\n5. 删除一行dd，删除后进入插入模式cc或者S\n6. 删除一个单词dw，删除一个单词进入插入模式cw\n7. 删除一个字符x或者dl，删除一个字符进入插入模式s或者cl\n8. 粘贴p，交换两个字符xp，交换两行ddp\n9. 复制y，复制一行yy\n10. 撤销u，重做ctrl + r，重复.\n11. 智能提示 ctrl + n 或者 ctrl + p\n12. 删除motion跨过的字符，删除并进入插入模式 c{motion}\n13. 删除到下一个字符跨过的字符，删除并进入插入模式，不包括x字符 ctx\n14. 删除当前字符到下一个字符处的所有字符，并进入插入模式，包括x字符，cfx\n15. 删除motion跨过的字符，删除但不进入插入模式 d{motion}\n16. 删除motion跨过的字符，删除但不进入插入模式，不包括x字符 dtx\n17. 删除当前字符到下一个字符处的所有字符，包括x字符 dfx\n18. 如果只是复制的情况时，将12-17条中的c或d改为y\n19. 删除到行尾可以使用D或C\n20. 拷贝当前行 yy或者Y\n21. 删除当前字符 x\n22. 粘贴 p\n23. 可以使用多重剪切板，查看状态使用:reg，使用剪切板使用”，例如复制到w寄存器，”wyy，或者使用可视模式v”wy\n24. 重复执行上一个作用使用.\n25. 使用数字可以跨过n个区域，如y3x，会拷贝光标到第三个x之间的区域，3j向下移动3行\n26. 在编写代码的时候可以使用]p粘贴，这样可以自动进行代码缩进\n27. \\>> 缩进所有选择的代码\n28. << 反缩进所有选择的代码\n29. gd 移动到光标所处的函数或变量的定义处\n30. K 在man里搜索光标所在的词\n31. 合并两行 J\n32. 若不想保存文件，而重新打开 :e!\n33. 若想打开新文件 :e filename，然后使用ctrl + ^进行文件切换\n\n## 四. 窗口操作\n1. 分隔一个窗口:split或者:vsplit\n2. 创建一个窗口:new或者:vnew\n3. 在新窗口打开文件:sf {filename}\n4. 关闭当前窗口:close\n5. 仅保留当前窗口:only\n6. 到左边窗口 ctrl + w, h\n7. 到右边窗口 ctrl + w, l\n8. 到上边窗口 ctrl + w, k\n9. 到下边窗口 ctrl + w, j\n10. 到顶部窗口 ctrl + w, t\n11. 到底部窗口 ctrl + w, b\n\n## 五. 宏操作\n1. 开始记录宏操作q[a-z]，按q结束，保存操作到寄存器[a-z]中\n2. @[a-z]执行寄存器[a-z]中的操作\n3. @@执行最近一次记录的宏操作\n\n## 六. 可视操作\n1. 进入块可视模式 ctrl + v\n2. 进入字符可视模式 v\n3. 进入行可视模式 V\n4. 删除选定的块 d\n5. 删除选定的块然后进入插入模式 c\n6. 在选中的块同是插入相同的字符 IESC\n\n## 七. 跳到声明\n1. [[ 向前跳到顶格第一个{  \n2. [] 向前跳到顶格第一个}\n3. ]] 向后跳到顶格的第一个{\n4. ]] 向后跳到顶格的第一个}\n5. [{ 跳到本代码块的开头\n6. ]} 跳到本代码块的结尾\n\n## 八. 挂起操作\n1. 挂起Vim ctrl + z 或者 :suspend\n2. 查看任务 在shell中输入 jobs\n3. 恢复任务 fg [job number]（将后台程序放到前台）或者 bg [job number]（将前台程序放到后台）\n4. 执行shell命令 :!command\n5. 开启shell命令 :shell，退出该shell exit\n6. 保存vim状态 :mksession name.vim\n7. 恢复vim状态 :source name.vim\n8. 启动vim时恢复状态 vim -S name.vim\n","slug":"note/vimNotes","published":1,"updated":"2018-05-08T13:00:14.285Z","comments":1,"photos":[],"link":"","_id":"cjgxop3l7000djah18m2pgpxh","content":"<h2 id=\"一-移动光标\"><a href=\"#一-移动光标\" class=\"headerlink\" title=\"一. 移动光标\"></a>一. 移动光标</h2><ol>\n<li>左移h. 右移l. 下移j. 上移k</li>\n<li>向下翻页ctrl + f，向上翻页ctrl + b    </li>\n<li>向下翻半页ctrl + d，向上翻半页ctrl + u</li>\n<li>移动到行尾$，移动到行首0（数字），移动到行首第一个字符处^</li>\n<li>移动光标到下一个句子 ），移动光标到上一个句子（</li>\n<li>移动到段首{，移动到段尾}</li>\n<li>移动到下一个词w，移动到上一个词b</li>\n<li>移动到文档开始gg，移动到文档结束G</li>\n<li>移动到匹配的{}.().[]处%</li>\n<li>跳到第n行 ngg 或 nG 或 :n</li>\n<li>移动光标到屏幕顶端H，移动到屏幕中间M，移动到底部L</li>\n<li>读取当前字符，并移动到本屏幕内下一次出现的地方*</li>\n<li>读取当前字符，并移动到本屏幕内上一次出现的地方#</li>\n</ol>\n<a id=\"more\"></a>\n<h2 id=\"二-查找替换\"><a href=\"#二-查找替换\" class=\"headerlink\" title=\"二. 查找替换\"></a>二. 查找替换</h2><ol>\n<li>光标向后查找关键字 #或者g#</li>\n<li>光标向前查找关键字 <em>或者g</em></li>\n<li>当前行查找字符 fx, Fx, tx, Tx</li>\n<li>基本替换 :s/s1/s2 （将下一个s1替换为s2）</li>\n<li>全部替换 :%s/s1/s2</li>\n<li>只替换当前行 :s/s1/s2/g</li>\n<li>替换某些行 :n1,n2 s/s1/s2/g</li>\n<li>搜索模式为 /string，搜索下一处为n，搜索上一处为N</li>\n<li>制定书签 mx, 但是看不到书签标记，而且只能用小写字母</li>\n<li>移动到某标签处 `x，1旁边的键</li>\n<li>移动到上次编辑文件的位置 `.</li>\n</ol>\n<h5 id=\"PS：-代表一个任意字符-代表一个或多个字符的重复\"><a href=\"#PS：-代表一个任意字符-代表一个或多个字符的重复\" class=\"headerlink\" title=\"PS：.代表一个任意字符 *代表一个或多个字符的重复\"></a>PS：.代表一个任意字符 *代表一个或多个字符的重复</h5><h2 id=\"三-编辑操作\"><a href=\"#三-编辑操作\" class=\"headerlink\" title=\"三. 编辑操作\"></a>三. 编辑操作</h2><ol>\n<li>光标后插入a, 行尾插入A</li>\n<li>后插一行插入o，前插一行插入O</li>\n<li>删除字符插入s， 删除正行插入S</li>\n<li>光标前插入i，行首插入I</li>\n<li>删除一行dd，删除后进入插入模式cc或者S</li>\n<li>删除一个单词dw，删除一个单词进入插入模式cw</li>\n<li>删除一个字符x或者dl，删除一个字符进入插入模式s或者cl</li>\n<li>粘贴p，交换两个字符xp，交换两行ddp</li>\n<li>复制y，复制一行yy</li>\n<li>撤销u，重做ctrl + r，重复.</li>\n<li>智能提示 ctrl + n 或者 ctrl + p</li>\n<li>删除motion跨过的字符，删除并进入插入模式 c{motion}</li>\n<li>删除到下一个字符跨过的字符，删除并进入插入模式，不包括x字符 ctx</li>\n<li>删除当前字符到下一个字符处的所有字符，并进入插入模式，包括x字符，cfx</li>\n<li>删除motion跨过的字符，删除但不进入插入模式 d{motion}</li>\n<li>删除motion跨过的字符，删除但不进入插入模式，不包括x字符 dtx</li>\n<li>删除当前字符到下一个字符处的所有字符，包括x字符 dfx</li>\n<li>如果只是复制的情况时，将12-17条中的c或d改为y</li>\n<li>删除到行尾可以使用D或C</li>\n<li>拷贝当前行 yy或者Y</li>\n<li>删除当前字符 x</li>\n<li>粘贴 p</li>\n<li>可以使用多重剪切板，查看状态使用:reg，使用剪切板使用”，例如复制到w寄存器，”wyy，或者使用可视模式v”wy</li>\n<li>重复执行上一个作用使用.</li>\n<li>使用数字可以跨过n个区域，如y3x，会拷贝光标到第三个x之间的区域，3j向下移动3行</li>\n<li>在编写代码的时候可以使用]p粘贴，这样可以自动进行代码缩进</li>\n<li>>&gt; 缩进所有选择的代码</li>\n<li>&lt;&lt; 反缩进所有选择的代码</li>\n<li>gd 移动到光标所处的函数或变量的定义处</li>\n<li>K 在man里搜索光标所在的词</li>\n<li>合并两行 J</li>\n<li>若不想保存文件，而重新打开 :e!</li>\n<li>若想打开新文件 :e filename，然后使用ctrl + ^进行文件切换</li>\n</ol>\n<h2 id=\"四-窗口操作\"><a href=\"#四-窗口操作\" class=\"headerlink\" title=\"四. 窗口操作\"></a>四. 窗口操作</h2><ol>\n<li>分隔一个窗口:split或者:vsplit</li>\n<li>创建一个窗口:new或者:vnew</li>\n<li>在新窗口打开文件:sf {filename}</li>\n<li>关闭当前窗口:close</li>\n<li>仅保留当前窗口:only</li>\n<li>到左边窗口 ctrl + w, h</li>\n<li>到右边窗口 ctrl + w, l</li>\n<li>到上边窗口 ctrl + w, k</li>\n<li>到下边窗口 ctrl + w, j</li>\n<li>到顶部窗口 ctrl + w, t</li>\n<li>到底部窗口 ctrl + w, b</li>\n</ol>\n<h2 id=\"五-宏操作\"><a href=\"#五-宏操作\" class=\"headerlink\" title=\"五. 宏操作\"></a>五. 宏操作</h2><ol>\n<li>开始记录宏操作q[a-z]，按q结束，保存操作到寄存器[a-z]中</li>\n<li>@[a-z]执行寄存器[a-z]中的操作</li>\n<li>@@执行最近一次记录的宏操作</li>\n</ol>\n<h2 id=\"六-可视操作\"><a href=\"#六-可视操作\" class=\"headerlink\" title=\"六. 可视操作\"></a>六. 可视操作</h2><ol>\n<li>进入块可视模式 ctrl + v</li>\n<li>进入字符可视模式 v</li>\n<li>进入行可视模式 V</li>\n<li>删除选定的块 d</li>\n<li>删除选定的块然后进入插入模式 c</li>\n<li>在选中的块同是插入相同的字符 IESC</li>\n</ol>\n<h2 id=\"七-跳到声明\"><a href=\"#七-跳到声明\" class=\"headerlink\" title=\"七. 跳到声明\"></a>七. 跳到声明</h2><ol>\n<li>[[ 向前跳到顶格第一个{  </li>\n<li>[] 向前跳到顶格第一个}</li>\n<li>]] 向后跳到顶格的第一个{</li>\n<li>]] 向后跳到顶格的第一个}</li>\n<li>[{ 跳到本代码块的开头</li>\n<li>]} 跳到本代码块的结尾</li>\n</ol>\n<h2 id=\"八-挂起操作\"><a href=\"#八-挂起操作\" class=\"headerlink\" title=\"八. 挂起操作\"></a>八. 挂起操作</h2><ol>\n<li>挂起Vim ctrl + z 或者 :suspend</li>\n<li>查看任务 在shell中输入 jobs</li>\n<li>恢复任务 fg [job number]（将后台程序放到前台）或者 bg [job number]（将前台程序放到后台）</li>\n<li>执行shell命令 :!command</li>\n<li>开启shell命令 :shell，退出该shell exit</li>\n<li>保存vim状态 :mksession name.vim</li>\n<li>恢复vim状态 :source name.vim</li>\n<li>启动vim时恢复状态 vim -S name.vim</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h2 id=\"一-移动光标\"><a href=\"#一-移动光标\" class=\"headerlink\" title=\"一. 移动光标\"></a>一. 移动光标</h2><ol>\n<li>左移h. 右移l. 下移j. 上移k</li>\n<li>向下翻页ctrl + f，向上翻页ctrl + b    </li>\n<li>向下翻半页ctrl + d，向上翻半页ctrl + u</li>\n<li>移动到行尾$，移动到行首0（数字），移动到行首第一个字符处^</li>\n<li>移动光标到下一个句子 ），移动光标到上一个句子（</li>\n<li>移动到段首{，移动到段尾}</li>\n<li>移动到下一个词w，移动到上一个词b</li>\n<li>移动到文档开始gg，移动到文档结束G</li>\n<li>移动到匹配的{}.().[]处%</li>\n<li>跳到第n行 ngg 或 nG 或 :n</li>\n<li>移动光标到屏幕顶端H，移动到屏幕中间M，移动到底部L</li>\n<li>读取当前字符，并移动到本屏幕内下一次出现的地方*</li>\n<li>读取当前字符，并移动到本屏幕内上一次出现的地方#</li>\n</ol>","more":"<h2 id=\"二-查找替换\"><a href=\"#二-查找替换\" class=\"headerlink\" title=\"二. 查找替换\"></a>二. 查找替换</h2><ol>\n<li>光标向后查找关键字 #或者g#</li>\n<li>光标向前查找关键字 <em>或者g</em></li>\n<li>当前行查找字符 fx, Fx, tx, Tx</li>\n<li>基本替换 :s/s1/s2 （将下一个s1替换为s2）</li>\n<li>全部替换 :%s/s1/s2</li>\n<li>只替换当前行 :s/s1/s2/g</li>\n<li>替换某些行 :n1,n2 s/s1/s2/g</li>\n<li>搜索模式为 /string，搜索下一处为n，搜索上一处为N</li>\n<li>制定书签 mx, 但是看不到书签标记，而且只能用小写字母</li>\n<li>移动到某标签处 `x，1旁边的键</li>\n<li>移动到上次编辑文件的位置 `.</li>\n</ol>\n<h5 id=\"PS：-代表一个任意字符-代表一个或多个字符的重复\"><a href=\"#PS：-代表一个任意字符-代表一个或多个字符的重复\" class=\"headerlink\" title=\"PS：.代表一个任意字符 *代表一个或多个字符的重复\"></a>PS：.代表一个任意字符 *代表一个或多个字符的重复</h5><h2 id=\"三-编辑操作\"><a href=\"#三-编辑操作\" class=\"headerlink\" title=\"三. 编辑操作\"></a>三. 编辑操作</h2><ol>\n<li>光标后插入a, 行尾插入A</li>\n<li>后插一行插入o，前插一行插入O</li>\n<li>删除字符插入s， 删除正行插入S</li>\n<li>光标前插入i，行首插入I</li>\n<li>删除一行dd，删除后进入插入模式cc或者S</li>\n<li>删除一个单词dw，删除一个单词进入插入模式cw</li>\n<li>删除一个字符x或者dl，删除一个字符进入插入模式s或者cl</li>\n<li>粘贴p，交换两个字符xp，交换两行ddp</li>\n<li>复制y，复制一行yy</li>\n<li>撤销u，重做ctrl + r，重复.</li>\n<li>智能提示 ctrl + n 或者 ctrl + p</li>\n<li>删除motion跨过的字符，删除并进入插入模式 c{motion}</li>\n<li>删除到下一个字符跨过的字符，删除并进入插入模式，不包括x字符 ctx</li>\n<li>删除当前字符到下一个字符处的所有字符，并进入插入模式，包括x字符，cfx</li>\n<li>删除motion跨过的字符，删除但不进入插入模式 d{motion}</li>\n<li>删除motion跨过的字符，删除但不进入插入模式，不包括x字符 dtx</li>\n<li>删除当前字符到下一个字符处的所有字符，包括x字符 dfx</li>\n<li>如果只是复制的情况时，将12-17条中的c或d改为y</li>\n<li>删除到行尾可以使用D或C</li>\n<li>拷贝当前行 yy或者Y</li>\n<li>删除当前字符 x</li>\n<li>粘贴 p</li>\n<li>可以使用多重剪切板，查看状态使用:reg，使用剪切板使用”，例如复制到w寄存器，”wyy，或者使用可视模式v”wy</li>\n<li>重复执行上一个作用使用.</li>\n<li>使用数字可以跨过n个区域，如y3x，会拷贝光标到第三个x之间的区域，3j向下移动3行</li>\n<li>在编写代码的时候可以使用]p粘贴，这样可以自动进行代码缩进</li>\n<li>>&gt; 缩进所有选择的代码</li>\n<li>&lt;&lt; 反缩进所有选择的代码</li>\n<li>gd 移动到光标所处的函数或变量的定义处</li>\n<li>K 在man里搜索光标所在的词</li>\n<li>合并两行 J</li>\n<li>若不想保存文件，而重新打开 :e!</li>\n<li>若想打开新文件 :e filename，然后使用ctrl + ^进行文件切换</li>\n</ol>\n<h2 id=\"四-窗口操作\"><a href=\"#四-窗口操作\" class=\"headerlink\" title=\"四. 窗口操作\"></a>四. 窗口操作</h2><ol>\n<li>分隔一个窗口:split或者:vsplit</li>\n<li>创建一个窗口:new或者:vnew</li>\n<li>在新窗口打开文件:sf {filename}</li>\n<li>关闭当前窗口:close</li>\n<li>仅保留当前窗口:only</li>\n<li>到左边窗口 ctrl + w, h</li>\n<li>到右边窗口 ctrl + w, l</li>\n<li>到上边窗口 ctrl + w, k</li>\n<li>到下边窗口 ctrl + w, j</li>\n<li>到顶部窗口 ctrl + w, t</li>\n<li>到底部窗口 ctrl + w, b</li>\n</ol>\n<h2 id=\"五-宏操作\"><a href=\"#五-宏操作\" class=\"headerlink\" title=\"五. 宏操作\"></a>五. 宏操作</h2><ol>\n<li>开始记录宏操作q[a-z]，按q结束，保存操作到寄存器[a-z]中</li>\n<li>@[a-z]执行寄存器[a-z]中的操作</li>\n<li>@@执行最近一次记录的宏操作</li>\n</ol>\n<h2 id=\"六-可视操作\"><a href=\"#六-可视操作\" class=\"headerlink\" title=\"六. 可视操作\"></a>六. 可视操作</h2><ol>\n<li>进入块可视模式 ctrl + v</li>\n<li>进入字符可视模式 v</li>\n<li>进入行可视模式 V</li>\n<li>删除选定的块 d</li>\n<li>删除选定的块然后进入插入模式 c</li>\n<li>在选中的块同是插入相同的字符 IESC</li>\n</ol>\n<h2 id=\"七-跳到声明\"><a href=\"#七-跳到声明\" class=\"headerlink\" title=\"七. 跳到声明\"></a>七. 跳到声明</h2><ol>\n<li>[[ 向前跳到顶格第一个{  </li>\n<li>[] 向前跳到顶格第一个}</li>\n<li>]] 向后跳到顶格的第一个{</li>\n<li>]] 向后跳到顶格的第一个}</li>\n<li>[{ 跳到本代码块的开头</li>\n<li>]} 跳到本代码块的结尾</li>\n</ol>\n<h2 id=\"八-挂起操作\"><a href=\"#八-挂起操作\" class=\"headerlink\" title=\"八. 挂起操作\"></a>八. 挂起操作</h2><ol>\n<li>挂起Vim ctrl + z 或者 :suspend</li>\n<li>查看任务 在shell中输入 jobs</li>\n<li>恢复任务 fg [job number]（将后台程序放到前台）或者 bg [job number]（将前台程序放到后台）</li>\n<li>执行shell命令 :!command</li>\n<li>开启shell命令 :shell，退出该shell exit</li>\n<li>保存vim状态 :mksession name.vim</li>\n<li>恢复vim状态 :source name.vim</li>\n<li>启动vim时恢复状态 vim -S name.vim</li>\n</ol>"},{"layout":"book","title":"1984","author":"乔治·奥威尔[英]","date":"2017-05-31T16:00:00.000Z","cover":"1984.jpg","color":"#E30D23","_content":"\n## 内容简介\n##### 　　《1984》是一部杰出的政治寓言小说，也是一部幻想小说。作品刻画了人类在极权主义社会的生存状态，仿佛一个永不退色的警世标签，警醒世人提防这种预想中的黑暗成为现实。历经几十年，其生命力日益强大，被誉为20世纪影响最为深远的文学经典之一。\n\n## 笔记\n### 　　\"战争就是和平 自由就是奴役 无知就是力量\"\n### 　　\"那个黑发姑娘穿过田野向他走来。她好像一下子就脱光了衣服，不屑地扔到一边。她的身体白皙光滑，却没有引起他的任何欲望，事实上，他几乎没怎么看她。此刻，他满心只是赞叹着她扔衣服的动作。那种优雅随意的态度似乎能摧毁整个文化、整个思想体系，这绝妙的一挥手似乎能把老大哥、党和思想警察一扫而光。这也是一个属于古老的时代的动作。温斯顿醒来时嘴上还念着“莎士比亚”这个词。\"\n### 　　\"控制过去就能控制未来，控制现在就能控制过去\"\n### 　　\"眼前的真理就是永远的真理。很简单。所需的只是不断战胜自己的记忆而已。他们称它为“现实控制”，用新话说就是“双重思想”。\"\n### 　　\"用逻辑否定逻辑，既否认道德又维护道德，既相信民主的不可能又相信党是民主的卫士；\"\n### 　　\"“我讨厌纯洁，我讨厌善良！我讨厌任何美德的存在。我要让每个人都坏到骨子里去。”\"\n### 　　\"如果你遵守小的规定就可以违反大的规定。\"\n### 　　\"下等人的永久特征就是被劳役所压垮，以至于只能断断续续地认识到他们日常生活以外的东西——就是消除一切差别，建立一个人人平等的社会\"\n### 　　\"双重思想是英社的核心，因为党的主要行为就是故意欺骗，同时保持目标明确，毫不动摇，貌像完全诚实。故意撒谎又真诚地相信谎言；忘记不利的事实，必要的时候将它从遗忘中唤起，用完以后又立即忘记；否认客观现实的存在，同时又顾及被否认的事实——所有这些都必不可少。\"\n### 　　\"只是一个无望的幻想，像一个转瞬即逝的四月天，可一个眼神、一句话语却唤起了我的梦想，我的心便从此不见！\"\n","source":"_posts/read/1984.md","raw":"---\nlayout: book\ntitle: 1984\nauthor: 乔治·奥威尔[英]\ndate: 2017/06/01\ncover: 1984.jpg\ncategories: [read]\ncolor: '#E30D23'\n---\n\n## 内容简介\n##### 　　《1984》是一部杰出的政治寓言小说，也是一部幻想小说。作品刻画了人类在极权主义社会的生存状态，仿佛一个永不退色的警世标签，警醒世人提防这种预想中的黑暗成为现实。历经几十年，其生命力日益强大，被誉为20世纪影响最为深远的文学经典之一。\n\n## 笔记\n### 　　\"战争就是和平 自由就是奴役 无知就是力量\"\n### 　　\"那个黑发姑娘穿过田野向他走来。她好像一下子就脱光了衣服，不屑地扔到一边。她的身体白皙光滑，却没有引起他的任何欲望，事实上，他几乎没怎么看她。此刻，他满心只是赞叹着她扔衣服的动作。那种优雅随意的态度似乎能摧毁整个文化、整个思想体系，这绝妙的一挥手似乎能把老大哥、党和思想警察一扫而光。这也是一个属于古老的时代的动作。温斯顿醒来时嘴上还念着“莎士比亚”这个词。\"\n### 　　\"控制过去就能控制未来，控制现在就能控制过去\"\n### 　　\"眼前的真理就是永远的真理。很简单。所需的只是不断战胜自己的记忆而已。他们称它为“现实控制”，用新话说就是“双重思想”。\"\n### 　　\"用逻辑否定逻辑，既否认道德又维护道德，既相信民主的不可能又相信党是民主的卫士；\"\n### 　　\"“我讨厌纯洁，我讨厌善良！我讨厌任何美德的存在。我要让每个人都坏到骨子里去。”\"\n### 　　\"如果你遵守小的规定就可以违反大的规定。\"\n### 　　\"下等人的永久特征就是被劳役所压垮，以至于只能断断续续地认识到他们日常生活以外的东西——就是消除一切差别，建立一个人人平等的社会\"\n### 　　\"双重思想是英社的核心，因为党的主要行为就是故意欺骗，同时保持目标明确，毫不动摇，貌像完全诚实。故意撒谎又真诚地相信谎言；忘记不利的事实，必要的时候将它从遗忘中唤起，用完以后又立即忘记；否认客观现实的存在，同时又顾及被否认的事实——所有这些都必不可少。\"\n### 　　\"只是一个无望的幻想，像一个转瞬即逝的四月天，可一个眼神、一句话语却唤起了我的梦想，我的心便从此不见！\"\n","slug":"read/1984","published":1,"updated":"2018-05-08T13:00:14.286Z","comments":1,"photos":[],"link":"","_id":"cjgxop3l9000gjah1funx8vjm","content":"<h2 id=\"内容简介\"><a href=\"#内容简介\" class=\"headerlink\" title=\"内容简介\"></a>内容简介</h2><h5 id=\"《1984》是一部杰出的政治寓言小说，也是一部幻想小说。作品刻画了人类在极权主义社会的生存状态，仿佛一个永不退色的警世标签，警醒世人提防这种预想中的黑暗成为现实。历经几十年，其生命力日益强大，被誉为20世纪影响最为深远的文学经典之一。\"><a href=\"#《1984》是一部杰出的政治寓言小说，也是一部幻想小说。作品刻画了人类在极权主义社会的生存状态，仿佛一个永不退色的警世标签，警醒世人提防这种预想中的黑暗成为现实。历经几十年，其生命力日益强大，被誉为20世纪影响最为深远的文学经典之一。\" class=\"headerlink\" title=\"　　《1984》是一部杰出的政治寓言小说，也是一部幻想小说。作品刻画了人类在极权主义社会的生存状态，仿佛一个永不退色的警世标签，警醒世人提防这种预想中的黑暗成为现实。历经几十年，其生命力日益强大，被誉为20世纪影响最为深远的文学经典之一。\"></a>　　《1984》是一部杰出的政治寓言小说，也是一部幻想小说。作品刻画了人类在极权主义社会的生存状态，仿佛一个永不退色的警世标签，警醒世人提防这种预想中的黑暗成为现实。历经几十年，其生命力日益强大，被誉为20世纪影响最为深远的文学经典之一。</h5><h2 id=\"笔记\"><a href=\"#笔记\" class=\"headerlink\" title=\"笔记\"></a>笔记</h2><h3 id=\"“战争就是和平-自由就是奴役-无知就是力量”\"><a href=\"#“战争就是和平-自由就是奴役-无知就是力量”\" class=\"headerlink\" title=\"　　“战争就是和平 自由就是奴役 无知就是力量”\"></a>　　“战争就是和平 自由就是奴役 无知就是力量”</h3><h3 id=\"“那个黑发姑娘穿过田野向他走来。她好像一下子就脱光了衣服，不屑地扔到一边。她的身体白皙光滑，却没有引起他的任何欲望，事实上，他几乎没怎么看她。此刻，他满心只是赞叹着她扔衣服的动作。那种优雅随意的态度似乎能摧毁整个文化、整个思想体系，这绝妙的一挥手似乎能把老大哥、党和思想警察一扫而光。这也是一个属于古老的时代的动作。温斯顿醒来时嘴上还念着“莎士比亚”这个词。”\"><a href=\"#“那个黑发姑娘穿过田野向他走来。她好像一下子就脱光了衣服，不屑地扔到一边。她的身体白皙光滑，却没有引起他的任何欲望，事实上，他几乎没怎么看她。此刻，他满心只是赞叹着她扔衣服的动作。那种优雅随意的态度似乎能摧毁整个文化、整个思想体系，这绝妙的一挥手似乎能把老大哥、党和思想警察一扫而光。这也是一个属于古老的时代的动作。温斯顿醒来时嘴上还念着“莎士比亚”这个词。”\" class=\"headerlink\" title=\"　　“那个黑发姑娘穿过田野向他走来。她好像一下子就脱光了衣服，不屑地扔到一边。她的身体白皙光滑，却没有引起他的任何欲望，事实上，他几乎没怎么看她。此刻，他满心只是赞叹着她扔衣服的动作。那种优雅随意的态度似乎能摧毁整个文化、整个思想体系，这绝妙的一挥手似乎能把老大哥、党和思想警察一扫而光。这也是一个属于古老的时代的动作。温斯顿醒来时嘴上还念着“莎士比亚”这个词。”\"></a>　　“那个黑发姑娘穿过田野向他走来。她好像一下子就脱光了衣服，不屑地扔到一边。她的身体白皙光滑，却没有引起他的任何欲望，事实上，他几乎没怎么看她。此刻，他满心只是赞叹着她扔衣服的动作。那种优雅随意的态度似乎能摧毁整个文化、整个思想体系，这绝妙的一挥手似乎能把老大哥、党和思想警察一扫而光。这也是一个属于古老的时代的动作。温斯顿醒来时嘴上还念着“莎士比亚”这个词。”</h3><h3 id=\"“控制过去就能控制未来，控制现在就能控制过去”\"><a href=\"#“控制过去就能控制未来，控制现在就能控制过去”\" class=\"headerlink\" title=\"　　“控制过去就能控制未来，控制现在就能控制过去”\"></a>　　“控制过去就能控制未来，控制现在就能控制过去”</h3><h3 id=\"“眼前的真理就是永远的真理。很简单。所需的只是不断战胜自己的记忆而已。他们称它为“现实控制”，用新话说就是“双重思想”。”\"><a href=\"#“眼前的真理就是永远的真理。很简单。所需的只是不断战胜自己的记忆而已。他们称它为“现实控制”，用新话说就是“双重思想”。”\" class=\"headerlink\" title=\"　　“眼前的真理就是永远的真理。很简单。所需的只是不断战胜自己的记忆而已。他们称它为“现实控制”，用新话说就是“双重思想”。”\"></a>　　“眼前的真理就是永远的真理。很简单。所需的只是不断战胜自己的记忆而已。他们称它为“现实控制”，用新话说就是“双重思想”。”</h3><h3 id=\"“用逻辑否定逻辑，既否认道德又维护道德，既相信民主的不可能又相信党是民主的卫士；”\"><a href=\"#“用逻辑否定逻辑，既否认道德又维护道德，既相信民主的不可能又相信党是民主的卫士；”\" class=\"headerlink\" title=\"　　“用逻辑否定逻辑，既否认道德又维护道德，既相信民主的不可能又相信党是民主的卫士；”\"></a>　　“用逻辑否定逻辑，既否认道德又维护道德，既相信民主的不可能又相信党是民主的卫士；”</h3><h3 id=\"““我讨厌纯洁，我讨厌善良！我讨厌任何美德的存在。我要让每个人都坏到骨子里去。””\"><a href=\"#““我讨厌纯洁，我讨厌善良！我讨厌任何美德的存在。我要让每个人都坏到骨子里去。””\" class=\"headerlink\" title=\"　　““我讨厌纯洁，我讨厌善良！我讨厌任何美德的存在。我要让每个人都坏到骨子里去。””\"></a>　　““我讨厌纯洁，我讨厌善良！我讨厌任何美德的存在。我要让每个人都坏到骨子里去。””</h3><h3 id=\"“如果你遵守小的规定就可以违反大的规定。”\"><a href=\"#“如果你遵守小的规定就可以违反大的规定。”\" class=\"headerlink\" title=\"　　“如果你遵守小的规定就可以违反大的规定。”\"></a>　　“如果你遵守小的规定就可以违反大的规定。”</h3><h3 id=\"“下等人的永久特征就是被劳役所压垮，以至于只能断断续续地认识到他们日常生活以外的东西——就是消除一切差别，建立一个人人平等的社会”\"><a href=\"#“下等人的永久特征就是被劳役所压垮，以至于只能断断续续地认识到他们日常生活以外的东西——就是消除一切差别，建立一个人人平等的社会”\" class=\"headerlink\" title=\"　　“下等人的永久特征就是被劳役所压垮，以至于只能断断续续地认识到他们日常生活以外的东西——就是消除一切差别，建立一个人人平等的社会”\"></a>　　“下等人的永久特征就是被劳役所压垮，以至于只能断断续续地认识到他们日常生活以外的东西——就是消除一切差别，建立一个人人平等的社会”</h3><h3 id=\"“双重思想是英社的核心，因为党的主要行为就是故意欺骗，同时保持目标明确，毫不动摇，貌像完全诚实。故意撒谎又真诚地相信谎言；忘记不利的事实，必要的时候将它从遗忘中唤起，用完以后又立即忘记；否认客观现实的存在，同时又顾及被否认的事实——所有这些都必不可少。”\"><a href=\"#“双重思想是英社的核心，因为党的主要行为就是故意欺骗，同时保持目标明确，毫不动摇，貌像完全诚实。故意撒谎又真诚地相信谎言；忘记不利的事实，必要的时候将它从遗忘中唤起，用完以后又立即忘记；否认客观现实的存在，同时又顾及被否认的事实——所有这些都必不可少。”\" class=\"headerlink\" title=\"　　“双重思想是英社的核心，因为党的主要行为就是故意欺骗，同时保持目标明确，毫不动摇，貌像完全诚实。故意撒谎又真诚地相信谎言；忘记不利的事实，必要的时候将它从遗忘中唤起，用完以后又立即忘记；否认客观现实的存在，同时又顾及被否认的事实——所有这些都必不可少。”\"></a>　　“双重思想是英社的核心，因为党的主要行为就是故意欺骗，同时保持目标明确，毫不动摇，貌像完全诚实。故意撒谎又真诚地相信谎言；忘记不利的事实，必要的时候将它从遗忘中唤起，用完以后又立即忘记；否认客观现实的存在，同时又顾及被否认的事实——所有这些都必不可少。”</h3><h3 id=\"“只是一个无望的幻想，像一个转瞬即逝的四月天，可一个眼神、一句话语却唤起了我的梦想，我的心便从此不见！”\"><a href=\"#“只是一个无望的幻想，像一个转瞬即逝的四月天，可一个眼神、一句话语却唤起了我的梦想，我的心便从此不见！”\" class=\"headerlink\" title=\"　　“只是一个无望的幻想，像一个转瞬即逝的四月天，可一个眼神、一句话语却唤起了我的梦想，我的心便从此不见！”\"></a>　　“只是一个无望的幻想，像一个转瞬即逝的四月天，可一个眼神、一句话语却唤起了我的梦想，我的心便从此不见！”</h3>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"内容简介\"><a href=\"#内容简介\" class=\"headerlink\" title=\"内容简介\"></a>内容简介</h2><h5 id=\"《1984》是一部杰出的政治寓言小说，也是一部幻想小说。作品刻画了人类在极权主义社会的生存状态，仿佛一个永不退色的警世标签，警醒世人提防这种预想中的黑暗成为现实。历经几十年，其生命力日益强大，被誉为20世纪影响最为深远的文学经典之一。\"><a href=\"#《1984》是一部杰出的政治寓言小说，也是一部幻想小说。作品刻画了人类在极权主义社会的生存状态，仿佛一个永不退色的警世标签，警醒世人提防这种预想中的黑暗成为现实。历经几十年，其生命力日益强大，被誉为20世纪影响最为深远的文学经典之一。\" class=\"headerlink\" title=\"　　《1984》是一部杰出的政治寓言小说，也是一部幻想小说。作品刻画了人类在极权主义社会的生存状态，仿佛一个永不退色的警世标签，警醒世人提防这种预想中的黑暗成为现实。历经几十年，其生命力日益强大，被誉为20世纪影响最为深远的文学经典之一。\"></a>　　《1984》是一部杰出的政治寓言小说，也是一部幻想小说。作品刻画了人类在极权主义社会的生存状态，仿佛一个永不退色的警世标签，警醒世人提防这种预想中的黑暗成为现实。历经几十年，其生命力日益强大，被誉为20世纪影响最为深远的文学经典之一。</h5><h2 id=\"笔记\"><a href=\"#笔记\" class=\"headerlink\" title=\"笔记\"></a>笔记</h2><h3 id=\"“战争就是和平-自由就是奴役-无知就是力量”\"><a href=\"#“战争就是和平-自由就是奴役-无知就是力量”\" class=\"headerlink\" title=\"　　“战争就是和平 自由就是奴役 无知就是力量”\"></a>　　“战争就是和平 自由就是奴役 无知就是力量”</h3><h3 id=\"“那个黑发姑娘穿过田野向他走来。她好像一下子就脱光了衣服，不屑地扔到一边。她的身体白皙光滑，却没有引起他的任何欲望，事实上，他几乎没怎么看她。此刻，他满心只是赞叹着她扔衣服的动作。那种优雅随意的态度似乎能摧毁整个文化、整个思想体系，这绝妙的一挥手似乎能把老大哥、党和思想警察一扫而光。这也是一个属于古老的时代的动作。温斯顿醒来时嘴上还念着“莎士比亚”这个词。”\"><a href=\"#“那个黑发姑娘穿过田野向他走来。她好像一下子就脱光了衣服，不屑地扔到一边。她的身体白皙光滑，却没有引起他的任何欲望，事实上，他几乎没怎么看她。此刻，他满心只是赞叹着她扔衣服的动作。那种优雅随意的态度似乎能摧毁整个文化、整个思想体系，这绝妙的一挥手似乎能把老大哥、党和思想警察一扫而光。这也是一个属于古老的时代的动作。温斯顿醒来时嘴上还念着“莎士比亚”这个词。”\" class=\"headerlink\" title=\"　　“那个黑发姑娘穿过田野向他走来。她好像一下子就脱光了衣服，不屑地扔到一边。她的身体白皙光滑，却没有引起他的任何欲望，事实上，他几乎没怎么看她。此刻，他满心只是赞叹着她扔衣服的动作。那种优雅随意的态度似乎能摧毁整个文化、整个思想体系，这绝妙的一挥手似乎能把老大哥、党和思想警察一扫而光。这也是一个属于古老的时代的动作。温斯顿醒来时嘴上还念着“莎士比亚”这个词。”\"></a>　　“那个黑发姑娘穿过田野向他走来。她好像一下子就脱光了衣服，不屑地扔到一边。她的身体白皙光滑，却没有引起他的任何欲望，事实上，他几乎没怎么看她。此刻，他满心只是赞叹着她扔衣服的动作。那种优雅随意的态度似乎能摧毁整个文化、整个思想体系，这绝妙的一挥手似乎能把老大哥、党和思想警察一扫而光。这也是一个属于古老的时代的动作。温斯顿醒来时嘴上还念着“莎士比亚”这个词。”</h3><h3 id=\"“控制过去就能控制未来，控制现在就能控制过去”\"><a href=\"#“控制过去就能控制未来，控制现在就能控制过去”\" class=\"headerlink\" title=\"　　“控制过去就能控制未来，控制现在就能控制过去”\"></a>　　“控制过去就能控制未来，控制现在就能控制过去”</h3><h3 id=\"“眼前的真理就是永远的真理。很简单。所需的只是不断战胜自己的记忆而已。他们称它为“现实控制”，用新话说就是“双重思想”。”\"><a href=\"#“眼前的真理就是永远的真理。很简单。所需的只是不断战胜自己的记忆而已。他们称它为“现实控制”，用新话说就是“双重思想”。”\" class=\"headerlink\" title=\"　　“眼前的真理就是永远的真理。很简单。所需的只是不断战胜自己的记忆而已。他们称它为“现实控制”，用新话说就是“双重思想”。”\"></a>　　“眼前的真理就是永远的真理。很简单。所需的只是不断战胜自己的记忆而已。他们称它为“现实控制”，用新话说就是“双重思想”。”</h3><h3 id=\"“用逻辑否定逻辑，既否认道德又维护道德，既相信民主的不可能又相信党是民主的卫士；”\"><a href=\"#“用逻辑否定逻辑，既否认道德又维护道德，既相信民主的不可能又相信党是民主的卫士；”\" class=\"headerlink\" title=\"　　“用逻辑否定逻辑，既否认道德又维护道德，既相信民主的不可能又相信党是民主的卫士；”\"></a>　　“用逻辑否定逻辑，既否认道德又维护道德，既相信民主的不可能又相信党是民主的卫士；”</h3><h3 id=\"““我讨厌纯洁，我讨厌善良！我讨厌任何美德的存在。我要让每个人都坏到骨子里去。””\"><a href=\"#““我讨厌纯洁，我讨厌善良！我讨厌任何美德的存在。我要让每个人都坏到骨子里去。””\" class=\"headerlink\" title=\"　　““我讨厌纯洁，我讨厌善良！我讨厌任何美德的存在。我要让每个人都坏到骨子里去。””\"></a>　　““我讨厌纯洁，我讨厌善良！我讨厌任何美德的存在。我要让每个人都坏到骨子里去。””</h3><h3 id=\"“如果你遵守小的规定就可以违反大的规定。”\"><a href=\"#“如果你遵守小的规定就可以违反大的规定。”\" class=\"headerlink\" title=\"　　“如果你遵守小的规定就可以违反大的规定。”\"></a>　　“如果你遵守小的规定就可以违反大的规定。”</h3><h3 id=\"“下等人的永久特征就是被劳役所压垮，以至于只能断断续续地认识到他们日常生活以外的东西——就是消除一切差别，建立一个人人平等的社会”\"><a href=\"#“下等人的永久特征就是被劳役所压垮，以至于只能断断续续地认识到他们日常生活以外的东西——就是消除一切差别，建立一个人人平等的社会”\" class=\"headerlink\" title=\"　　“下等人的永久特征就是被劳役所压垮，以至于只能断断续续地认识到他们日常生活以外的东西——就是消除一切差别，建立一个人人平等的社会”\"></a>　　“下等人的永久特征就是被劳役所压垮，以至于只能断断续续地认识到他们日常生活以外的东西——就是消除一切差别，建立一个人人平等的社会”</h3><h3 id=\"“双重思想是英社的核心，因为党的主要行为就是故意欺骗，同时保持目标明确，毫不动摇，貌像完全诚实。故意撒谎又真诚地相信谎言；忘记不利的事实，必要的时候将它从遗忘中唤起，用完以后又立即忘记；否认客观现实的存在，同时又顾及被否认的事实——所有这些都必不可少。”\"><a href=\"#“双重思想是英社的核心，因为党的主要行为就是故意欺骗，同时保持目标明确，毫不动摇，貌像完全诚实。故意撒谎又真诚地相信谎言；忘记不利的事实，必要的时候将它从遗忘中唤起，用完以后又立即忘记；否认客观现实的存在，同时又顾及被否认的事实——所有这些都必不可少。”\" class=\"headerlink\" title=\"　　“双重思想是英社的核心，因为党的主要行为就是故意欺骗，同时保持目标明确，毫不动摇，貌像完全诚实。故意撒谎又真诚地相信谎言；忘记不利的事实，必要的时候将它从遗忘中唤起，用完以后又立即忘记；否认客观现实的存在，同时又顾及被否认的事实——所有这些都必不可少。”\"></a>　　“双重思想是英社的核心，因为党的主要行为就是故意欺骗，同时保持目标明确，毫不动摇，貌像完全诚实。故意撒谎又真诚地相信谎言；忘记不利的事实，必要的时候将它从遗忘中唤起，用完以后又立即忘记；否认客观现实的存在，同时又顾及被否认的事实——所有这些都必不可少。”</h3><h3 id=\"“只是一个无望的幻想，像一个转瞬即逝的四月天，可一个眼神、一句话语却唤起了我的梦想，我的心便从此不见！”\"><a href=\"#“只是一个无望的幻想，像一个转瞬即逝的四月天，可一个眼神、一句话语却唤起了我的梦想，我的心便从此不见！”\" class=\"headerlink\" title=\"　　“只是一个无望的幻想，像一个转瞬即逝的四月天，可一个眼神、一句话语却唤起了我的梦想，我的心便从此不见！”\"></a>　　“只是一个无望的幻想，像一个转瞬即逝的四月天，可一个眼神、一句话语却唤起了我的梦想，我的心便从此不见！”</h3>"},{"layout":"post","title":"zookeeper原理","date":"2016-11-30T16:00:00.000Z","_content":"\n##### ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，它包含一个简单的原语集，分布式应用程序可以基于它实现同步服务，配置维护和命名服务等。Zookeeper是hadoop的一个子项目，其发展历程无需赘述。在分布式应用中，由于工程师不能很好地使用锁机制，以及基于消息的协调机制不适合在某些应用中使用，因此需要有一种可靠的、可扩展的、分布式的、可配置的协调机制来统一系统的状态。Zookeeper的目的就在于此。本文简单分析zookeeper的工作原理，对于如何使用zookeeper不是本文讨论的重点。\n<!--more-->\n## 1 Zookeeper的基本概念\n### 1.1 角色\n\n##### Zookeeper中的角色主要有以下三类，如下表所示：\n![zookeeper角色](/img/zookeeper/role.jpg)\n\n##### 系统模型如图所示：\n![zookeeper系统模型](/img/zookeeper/zookeeperModel.jpg)\n\n\n### 1.2 设计目的\n\n1. 最终一致性：client不论连接到哪个Server，展示给它都是同一个视图，这是zookeeper最重要的性能。\n2. 可靠性：具有简单、健壮、良好的性能，如果消息m被到一台服务器接受，那么它将被所有的服务器接受。\n3. 实时性：Zookeeper保证客户端将在一个时间间隔范围内获得服务器的更新信息，或者服务器失效的信息。但由于网络延时等原因，Zookeeper不能保证两个客户端能同时得到刚更新的数据，如果需要最新数据，应该在读数据之前调用sync()接口。\n4. 等待无关（wait-free）：慢的或者失效的client不得干预快速的client的请求，使得每个client都能有效的等待。\n5. 原子性：更新只能成功或者失败，没有中间状态。\n6. 顺序性：包括全局有序和偏序两种：全局有序是指如果在一台服务器上消息a在消息b前发布，则在所有Server上消息a都将在消息b前被发布；偏序是指如果一个消息b在消息a后被同一个发送者发布，a必将排在b前面。\n\n## 2 ZooKeeper的工作原理\n##### Zookeeper的核心是原子广播，这个机制保证了各个Server之间的同步。实现这个机制的协议叫做Zab协议。Zab协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数Server完成了和leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和Server具有相同的系统状态。\n##### 为了保证事务的顺序一致性，zookeeper采用了递增的事务id号（zxid）来标识事务。所有的提议（proposal）都在被提出的时候加上了zxid。实现中zxid是一个64位的数字，它高32位是epoch用来标识leader关系是否改变，每次一个leader被选出来，它都会有一个新的epoch，标识当前属于那个leader的统治时期。低32位用于递增计数。\n##### 每个Server在工作过程中有三种状态：\n* LOOKING：当前Server不知道leader是谁，正在搜寻\n* LEADING：当前Server即为选举出来的leader\n* FOLLOWING：leader已经选举出来，当前Server与之同步\n\n### 2.1 选主流程\n\n##### 当leader崩溃或者leader失去大多数的follower，这时候zk进入恢复模式，恢复模式需要重新选举出一个新的leader，让所有的Server都恢复到一个正确的状态。Zk的选举算法有两种：一种是基于basic paxos实现的，另外一种是基于fast paxos算法实现的。系统默认的选举算法为fast paxos。先介绍basic paxos流程：\n1. 选举线程由当前Server发起选举的线程担任，其主要功能是对投票结果进行统计，并选出推荐的Server；\n2. 选举线程首先向所有Server发起一次询问(包括自己)；\n3. 选举线程收到回复后，验证是否是自己发起的询问(验证zxid是否一致)，然后获取对方的id(myid)，并存储到当前询问对象列表中，最后获取对方提议的leader相关信息(id,zxid)，并将这些信息存储到当次选举的投票记录表中；\n4. 收到所有Server回复以后，就计算出zxid最大的那个Server，并将这个Server相关信息设置成下一次要投票的Server；\n5. 线程将当前zxid最大的Server设置为当前Server要推荐的Leader，如果此时获胜的Server获得n/2 + 1的Server票数， 设置当前推荐的leader为获胜的Server，将根据获胜的Server相关信息设置自己的状态，否则，继续这个过程，直到leader被选举出来。\n\n##### 通过流程分析我们可以得出：要使Leader获得多数Server的支持，则Server总数必须是奇数2n+1，且存活的Server的数目不得少于n+1.\n##### 每个Server启动后都会重复以上流程。在恢复模式下，如果是刚从崩溃状态恢复的或者刚启动的server还会从磁盘快照中恢复数据和会话信息，zk会记录事务日志并定期进行快照，方便在恢复时进行状态恢复。选主的具体流程图如下所示：\n![zookeeper流程图](/img/zookeeper/zookeeperLc.jpg)\n\n##### fast paxos流程是在选举过程中，某Server首先向所有Server提议自己要成为leader，当其它Server收到提议以后，解决epoch和zxid的冲突，并接受对方的提议，然后向对方发送接受提议完成的消息，重复这个流程，最后一定能选举出Leader。其流程图如下所示：\n![zookeeper流程图](/img/zookeeper/zookeeperLc2.jpg)\n\n### 2.2 同步流程\n##### 选完leader以后，zk就进入状态同步过程。\n1. leader等待server连接；\n2. Follower连接leader，将最大的zxid发送给leader；\n3. Leader根据follower的zxid确定同步点；\n4. 完成同步后通知follower 已经成为uptodate状态；\n5. Follower收到uptodate消息后，又可以重新接受client的请求进行服务了。\n\n##### 流程图如下所示：\n![zookeeper流程图](/img/zookeeper/zookeeperLc3.jpg)\n\n### 2.3 工作流程\n#### 2.3.1 Leader工作流程\n##### Leader主要有三个功能：\n1. 恢复数据；\n2. 维持与Learner的心跳，接收Learner请求并判断Learner的请求消息类型；\n3. Learner的消息类型主要有PING消息、REQUEST消息、ACK消息、REVALIDATE消息，根据不同的消息类型，进行不同的处理。\n\n##### PING消息是指Learner的心跳信息；REQUEST消息是Follower发送的提议信息，包括写请求及同步请求；ACK消息是Follower的对提议的回复，超过半数的Follower通过，则commit该提议；REVALIDATE消息是用来延长SESSION有效时间。\n##### Leader的工作流程简图如下所示，在实际实现中，流程要比下图复杂得多，启动了三个线程来实现功能。\n![zookeeper流程图](/img/zookeeper/zookeeperLc4.jpg)\n\n#### 2.3.2 Follower工作流程\n##### Follower主要有四个功能：\n1. 向Leader发送请求（PING消息、REQUEST消息、ACK消息、REVALIDATE消息）；\n2. 接收Leader消息并进行处理；\n3. 接收Client的请求，如果为写请求，发送给Leader进行投票；\n4. 返回Client结果。\n\n##### Follower的消息循环处理如下几种来自Leader的消息：\n1. PING消息： 心跳消息；\n2. PROPOSAL消息：Leader发起的提案，要求Follower投票；\n3. COMMIT消息：服务器端最新一次提案的信息；\n4. UPTODATE消息：表明同步完成；\n5. REVALIDATE消息：根据Leader的REVALIDATE结果，关闭待revalidate的session还是允许其接受消息；\n6. SYNC消息：返回SYNC结果到客户端，这个消息最初由客户端发起，用来强制得到最新的更新。\n\n##### Follower的工作流程简图如下所示，在实际实现中，Follower是通过5个线程来实现功能的。\n![zookeeper流程图](/img/zookeeper/zookeeperLc5.jpg)\n\n##### 对于observer的流程不再叙述，observer流程和Follower的唯一不同的地方就是observer不会参加leader发起的投票。\n##### 主流应用场景：\n##### __Zookeeper的主流应用场景实现思路（除去官方示例）__ \n\n#### (1)配置管理\n##### 集中式的配置管理在应用集群中是非常常见的，一般商业公司内部都会实现一套集中的配置管理中心，应对不同的应用集群对于共享各自配置的需求，并且在配置变更时能够通知到集群中的每一个机器。\n##### Zookeeper很容易实现这种集中式的配置管理，比如将APP1的所有配置配置到/APP1 znode下，APP1所有机器一启动就对/APP1这个节点进行监控(zk.exist(\"/APP1\",true)),并且实现回调方法Watcher，那么在zookeeper上/APP1 znode节点下数据发生变化的时候，每个机器都会收到通知，Watcher方法将会被执行，那么应用再取下数据即可(zk.getData(\"/APP1\",false,null));\n##### 以上这个例子只是简单的粗颗粒度配置监控，细颗粒度的数据可以进行分层级监控，这一切都是可以设计和控制的。     \n![zookeeper流程图](/img/zookeeper/zookeeper1.jpg)\n\n#### (2)集群管理 \n##### 应用集群中，我们常常需要让每一个机器知道集群中（或依赖的其他某一个集群）哪些机器是活着的，并且在集群机器因为宕机，网络断链等原因能够不在人工介入的情况下迅速通知到每一个机器。\n##### Zookeeper同样很容易实现这个功能，比如我在zookeeper服务器端有一个znode叫/APP1SERVERS,那么集群中每一个机器启动的时候都去这个节点下创建一个EPHEMERAL类型的节点，比如server1创建/APP1SERVERS/SERVER1(可以使用ip,保证不重复)，server2创建/APP1SERVERS/SERVER2，然后SERVER1和SERVER2都watch /APP1SERVERS这个父节点，那么也就是这个父节点下数据或者子节点变化都会通知对该节点进行watch的客户端。因为EPHEMERAL类型节点有一个很重要的特性，就是客户端和服务器端连接断掉或者session过期就会使节点消失，那么在某一个机器挂掉或者断链的时候，其对应的节点就会消失，然后集群中所有对/APP1SERVERS进行watch的客户端都会收到通知，然后取得最新列表即可。\n##### 另外有一个应用场景就是集群选master,一旦master挂掉能够马上能从slave中选出一个master,实现步骤和前者一样，只是机器在启动的时候在APP1SERVERS创建的节点类型变为EPHEMERAL_SEQUENTIAL类型，这样每个节点会自动被编号\n##### 我们默认规定编号最小的为master,所以当我们对/APP1SERVERS节点做监控的时候，得到服务器列表，只要所有集群机器逻辑认为最小编号节点为master，那么master就被选出，而这个master宕机的时候，相应的znode会消失，然后新的服务器列表就被推送到客户端，然后每个节点逻辑认为最小编号节点为master，这样就做到动态master选举。\n![zookeeper流程图](/img/zookeeper/zookeeper2.jpg)\n\n#### Zookeeper 监视（Watches） 简介\n##### Zookeeper C API 的声明和描述在 include/zookeeper.h 中可以找到，另外大部分的 Zookeeper C API 常量、结构体声明也在 zookeeper.h 中，如果如果你在使用 C API 是遇到不明白的地方，最好看看 zookeeper.h，或者自己使用 doxygen 生成 Zookeeper C API 的帮助文档。\n##### Zookeeper 中最有特色且最不容易理解的是监视(Watches)。Zookeeper 所有的读操作——getData(), getChildren(), 和 exists() 都 可以设置监视(watch)，监视事件可以理解为一次性的触发器， 官方定义如下： a watch event is one-time trigger, sent to the client that set the watch, which occurs when the data for which the watch was set changes。对此需要作出如下理解：\n* （一次性触发）One-time trigger\n\n##### 当设置监视的数据发生改变时，该监视事件会被发送到客户端，例如，如果客户端调用了 getData(\"/znode1\", true) 并且稍后 /znode1 节点上的数据发生了改变或者被删除了，客户端将会获取到 /znode1 发生变化的监视事件，而如果 /znode1 再一次发生了变化，除非客户端再次对 /znode1 设置监视，否则客户端不会收到事件通知。\n* （发送至客户端）Sent to the client\n\n##### Zookeeper 客户端和服务端是通过 socket 进行通信的，由于网络存在故障，所以监视事件很有可能不会成功地到达客户端，监视事件是异步发送至监视者的，Zookeeper 本身提供了保序性(ordering guarantee)：即客户端只有首先看到了监视事件后，才会感知到它所设置监视的 znode 发生了变化(a client will never see a change for which it has set a watch until it first sees the watch event). 网络延迟或者其他因素可能导致不同的客户端在不同的时刻感知某一监视事件，但是不同的客户端所看到的一切具有一致的顺序。\n* （被设置 watch 的数据）The data for which the watch was set\n\n##### 这意味着 znode 节点本身具有不同的改变方式。你也可以想象 Zookeeper 维护了两条监视链表：数据监视和子节点监视(data watches and child watches) getData() and exists() 设置数据监视，getChildren() 设置子节点监视。 或者，你也可以想象 Zookeeper 设置的不同监视返回不同的数据，getData() 和 exists() 返回 znode 节点的相关信息，而 getChildren() 返回子节点列表。因此， setData() 会触发设置在某一节点上所设置的数据监视(假定数据设置成功)，而一次成功的 create() 操作则会出发当前节点上所设置的数据监视以及父节点的子节点监视。一次成功的 delete() 操作将会触发当前节点的数据监视和子节点监视事件，同时也会触发该节点父节点的child watch。\n##### Zookeeper 中的监视是轻量级的，因此容易设置、维护和分发。当客户端与 Zookeeper 服务器端失去联系时，客户端并不会收到监视事件的通知，只有当客户端重新连接后，若在必要的情况下，以前注册的监视会重新被注册并触发，对于开发人员来说 这通常是透明的。只有一种情况会导致监视事件的丢失，即：通过 exists() 设置了某个 znode 节点的监视，但是如果某个客户端在此 znode 节点被创建和删除的时间间隔内与 zookeeper 服务器失去了联系，该客户端即使稍后重新连接 zookeeper服务器后也得不到事件通知。\n\n### Zookeeper C API 常量与部分结构(struct)介绍\n\n#### 与 ACL 相关的结构与常量：\n##### struct Id 结构为：\n```\nstruct Id {     char * scheme;     char * id; };\n```\n##### struct ACL 结构为：\n```\nstruct ACL {     int32_t perms;     struct Id id; };\n```\n##### struct ACL_vector 结构为：\n```\nstruct ACL_vector {     int32_t count;     struct ACL *data; };\n```\n##### 与 znode 访问权限有关的常量\n* const int ZOO_PERM_READ; //允许客户端读取 znode 节点的值以及子节点列表。\n* const int ZOO_PERM_WRITE;// 允许客户端设置 znode 节点的值。\n* const int ZOO_PERM_CREATE; //允许客户端在该 znode 节点下创建子节点。\n* const int ZOO_PERM_DELETE;//允许客户端删除子节点。\n* const int ZOO_PERM_ADMIN; //允许客户端执行 set_acl()。\n* const int ZOO_PERM_ALL;//允许客户端执行所有操作，等价与上述所有标志的或(OR) 。\n\n##### 与 ACL IDs 相关的常量\n* struct Id ZOO_ANYONE_ID_UNSAFE; //(‘world’,’anyone’)\n* struct Id ZOO_AUTH_IDS;// (‘auth’,’’)\n\n##### 三种标准的 ACL\n* struct ACL_vector ZOO_OPEN_ACL_UNSAFE; //(ZOO_PERM_ALL,ZOO_ANYONE_ID_UNSAFE)\n* struct ACL_vector ZOO_READ_ACL_UNSAFE;// (ZOO_PERM_READ, ZOO_ANYONE_ID_UNSAFE)\n* struct ACL_vector ZOO_CREATOR_ALL_ACL; //(ZOO_PERM_ALL,ZOO_AUTH_IDS)\n\n#### 与 Interest 相关的常量：ZOOKEEPER_WRITE, ZOOKEEPER_READ\n##### 这两个常量用于标识感兴趣的事件并通知zookeeper发生了哪些事件。Interest 常量可以进行组合或（OR）来标识多种兴趣(multiple interests: write, read)，这两个常量一般用于 zookeeper_interest() 和 zookeeper_process()两个函数中。\n\n#### 与节点创建相关的常量：ZOO_EPHEMERAL, ZOO_SEQUENCE\n##### zoo_create 函数标志，ZOO_EPHEMERAL 用来标识创建临时节点，ZOO_SEQUENCE 用来标识节点命名具有递增的后缀序号(一般是节点名称后填充 10 位字符的序号，如 /xyz0000000000, /xyz0000000001, /xyz0000000002, ...)，同样地，ZOO_EPHEMERAL, ZOO_SEQUENCE 可以组合。\n\n#### 与连接状态 Stat 相关的常量\n\n##### 以下常量均与 Zookeeper 连接状态有关，他们通常用作监视器回调函数的参数。\n\n| ZOOAPI const int | ZOO_EXPIRED_SESSION_STATE |\n|:-----------------|:--------------------------|\n| ZOOAPI const int |     ZOO_AUTH_FAILED_STATE |\n| ZOOAPI const int |      ZOO_CONNECTING_STATE |\n| ZOOAPI const int |     ZOO_ASSOCIATING_STATE |\n| ZOOAPI const int |       ZOO_CONNECTED_STATE |\n\n#### 与监视类型(Watch Types)相关的常量\n\n##### 以下常量标识监视事件的类型，他们通常用作监视器回调函数的第一个参数。\n* ZOO_CREATED_EVENT; // 节点被创建(此前该节点不存在)，通过 zoo_exists() 设置监视。\n* ZOO_DELETED_EVENT; // 节点被删除，通过 zoo_exists() 和 zoo_get() 设置监视。\n* ZOO_CHANGED_EVENT; // 节点发生变化，通过 zoo_exists() 和 zoo_get() 设置监视。\n* ZOO_CHILD_EVENT; // 子节点事件，通过zoo_get_children() 和 zoo_get_children2()设置监视。\n* ZOO_SESSION_EVENT; // 会话丢失\n* ZOO_NOTWATCHING_EVENT; // 监视被移除。\n\n#### Zookeeper C API 错误码介绍 ZOO_ERRORS\n\nZOK | 正常返回\n----|--------\nZSYSTEMERROR | 系统或服务器端错误(System and server-side errors)，服务器不会抛出该错误，该错误也只是用来标识错误范围的，即大于该错误值，且小于 ZAPIERROR 都是系统错误。\nZRUNTIMEINCONSISTENCY | 运行时非一致性错误。\nZDATAINCONSISTENCY | 数据非一致性错误。\nZCONNECTIONLOSS | Zookeeper 客户端与服务器端失去连接\nZMARSHALLINGERROR | 在 marshalling 和 unmarshalling 数据时出现错误(Error while marshalling or unmarshalling data)\nZUNIMPLEMENTED | 该操作未实现(Operation is unimplemented)\nZOPERATIONTIMEOUT | 该操作超时(Operation timeout)\nZBADARGUMENTS | 非法参数错误(Invalid arguments)\nZINVALIDSTATE | 非法句柄状态(Invliad zhandle state)\nZAPIERROR | API 错误(API errors)，服务器不会抛出该错误，该错误也只是用来标识错误范围的，错误值大于该值的标识 API 错误，而小于该值的标识 ZSYSTEMERROR。\nZNONODE | 节点不存在(Node does not exist)\nZNOAUTH | 没有经过授权(Not authenticated)\nZBADVERSION | 版本冲突(Version conflict)\nZNOCHILDRENFOREPHEMERALS | 临时节点不能拥有子节点(Ephemeral nodes may not have children)\nZNODEEXISTS | 节点已经存在(The node already exists)\nZNOTEMPTY | 该节点具有自身的子节点(The node has children)\nZSESSIONEXPIRED | 会话过期(The session has been expired by the server)\nZINVALIDCALLBACK | 非法的回调函数(Invalid callback specified)\nZINVALIDACL | 非法的ACL(Invalid ACL specified)\nZAUTHFAILED | 客户端授权失败(Client authentication failed)\nZCLOSING | Zookeeper 连接关闭(ZooKeeper is closing)\nZNOTHING | 并非错误，客户端不需要处理服务器的响应(not error, no server responses to process)\nZSESSIONMOVED | 会话转移至其他服务器，所以操作被忽略(session moved to another server, so operation is ignored) \n\n##### Watch事件类型：\n* ZOO_CREATED_EVENT：节点创建事件，需要watch一个不存在的节点，当节点被创建时触发，此watch通过zoo_exists()设置\n* ZOO_DELETED_EVENT：节点删除事件，此watch通过zoo_exists()或zoo_get()设置\n* ZOO_CHANGED_EVENT：节点数据改变事件，此watch通过zoo_exists()或zoo_get()设置\n* ZOO_CHILD_EVENT：子节点列表改变事件，此watch通过zoo_get_children()或zoo_get_children2()设置\n* ZOO_SESSION_EVENT：会话失效事件，客户端与服务端断开或重连时触发\n* ZOO_NOTWATCHING_EVENT：watch移除事件，服务端出于某些原因不再为客户端watch节点时触发","source":"_posts/note/zookeeper.md","raw":"---\nlayout: post\ntitle: zookeeper原理\ndate: 2016/12/01\ntags: [tech, index]\n---\n\n##### ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，它包含一个简单的原语集，分布式应用程序可以基于它实现同步服务，配置维护和命名服务等。Zookeeper是hadoop的一个子项目，其发展历程无需赘述。在分布式应用中，由于工程师不能很好地使用锁机制，以及基于消息的协调机制不适合在某些应用中使用，因此需要有一种可靠的、可扩展的、分布式的、可配置的协调机制来统一系统的状态。Zookeeper的目的就在于此。本文简单分析zookeeper的工作原理，对于如何使用zookeeper不是本文讨论的重点。\n<!--more-->\n## 1 Zookeeper的基本概念\n### 1.1 角色\n\n##### Zookeeper中的角色主要有以下三类，如下表所示：\n![zookeeper角色](/img/zookeeper/role.jpg)\n\n##### 系统模型如图所示：\n![zookeeper系统模型](/img/zookeeper/zookeeperModel.jpg)\n\n\n### 1.2 设计目的\n\n1. 最终一致性：client不论连接到哪个Server，展示给它都是同一个视图，这是zookeeper最重要的性能。\n2. 可靠性：具有简单、健壮、良好的性能，如果消息m被到一台服务器接受，那么它将被所有的服务器接受。\n3. 实时性：Zookeeper保证客户端将在一个时间间隔范围内获得服务器的更新信息，或者服务器失效的信息。但由于网络延时等原因，Zookeeper不能保证两个客户端能同时得到刚更新的数据，如果需要最新数据，应该在读数据之前调用sync()接口。\n4. 等待无关（wait-free）：慢的或者失效的client不得干预快速的client的请求，使得每个client都能有效的等待。\n5. 原子性：更新只能成功或者失败，没有中间状态。\n6. 顺序性：包括全局有序和偏序两种：全局有序是指如果在一台服务器上消息a在消息b前发布，则在所有Server上消息a都将在消息b前被发布；偏序是指如果一个消息b在消息a后被同一个发送者发布，a必将排在b前面。\n\n## 2 ZooKeeper的工作原理\n##### Zookeeper的核心是原子广播，这个机制保证了各个Server之间的同步。实现这个机制的协议叫做Zab协议。Zab协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数Server完成了和leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和Server具有相同的系统状态。\n##### 为了保证事务的顺序一致性，zookeeper采用了递增的事务id号（zxid）来标识事务。所有的提议（proposal）都在被提出的时候加上了zxid。实现中zxid是一个64位的数字，它高32位是epoch用来标识leader关系是否改变，每次一个leader被选出来，它都会有一个新的epoch，标识当前属于那个leader的统治时期。低32位用于递增计数。\n##### 每个Server在工作过程中有三种状态：\n* LOOKING：当前Server不知道leader是谁，正在搜寻\n* LEADING：当前Server即为选举出来的leader\n* FOLLOWING：leader已经选举出来，当前Server与之同步\n\n### 2.1 选主流程\n\n##### 当leader崩溃或者leader失去大多数的follower，这时候zk进入恢复模式，恢复模式需要重新选举出一个新的leader，让所有的Server都恢复到一个正确的状态。Zk的选举算法有两种：一种是基于basic paxos实现的，另外一种是基于fast paxos算法实现的。系统默认的选举算法为fast paxos。先介绍basic paxos流程：\n1. 选举线程由当前Server发起选举的线程担任，其主要功能是对投票结果进行统计，并选出推荐的Server；\n2. 选举线程首先向所有Server发起一次询问(包括自己)；\n3. 选举线程收到回复后，验证是否是自己发起的询问(验证zxid是否一致)，然后获取对方的id(myid)，并存储到当前询问对象列表中，最后获取对方提议的leader相关信息(id,zxid)，并将这些信息存储到当次选举的投票记录表中；\n4. 收到所有Server回复以后，就计算出zxid最大的那个Server，并将这个Server相关信息设置成下一次要投票的Server；\n5. 线程将当前zxid最大的Server设置为当前Server要推荐的Leader，如果此时获胜的Server获得n/2 + 1的Server票数， 设置当前推荐的leader为获胜的Server，将根据获胜的Server相关信息设置自己的状态，否则，继续这个过程，直到leader被选举出来。\n\n##### 通过流程分析我们可以得出：要使Leader获得多数Server的支持，则Server总数必须是奇数2n+1，且存活的Server的数目不得少于n+1.\n##### 每个Server启动后都会重复以上流程。在恢复模式下，如果是刚从崩溃状态恢复的或者刚启动的server还会从磁盘快照中恢复数据和会话信息，zk会记录事务日志并定期进行快照，方便在恢复时进行状态恢复。选主的具体流程图如下所示：\n![zookeeper流程图](/img/zookeeper/zookeeperLc.jpg)\n\n##### fast paxos流程是在选举过程中，某Server首先向所有Server提议自己要成为leader，当其它Server收到提议以后，解决epoch和zxid的冲突，并接受对方的提议，然后向对方发送接受提议完成的消息，重复这个流程，最后一定能选举出Leader。其流程图如下所示：\n![zookeeper流程图](/img/zookeeper/zookeeperLc2.jpg)\n\n### 2.2 同步流程\n##### 选完leader以后，zk就进入状态同步过程。\n1. leader等待server连接；\n2. Follower连接leader，将最大的zxid发送给leader；\n3. Leader根据follower的zxid确定同步点；\n4. 完成同步后通知follower 已经成为uptodate状态；\n5. Follower收到uptodate消息后，又可以重新接受client的请求进行服务了。\n\n##### 流程图如下所示：\n![zookeeper流程图](/img/zookeeper/zookeeperLc3.jpg)\n\n### 2.3 工作流程\n#### 2.3.1 Leader工作流程\n##### Leader主要有三个功能：\n1. 恢复数据；\n2. 维持与Learner的心跳，接收Learner请求并判断Learner的请求消息类型；\n3. Learner的消息类型主要有PING消息、REQUEST消息、ACK消息、REVALIDATE消息，根据不同的消息类型，进行不同的处理。\n\n##### PING消息是指Learner的心跳信息；REQUEST消息是Follower发送的提议信息，包括写请求及同步请求；ACK消息是Follower的对提议的回复，超过半数的Follower通过，则commit该提议；REVALIDATE消息是用来延长SESSION有效时间。\n##### Leader的工作流程简图如下所示，在实际实现中，流程要比下图复杂得多，启动了三个线程来实现功能。\n![zookeeper流程图](/img/zookeeper/zookeeperLc4.jpg)\n\n#### 2.3.2 Follower工作流程\n##### Follower主要有四个功能：\n1. 向Leader发送请求（PING消息、REQUEST消息、ACK消息、REVALIDATE消息）；\n2. 接收Leader消息并进行处理；\n3. 接收Client的请求，如果为写请求，发送给Leader进行投票；\n4. 返回Client结果。\n\n##### Follower的消息循环处理如下几种来自Leader的消息：\n1. PING消息： 心跳消息；\n2. PROPOSAL消息：Leader发起的提案，要求Follower投票；\n3. COMMIT消息：服务器端最新一次提案的信息；\n4. UPTODATE消息：表明同步完成；\n5. REVALIDATE消息：根据Leader的REVALIDATE结果，关闭待revalidate的session还是允许其接受消息；\n6. SYNC消息：返回SYNC结果到客户端，这个消息最初由客户端发起，用来强制得到最新的更新。\n\n##### Follower的工作流程简图如下所示，在实际实现中，Follower是通过5个线程来实现功能的。\n![zookeeper流程图](/img/zookeeper/zookeeperLc5.jpg)\n\n##### 对于observer的流程不再叙述，observer流程和Follower的唯一不同的地方就是observer不会参加leader发起的投票。\n##### 主流应用场景：\n##### __Zookeeper的主流应用场景实现思路（除去官方示例）__ \n\n#### (1)配置管理\n##### 集中式的配置管理在应用集群中是非常常见的，一般商业公司内部都会实现一套集中的配置管理中心，应对不同的应用集群对于共享各自配置的需求，并且在配置变更时能够通知到集群中的每一个机器。\n##### Zookeeper很容易实现这种集中式的配置管理，比如将APP1的所有配置配置到/APP1 znode下，APP1所有机器一启动就对/APP1这个节点进行监控(zk.exist(\"/APP1\",true)),并且实现回调方法Watcher，那么在zookeeper上/APP1 znode节点下数据发生变化的时候，每个机器都会收到通知，Watcher方法将会被执行，那么应用再取下数据即可(zk.getData(\"/APP1\",false,null));\n##### 以上这个例子只是简单的粗颗粒度配置监控，细颗粒度的数据可以进行分层级监控，这一切都是可以设计和控制的。     \n![zookeeper流程图](/img/zookeeper/zookeeper1.jpg)\n\n#### (2)集群管理 \n##### 应用集群中，我们常常需要让每一个机器知道集群中（或依赖的其他某一个集群）哪些机器是活着的，并且在集群机器因为宕机，网络断链等原因能够不在人工介入的情况下迅速通知到每一个机器。\n##### Zookeeper同样很容易实现这个功能，比如我在zookeeper服务器端有一个znode叫/APP1SERVERS,那么集群中每一个机器启动的时候都去这个节点下创建一个EPHEMERAL类型的节点，比如server1创建/APP1SERVERS/SERVER1(可以使用ip,保证不重复)，server2创建/APP1SERVERS/SERVER2，然后SERVER1和SERVER2都watch /APP1SERVERS这个父节点，那么也就是这个父节点下数据或者子节点变化都会通知对该节点进行watch的客户端。因为EPHEMERAL类型节点有一个很重要的特性，就是客户端和服务器端连接断掉或者session过期就会使节点消失，那么在某一个机器挂掉或者断链的时候，其对应的节点就会消失，然后集群中所有对/APP1SERVERS进行watch的客户端都会收到通知，然后取得最新列表即可。\n##### 另外有一个应用场景就是集群选master,一旦master挂掉能够马上能从slave中选出一个master,实现步骤和前者一样，只是机器在启动的时候在APP1SERVERS创建的节点类型变为EPHEMERAL_SEQUENTIAL类型，这样每个节点会自动被编号\n##### 我们默认规定编号最小的为master,所以当我们对/APP1SERVERS节点做监控的时候，得到服务器列表，只要所有集群机器逻辑认为最小编号节点为master，那么master就被选出，而这个master宕机的时候，相应的znode会消失，然后新的服务器列表就被推送到客户端，然后每个节点逻辑认为最小编号节点为master，这样就做到动态master选举。\n![zookeeper流程图](/img/zookeeper/zookeeper2.jpg)\n\n#### Zookeeper 监视（Watches） 简介\n##### Zookeeper C API 的声明和描述在 include/zookeeper.h 中可以找到，另外大部分的 Zookeeper C API 常量、结构体声明也在 zookeeper.h 中，如果如果你在使用 C API 是遇到不明白的地方，最好看看 zookeeper.h，或者自己使用 doxygen 生成 Zookeeper C API 的帮助文档。\n##### Zookeeper 中最有特色且最不容易理解的是监视(Watches)。Zookeeper 所有的读操作——getData(), getChildren(), 和 exists() 都 可以设置监视(watch)，监视事件可以理解为一次性的触发器， 官方定义如下： a watch event is one-time trigger, sent to the client that set the watch, which occurs when the data for which the watch was set changes。对此需要作出如下理解：\n* （一次性触发）One-time trigger\n\n##### 当设置监视的数据发生改变时，该监视事件会被发送到客户端，例如，如果客户端调用了 getData(\"/znode1\", true) 并且稍后 /znode1 节点上的数据发生了改变或者被删除了，客户端将会获取到 /znode1 发生变化的监视事件，而如果 /znode1 再一次发生了变化，除非客户端再次对 /znode1 设置监视，否则客户端不会收到事件通知。\n* （发送至客户端）Sent to the client\n\n##### Zookeeper 客户端和服务端是通过 socket 进行通信的，由于网络存在故障，所以监视事件很有可能不会成功地到达客户端，监视事件是异步发送至监视者的，Zookeeper 本身提供了保序性(ordering guarantee)：即客户端只有首先看到了监视事件后，才会感知到它所设置监视的 znode 发生了变化(a client will never see a change for which it has set a watch until it first sees the watch event). 网络延迟或者其他因素可能导致不同的客户端在不同的时刻感知某一监视事件，但是不同的客户端所看到的一切具有一致的顺序。\n* （被设置 watch 的数据）The data for which the watch was set\n\n##### 这意味着 znode 节点本身具有不同的改变方式。你也可以想象 Zookeeper 维护了两条监视链表：数据监视和子节点监视(data watches and child watches) getData() and exists() 设置数据监视，getChildren() 设置子节点监视。 或者，你也可以想象 Zookeeper 设置的不同监视返回不同的数据，getData() 和 exists() 返回 znode 节点的相关信息，而 getChildren() 返回子节点列表。因此， setData() 会触发设置在某一节点上所设置的数据监视(假定数据设置成功)，而一次成功的 create() 操作则会出发当前节点上所设置的数据监视以及父节点的子节点监视。一次成功的 delete() 操作将会触发当前节点的数据监视和子节点监视事件，同时也会触发该节点父节点的child watch。\n##### Zookeeper 中的监视是轻量级的，因此容易设置、维护和分发。当客户端与 Zookeeper 服务器端失去联系时，客户端并不会收到监视事件的通知，只有当客户端重新连接后，若在必要的情况下，以前注册的监视会重新被注册并触发，对于开发人员来说 这通常是透明的。只有一种情况会导致监视事件的丢失，即：通过 exists() 设置了某个 znode 节点的监视，但是如果某个客户端在此 znode 节点被创建和删除的时间间隔内与 zookeeper 服务器失去了联系，该客户端即使稍后重新连接 zookeeper服务器后也得不到事件通知。\n\n### Zookeeper C API 常量与部分结构(struct)介绍\n\n#### 与 ACL 相关的结构与常量：\n##### struct Id 结构为：\n```\nstruct Id {     char * scheme;     char * id; };\n```\n##### struct ACL 结构为：\n```\nstruct ACL {     int32_t perms;     struct Id id; };\n```\n##### struct ACL_vector 结构为：\n```\nstruct ACL_vector {     int32_t count;     struct ACL *data; };\n```\n##### 与 znode 访问权限有关的常量\n* const int ZOO_PERM_READ; //允许客户端读取 znode 节点的值以及子节点列表。\n* const int ZOO_PERM_WRITE;// 允许客户端设置 znode 节点的值。\n* const int ZOO_PERM_CREATE; //允许客户端在该 znode 节点下创建子节点。\n* const int ZOO_PERM_DELETE;//允许客户端删除子节点。\n* const int ZOO_PERM_ADMIN; //允许客户端执行 set_acl()。\n* const int ZOO_PERM_ALL;//允许客户端执行所有操作，等价与上述所有标志的或(OR) 。\n\n##### 与 ACL IDs 相关的常量\n* struct Id ZOO_ANYONE_ID_UNSAFE; //(‘world’,’anyone’)\n* struct Id ZOO_AUTH_IDS;// (‘auth’,’’)\n\n##### 三种标准的 ACL\n* struct ACL_vector ZOO_OPEN_ACL_UNSAFE; //(ZOO_PERM_ALL,ZOO_ANYONE_ID_UNSAFE)\n* struct ACL_vector ZOO_READ_ACL_UNSAFE;// (ZOO_PERM_READ, ZOO_ANYONE_ID_UNSAFE)\n* struct ACL_vector ZOO_CREATOR_ALL_ACL; //(ZOO_PERM_ALL,ZOO_AUTH_IDS)\n\n#### 与 Interest 相关的常量：ZOOKEEPER_WRITE, ZOOKEEPER_READ\n##### 这两个常量用于标识感兴趣的事件并通知zookeeper发生了哪些事件。Interest 常量可以进行组合或（OR）来标识多种兴趣(multiple interests: write, read)，这两个常量一般用于 zookeeper_interest() 和 zookeeper_process()两个函数中。\n\n#### 与节点创建相关的常量：ZOO_EPHEMERAL, ZOO_SEQUENCE\n##### zoo_create 函数标志，ZOO_EPHEMERAL 用来标识创建临时节点，ZOO_SEQUENCE 用来标识节点命名具有递增的后缀序号(一般是节点名称后填充 10 位字符的序号，如 /xyz0000000000, /xyz0000000001, /xyz0000000002, ...)，同样地，ZOO_EPHEMERAL, ZOO_SEQUENCE 可以组合。\n\n#### 与连接状态 Stat 相关的常量\n\n##### 以下常量均与 Zookeeper 连接状态有关，他们通常用作监视器回调函数的参数。\n\n| ZOOAPI const int | ZOO_EXPIRED_SESSION_STATE |\n|:-----------------|:--------------------------|\n| ZOOAPI const int |     ZOO_AUTH_FAILED_STATE |\n| ZOOAPI const int |      ZOO_CONNECTING_STATE |\n| ZOOAPI const int |     ZOO_ASSOCIATING_STATE |\n| ZOOAPI const int |       ZOO_CONNECTED_STATE |\n\n#### 与监视类型(Watch Types)相关的常量\n\n##### 以下常量标识监视事件的类型，他们通常用作监视器回调函数的第一个参数。\n* ZOO_CREATED_EVENT; // 节点被创建(此前该节点不存在)，通过 zoo_exists() 设置监视。\n* ZOO_DELETED_EVENT; // 节点被删除，通过 zoo_exists() 和 zoo_get() 设置监视。\n* ZOO_CHANGED_EVENT; // 节点发生变化，通过 zoo_exists() 和 zoo_get() 设置监视。\n* ZOO_CHILD_EVENT; // 子节点事件，通过zoo_get_children() 和 zoo_get_children2()设置监视。\n* ZOO_SESSION_EVENT; // 会话丢失\n* ZOO_NOTWATCHING_EVENT; // 监视被移除。\n\n#### Zookeeper C API 错误码介绍 ZOO_ERRORS\n\nZOK | 正常返回\n----|--------\nZSYSTEMERROR | 系统或服务器端错误(System and server-side errors)，服务器不会抛出该错误，该错误也只是用来标识错误范围的，即大于该错误值，且小于 ZAPIERROR 都是系统错误。\nZRUNTIMEINCONSISTENCY | 运行时非一致性错误。\nZDATAINCONSISTENCY | 数据非一致性错误。\nZCONNECTIONLOSS | Zookeeper 客户端与服务器端失去连接\nZMARSHALLINGERROR | 在 marshalling 和 unmarshalling 数据时出现错误(Error while marshalling or unmarshalling data)\nZUNIMPLEMENTED | 该操作未实现(Operation is unimplemented)\nZOPERATIONTIMEOUT | 该操作超时(Operation timeout)\nZBADARGUMENTS | 非法参数错误(Invalid arguments)\nZINVALIDSTATE | 非法句柄状态(Invliad zhandle state)\nZAPIERROR | API 错误(API errors)，服务器不会抛出该错误，该错误也只是用来标识错误范围的，错误值大于该值的标识 API 错误，而小于该值的标识 ZSYSTEMERROR。\nZNONODE | 节点不存在(Node does not exist)\nZNOAUTH | 没有经过授权(Not authenticated)\nZBADVERSION | 版本冲突(Version conflict)\nZNOCHILDRENFOREPHEMERALS | 临时节点不能拥有子节点(Ephemeral nodes may not have children)\nZNODEEXISTS | 节点已经存在(The node already exists)\nZNOTEMPTY | 该节点具有自身的子节点(The node has children)\nZSESSIONEXPIRED | 会话过期(The session has been expired by the server)\nZINVALIDCALLBACK | 非法的回调函数(Invalid callback specified)\nZINVALIDACL | 非法的ACL(Invalid ACL specified)\nZAUTHFAILED | 客户端授权失败(Client authentication failed)\nZCLOSING | Zookeeper 连接关闭(ZooKeeper is closing)\nZNOTHING | 并非错误，客户端不需要处理服务器的响应(not error, no server responses to process)\nZSESSIONMOVED | 会话转移至其他服务器，所以操作被忽略(session moved to another server, so operation is ignored) \n\n##### Watch事件类型：\n* ZOO_CREATED_EVENT：节点创建事件，需要watch一个不存在的节点，当节点被创建时触发，此watch通过zoo_exists()设置\n* ZOO_DELETED_EVENT：节点删除事件，此watch通过zoo_exists()或zoo_get()设置\n* ZOO_CHANGED_EVENT：节点数据改变事件，此watch通过zoo_exists()或zoo_get()设置\n* ZOO_CHILD_EVENT：子节点列表改变事件，此watch通过zoo_get_children()或zoo_get_children2()设置\n* ZOO_SESSION_EVENT：会话失效事件，客户端与服务端断开或重连时触发\n* ZOO_NOTWATCHING_EVENT：watch移除事件，服务端出于某些原因不再为客户端watch节点时触发","slug":"note/zookeeper","published":1,"updated":"2018-05-08T13:00:14.285Z","comments":1,"photos":[],"link":"","_id":"cjgxop3la000hjah1idyauv3l","content":"<h5 id=\"ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，它包含一个简单的原语集，分布式应用程序可以基于它实现同步服务，配置维护和命名服务等。Zookeeper是hadoop的一个子项目，其发展历程无需赘述。在分布式应用中，由于工程师不能很好地使用锁机制，以及基于消息的协调机制不适合在某些应用中使用，因此需要有一种可靠的、可扩展的、分布式的、可配置的协调机制来统一系统的状态。Zookeeper的目的就在于此。本文简单分析zookeeper的工作原理，对于如何使用zookeeper不是本文讨论的重点。\"><a href=\"#ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，它包含一个简单的原语集，分布式应用程序可以基于它实现同步服务，配置维护和命名服务等。Zookeeper是hadoop的一个子项目，其发展历程无需赘述。在分布式应用中，由于工程师不能很好地使用锁机制，以及基于消息的协调机制不适合在某些应用中使用，因此需要有一种可靠的、可扩展的、分布式的、可配置的协调机制来统一系统的状态。Zookeeper的目的就在于此。本文简单分析zookeeper的工作原理，对于如何使用zookeeper不是本文讨论的重点。\" class=\"headerlink\" title=\"ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，它包含一个简单的原语集，分布式应用程序可以基于它实现同步服务，配置维护和命名服务等。Zookeeper是hadoop的一个子项目，其发展历程无需赘述。在分布式应用中，由于工程师不能很好地使用锁机制，以及基于消息的协调机制不适合在某些应用中使用，因此需要有一种可靠的、可扩展的、分布式的、可配置的协调机制来统一系统的状态。Zookeeper的目的就在于此。本文简单分析zookeeper的工作原理，对于如何使用zookeeper不是本文讨论的重点。\"></a>ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，它包含一个简单的原语集，分布式应用程序可以基于它实现同步服务，配置维护和命名服务等。Zookeeper是hadoop的一个子项目，其发展历程无需赘述。在分布式应用中，由于工程师不能很好地使用锁机制，以及基于消息的协调机制不适合在某些应用中使用，因此需要有一种可靠的、可扩展的、分布式的、可配置的协调机制来统一系统的状态。Zookeeper的目的就在于此。本文简单分析zookeeper的工作原理，对于如何使用zookeeper不是本文讨论的重点。</h5><a id=\"more\"></a>\n<h2 id=\"1-Zookeeper的基本概念\"><a href=\"#1-Zookeeper的基本概念\" class=\"headerlink\" title=\"1 Zookeeper的基本概念\"></a>1 Zookeeper的基本概念</h2><h3 id=\"1-1-角色\"><a href=\"#1-1-角色\" class=\"headerlink\" title=\"1.1 角色\"></a>1.1 角色</h3><h5 id=\"Zookeeper中的角色主要有以下三类，如下表所示：\"><a href=\"#Zookeeper中的角色主要有以下三类，如下表所示：\" class=\"headerlink\" title=\"Zookeeper中的角色主要有以下三类，如下表所示：\"></a>Zookeeper中的角色主要有以下三类，如下表所示：</h5><p><img src=\"/img/zookeeper/role.jpg\" alt=\"zookeeper角色\"></p>\n<h5 id=\"系统模型如图所示：\"><a href=\"#系统模型如图所示：\" class=\"headerlink\" title=\"系统模型如图所示：\"></a>系统模型如图所示：</h5><p><img src=\"/img/zookeeper/zookeeperModel.jpg\" alt=\"zookeeper系统模型\"></p>\n<h3 id=\"1-2-设计目的\"><a href=\"#1-2-设计目的\" class=\"headerlink\" title=\"1.2 设计目的\"></a>1.2 设计目的</h3><ol>\n<li>最终一致性：client不论连接到哪个Server，展示给它都是同一个视图，这是zookeeper最重要的性能。</li>\n<li>可靠性：具有简单、健壮、良好的性能，如果消息m被到一台服务器接受，那么它将被所有的服务器接受。</li>\n<li>实时性：Zookeeper保证客户端将在一个时间间隔范围内获得服务器的更新信息，或者服务器失效的信息。但由于网络延时等原因，Zookeeper不能保证两个客户端能同时得到刚更新的数据，如果需要最新数据，应该在读数据之前调用sync()接口。</li>\n<li>等待无关（wait-free）：慢的或者失效的client不得干预快速的client的请求，使得每个client都能有效的等待。</li>\n<li>原子性：更新只能成功或者失败，没有中间状态。</li>\n<li>顺序性：包括全局有序和偏序两种：全局有序是指如果在一台服务器上消息a在消息b前发布，则在所有Server上消息a都将在消息b前被发布；偏序是指如果一个消息b在消息a后被同一个发送者发布，a必将排在b前面。</li>\n</ol>\n<h2 id=\"2-ZooKeeper的工作原理\"><a href=\"#2-ZooKeeper的工作原理\" class=\"headerlink\" title=\"2 ZooKeeper的工作原理\"></a>2 ZooKeeper的工作原理</h2><h5 id=\"Zookeeper的核心是原子广播，这个机制保证了各个Server之间的同步。实现这个机制的协议叫做Zab协议。Zab协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数Server完成了和leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和Server具有相同的系统状态。\"><a href=\"#Zookeeper的核心是原子广播，这个机制保证了各个Server之间的同步。实现这个机制的协议叫做Zab协议。Zab协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数Server完成了和leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和Server具有相同的系统状态。\" class=\"headerlink\" title=\"Zookeeper的核心是原子广播，这个机制保证了各个Server之间的同步。实现这个机制的协议叫做Zab协议。Zab协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数Server完成了和leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和Server具有相同的系统状态。\"></a>Zookeeper的核心是原子广播，这个机制保证了各个Server之间的同步。实现这个机制的协议叫做Zab协议。Zab协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数Server完成了和leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和Server具有相同的系统状态。</h5><h5 id=\"为了保证事务的顺序一致性，zookeeper采用了递增的事务id号（zxid）来标识事务。所有的提议（proposal）都在被提出的时候加上了zxid。实现中zxid是一个64位的数字，它高32位是epoch用来标识leader关系是否改变，每次一个leader被选出来，它都会有一个新的epoch，标识当前属于那个leader的统治时期。低32位用于递增计数。\"><a href=\"#为了保证事务的顺序一致性，zookeeper采用了递增的事务id号（zxid）来标识事务。所有的提议（proposal）都在被提出的时候加上了zxid。实现中zxid是一个64位的数字，它高32位是epoch用来标识leader关系是否改变，每次一个leader被选出来，它都会有一个新的epoch，标识当前属于那个leader的统治时期。低32位用于递增计数。\" class=\"headerlink\" title=\"为了保证事务的顺序一致性，zookeeper采用了递增的事务id号（zxid）来标识事务。所有的提议（proposal）都在被提出的时候加上了zxid。实现中zxid是一个64位的数字，它高32位是epoch用来标识leader关系是否改变，每次一个leader被选出来，它都会有一个新的epoch，标识当前属于那个leader的统治时期。低32位用于递增计数。\"></a>为了保证事务的顺序一致性，zookeeper采用了递增的事务id号（zxid）来标识事务。所有的提议（proposal）都在被提出的时候加上了zxid。实现中zxid是一个64位的数字，它高32位是epoch用来标识leader关系是否改变，每次一个leader被选出来，它都会有一个新的epoch，标识当前属于那个leader的统治时期。低32位用于递增计数。</h5><h5 id=\"每个Server在工作过程中有三种状态：\"><a href=\"#每个Server在工作过程中有三种状态：\" class=\"headerlink\" title=\"每个Server在工作过程中有三种状态：\"></a>每个Server在工作过程中有三种状态：</h5><ul>\n<li>LOOKING：当前Server不知道leader是谁，正在搜寻</li>\n<li>LEADING：当前Server即为选举出来的leader</li>\n<li>FOLLOWING：leader已经选举出来，当前Server与之同步</li>\n</ul>\n<h3 id=\"2-1-选主流程\"><a href=\"#2-1-选主流程\" class=\"headerlink\" title=\"2.1 选主流程\"></a>2.1 选主流程</h3><h5 id=\"当leader崩溃或者leader失去大多数的follower，这时候zk进入恢复模式，恢复模式需要重新选举出一个新的leader，让所有的Server都恢复到一个正确的状态。Zk的选举算法有两种：一种是基于basic-paxos实现的，另外一种是基于fast-paxos算法实现的。系统默认的选举算法为fast-paxos。先介绍basic-paxos流程：\"><a href=\"#当leader崩溃或者leader失去大多数的follower，这时候zk进入恢复模式，恢复模式需要重新选举出一个新的leader，让所有的Server都恢复到一个正确的状态。Zk的选举算法有两种：一种是基于basic-paxos实现的，另外一种是基于fast-paxos算法实现的。系统默认的选举算法为fast-paxos。先介绍basic-paxos流程：\" class=\"headerlink\" title=\"当leader崩溃或者leader失去大多数的follower，这时候zk进入恢复模式，恢复模式需要重新选举出一个新的leader，让所有的Server都恢复到一个正确的状态。Zk的选举算法有两种：一种是基于basic paxos实现的，另外一种是基于fast paxos算法实现的。系统默认的选举算法为fast paxos。先介绍basic paxos流程：\"></a>当leader崩溃或者leader失去大多数的follower，这时候zk进入恢复模式，恢复模式需要重新选举出一个新的leader，让所有的Server都恢复到一个正确的状态。Zk的选举算法有两种：一种是基于basic paxos实现的，另外一种是基于fast paxos算法实现的。系统默认的选举算法为fast paxos。先介绍basic paxos流程：</h5><ol>\n<li>选举线程由当前Server发起选举的线程担任，其主要功能是对投票结果进行统计，并选出推荐的Server；</li>\n<li>选举线程首先向所有Server发起一次询问(包括自己)；</li>\n<li>选举线程收到回复后，验证是否是自己发起的询问(验证zxid是否一致)，然后获取对方的id(myid)，并存储到当前询问对象列表中，最后获取对方提议的leader相关信息(id,zxid)，并将这些信息存储到当次选举的投票记录表中；</li>\n<li>收到所有Server回复以后，就计算出zxid最大的那个Server，并将这个Server相关信息设置成下一次要投票的Server；</li>\n<li>线程将当前zxid最大的Server设置为当前Server要推荐的Leader，如果此时获胜的Server获得n/2 + 1的Server票数， 设置当前推荐的leader为获胜的Server，将根据获胜的Server相关信息设置自己的状态，否则，继续这个过程，直到leader被选举出来。</li>\n</ol>\n<h5 id=\"通过流程分析我们可以得出：要使Leader获得多数Server的支持，则Server总数必须是奇数2n-1，且存活的Server的数目不得少于n-1\"><a href=\"#通过流程分析我们可以得出：要使Leader获得多数Server的支持，则Server总数必须是奇数2n-1，且存活的Server的数目不得少于n-1\" class=\"headerlink\" title=\"通过流程分析我们可以得出：要使Leader获得多数Server的支持，则Server总数必须是奇数2n+1，且存活的Server的数目不得少于n+1.\"></a>通过流程分析我们可以得出：要使Leader获得多数Server的支持，则Server总数必须是奇数2n+1，且存活的Server的数目不得少于n+1.</h5><h5 id=\"每个Server启动后都会重复以上流程。在恢复模式下，如果是刚从崩溃状态恢复的或者刚启动的server还会从磁盘快照中恢复数据和会话信息，zk会记录事务日志并定期进行快照，方便在恢复时进行状态恢复。选主的具体流程图如下所示：\"><a href=\"#每个Server启动后都会重复以上流程。在恢复模式下，如果是刚从崩溃状态恢复的或者刚启动的server还会从磁盘快照中恢复数据和会话信息，zk会记录事务日志并定期进行快照，方便在恢复时进行状态恢复。选主的具体流程图如下所示：\" class=\"headerlink\" title=\"每个Server启动后都会重复以上流程。在恢复模式下，如果是刚从崩溃状态恢复的或者刚启动的server还会从磁盘快照中恢复数据和会话信息，zk会记录事务日志并定期进行快照，方便在恢复时进行状态恢复。选主的具体流程图如下所示：\"></a>每个Server启动后都会重复以上流程。在恢复模式下，如果是刚从崩溃状态恢复的或者刚启动的server还会从磁盘快照中恢复数据和会话信息，zk会记录事务日志并定期进行快照，方便在恢复时进行状态恢复。选主的具体流程图如下所示：</h5><p><img src=\"/img/zookeeper/zookeeperLc.jpg\" alt=\"zookeeper流程图\"></p>\n<h5 id=\"fast-paxos流程是在选举过程中，某Server首先向所有Server提议自己要成为leader，当其它Server收到提议以后，解决epoch和zxid的冲突，并接受对方的提议，然后向对方发送接受提议完成的消息，重复这个流程，最后一定能选举出Leader。其流程图如下所示：\"><a href=\"#fast-paxos流程是在选举过程中，某Server首先向所有Server提议自己要成为leader，当其它Server收到提议以后，解决epoch和zxid的冲突，并接受对方的提议，然后向对方发送接受提议完成的消息，重复这个流程，最后一定能选举出Leader。其流程图如下所示：\" class=\"headerlink\" title=\"fast paxos流程是在选举过程中，某Server首先向所有Server提议自己要成为leader，当其它Server收到提议以后，解决epoch和zxid的冲突，并接受对方的提议，然后向对方发送接受提议完成的消息，重复这个流程，最后一定能选举出Leader。其流程图如下所示：\"></a>fast paxos流程是在选举过程中，某Server首先向所有Server提议自己要成为leader，当其它Server收到提议以后，解决epoch和zxid的冲突，并接受对方的提议，然后向对方发送接受提议完成的消息，重复这个流程，最后一定能选举出Leader。其流程图如下所示：</h5><p><img src=\"/img/zookeeper/zookeeperLc2.jpg\" alt=\"zookeeper流程图\"></p>\n<h3 id=\"2-2-同步流程\"><a href=\"#2-2-同步流程\" class=\"headerlink\" title=\"2.2 同步流程\"></a>2.2 同步流程</h3><h5 id=\"选完leader以后，zk就进入状态同步过程。\"><a href=\"#选完leader以后，zk就进入状态同步过程。\" class=\"headerlink\" title=\"选完leader以后，zk就进入状态同步过程。\"></a>选完leader以后，zk就进入状态同步过程。</h5><ol>\n<li>leader等待server连接；</li>\n<li>Follower连接leader，将最大的zxid发送给leader；</li>\n<li>Leader根据follower的zxid确定同步点；</li>\n<li>完成同步后通知follower 已经成为uptodate状态；</li>\n<li>Follower收到uptodate消息后，又可以重新接受client的请求进行服务了。</li>\n</ol>\n<h5 id=\"流程图如下所示：\"><a href=\"#流程图如下所示：\" class=\"headerlink\" title=\"流程图如下所示：\"></a>流程图如下所示：</h5><p><img src=\"/img/zookeeper/zookeeperLc3.jpg\" alt=\"zookeeper流程图\"></p>\n<h3 id=\"2-3-工作流程\"><a href=\"#2-3-工作流程\" class=\"headerlink\" title=\"2.3 工作流程\"></a>2.3 工作流程</h3><h4 id=\"2-3-1-Leader工作流程\"><a href=\"#2-3-1-Leader工作流程\" class=\"headerlink\" title=\"2.3.1 Leader工作流程\"></a>2.3.1 Leader工作流程</h4><h5 id=\"Leader主要有三个功能：\"><a href=\"#Leader主要有三个功能：\" class=\"headerlink\" title=\"Leader主要有三个功能：\"></a>Leader主要有三个功能：</h5><ol>\n<li>恢复数据；</li>\n<li>维持与Learner的心跳，接收Learner请求并判断Learner的请求消息类型；</li>\n<li>Learner的消息类型主要有PING消息、REQUEST消息、ACK消息、REVALIDATE消息，根据不同的消息类型，进行不同的处理。</li>\n</ol>\n<h5 id=\"PING消息是指Learner的心跳信息；REQUEST消息是Follower发送的提议信息，包括写请求及同步请求；ACK消息是Follower的对提议的回复，超过半数的Follower通过，则commit该提议；REVALIDATE消息是用来延长SESSION有效时间。\"><a href=\"#PING消息是指Learner的心跳信息；REQUEST消息是Follower发送的提议信息，包括写请求及同步请求；ACK消息是Follower的对提议的回复，超过半数的Follower通过，则commit该提议；REVALIDATE消息是用来延长SESSION有效时间。\" class=\"headerlink\" title=\"PING消息是指Learner的心跳信息；REQUEST消息是Follower发送的提议信息，包括写请求及同步请求；ACK消息是Follower的对提议的回复，超过半数的Follower通过，则commit该提议；REVALIDATE消息是用来延长SESSION有效时间。\"></a>PING消息是指Learner的心跳信息；REQUEST消息是Follower发送的提议信息，包括写请求及同步请求；ACK消息是Follower的对提议的回复，超过半数的Follower通过，则commit该提议；REVALIDATE消息是用来延长SESSION有效时间。</h5><h5 id=\"Leader的工作流程简图如下所示，在实际实现中，流程要比下图复杂得多，启动了三个线程来实现功能。\"><a href=\"#Leader的工作流程简图如下所示，在实际实现中，流程要比下图复杂得多，启动了三个线程来实现功能。\" class=\"headerlink\" title=\"Leader的工作流程简图如下所示，在实际实现中，流程要比下图复杂得多，启动了三个线程来实现功能。\"></a>Leader的工作流程简图如下所示，在实际实现中，流程要比下图复杂得多，启动了三个线程来实现功能。</h5><p><img src=\"/img/zookeeper/zookeeperLc4.jpg\" alt=\"zookeeper流程图\"></p>\n<h4 id=\"2-3-2-Follower工作流程\"><a href=\"#2-3-2-Follower工作流程\" class=\"headerlink\" title=\"2.3.2 Follower工作流程\"></a>2.3.2 Follower工作流程</h4><h5 id=\"Follower主要有四个功能：\"><a href=\"#Follower主要有四个功能：\" class=\"headerlink\" title=\"Follower主要有四个功能：\"></a>Follower主要有四个功能：</h5><ol>\n<li>向Leader发送请求（PING消息、REQUEST消息、ACK消息、REVALIDATE消息）；</li>\n<li>接收Leader消息并进行处理；</li>\n<li>接收Client的请求，如果为写请求，发送给Leader进行投票；</li>\n<li>返回Client结果。</li>\n</ol>\n<h5 id=\"Follower的消息循环处理如下几种来自Leader的消息：\"><a href=\"#Follower的消息循环处理如下几种来自Leader的消息：\" class=\"headerlink\" title=\"Follower的消息循环处理如下几种来自Leader的消息：\"></a>Follower的消息循环处理如下几种来自Leader的消息：</h5><ol>\n<li>PING消息： 心跳消息；</li>\n<li>PROPOSAL消息：Leader发起的提案，要求Follower投票；</li>\n<li>COMMIT消息：服务器端最新一次提案的信息；</li>\n<li>UPTODATE消息：表明同步完成；</li>\n<li>REVALIDATE消息：根据Leader的REVALIDATE结果，关闭待revalidate的session还是允许其接受消息；</li>\n<li>SYNC消息：返回SYNC结果到客户端，这个消息最初由客户端发起，用来强制得到最新的更新。</li>\n</ol>\n<h5 id=\"Follower的工作流程简图如下所示，在实际实现中，Follower是通过5个线程来实现功能的。\"><a href=\"#Follower的工作流程简图如下所示，在实际实现中，Follower是通过5个线程来实现功能的。\" class=\"headerlink\" title=\"Follower的工作流程简图如下所示，在实际实现中，Follower是通过5个线程来实现功能的。\"></a>Follower的工作流程简图如下所示，在实际实现中，Follower是通过5个线程来实现功能的。</h5><p><img src=\"/img/zookeeper/zookeeperLc5.jpg\" alt=\"zookeeper流程图\"></p>\n<h5 id=\"对于observer的流程不再叙述，observer流程和Follower的唯一不同的地方就是observer不会参加leader发起的投票。\"><a href=\"#对于observer的流程不再叙述，observer流程和Follower的唯一不同的地方就是observer不会参加leader发起的投票。\" class=\"headerlink\" title=\"对于observer的流程不再叙述，observer流程和Follower的唯一不同的地方就是observer不会参加leader发起的投票。\"></a>对于observer的流程不再叙述，observer流程和Follower的唯一不同的地方就是observer不会参加leader发起的投票。</h5><h5 id=\"主流应用场景：\"><a href=\"#主流应用场景：\" class=\"headerlink\" title=\"主流应用场景：\"></a>主流应用场景：</h5><h5 id=\"Zookeeper的主流应用场景实现思路（除去官方示例）\"><a href=\"#Zookeeper的主流应用场景实现思路（除去官方示例）\" class=\"headerlink\" title=\"Zookeeper的主流应用场景实现思路（除去官方示例）\"></a><strong>Zookeeper的主流应用场景实现思路（除去官方示例）</strong></h5><h4 id=\"1-配置管理\"><a href=\"#1-配置管理\" class=\"headerlink\" title=\"(1)配置管理\"></a>(1)配置管理</h4><h5 id=\"集中式的配置管理在应用集群中是非常常见的，一般商业公司内部都会实现一套集中的配置管理中心，应对不同的应用集群对于共享各自配置的需求，并且在配置变更时能够通知到集群中的每一个机器。\"><a href=\"#集中式的配置管理在应用集群中是非常常见的，一般商业公司内部都会实现一套集中的配置管理中心，应对不同的应用集群对于共享各自配置的需求，并且在配置变更时能够通知到集群中的每一个机器。\" class=\"headerlink\" title=\"集中式的配置管理在应用集群中是非常常见的，一般商业公司内部都会实现一套集中的配置管理中心，应对不同的应用集群对于共享各自配置的需求，并且在配置变更时能够通知到集群中的每一个机器。\"></a>集中式的配置管理在应用集群中是非常常见的，一般商业公司内部都会实现一套集中的配置管理中心，应对不同的应用集群对于共享各自配置的需求，并且在配置变更时能够通知到集群中的每一个机器。</h5><h5 id=\"Zookeeper很容易实现这种集中式的配置管理，比如将APP1的所有配置配置到-APP1-znode下，APP1所有机器一启动就对-APP1这个节点进行监控-zk-exist-“-APP1”-true-并且实现回调方法Watcher，那么在zookeeper上-APP1-znode节点下数据发生变化的时候，每个机器都会收到通知，Watcher方法将会被执行，那么应用再取下数据即可-zk-getData-“-APP1”-false-null\"><a href=\"#Zookeeper很容易实现这种集中式的配置管理，比如将APP1的所有配置配置到-APP1-znode下，APP1所有机器一启动就对-APP1这个节点进行监控-zk-exist-“-APP1”-true-并且实现回调方法Watcher，那么在zookeeper上-APP1-znode节点下数据发生变化的时候，每个机器都会收到通知，Watcher方法将会被执行，那么应用再取下数据即可-zk-getData-“-APP1”-false-null\" class=\"headerlink\" title=\"Zookeeper很容易实现这种集中式的配置管理，比如将APP1的所有配置配置到/APP1 znode下，APP1所有机器一启动就对/APP1这个节点进行监控(zk.exist(“/APP1”,true)),并且实现回调方法Watcher，那么在zookeeper上/APP1 znode节点下数据发生变化的时候，每个机器都会收到通知，Watcher方法将会被执行，那么应用再取下数据即可(zk.getData(“/APP1”,false,null));\"></a>Zookeeper很容易实现这种集中式的配置管理，比如将APP1的所有配置配置到/APP1 znode下，APP1所有机器一启动就对/APP1这个节点进行监控(zk.exist(“/APP1”,true)),并且实现回调方法Watcher，那么在zookeeper上/APP1 znode节点下数据发生变化的时候，每个机器都会收到通知，Watcher方法将会被执行，那么应用再取下数据即可(zk.getData(“/APP1”,false,null));</h5><h5 id=\"以上这个例子只是简单的粗颗粒度配置监控，细颗粒度的数据可以进行分层级监控，这一切都是可以设计和控制的。\"><a href=\"#以上这个例子只是简单的粗颗粒度配置监控，细颗粒度的数据可以进行分层级监控，这一切都是可以设计和控制的。\" class=\"headerlink\" title=\"以上这个例子只是简单的粗颗粒度配置监控，细颗粒度的数据可以进行分层级监控，这一切都是可以设计和控制的。\"></a>以上这个例子只是简单的粗颗粒度配置监控，细颗粒度的数据可以进行分层级监控，这一切都是可以设计和控制的。</h5><p><img src=\"/img/zookeeper/zookeeper1.jpg\" alt=\"zookeeper流程图\"></p>\n<h4 id=\"2-集群管理\"><a href=\"#2-集群管理\" class=\"headerlink\" title=\"(2)集群管理\"></a>(2)集群管理</h4><h5 id=\"应用集群中，我们常常需要让每一个机器知道集群中（或依赖的其他某一个集群）哪些机器是活着的，并且在集群机器因为宕机，网络断链等原因能够不在人工介入的情况下迅速通知到每一个机器。\"><a href=\"#应用集群中，我们常常需要让每一个机器知道集群中（或依赖的其他某一个集群）哪些机器是活着的，并且在集群机器因为宕机，网络断链等原因能够不在人工介入的情况下迅速通知到每一个机器。\" class=\"headerlink\" title=\"应用集群中，我们常常需要让每一个机器知道集群中（或依赖的其他某一个集群）哪些机器是活着的，并且在集群机器因为宕机，网络断链等原因能够不在人工介入的情况下迅速通知到每一个机器。\"></a>应用集群中，我们常常需要让每一个机器知道集群中（或依赖的其他某一个集群）哪些机器是活着的，并且在集群机器因为宕机，网络断链等原因能够不在人工介入的情况下迅速通知到每一个机器。</h5><h5 id=\"Zookeeper同样很容易实现这个功能，比如我在zookeeper服务器端有一个znode叫-APP1SERVERS-那么集群中每一个机器启动的时候都去这个节点下创建一个EPHEMERAL类型的节点，比如server1创建-APP1SERVERS-SERVER1-可以使用ip-保证不重复-，server2创建-APP1SERVERS-SERVER2，然后SERVER1和SERVER2都watch-APP1SERVERS这个父节点，那么也就是这个父节点下数据或者子节点变化都会通知对该节点进行watch的客户端。因为EPHEMERAL类型节点有一个很重要的特性，就是客户端和服务器端连接断掉或者session过期就会使节点消失，那么在某一个机器挂掉或者断链的时候，其对应的节点就会消失，然后集群中所有对-APP1SERVERS进行watch的客户端都会收到通知，然后取得最新列表即可。\"><a href=\"#Zookeeper同样很容易实现这个功能，比如我在zookeeper服务器端有一个znode叫-APP1SERVERS-那么集群中每一个机器启动的时候都去这个节点下创建一个EPHEMERAL类型的节点，比如server1创建-APP1SERVERS-SERVER1-可以使用ip-保证不重复-，server2创建-APP1SERVERS-SERVER2，然后SERVER1和SERVER2都watch-APP1SERVERS这个父节点，那么也就是这个父节点下数据或者子节点变化都会通知对该节点进行watch的客户端。因为EPHEMERAL类型节点有一个很重要的特性，就是客户端和服务器端连接断掉或者session过期就会使节点消失，那么在某一个机器挂掉或者断链的时候，其对应的节点就会消失，然后集群中所有对-APP1SERVERS进行watch的客户端都会收到通知，然后取得最新列表即可。\" class=\"headerlink\" title=\"Zookeeper同样很容易实现这个功能，比如我在zookeeper服务器端有一个znode叫/APP1SERVERS,那么集群中每一个机器启动的时候都去这个节点下创建一个EPHEMERAL类型的节点，比如server1创建/APP1SERVERS/SERVER1(可以使用ip,保证不重复)，server2创建/APP1SERVERS/SERVER2，然后SERVER1和SERVER2都watch /APP1SERVERS这个父节点，那么也就是这个父节点下数据或者子节点变化都会通知对该节点进行watch的客户端。因为EPHEMERAL类型节点有一个很重要的特性，就是客户端和服务器端连接断掉或者session过期就会使节点消失，那么在某一个机器挂掉或者断链的时候，其对应的节点就会消失，然后集群中所有对/APP1SERVERS进行watch的客户端都会收到通知，然后取得最新列表即可。\"></a>Zookeeper同样很容易实现这个功能，比如我在zookeeper服务器端有一个znode叫/APP1SERVERS,那么集群中每一个机器启动的时候都去这个节点下创建一个EPHEMERAL类型的节点，比如server1创建/APP1SERVERS/SERVER1(可以使用ip,保证不重复)，server2创建/APP1SERVERS/SERVER2，然后SERVER1和SERVER2都watch /APP1SERVERS这个父节点，那么也就是这个父节点下数据或者子节点变化都会通知对该节点进行watch的客户端。因为EPHEMERAL类型节点有一个很重要的特性，就是客户端和服务器端连接断掉或者session过期就会使节点消失，那么在某一个机器挂掉或者断链的时候，其对应的节点就会消失，然后集群中所有对/APP1SERVERS进行watch的客户端都会收到通知，然后取得最新列表即可。</h5><h5 id=\"另外有一个应用场景就是集群选master-一旦master挂掉能够马上能从slave中选出一个master-实现步骤和前者一样，只是机器在启动的时候在APP1SERVERS创建的节点类型变为EPHEMERAL-SEQUENTIAL类型，这样每个节点会自动被编号\"><a href=\"#另外有一个应用场景就是集群选master-一旦master挂掉能够马上能从slave中选出一个master-实现步骤和前者一样，只是机器在启动的时候在APP1SERVERS创建的节点类型变为EPHEMERAL-SEQUENTIAL类型，这样每个节点会自动被编号\" class=\"headerlink\" title=\"另外有一个应用场景就是集群选master,一旦master挂掉能够马上能从slave中选出一个master,实现步骤和前者一样，只是机器在启动的时候在APP1SERVERS创建的节点类型变为EPHEMERAL_SEQUENTIAL类型，这样每个节点会自动被编号\"></a>另外有一个应用场景就是集群选master,一旦master挂掉能够马上能从slave中选出一个master,实现步骤和前者一样，只是机器在启动的时候在APP1SERVERS创建的节点类型变为EPHEMERAL_SEQUENTIAL类型，这样每个节点会自动被编号</h5><h5 id=\"我们默认规定编号最小的为master-所以当我们对-APP1SERVERS节点做监控的时候，得到服务器列表，只要所有集群机器逻辑认为最小编号节点为master，那么master就被选出，而这个master宕机的时候，相应的znode会消失，然后新的服务器列表就被推送到客户端，然后每个节点逻辑认为最小编号节点为master，这样就做到动态master选举。\"><a href=\"#我们默认规定编号最小的为master-所以当我们对-APP1SERVERS节点做监控的时候，得到服务器列表，只要所有集群机器逻辑认为最小编号节点为master，那么master就被选出，而这个master宕机的时候，相应的znode会消失，然后新的服务器列表就被推送到客户端，然后每个节点逻辑认为最小编号节点为master，这样就做到动态master选举。\" class=\"headerlink\" title=\"我们默认规定编号最小的为master,所以当我们对/APP1SERVERS节点做监控的时候，得到服务器列表，只要所有集群机器逻辑认为最小编号节点为master，那么master就被选出，而这个master宕机的时候，相应的znode会消失，然后新的服务器列表就被推送到客户端，然后每个节点逻辑认为最小编号节点为master，这样就做到动态master选举。\"></a>我们默认规定编号最小的为master,所以当我们对/APP1SERVERS节点做监控的时候，得到服务器列表，只要所有集群机器逻辑认为最小编号节点为master，那么master就被选出，而这个master宕机的时候，相应的znode会消失，然后新的服务器列表就被推送到客户端，然后每个节点逻辑认为最小编号节点为master，这样就做到动态master选举。</h5><p><img src=\"/img/zookeeper/zookeeper2.jpg\" alt=\"zookeeper流程图\"></p>\n<h4 id=\"Zookeeper-监视（Watches）-简介\"><a href=\"#Zookeeper-监视（Watches）-简介\" class=\"headerlink\" title=\"Zookeeper 监视（Watches） 简介\"></a>Zookeeper 监视（Watches） 简介</h4><h5 id=\"Zookeeper-C-API-的声明和描述在-include-zookeeper-h-中可以找到，另外大部分的-Zookeeper-C-API-常量、结构体声明也在-zookeeper-h-中，如果如果你在使用-C-API-是遇到不明白的地方，最好看看-zookeeper-h，或者自己使用-doxygen-生成-Zookeeper-C-API-的帮助文档。\"><a href=\"#Zookeeper-C-API-的声明和描述在-include-zookeeper-h-中可以找到，另外大部分的-Zookeeper-C-API-常量、结构体声明也在-zookeeper-h-中，如果如果你在使用-C-API-是遇到不明白的地方，最好看看-zookeeper-h，或者自己使用-doxygen-生成-Zookeeper-C-API-的帮助文档。\" class=\"headerlink\" title=\"Zookeeper C API 的声明和描述在 include/zookeeper.h 中可以找到，另外大部分的 Zookeeper C API 常量、结构体声明也在 zookeeper.h 中，如果如果你在使用 C API 是遇到不明白的地方，最好看看 zookeeper.h，或者自己使用 doxygen 生成 Zookeeper C API 的帮助文档。\"></a>Zookeeper C API 的声明和描述在 include/zookeeper.h 中可以找到，另外大部分的 Zookeeper C API 常量、结构体声明也在 zookeeper.h 中，如果如果你在使用 C API 是遇到不明白的地方，最好看看 zookeeper.h，或者自己使用 doxygen 生成 Zookeeper C API 的帮助文档。</h5><h5 id=\"Zookeeper-中最有特色且最不容易理解的是监视-Watches-。Zookeeper-所有的读操作——getData-getChildren-和-exists-都-可以设置监视-watch-，监视事件可以理解为一次性的触发器，-官方定义如下：-a-watch-event-is-one-time-trigger-sent-to-the-client-that-set-the-watch-which-occurs-when-the-data-for-which-the-watch-was-set-changes。对此需要作出如下理解：\"><a href=\"#Zookeeper-中最有特色且最不容易理解的是监视-Watches-。Zookeeper-所有的读操作——getData-getChildren-和-exists-都-可以设置监视-watch-，监视事件可以理解为一次性的触发器，-官方定义如下：-a-watch-event-is-one-time-trigger-sent-to-the-client-that-set-the-watch-which-occurs-when-the-data-for-which-the-watch-was-set-changes。对此需要作出如下理解：\" class=\"headerlink\" title=\"Zookeeper 中最有特色且最不容易理解的是监视(Watches)。Zookeeper 所有的读操作——getData(), getChildren(), 和 exists() 都 可以设置监视(watch)，监视事件可以理解为一次性的触发器， 官方定义如下： a watch event is one-time trigger, sent to the client that set the watch, which occurs when the data for which the watch was set changes。对此需要作出如下理解：\"></a>Zookeeper 中最有特色且最不容易理解的是监视(Watches)。Zookeeper 所有的读操作——getData(), getChildren(), 和 exists() 都 可以设置监视(watch)，监视事件可以理解为一次性的触发器， 官方定义如下： a watch event is one-time trigger, sent to the client that set the watch, which occurs when the data for which the watch was set changes。对此需要作出如下理解：</h5><ul>\n<li>（一次性触发）One-time trigger</li>\n</ul>\n<h5 id=\"当设置监视的数据发生改变时，该监视事件会被发送到客户端，例如，如果客户端调用了-getData-“-znode1”-true-并且稍后-znode1-节点上的数据发生了改变或者被删除了，客户端将会获取到-znode1-发生变化的监视事件，而如果-znode1-再一次发生了变化，除非客户端再次对-znode1-设置监视，否则客户端不会收到事件通知。\"><a href=\"#当设置监视的数据发生改变时，该监视事件会被发送到客户端，例如，如果客户端调用了-getData-“-znode1”-true-并且稍后-znode1-节点上的数据发生了改变或者被删除了，客户端将会获取到-znode1-发生变化的监视事件，而如果-znode1-再一次发生了变化，除非客户端再次对-znode1-设置监视，否则客户端不会收到事件通知。\" class=\"headerlink\" title=\"当设置监视的数据发生改变时，该监视事件会被发送到客户端，例如，如果客户端调用了 getData(“/znode1”, true) 并且稍后 /znode1 节点上的数据发生了改变或者被删除了，客户端将会获取到 /znode1 发生变化的监视事件，而如果 /znode1 再一次发生了变化，除非客户端再次对 /znode1 设置监视，否则客户端不会收到事件通知。\"></a>当设置监视的数据发生改变时，该监视事件会被发送到客户端，例如，如果客户端调用了 getData(“/znode1”, true) 并且稍后 /znode1 节点上的数据发生了改变或者被删除了，客户端将会获取到 /znode1 发生变化的监视事件，而如果 /znode1 再一次发生了变化，除非客户端再次对 /znode1 设置监视，否则客户端不会收到事件通知。</h5><ul>\n<li>（发送至客户端）Sent to the client</li>\n</ul>\n<h5 id=\"Zookeeper-客户端和服务端是通过-socket-进行通信的，由于网络存在故障，所以监视事件很有可能不会成功地到达客户端，监视事件是异步发送至监视者的，Zookeeper-本身提供了保序性-ordering-guarantee-：即客户端只有首先看到了监视事件后，才会感知到它所设置监视的-znode-发生了变化-a-client-will-never-see-a-change-for-which-it-has-set-a-watch-until-it-first-sees-the-watch-event-网络延迟或者其他因素可能导致不同的客户端在不同的时刻感知某一监视事件，但是不同的客户端所看到的一切具有一致的顺序。\"><a href=\"#Zookeeper-客户端和服务端是通过-socket-进行通信的，由于网络存在故障，所以监视事件很有可能不会成功地到达客户端，监视事件是异步发送至监视者的，Zookeeper-本身提供了保序性-ordering-guarantee-：即客户端只有首先看到了监视事件后，才会感知到它所设置监视的-znode-发生了变化-a-client-will-never-see-a-change-for-which-it-has-set-a-watch-until-it-first-sees-the-watch-event-网络延迟或者其他因素可能导致不同的客户端在不同的时刻感知某一监视事件，但是不同的客户端所看到的一切具有一致的顺序。\" class=\"headerlink\" title=\"Zookeeper 客户端和服务端是通过 socket 进行通信的，由于网络存在故障，所以监视事件很有可能不会成功地到达客户端，监视事件是异步发送至监视者的，Zookeeper 本身提供了保序性(ordering guarantee)：即客户端只有首先看到了监视事件后，才会感知到它所设置监视的 znode 发生了变化(a client will never see a change for which it has set a watch until it first sees the watch event). 网络延迟或者其他因素可能导致不同的客户端在不同的时刻感知某一监视事件，但是不同的客户端所看到的一切具有一致的顺序。\"></a>Zookeeper 客户端和服务端是通过 socket 进行通信的，由于网络存在故障，所以监视事件很有可能不会成功地到达客户端，监视事件是异步发送至监视者的，Zookeeper 本身提供了保序性(ordering guarantee)：即客户端只有首先看到了监视事件后，才会感知到它所设置监视的 znode 发生了变化(a client will never see a change for which it has set a watch until it first sees the watch event). 网络延迟或者其他因素可能导致不同的客户端在不同的时刻感知某一监视事件，但是不同的客户端所看到的一切具有一致的顺序。</h5><ul>\n<li>（被设置 watch 的数据）The data for which the watch was set</li>\n</ul>\n<h5 id=\"这意味着-znode-节点本身具有不同的改变方式。你也可以想象-Zookeeper-维护了两条监视链表：数据监视和子节点监视-data-watches-and-child-watches-getData-and-exists-设置数据监视，getChildren-设置子节点监视。-或者，你也可以想象-Zookeeper-设置的不同监视返回不同的数据，getData-和-exists-返回-znode-节点的相关信息，而-getChildren-返回子节点列表。因此，-setData-会触发设置在某一节点上所设置的数据监视-假定数据设置成功-，而一次成功的-create-操作则会出发当前节点上所设置的数据监视以及父节点的子节点监视。一次成功的-delete-操作将会触发当前节点的数据监视和子节点监视事件，同时也会触发该节点父节点的child-watch。\"><a href=\"#这意味着-znode-节点本身具有不同的改变方式。你也可以想象-Zookeeper-维护了两条监视链表：数据监视和子节点监视-data-watches-and-child-watches-getData-and-exists-设置数据监视，getChildren-设置子节点监视。-或者，你也可以想象-Zookeeper-设置的不同监视返回不同的数据，getData-和-exists-返回-znode-节点的相关信息，而-getChildren-返回子节点列表。因此，-setData-会触发设置在某一节点上所设置的数据监视-假定数据设置成功-，而一次成功的-create-操作则会出发当前节点上所设置的数据监视以及父节点的子节点监视。一次成功的-delete-操作将会触发当前节点的数据监视和子节点监视事件，同时也会触发该节点父节点的child-watch。\" class=\"headerlink\" title=\"这意味着 znode 节点本身具有不同的改变方式。你也可以想象 Zookeeper 维护了两条监视链表：数据监视和子节点监视(data watches and child watches) getData() and exists() 设置数据监视，getChildren() 设置子节点监视。 或者，你也可以想象 Zookeeper 设置的不同监视返回不同的数据，getData() 和 exists() 返回 znode 节点的相关信息，而 getChildren() 返回子节点列表。因此， setData() 会触发设置在某一节点上所设置的数据监视(假定数据设置成功)，而一次成功的 create() 操作则会出发当前节点上所设置的数据监视以及父节点的子节点监视。一次成功的 delete() 操作将会触发当前节点的数据监视和子节点监视事件，同时也会触发该节点父节点的child watch。\"></a>这意味着 znode 节点本身具有不同的改变方式。你也可以想象 Zookeeper 维护了两条监视链表：数据监视和子节点监视(data watches and child watches) getData() and exists() 设置数据监视，getChildren() 设置子节点监视。 或者，你也可以想象 Zookeeper 设置的不同监视返回不同的数据，getData() 和 exists() 返回 znode 节点的相关信息，而 getChildren() 返回子节点列表。因此， setData() 会触发设置在某一节点上所设置的数据监视(假定数据设置成功)，而一次成功的 create() 操作则会出发当前节点上所设置的数据监视以及父节点的子节点监视。一次成功的 delete() 操作将会触发当前节点的数据监视和子节点监视事件，同时也会触发该节点父节点的child watch。</h5><h5 id=\"Zookeeper-中的监视是轻量级的，因此容易设置、维护和分发。当客户端与-Zookeeper-服务器端失去联系时，客户端并不会收到监视事件的通知，只有当客户端重新连接后，若在必要的情况下，以前注册的监视会重新被注册并触发，对于开发人员来说-这通常是透明的。只有一种情况会导致监视事件的丢失，即：通过-exists-设置了某个-znode-节点的监视，但是如果某个客户端在此-znode-节点被创建和删除的时间间隔内与-zookeeper-服务器失去了联系，该客户端即使稍后重新连接-zookeeper服务器后也得不到事件通知。\"><a href=\"#Zookeeper-中的监视是轻量级的，因此容易设置、维护和分发。当客户端与-Zookeeper-服务器端失去联系时，客户端并不会收到监视事件的通知，只有当客户端重新连接后，若在必要的情况下，以前注册的监视会重新被注册并触发，对于开发人员来说-这通常是透明的。只有一种情况会导致监视事件的丢失，即：通过-exists-设置了某个-znode-节点的监视，但是如果某个客户端在此-znode-节点被创建和删除的时间间隔内与-zookeeper-服务器失去了联系，该客户端即使稍后重新连接-zookeeper服务器后也得不到事件通知。\" class=\"headerlink\" title=\"Zookeeper 中的监视是轻量级的，因此容易设置、维护和分发。当客户端与 Zookeeper 服务器端失去联系时，客户端并不会收到监视事件的通知，只有当客户端重新连接后，若在必要的情况下，以前注册的监视会重新被注册并触发，对于开发人员来说 这通常是透明的。只有一种情况会导致监视事件的丢失，即：通过 exists() 设置了某个 znode 节点的监视，但是如果某个客户端在此 znode 节点被创建和删除的时间间隔内与 zookeeper 服务器失去了联系，该客户端即使稍后重新连接 zookeeper服务器后也得不到事件通知。\"></a>Zookeeper 中的监视是轻量级的，因此容易设置、维护和分发。当客户端与 Zookeeper 服务器端失去联系时，客户端并不会收到监视事件的通知，只有当客户端重新连接后，若在必要的情况下，以前注册的监视会重新被注册并触发，对于开发人员来说 这通常是透明的。只有一种情况会导致监视事件的丢失，即：通过 exists() 设置了某个 znode 节点的监视，但是如果某个客户端在此 znode 节点被创建和删除的时间间隔内与 zookeeper 服务器失去了联系，该客户端即使稍后重新连接 zookeeper服务器后也得不到事件通知。</h5><h3 id=\"Zookeeper-C-API-常量与部分结构-struct-介绍\"><a href=\"#Zookeeper-C-API-常量与部分结构-struct-介绍\" class=\"headerlink\" title=\"Zookeeper C API 常量与部分结构(struct)介绍\"></a>Zookeeper C API 常量与部分结构(struct)介绍</h3><h4 id=\"与-ACL-相关的结构与常量：\"><a href=\"#与-ACL-相关的结构与常量：\" class=\"headerlink\" title=\"与 ACL 相关的结构与常量：\"></a>与 ACL 相关的结构与常量：</h4><h5 id=\"struct-Id-结构为：\"><a href=\"#struct-Id-结构为：\" class=\"headerlink\" title=\"struct Id 结构为：\"></a>struct Id 结构为：</h5><pre><code>struct Id {     char * scheme;     char * id; };\n</code></pre><h5 id=\"struct-ACL-结构为：\"><a href=\"#struct-ACL-结构为：\" class=\"headerlink\" title=\"struct ACL 结构为：\"></a>struct ACL 结构为：</h5><pre><code>struct ACL {     int32_t perms;     struct Id id; };\n</code></pre><h5 id=\"struct-ACL-vector-结构为：\"><a href=\"#struct-ACL-vector-结构为：\" class=\"headerlink\" title=\"struct ACL_vector 结构为：\"></a>struct ACL_vector 结构为：</h5><pre><code>struct ACL_vector {     int32_t count;     struct ACL *data; };\n</code></pre><h5 id=\"与-znode-访问权限有关的常量\"><a href=\"#与-znode-访问权限有关的常量\" class=\"headerlink\" title=\"与 znode 访问权限有关的常量\"></a>与 znode 访问权限有关的常量</h5><ul>\n<li>const int ZOO_PERM_READ; //允许客户端读取 znode 节点的值以及子节点列表。</li>\n<li>const int ZOO_PERM_WRITE;// 允许客户端设置 znode 节点的值。</li>\n<li>const int ZOO_PERM_CREATE; //允许客户端在该 znode 节点下创建子节点。</li>\n<li>const int ZOO_PERM_DELETE;//允许客户端删除子节点。</li>\n<li>const int ZOO_PERM_ADMIN; //允许客户端执行 set_acl()。</li>\n<li>const int ZOO_PERM_ALL;//允许客户端执行所有操作，等价与上述所有标志的或(OR) 。</li>\n</ul>\n<h5 id=\"与-ACL-IDs-相关的常量\"><a href=\"#与-ACL-IDs-相关的常量\" class=\"headerlink\" title=\"与 ACL IDs 相关的常量\"></a>与 ACL IDs 相关的常量</h5><ul>\n<li>struct Id ZOO_ANYONE_ID_UNSAFE; //(‘world’,’anyone’)</li>\n<li>struct Id ZOO_AUTH_IDS;// (‘auth’,’’)</li>\n</ul>\n<h5 id=\"三种标准的-ACL\"><a href=\"#三种标准的-ACL\" class=\"headerlink\" title=\"三种标准的 ACL\"></a>三种标准的 ACL</h5><ul>\n<li>struct ACL_vector ZOO_OPEN_ACL_UNSAFE; //(ZOO_PERM_ALL,ZOO_ANYONE_ID_UNSAFE)</li>\n<li>struct ACL_vector ZOO_READ_ACL_UNSAFE;// (ZOO_PERM_READ, ZOO_ANYONE_ID_UNSAFE)</li>\n<li>struct ACL_vector ZOO_CREATOR_ALL_ACL; //(ZOO_PERM_ALL,ZOO_AUTH_IDS)</li>\n</ul>\n<h4 id=\"与-Interest-相关的常量：ZOOKEEPER-WRITE-ZOOKEEPER-READ\"><a href=\"#与-Interest-相关的常量：ZOOKEEPER-WRITE-ZOOKEEPER-READ\" class=\"headerlink\" title=\"与 Interest 相关的常量：ZOOKEEPER_WRITE, ZOOKEEPER_READ\"></a>与 Interest 相关的常量：ZOOKEEPER_WRITE, ZOOKEEPER_READ</h4><h5 id=\"这两个常量用于标识感兴趣的事件并通知zookeeper发生了哪些事件。Interest-常量可以进行组合或（OR）来标识多种兴趣-multiple-interests-write-read-，这两个常量一般用于-zookeeper-interest-和-zookeeper-process-两个函数中。\"><a href=\"#这两个常量用于标识感兴趣的事件并通知zookeeper发生了哪些事件。Interest-常量可以进行组合或（OR）来标识多种兴趣-multiple-interests-write-read-，这两个常量一般用于-zookeeper-interest-和-zookeeper-process-两个函数中。\" class=\"headerlink\" title=\"这两个常量用于标识感兴趣的事件并通知zookeeper发生了哪些事件。Interest 常量可以进行组合或（OR）来标识多种兴趣(multiple interests: write, read)，这两个常量一般用于 zookeeper_interest() 和 zookeeper_process()两个函数中。\"></a>这两个常量用于标识感兴趣的事件并通知zookeeper发生了哪些事件。Interest 常量可以进行组合或（OR）来标识多种兴趣(multiple interests: write, read)，这两个常量一般用于 zookeeper_interest() 和 zookeeper_process()两个函数中。</h5><h4 id=\"与节点创建相关的常量：ZOO-EPHEMERAL-ZOO-SEQUENCE\"><a href=\"#与节点创建相关的常量：ZOO-EPHEMERAL-ZOO-SEQUENCE\" class=\"headerlink\" title=\"与节点创建相关的常量：ZOO_EPHEMERAL, ZOO_SEQUENCE\"></a>与节点创建相关的常量：ZOO_EPHEMERAL, ZOO_SEQUENCE</h4><h5 id=\"zoo-create-函数标志，ZOO-EPHEMERAL-用来标识创建临时节点，ZOO-SEQUENCE-用来标识节点命名具有递增的后缀序号-一般是节点名称后填充-10-位字符的序号，如-xyz0000000000-xyz0000000001-xyz0000000002-…-，同样地，ZOO-EPHEMERAL-ZOO-SEQUENCE-可以组合。\"><a href=\"#zoo-create-函数标志，ZOO-EPHEMERAL-用来标识创建临时节点，ZOO-SEQUENCE-用来标识节点命名具有递增的后缀序号-一般是节点名称后填充-10-位字符的序号，如-xyz0000000000-xyz0000000001-xyz0000000002-…-，同样地，ZOO-EPHEMERAL-ZOO-SEQUENCE-可以组合。\" class=\"headerlink\" title=\"zoo_create 函数标志，ZOO_EPHEMERAL 用来标识创建临时节点，ZOO_SEQUENCE 用来标识节点命名具有递增的后缀序号(一般是节点名称后填充 10 位字符的序号，如 /xyz0000000000, /xyz0000000001, /xyz0000000002, …)，同样地，ZOO_EPHEMERAL, ZOO_SEQUENCE 可以组合。\"></a>zoo_create 函数标志，ZOO_EPHEMERAL 用来标识创建临时节点，ZOO_SEQUENCE 用来标识节点命名具有递增的后缀序号(一般是节点名称后填充 10 位字符的序号，如 /xyz0000000000, /xyz0000000001, /xyz0000000002, …)，同样地，ZOO_EPHEMERAL, ZOO_SEQUENCE 可以组合。</h5><h4 id=\"与连接状态-Stat-相关的常量\"><a href=\"#与连接状态-Stat-相关的常量\" class=\"headerlink\" title=\"与连接状态 Stat 相关的常量\"></a>与连接状态 Stat 相关的常量</h4><h5 id=\"以下常量均与-Zookeeper-连接状态有关，他们通常用作监视器回调函数的参数。\"><a href=\"#以下常量均与-Zookeeper-连接状态有关，他们通常用作监视器回调函数的参数。\" class=\"headerlink\" title=\"以下常量均与 Zookeeper 连接状态有关，他们通常用作监视器回调函数的参数。\"></a>以下常量均与 Zookeeper 连接状态有关，他们通常用作监视器回调函数的参数。</h5><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">ZOOAPI const int</th>\n<th style=\"text-align:left\">ZOO_EXPIRED_SESSION_STATE</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ZOOAPI const int</td>\n<td style=\"text-align:left\">ZOO_AUTH_FAILED_STATE</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ZOOAPI const int</td>\n<td style=\"text-align:left\">ZOO_CONNECTING_STATE</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ZOOAPI const int</td>\n<td style=\"text-align:left\">ZOO_ASSOCIATING_STATE</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ZOOAPI const int</td>\n<td style=\"text-align:left\">ZOO_CONNECTED_STATE</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h4 id=\"与监视类型-Watch-Types-相关的常量\"><a href=\"#与监视类型-Watch-Types-相关的常量\" class=\"headerlink\" title=\"与监视类型(Watch Types)相关的常量\"></a>与监视类型(Watch Types)相关的常量</h4><h5 id=\"以下常量标识监视事件的类型，他们通常用作监视器回调函数的第一个参数。\"><a href=\"#以下常量标识监视事件的类型，他们通常用作监视器回调函数的第一个参数。\" class=\"headerlink\" title=\"以下常量标识监视事件的类型，他们通常用作监视器回调函数的第一个参数。\"></a>以下常量标识监视事件的类型，他们通常用作监视器回调函数的第一个参数。</h5><ul>\n<li>ZOO_CREATED_EVENT; // 节点被创建(此前该节点不存在)，通过 zoo_exists() 设置监视。</li>\n<li>ZOO_DELETED_EVENT; // 节点被删除，通过 zoo_exists() 和 zoo_get() 设置监视。</li>\n<li>ZOO_CHANGED_EVENT; // 节点发生变化，通过 zoo_exists() 和 zoo_get() 设置监视。</li>\n<li>ZOO_CHILD_EVENT; // 子节点事件，通过zoo_get_children() 和 zoo_get_children2()设置监视。</li>\n<li>ZOO_SESSION_EVENT; // 会话丢失</li>\n<li>ZOO_NOTWATCHING_EVENT; // 监视被移除。</li>\n</ul>\n<h4 id=\"Zookeeper-C-API-错误码介绍-ZOO-ERRORS\"><a href=\"#Zookeeper-C-API-错误码介绍-ZOO-ERRORS\" class=\"headerlink\" title=\"Zookeeper C API 错误码介绍 ZOO_ERRORS\"></a>Zookeeper C API 错误码介绍 ZOO_ERRORS</h4><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>ZOK</th>\n<th>正常返回</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ZSYSTEMERROR</td>\n<td>系统或服务器端错误(System and server-side errors)，服务器不会抛出该错误，该错误也只是用来标识错误范围的，即大于该错误值，且小于 ZAPIERROR 都是系统错误。</td>\n</tr>\n<tr>\n<td>ZRUNTIMEINCONSISTENCY</td>\n<td>运行时非一致性错误。</td>\n</tr>\n<tr>\n<td>ZDATAINCONSISTENCY</td>\n<td>数据非一致性错误。</td>\n</tr>\n<tr>\n<td>ZCONNECTIONLOSS</td>\n<td>Zookeeper 客户端与服务器端失去连接</td>\n</tr>\n<tr>\n<td>ZMARSHALLINGERROR</td>\n<td>在 marshalling 和 unmarshalling 数据时出现错误(Error while marshalling or unmarshalling data)</td>\n</tr>\n<tr>\n<td>ZUNIMPLEMENTED</td>\n<td>该操作未实现(Operation is unimplemented)</td>\n</tr>\n<tr>\n<td>ZOPERATIONTIMEOUT</td>\n<td>该操作超时(Operation timeout)</td>\n</tr>\n<tr>\n<td>ZBADARGUMENTS</td>\n<td>非法参数错误(Invalid arguments)</td>\n</tr>\n<tr>\n<td>ZINVALIDSTATE</td>\n<td>非法句柄状态(Invliad zhandle state)</td>\n</tr>\n<tr>\n<td>ZAPIERROR</td>\n<td>API 错误(API errors)，服务器不会抛出该错误，该错误也只是用来标识错误范围的，错误值大于该值的标识 API 错误，而小于该值的标识 ZSYSTEMERROR。</td>\n</tr>\n<tr>\n<td>ZNONODE</td>\n<td>节点不存在(Node does not exist)</td>\n</tr>\n<tr>\n<td>ZNOAUTH</td>\n<td>没有经过授权(Not authenticated)</td>\n</tr>\n<tr>\n<td>ZBADVERSION</td>\n<td>版本冲突(Version conflict)</td>\n</tr>\n<tr>\n<td>ZNOCHILDRENFOREPHEMERALS</td>\n<td>临时节点不能拥有子节点(Ephemeral nodes may not have children)</td>\n</tr>\n<tr>\n<td>ZNODEEXISTS</td>\n<td>节点已经存在(The node already exists)</td>\n</tr>\n<tr>\n<td>ZNOTEMPTY</td>\n<td>该节点具有自身的子节点(The node has children)</td>\n</tr>\n<tr>\n<td>ZSESSIONEXPIRED</td>\n<td>会话过期(The session has been expired by the server)</td>\n</tr>\n<tr>\n<td>ZINVALIDCALLBACK</td>\n<td>非法的回调函数(Invalid callback specified)</td>\n</tr>\n<tr>\n<td>ZINVALIDACL</td>\n<td>非法的ACL(Invalid ACL specified)</td>\n</tr>\n<tr>\n<td>ZAUTHFAILED</td>\n<td>客户端授权失败(Client authentication failed)</td>\n</tr>\n<tr>\n<td>ZCLOSING</td>\n<td>Zookeeper 连接关闭(ZooKeeper is closing)</td>\n</tr>\n<tr>\n<td>ZNOTHING</td>\n<td>并非错误，客户端不需要处理服务器的响应(not error, no server responses to process)</td>\n</tr>\n<tr>\n<td>ZSESSIONMOVED</td>\n<td>会话转移至其他服务器，所以操作被忽略(session moved to another server, so operation is ignored) </td>\n</tr>\n</tbody>\n</table>\n</div>\n<h5 id=\"Watch事件类型：\"><a href=\"#Watch事件类型：\" class=\"headerlink\" title=\"Watch事件类型：\"></a>Watch事件类型：</h5><ul>\n<li>ZOO_CREATED_EVENT：节点创建事件，需要watch一个不存在的节点，当节点被创建时触发，此watch通过zoo_exists()设置</li>\n<li>ZOO_DELETED_EVENT：节点删除事件，此watch通过zoo_exists()或zoo_get()设置</li>\n<li>ZOO_CHANGED_EVENT：节点数据改变事件，此watch通过zoo_exists()或zoo_get()设置</li>\n<li>ZOO_CHILD_EVENT：子节点列表改变事件，此watch通过zoo_get_children()或zoo_get_children2()设置</li>\n<li>ZOO_SESSION_EVENT：会话失效事件，客户端与服务端断开或重连时触发</li>\n<li>ZOO_NOTWATCHING_EVENT：watch移除事件，服务端出于某些原因不再为客户端watch节点时触发</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h5 id=\"ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，它包含一个简单的原语集，分布式应用程序可以基于它实现同步服务，配置维护和命名服务等。Zookeeper是hadoop的一个子项目，其发展历程无需赘述。在分布式应用中，由于工程师不能很好地使用锁机制，以及基于消息的协调机制不适合在某些应用中使用，因此需要有一种可靠的、可扩展的、分布式的、可配置的协调机制来统一系统的状态。Zookeeper的目的就在于此。本文简单分析zookeeper的工作原理，对于如何使用zookeeper不是本文讨论的重点。\"><a href=\"#ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，它包含一个简单的原语集，分布式应用程序可以基于它实现同步服务，配置维护和命名服务等。Zookeeper是hadoop的一个子项目，其发展历程无需赘述。在分布式应用中，由于工程师不能很好地使用锁机制，以及基于消息的协调机制不适合在某些应用中使用，因此需要有一种可靠的、可扩展的、分布式的、可配置的协调机制来统一系统的状态。Zookeeper的目的就在于此。本文简单分析zookeeper的工作原理，对于如何使用zookeeper不是本文讨论的重点。\" class=\"headerlink\" title=\"ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，它包含一个简单的原语集，分布式应用程序可以基于它实现同步服务，配置维护和命名服务等。Zookeeper是hadoop的一个子项目，其发展历程无需赘述。在分布式应用中，由于工程师不能很好地使用锁机制，以及基于消息的协调机制不适合在某些应用中使用，因此需要有一种可靠的、可扩展的、分布式的、可配置的协调机制来统一系统的状态。Zookeeper的目的就在于此。本文简单分析zookeeper的工作原理，对于如何使用zookeeper不是本文讨论的重点。\"></a>ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，它包含一个简单的原语集，分布式应用程序可以基于它实现同步服务，配置维护和命名服务等。Zookeeper是hadoop的一个子项目，其发展历程无需赘述。在分布式应用中，由于工程师不能很好地使用锁机制，以及基于消息的协调机制不适合在某些应用中使用，因此需要有一种可靠的、可扩展的、分布式的、可配置的协调机制来统一系统的状态。Zookeeper的目的就在于此。本文简单分析zookeeper的工作原理，对于如何使用zookeeper不是本文讨论的重点。</h5>","more":"<h2 id=\"1-Zookeeper的基本概念\"><a href=\"#1-Zookeeper的基本概念\" class=\"headerlink\" title=\"1 Zookeeper的基本概念\"></a>1 Zookeeper的基本概念</h2><h3 id=\"1-1-角色\"><a href=\"#1-1-角色\" class=\"headerlink\" title=\"1.1 角色\"></a>1.1 角色</h3><h5 id=\"Zookeeper中的角色主要有以下三类，如下表所示：\"><a href=\"#Zookeeper中的角色主要有以下三类，如下表所示：\" class=\"headerlink\" title=\"Zookeeper中的角色主要有以下三类，如下表所示：\"></a>Zookeeper中的角色主要有以下三类，如下表所示：</h5><p><img src=\"/img/zookeeper/role.jpg\" alt=\"zookeeper角色\"></p>\n<h5 id=\"系统模型如图所示：\"><a href=\"#系统模型如图所示：\" class=\"headerlink\" title=\"系统模型如图所示：\"></a>系统模型如图所示：</h5><p><img src=\"/img/zookeeper/zookeeperModel.jpg\" alt=\"zookeeper系统模型\"></p>\n<h3 id=\"1-2-设计目的\"><a href=\"#1-2-设计目的\" class=\"headerlink\" title=\"1.2 设计目的\"></a>1.2 设计目的</h3><ol>\n<li>最终一致性：client不论连接到哪个Server，展示给它都是同一个视图，这是zookeeper最重要的性能。</li>\n<li>可靠性：具有简单、健壮、良好的性能，如果消息m被到一台服务器接受，那么它将被所有的服务器接受。</li>\n<li>实时性：Zookeeper保证客户端将在一个时间间隔范围内获得服务器的更新信息，或者服务器失效的信息。但由于网络延时等原因，Zookeeper不能保证两个客户端能同时得到刚更新的数据，如果需要最新数据，应该在读数据之前调用sync()接口。</li>\n<li>等待无关（wait-free）：慢的或者失效的client不得干预快速的client的请求，使得每个client都能有效的等待。</li>\n<li>原子性：更新只能成功或者失败，没有中间状态。</li>\n<li>顺序性：包括全局有序和偏序两种：全局有序是指如果在一台服务器上消息a在消息b前发布，则在所有Server上消息a都将在消息b前被发布；偏序是指如果一个消息b在消息a后被同一个发送者发布，a必将排在b前面。</li>\n</ol>\n<h2 id=\"2-ZooKeeper的工作原理\"><a href=\"#2-ZooKeeper的工作原理\" class=\"headerlink\" title=\"2 ZooKeeper的工作原理\"></a>2 ZooKeeper的工作原理</h2><h5 id=\"Zookeeper的核心是原子广播，这个机制保证了各个Server之间的同步。实现这个机制的协议叫做Zab协议。Zab协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数Server完成了和leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和Server具有相同的系统状态。\"><a href=\"#Zookeeper的核心是原子广播，这个机制保证了各个Server之间的同步。实现这个机制的协议叫做Zab协议。Zab协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数Server完成了和leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和Server具有相同的系统状态。\" class=\"headerlink\" title=\"Zookeeper的核心是原子广播，这个机制保证了各个Server之间的同步。实现这个机制的协议叫做Zab协议。Zab协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数Server完成了和leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和Server具有相同的系统状态。\"></a>Zookeeper的核心是原子广播，这个机制保证了各个Server之间的同步。实现这个机制的协议叫做Zab协议。Zab协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数Server完成了和leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和Server具有相同的系统状态。</h5><h5 id=\"为了保证事务的顺序一致性，zookeeper采用了递增的事务id号（zxid）来标识事务。所有的提议（proposal）都在被提出的时候加上了zxid。实现中zxid是一个64位的数字，它高32位是epoch用来标识leader关系是否改变，每次一个leader被选出来，它都会有一个新的epoch，标识当前属于那个leader的统治时期。低32位用于递增计数。\"><a href=\"#为了保证事务的顺序一致性，zookeeper采用了递增的事务id号（zxid）来标识事务。所有的提议（proposal）都在被提出的时候加上了zxid。实现中zxid是一个64位的数字，它高32位是epoch用来标识leader关系是否改变，每次一个leader被选出来，它都会有一个新的epoch，标识当前属于那个leader的统治时期。低32位用于递增计数。\" class=\"headerlink\" title=\"为了保证事务的顺序一致性，zookeeper采用了递增的事务id号（zxid）来标识事务。所有的提议（proposal）都在被提出的时候加上了zxid。实现中zxid是一个64位的数字，它高32位是epoch用来标识leader关系是否改变，每次一个leader被选出来，它都会有一个新的epoch，标识当前属于那个leader的统治时期。低32位用于递增计数。\"></a>为了保证事务的顺序一致性，zookeeper采用了递增的事务id号（zxid）来标识事务。所有的提议（proposal）都在被提出的时候加上了zxid。实现中zxid是一个64位的数字，它高32位是epoch用来标识leader关系是否改变，每次一个leader被选出来，它都会有一个新的epoch，标识当前属于那个leader的统治时期。低32位用于递增计数。</h5><h5 id=\"每个Server在工作过程中有三种状态：\"><a href=\"#每个Server在工作过程中有三种状态：\" class=\"headerlink\" title=\"每个Server在工作过程中有三种状态：\"></a>每个Server在工作过程中有三种状态：</h5><ul>\n<li>LOOKING：当前Server不知道leader是谁，正在搜寻</li>\n<li>LEADING：当前Server即为选举出来的leader</li>\n<li>FOLLOWING：leader已经选举出来，当前Server与之同步</li>\n</ul>\n<h3 id=\"2-1-选主流程\"><a href=\"#2-1-选主流程\" class=\"headerlink\" title=\"2.1 选主流程\"></a>2.1 选主流程</h3><h5 id=\"当leader崩溃或者leader失去大多数的follower，这时候zk进入恢复模式，恢复模式需要重新选举出一个新的leader，让所有的Server都恢复到一个正确的状态。Zk的选举算法有两种：一种是基于basic-paxos实现的，另外一种是基于fast-paxos算法实现的。系统默认的选举算法为fast-paxos。先介绍basic-paxos流程：\"><a href=\"#当leader崩溃或者leader失去大多数的follower，这时候zk进入恢复模式，恢复模式需要重新选举出一个新的leader，让所有的Server都恢复到一个正确的状态。Zk的选举算法有两种：一种是基于basic-paxos实现的，另外一种是基于fast-paxos算法实现的。系统默认的选举算法为fast-paxos。先介绍basic-paxos流程：\" class=\"headerlink\" title=\"当leader崩溃或者leader失去大多数的follower，这时候zk进入恢复模式，恢复模式需要重新选举出一个新的leader，让所有的Server都恢复到一个正确的状态。Zk的选举算法有两种：一种是基于basic paxos实现的，另外一种是基于fast paxos算法实现的。系统默认的选举算法为fast paxos。先介绍basic paxos流程：\"></a>当leader崩溃或者leader失去大多数的follower，这时候zk进入恢复模式，恢复模式需要重新选举出一个新的leader，让所有的Server都恢复到一个正确的状态。Zk的选举算法有两种：一种是基于basic paxos实现的，另外一种是基于fast paxos算法实现的。系统默认的选举算法为fast paxos。先介绍basic paxos流程：</h5><ol>\n<li>选举线程由当前Server发起选举的线程担任，其主要功能是对投票结果进行统计，并选出推荐的Server；</li>\n<li>选举线程首先向所有Server发起一次询问(包括自己)；</li>\n<li>选举线程收到回复后，验证是否是自己发起的询问(验证zxid是否一致)，然后获取对方的id(myid)，并存储到当前询问对象列表中，最后获取对方提议的leader相关信息(id,zxid)，并将这些信息存储到当次选举的投票记录表中；</li>\n<li>收到所有Server回复以后，就计算出zxid最大的那个Server，并将这个Server相关信息设置成下一次要投票的Server；</li>\n<li>线程将当前zxid最大的Server设置为当前Server要推荐的Leader，如果此时获胜的Server获得n/2 + 1的Server票数， 设置当前推荐的leader为获胜的Server，将根据获胜的Server相关信息设置自己的状态，否则，继续这个过程，直到leader被选举出来。</li>\n</ol>\n<h5 id=\"通过流程分析我们可以得出：要使Leader获得多数Server的支持，则Server总数必须是奇数2n-1，且存活的Server的数目不得少于n-1\"><a href=\"#通过流程分析我们可以得出：要使Leader获得多数Server的支持，则Server总数必须是奇数2n-1，且存活的Server的数目不得少于n-1\" class=\"headerlink\" title=\"通过流程分析我们可以得出：要使Leader获得多数Server的支持，则Server总数必须是奇数2n+1，且存活的Server的数目不得少于n+1.\"></a>通过流程分析我们可以得出：要使Leader获得多数Server的支持，则Server总数必须是奇数2n+1，且存活的Server的数目不得少于n+1.</h5><h5 id=\"每个Server启动后都会重复以上流程。在恢复模式下，如果是刚从崩溃状态恢复的或者刚启动的server还会从磁盘快照中恢复数据和会话信息，zk会记录事务日志并定期进行快照，方便在恢复时进行状态恢复。选主的具体流程图如下所示：\"><a href=\"#每个Server启动后都会重复以上流程。在恢复模式下，如果是刚从崩溃状态恢复的或者刚启动的server还会从磁盘快照中恢复数据和会话信息，zk会记录事务日志并定期进行快照，方便在恢复时进行状态恢复。选主的具体流程图如下所示：\" class=\"headerlink\" title=\"每个Server启动后都会重复以上流程。在恢复模式下，如果是刚从崩溃状态恢复的或者刚启动的server还会从磁盘快照中恢复数据和会话信息，zk会记录事务日志并定期进行快照，方便在恢复时进行状态恢复。选主的具体流程图如下所示：\"></a>每个Server启动后都会重复以上流程。在恢复模式下，如果是刚从崩溃状态恢复的或者刚启动的server还会从磁盘快照中恢复数据和会话信息，zk会记录事务日志并定期进行快照，方便在恢复时进行状态恢复。选主的具体流程图如下所示：</h5><p><img src=\"/img/zookeeper/zookeeperLc.jpg\" alt=\"zookeeper流程图\"></p>\n<h5 id=\"fast-paxos流程是在选举过程中，某Server首先向所有Server提议自己要成为leader，当其它Server收到提议以后，解决epoch和zxid的冲突，并接受对方的提议，然后向对方发送接受提议完成的消息，重复这个流程，最后一定能选举出Leader。其流程图如下所示：\"><a href=\"#fast-paxos流程是在选举过程中，某Server首先向所有Server提议自己要成为leader，当其它Server收到提议以后，解决epoch和zxid的冲突，并接受对方的提议，然后向对方发送接受提议完成的消息，重复这个流程，最后一定能选举出Leader。其流程图如下所示：\" class=\"headerlink\" title=\"fast paxos流程是在选举过程中，某Server首先向所有Server提议自己要成为leader，当其它Server收到提议以后，解决epoch和zxid的冲突，并接受对方的提议，然后向对方发送接受提议完成的消息，重复这个流程，最后一定能选举出Leader。其流程图如下所示：\"></a>fast paxos流程是在选举过程中，某Server首先向所有Server提议自己要成为leader，当其它Server收到提议以后，解决epoch和zxid的冲突，并接受对方的提议，然后向对方发送接受提议完成的消息，重复这个流程，最后一定能选举出Leader。其流程图如下所示：</h5><p><img src=\"/img/zookeeper/zookeeperLc2.jpg\" alt=\"zookeeper流程图\"></p>\n<h3 id=\"2-2-同步流程\"><a href=\"#2-2-同步流程\" class=\"headerlink\" title=\"2.2 同步流程\"></a>2.2 同步流程</h3><h5 id=\"选完leader以后，zk就进入状态同步过程。\"><a href=\"#选完leader以后，zk就进入状态同步过程。\" class=\"headerlink\" title=\"选完leader以后，zk就进入状态同步过程。\"></a>选完leader以后，zk就进入状态同步过程。</h5><ol>\n<li>leader等待server连接；</li>\n<li>Follower连接leader，将最大的zxid发送给leader；</li>\n<li>Leader根据follower的zxid确定同步点；</li>\n<li>完成同步后通知follower 已经成为uptodate状态；</li>\n<li>Follower收到uptodate消息后，又可以重新接受client的请求进行服务了。</li>\n</ol>\n<h5 id=\"流程图如下所示：\"><a href=\"#流程图如下所示：\" class=\"headerlink\" title=\"流程图如下所示：\"></a>流程图如下所示：</h5><p><img src=\"/img/zookeeper/zookeeperLc3.jpg\" alt=\"zookeeper流程图\"></p>\n<h3 id=\"2-3-工作流程\"><a href=\"#2-3-工作流程\" class=\"headerlink\" title=\"2.3 工作流程\"></a>2.3 工作流程</h3><h4 id=\"2-3-1-Leader工作流程\"><a href=\"#2-3-1-Leader工作流程\" class=\"headerlink\" title=\"2.3.1 Leader工作流程\"></a>2.3.1 Leader工作流程</h4><h5 id=\"Leader主要有三个功能：\"><a href=\"#Leader主要有三个功能：\" class=\"headerlink\" title=\"Leader主要有三个功能：\"></a>Leader主要有三个功能：</h5><ol>\n<li>恢复数据；</li>\n<li>维持与Learner的心跳，接收Learner请求并判断Learner的请求消息类型；</li>\n<li>Learner的消息类型主要有PING消息、REQUEST消息、ACK消息、REVALIDATE消息，根据不同的消息类型，进行不同的处理。</li>\n</ol>\n<h5 id=\"PING消息是指Learner的心跳信息；REQUEST消息是Follower发送的提议信息，包括写请求及同步请求；ACK消息是Follower的对提议的回复，超过半数的Follower通过，则commit该提议；REVALIDATE消息是用来延长SESSION有效时间。\"><a href=\"#PING消息是指Learner的心跳信息；REQUEST消息是Follower发送的提议信息，包括写请求及同步请求；ACK消息是Follower的对提议的回复，超过半数的Follower通过，则commit该提议；REVALIDATE消息是用来延长SESSION有效时间。\" class=\"headerlink\" title=\"PING消息是指Learner的心跳信息；REQUEST消息是Follower发送的提议信息，包括写请求及同步请求；ACK消息是Follower的对提议的回复，超过半数的Follower通过，则commit该提议；REVALIDATE消息是用来延长SESSION有效时间。\"></a>PING消息是指Learner的心跳信息；REQUEST消息是Follower发送的提议信息，包括写请求及同步请求；ACK消息是Follower的对提议的回复，超过半数的Follower通过，则commit该提议；REVALIDATE消息是用来延长SESSION有效时间。</h5><h5 id=\"Leader的工作流程简图如下所示，在实际实现中，流程要比下图复杂得多，启动了三个线程来实现功能。\"><a href=\"#Leader的工作流程简图如下所示，在实际实现中，流程要比下图复杂得多，启动了三个线程来实现功能。\" class=\"headerlink\" title=\"Leader的工作流程简图如下所示，在实际实现中，流程要比下图复杂得多，启动了三个线程来实现功能。\"></a>Leader的工作流程简图如下所示，在实际实现中，流程要比下图复杂得多，启动了三个线程来实现功能。</h5><p><img src=\"/img/zookeeper/zookeeperLc4.jpg\" alt=\"zookeeper流程图\"></p>\n<h4 id=\"2-3-2-Follower工作流程\"><a href=\"#2-3-2-Follower工作流程\" class=\"headerlink\" title=\"2.3.2 Follower工作流程\"></a>2.3.2 Follower工作流程</h4><h5 id=\"Follower主要有四个功能：\"><a href=\"#Follower主要有四个功能：\" class=\"headerlink\" title=\"Follower主要有四个功能：\"></a>Follower主要有四个功能：</h5><ol>\n<li>向Leader发送请求（PING消息、REQUEST消息、ACK消息、REVALIDATE消息）；</li>\n<li>接收Leader消息并进行处理；</li>\n<li>接收Client的请求，如果为写请求，发送给Leader进行投票；</li>\n<li>返回Client结果。</li>\n</ol>\n<h5 id=\"Follower的消息循环处理如下几种来自Leader的消息：\"><a href=\"#Follower的消息循环处理如下几种来自Leader的消息：\" class=\"headerlink\" title=\"Follower的消息循环处理如下几种来自Leader的消息：\"></a>Follower的消息循环处理如下几种来自Leader的消息：</h5><ol>\n<li>PING消息： 心跳消息；</li>\n<li>PROPOSAL消息：Leader发起的提案，要求Follower投票；</li>\n<li>COMMIT消息：服务器端最新一次提案的信息；</li>\n<li>UPTODATE消息：表明同步完成；</li>\n<li>REVALIDATE消息：根据Leader的REVALIDATE结果，关闭待revalidate的session还是允许其接受消息；</li>\n<li>SYNC消息：返回SYNC结果到客户端，这个消息最初由客户端发起，用来强制得到最新的更新。</li>\n</ol>\n<h5 id=\"Follower的工作流程简图如下所示，在实际实现中，Follower是通过5个线程来实现功能的。\"><a href=\"#Follower的工作流程简图如下所示，在实际实现中，Follower是通过5个线程来实现功能的。\" class=\"headerlink\" title=\"Follower的工作流程简图如下所示，在实际实现中，Follower是通过5个线程来实现功能的。\"></a>Follower的工作流程简图如下所示，在实际实现中，Follower是通过5个线程来实现功能的。</h5><p><img src=\"/img/zookeeper/zookeeperLc5.jpg\" alt=\"zookeeper流程图\"></p>\n<h5 id=\"对于observer的流程不再叙述，observer流程和Follower的唯一不同的地方就是observer不会参加leader发起的投票。\"><a href=\"#对于observer的流程不再叙述，observer流程和Follower的唯一不同的地方就是observer不会参加leader发起的投票。\" class=\"headerlink\" title=\"对于observer的流程不再叙述，observer流程和Follower的唯一不同的地方就是observer不会参加leader发起的投票。\"></a>对于observer的流程不再叙述，observer流程和Follower的唯一不同的地方就是observer不会参加leader发起的投票。</h5><h5 id=\"主流应用场景：\"><a href=\"#主流应用场景：\" class=\"headerlink\" title=\"主流应用场景：\"></a>主流应用场景：</h5><h5 id=\"Zookeeper的主流应用场景实现思路（除去官方示例）\"><a href=\"#Zookeeper的主流应用场景实现思路（除去官方示例）\" class=\"headerlink\" title=\"Zookeeper的主流应用场景实现思路（除去官方示例）\"></a><strong>Zookeeper的主流应用场景实现思路（除去官方示例）</strong></h5><h4 id=\"1-配置管理\"><a href=\"#1-配置管理\" class=\"headerlink\" title=\"(1)配置管理\"></a>(1)配置管理</h4><h5 id=\"集中式的配置管理在应用集群中是非常常见的，一般商业公司内部都会实现一套集中的配置管理中心，应对不同的应用集群对于共享各自配置的需求，并且在配置变更时能够通知到集群中的每一个机器。\"><a href=\"#集中式的配置管理在应用集群中是非常常见的，一般商业公司内部都会实现一套集中的配置管理中心，应对不同的应用集群对于共享各自配置的需求，并且在配置变更时能够通知到集群中的每一个机器。\" class=\"headerlink\" title=\"集中式的配置管理在应用集群中是非常常见的，一般商业公司内部都会实现一套集中的配置管理中心，应对不同的应用集群对于共享各自配置的需求，并且在配置变更时能够通知到集群中的每一个机器。\"></a>集中式的配置管理在应用集群中是非常常见的，一般商业公司内部都会实现一套集中的配置管理中心，应对不同的应用集群对于共享各自配置的需求，并且在配置变更时能够通知到集群中的每一个机器。</h5><h5 id=\"Zookeeper很容易实现这种集中式的配置管理，比如将APP1的所有配置配置到-APP1-znode下，APP1所有机器一启动就对-APP1这个节点进行监控-zk-exist-“-APP1”-true-并且实现回调方法Watcher，那么在zookeeper上-APP1-znode节点下数据发生变化的时候，每个机器都会收到通知，Watcher方法将会被执行，那么应用再取下数据即可-zk-getData-“-APP1”-false-null\"><a href=\"#Zookeeper很容易实现这种集中式的配置管理，比如将APP1的所有配置配置到-APP1-znode下，APP1所有机器一启动就对-APP1这个节点进行监控-zk-exist-“-APP1”-true-并且实现回调方法Watcher，那么在zookeeper上-APP1-znode节点下数据发生变化的时候，每个机器都会收到通知，Watcher方法将会被执行，那么应用再取下数据即可-zk-getData-“-APP1”-false-null\" class=\"headerlink\" title=\"Zookeeper很容易实现这种集中式的配置管理，比如将APP1的所有配置配置到/APP1 znode下，APP1所有机器一启动就对/APP1这个节点进行监控(zk.exist(“/APP1”,true)),并且实现回调方法Watcher，那么在zookeeper上/APP1 znode节点下数据发生变化的时候，每个机器都会收到通知，Watcher方法将会被执行，那么应用再取下数据即可(zk.getData(“/APP1”,false,null));\"></a>Zookeeper很容易实现这种集中式的配置管理，比如将APP1的所有配置配置到/APP1 znode下，APP1所有机器一启动就对/APP1这个节点进行监控(zk.exist(“/APP1”,true)),并且实现回调方法Watcher，那么在zookeeper上/APP1 znode节点下数据发生变化的时候，每个机器都会收到通知，Watcher方法将会被执行，那么应用再取下数据即可(zk.getData(“/APP1”,false,null));</h5><h5 id=\"以上这个例子只是简单的粗颗粒度配置监控，细颗粒度的数据可以进行分层级监控，这一切都是可以设计和控制的。\"><a href=\"#以上这个例子只是简单的粗颗粒度配置监控，细颗粒度的数据可以进行分层级监控，这一切都是可以设计和控制的。\" class=\"headerlink\" title=\"以上这个例子只是简单的粗颗粒度配置监控，细颗粒度的数据可以进行分层级监控，这一切都是可以设计和控制的。\"></a>以上这个例子只是简单的粗颗粒度配置监控，细颗粒度的数据可以进行分层级监控，这一切都是可以设计和控制的。</h5><p><img src=\"/img/zookeeper/zookeeper1.jpg\" alt=\"zookeeper流程图\"></p>\n<h4 id=\"2-集群管理\"><a href=\"#2-集群管理\" class=\"headerlink\" title=\"(2)集群管理\"></a>(2)集群管理</h4><h5 id=\"应用集群中，我们常常需要让每一个机器知道集群中（或依赖的其他某一个集群）哪些机器是活着的，并且在集群机器因为宕机，网络断链等原因能够不在人工介入的情况下迅速通知到每一个机器。\"><a href=\"#应用集群中，我们常常需要让每一个机器知道集群中（或依赖的其他某一个集群）哪些机器是活着的，并且在集群机器因为宕机，网络断链等原因能够不在人工介入的情况下迅速通知到每一个机器。\" class=\"headerlink\" title=\"应用集群中，我们常常需要让每一个机器知道集群中（或依赖的其他某一个集群）哪些机器是活着的，并且在集群机器因为宕机，网络断链等原因能够不在人工介入的情况下迅速通知到每一个机器。\"></a>应用集群中，我们常常需要让每一个机器知道集群中（或依赖的其他某一个集群）哪些机器是活着的，并且在集群机器因为宕机，网络断链等原因能够不在人工介入的情况下迅速通知到每一个机器。</h5><h5 id=\"Zookeeper同样很容易实现这个功能，比如我在zookeeper服务器端有一个znode叫-APP1SERVERS-那么集群中每一个机器启动的时候都去这个节点下创建一个EPHEMERAL类型的节点，比如server1创建-APP1SERVERS-SERVER1-可以使用ip-保证不重复-，server2创建-APP1SERVERS-SERVER2，然后SERVER1和SERVER2都watch-APP1SERVERS这个父节点，那么也就是这个父节点下数据或者子节点变化都会通知对该节点进行watch的客户端。因为EPHEMERAL类型节点有一个很重要的特性，就是客户端和服务器端连接断掉或者session过期就会使节点消失，那么在某一个机器挂掉或者断链的时候，其对应的节点就会消失，然后集群中所有对-APP1SERVERS进行watch的客户端都会收到通知，然后取得最新列表即可。\"><a href=\"#Zookeeper同样很容易实现这个功能，比如我在zookeeper服务器端有一个znode叫-APP1SERVERS-那么集群中每一个机器启动的时候都去这个节点下创建一个EPHEMERAL类型的节点，比如server1创建-APP1SERVERS-SERVER1-可以使用ip-保证不重复-，server2创建-APP1SERVERS-SERVER2，然后SERVER1和SERVER2都watch-APP1SERVERS这个父节点，那么也就是这个父节点下数据或者子节点变化都会通知对该节点进行watch的客户端。因为EPHEMERAL类型节点有一个很重要的特性，就是客户端和服务器端连接断掉或者session过期就会使节点消失，那么在某一个机器挂掉或者断链的时候，其对应的节点就会消失，然后集群中所有对-APP1SERVERS进行watch的客户端都会收到通知，然后取得最新列表即可。\" class=\"headerlink\" title=\"Zookeeper同样很容易实现这个功能，比如我在zookeeper服务器端有一个znode叫/APP1SERVERS,那么集群中每一个机器启动的时候都去这个节点下创建一个EPHEMERAL类型的节点，比如server1创建/APP1SERVERS/SERVER1(可以使用ip,保证不重复)，server2创建/APP1SERVERS/SERVER2，然后SERVER1和SERVER2都watch /APP1SERVERS这个父节点，那么也就是这个父节点下数据或者子节点变化都会通知对该节点进行watch的客户端。因为EPHEMERAL类型节点有一个很重要的特性，就是客户端和服务器端连接断掉或者session过期就会使节点消失，那么在某一个机器挂掉或者断链的时候，其对应的节点就会消失，然后集群中所有对/APP1SERVERS进行watch的客户端都会收到通知，然后取得最新列表即可。\"></a>Zookeeper同样很容易实现这个功能，比如我在zookeeper服务器端有一个znode叫/APP1SERVERS,那么集群中每一个机器启动的时候都去这个节点下创建一个EPHEMERAL类型的节点，比如server1创建/APP1SERVERS/SERVER1(可以使用ip,保证不重复)，server2创建/APP1SERVERS/SERVER2，然后SERVER1和SERVER2都watch /APP1SERVERS这个父节点，那么也就是这个父节点下数据或者子节点变化都会通知对该节点进行watch的客户端。因为EPHEMERAL类型节点有一个很重要的特性，就是客户端和服务器端连接断掉或者session过期就会使节点消失，那么在某一个机器挂掉或者断链的时候，其对应的节点就会消失，然后集群中所有对/APP1SERVERS进行watch的客户端都会收到通知，然后取得最新列表即可。</h5><h5 id=\"另外有一个应用场景就是集群选master-一旦master挂掉能够马上能从slave中选出一个master-实现步骤和前者一样，只是机器在启动的时候在APP1SERVERS创建的节点类型变为EPHEMERAL-SEQUENTIAL类型，这样每个节点会自动被编号\"><a href=\"#另外有一个应用场景就是集群选master-一旦master挂掉能够马上能从slave中选出一个master-实现步骤和前者一样，只是机器在启动的时候在APP1SERVERS创建的节点类型变为EPHEMERAL-SEQUENTIAL类型，这样每个节点会自动被编号\" class=\"headerlink\" title=\"另外有一个应用场景就是集群选master,一旦master挂掉能够马上能从slave中选出一个master,实现步骤和前者一样，只是机器在启动的时候在APP1SERVERS创建的节点类型变为EPHEMERAL_SEQUENTIAL类型，这样每个节点会自动被编号\"></a>另外有一个应用场景就是集群选master,一旦master挂掉能够马上能从slave中选出一个master,实现步骤和前者一样，只是机器在启动的时候在APP1SERVERS创建的节点类型变为EPHEMERAL_SEQUENTIAL类型，这样每个节点会自动被编号</h5><h5 id=\"我们默认规定编号最小的为master-所以当我们对-APP1SERVERS节点做监控的时候，得到服务器列表，只要所有集群机器逻辑认为最小编号节点为master，那么master就被选出，而这个master宕机的时候，相应的znode会消失，然后新的服务器列表就被推送到客户端，然后每个节点逻辑认为最小编号节点为master，这样就做到动态master选举。\"><a href=\"#我们默认规定编号最小的为master-所以当我们对-APP1SERVERS节点做监控的时候，得到服务器列表，只要所有集群机器逻辑认为最小编号节点为master，那么master就被选出，而这个master宕机的时候，相应的znode会消失，然后新的服务器列表就被推送到客户端，然后每个节点逻辑认为最小编号节点为master，这样就做到动态master选举。\" class=\"headerlink\" title=\"我们默认规定编号最小的为master,所以当我们对/APP1SERVERS节点做监控的时候，得到服务器列表，只要所有集群机器逻辑认为最小编号节点为master，那么master就被选出，而这个master宕机的时候，相应的znode会消失，然后新的服务器列表就被推送到客户端，然后每个节点逻辑认为最小编号节点为master，这样就做到动态master选举。\"></a>我们默认规定编号最小的为master,所以当我们对/APP1SERVERS节点做监控的时候，得到服务器列表，只要所有集群机器逻辑认为最小编号节点为master，那么master就被选出，而这个master宕机的时候，相应的znode会消失，然后新的服务器列表就被推送到客户端，然后每个节点逻辑认为最小编号节点为master，这样就做到动态master选举。</h5><p><img src=\"/img/zookeeper/zookeeper2.jpg\" alt=\"zookeeper流程图\"></p>\n<h4 id=\"Zookeeper-监视（Watches）-简介\"><a href=\"#Zookeeper-监视（Watches）-简介\" class=\"headerlink\" title=\"Zookeeper 监视（Watches） 简介\"></a>Zookeeper 监视（Watches） 简介</h4><h5 id=\"Zookeeper-C-API-的声明和描述在-include-zookeeper-h-中可以找到，另外大部分的-Zookeeper-C-API-常量、结构体声明也在-zookeeper-h-中，如果如果你在使用-C-API-是遇到不明白的地方，最好看看-zookeeper-h，或者自己使用-doxygen-生成-Zookeeper-C-API-的帮助文档。\"><a href=\"#Zookeeper-C-API-的声明和描述在-include-zookeeper-h-中可以找到，另外大部分的-Zookeeper-C-API-常量、结构体声明也在-zookeeper-h-中，如果如果你在使用-C-API-是遇到不明白的地方，最好看看-zookeeper-h，或者自己使用-doxygen-生成-Zookeeper-C-API-的帮助文档。\" class=\"headerlink\" title=\"Zookeeper C API 的声明和描述在 include/zookeeper.h 中可以找到，另外大部分的 Zookeeper C API 常量、结构体声明也在 zookeeper.h 中，如果如果你在使用 C API 是遇到不明白的地方，最好看看 zookeeper.h，或者自己使用 doxygen 生成 Zookeeper C API 的帮助文档。\"></a>Zookeeper C API 的声明和描述在 include/zookeeper.h 中可以找到，另外大部分的 Zookeeper C API 常量、结构体声明也在 zookeeper.h 中，如果如果你在使用 C API 是遇到不明白的地方，最好看看 zookeeper.h，或者自己使用 doxygen 生成 Zookeeper C API 的帮助文档。</h5><h5 id=\"Zookeeper-中最有特色且最不容易理解的是监视-Watches-。Zookeeper-所有的读操作——getData-getChildren-和-exists-都-可以设置监视-watch-，监视事件可以理解为一次性的触发器，-官方定义如下：-a-watch-event-is-one-time-trigger-sent-to-the-client-that-set-the-watch-which-occurs-when-the-data-for-which-the-watch-was-set-changes。对此需要作出如下理解：\"><a href=\"#Zookeeper-中最有特色且最不容易理解的是监视-Watches-。Zookeeper-所有的读操作——getData-getChildren-和-exists-都-可以设置监视-watch-，监视事件可以理解为一次性的触发器，-官方定义如下：-a-watch-event-is-one-time-trigger-sent-to-the-client-that-set-the-watch-which-occurs-when-the-data-for-which-the-watch-was-set-changes。对此需要作出如下理解：\" class=\"headerlink\" title=\"Zookeeper 中最有特色且最不容易理解的是监视(Watches)。Zookeeper 所有的读操作——getData(), getChildren(), 和 exists() 都 可以设置监视(watch)，监视事件可以理解为一次性的触发器， 官方定义如下： a watch event is one-time trigger, sent to the client that set the watch, which occurs when the data for which the watch was set changes。对此需要作出如下理解：\"></a>Zookeeper 中最有特色且最不容易理解的是监视(Watches)。Zookeeper 所有的读操作——getData(), getChildren(), 和 exists() 都 可以设置监视(watch)，监视事件可以理解为一次性的触发器， 官方定义如下： a watch event is one-time trigger, sent to the client that set the watch, which occurs when the data for which the watch was set changes。对此需要作出如下理解：</h5><ul>\n<li>（一次性触发）One-time trigger</li>\n</ul>\n<h5 id=\"当设置监视的数据发生改变时，该监视事件会被发送到客户端，例如，如果客户端调用了-getData-“-znode1”-true-并且稍后-znode1-节点上的数据发生了改变或者被删除了，客户端将会获取到-znode1-发生变化的监视事件，而如果-znode1-再一次发生了变化，除非客户端再次对-znode1-设置监视，否则客户端不会收到事件通知。\"><a href=\"#当设置监视的数据发生改变时，该监视事件会被发送到客户端，例如，如果客户端调用了-getData-“-znode1”-true-并且稍后-znode1-节点上的数据发生了改变或者被删除了，客户端将会获取到-znode1-发生变化的监视事件，而如果-znode1-再一次发生了变化，除非客户端再次对-znode1-设置监视，否则客户端不会收到事件通知。\" class=\"headerlink\" title=\"当设置监视的数据发生改变时，该监视事件会被发送到客户端，例如，如果客户端调用了 getData(“/znode1”, true) 并且稍后 /znode1 节点上的数据发生了改变或者被删除了，客户端将会获取到 /znode1 发生变化的监视事件，而如果 /znode1 再一次发生了变化，除非客户端再次对 /znode1 设置监视，否则客户端不会收到事件通知。\"></a>当设置监视的数据发生改变时，该监视事件会被发送到客户端，例如，如果客户端调用了 getData(“/znode1”, true) 并且稍后 /znode1 节点上的数据发生了改变或者被删除了，客户端将会获取到 /znode1 发生变化的监视事件，而如果 /znode1 再一次发生了变化，除非客户端再次对 /znode1 设置监视，否则客户端不会收到事件通知。</h5><ul>\n<li>（发送至客户端）Sent to the client</li>\n</ul>\n<h5 id=\"Zookeeper-客户端和服务端是通过-socket-进行通信的，由于网络存在故障，所以监视事件很有可能不会成功地到达客户端，监视事件是异步发送至监视者的，Zookeeper-本身提供了保序性-ordering-guarantee-：即客户端只有首先看到了监视事件后，才会感知到它所设置监视的-znode-发生了变化-a-client-will-never-see-a-change-for-which-it-has-set-a-watch-until-it-first-sees-the-watch-event-网络延迟或者其他因素可能导致不同的客户端在不同的时刻感知某一监视事件，但是不同的客户端所看到的一切具有一致的顺序。\"><a href=\"#Zookeeper-客户端和服务端是通过-socket-进行通信的，由于网络存在故障，所以监视事件很有可能不会成功地到达客户端，监视事件是异步发送至监视者的，Zookeeper-本身提供了保序性-ordering-guarantee-：即客户端只有首先看到了监视事件后，才会感知到它所设置监视的-znode-发生了变化-a-client-will-never-see-a-change-for-which-it-has-set-a-watch-until-it-first-sees-the-watch-event-网络延迟或者其他因素可能导致不同的客户端在不同的时刻感知某一监视事件，但是不同的客户端所看到的一切具有一致的顺序。\" class=\"headerlink\" title=\"Zookeeper 客户端和服务端是通过 socket 进行通信的，由于网络存在故障，所以监视事件很有可能不会成功地到达客户端，监视事件是异步发送至监视者的，Zookeeper 本身提供了保序性(ordering guarantee)：即客户端只有首先看到了监视事件后，才会感知到它所设置监视的 znode 发生了变化(a client will never see a change for which it has set a watch until it first sees the watch event). 网络延迟或者其他因素可能导致不同的客户端在不同的时刻感知某一监视事件，但是不同的客户端所看到的一切具有一致的顺序。\"></a>Zookeeper 客户端和服务端是通过 socket 进行通信的，由于网络存在故障，所以监视事件很有可能不会成功地到达客户端，监视事件是异步发送至监视者的，Zookeeper 本身提供了保序性(ordering guarantee)：即客户端只有首先看到了监视事件后，才会感知到它所设置监视的 znode 发生了变化(a client will never see a change for which it has set a watch until it first sees the watch event). 网络延迟或者其他因素可能导致不同的客户端在不同的时刻感知某一监视事件，但是不同的客户端所看到的一切具有一致的顺序。</h5><ul>\n<li>（被设置 watch 的数据）The data for which the watch was set</li>\n</ul>\n<h5 id=\"这意味着-znode-节点本身具有不同的改变方式。你也可以想象-Zookeeper-维护了两条监视链表：数据监视和子节点监视-data-watches-and-child-watches-getData-and-exists-设置数据监视，getChildren-设置子节点监视。-或者，你也可以想象-Zookeeper-设置的不同监视返回不同的数据，getData-和-exists-返回-znode-节点的相关信息，而-getChildren-返回子节点列表。因此，-setData-会触发设置在某一节点上所设置的数据监视-假定数据设置成功-，而一次成功的-create-操作则会出发当前节点上所设置的数据监视以及父节点的子节点监视。一次成功的-delete-操作将会触发当前节点的数据监视和子节点监视事件，同时也会触发该节点父节点的child-watch。\"><a href=\"#这意味着-znode-节点本身具有不同的改变方式。你也可以想象-Zookeeper-维护了两条监视链表：数据监视和子节点监视-data-watches-and-child-watches-getData-and-exists-设置数据监视，getChildren-设置子节点监视。-或者，你也可以想象-Zookeeper-设置的不同监视返回不同的数据，getData-和-exists-返回-znode-节点的相关信息，而-getChildren-返回子节点列表。因此，-setData-会触发设置在某一节点上所设置的数据监视-假定数据设置成功-，而一次成功的-create-操作则会出发当前节点上所设置的数据监视以及父节点的子节点监视。一次成功的-delete-操作将会触发当前节点的数据监视和子节点监视事件，同时也会触发该节点父节点的child-watch。\" class=\"headerlink\" title=\"这意味着 znode 节点本身具有不同的改变方式。你也可以想象 Zookeeper 维护了两条监视链表：数据监视和子节点监视(data watches and child watches) getData() and exists() 设置数据监视，getChildren() 设置子节点监视。 或者，你也可以想象 Zookeeper 设置的不同监视返回不同的数据，getData() 和 exists() 返回 znode 节点的相关信息，而 getChildren() 返回子节点列表。因此， setData() 会触发设置在某一节点上所设置的数据监视(假定数据设置成功)，而一次成功的 create() 操作则会出发当前节点上所设置的数据监视以及父节点的子节点监视。一次成功的 delete() 操作将会触发当前节点的数据监视和子节点监视事件，同时也会触发该节点父节点的child watch。\"></a>这意味着 znode 节点本身具有不同的改变方式。你也可以想象 Zookeeper 维护了两条监视链表：数据监视和子节点监视(data watches and child watches) getData() and exists() 设置数据监视，getChildren() 设置子节点监视。 或者，你也可以想象 Zookeeper 设置的不同监视返回不同的数据，getData() 和 exists() 返回 znode 节点的相关信息，而 getChildren() 返回子节点列表。因此， setData() 会触发设置在某一节点上所设置的数据监视(假定数据设置成功)，而一次成功的 create() 操作则会出发当前节点上所设置的数据监视以及父节点的子节点监视。一次成功的 delete() 操作将会触发当前节点的数据监视和子节点监视事件，同时也会触发该节点父节点的child watch。</h5><h5 id=\"Zookeeper-中的监视是轻量级的，因此容易设置、维护和分发。当客户端与-Zookeeper-服务器端失去联系时，客户端并不会收到监视事件的通知，只有当客户端重新连接后，若在必要的情况下，以前注册的监视会重新被注册并触发，对于开发人员来说-这通常是透明的。只有一种情况会导致监视事件的丢失，即：通过-exists-设置了某个-znode-节点的监视，但是如果某个客户端在此-znode-节点被创建和删除的时间间隔内与-zookeeper-服务器失去了联系，该客户端即使稍后重新连接-zookeeper服务器后也得不到事件通知。\"><a href=\"#Zookeeper-中的监视是轻量级的，因此容易设置、维护和分发。当客户端与-Zookeeper-服务器端失去联系时，客户端并不会收到监视事件的通知，只有当客户端重新连接后，若在必要的情况下，以前注册的监视会重新被注册并触发，对于开发人员来说-这通常是透明的。只有一种情况会导致监视事件的丢失，即：通过-exists-设置了某个-znode-节点的监视，但是如果某个客户端在此-znode-节点被创建和删除的时间间隔内与-zookeeper-服务器失去了联系，该客户端即使稍后重新连接-zookeeper服务器后也得不到事件通知。\" class=\"headerlink\" title=\"Zookeeper 中的监视是轻量级的，因此容易设置、维护和分发。当客户端与 Zookeeper 服务器端失去联系时，客户端并不会收到监视事件的通知，只有当客户端重新连接后，若在必要的情况下，以前注册的监视会重新被注册并触发，对于开发人员来说 这通常是透明的。只有一种情况会导致监视事件的丢失，即：通过 exists() 设置了某个 znode 节点的监视，但是如果某个客户端在此 znode 节点被创建和删除的时间间隔内与 zookeeper 服务器失去了联系，该客户端即使稍后重新连接 zookeeper服务器后也得不到事件通知。\"></a>Zookeeper 中的监视是轻量级的，因此容易设置、维护和分发。当客户端与 Zookeeper 服务器端失去联系时，客户端并不会收到监视事件的通知，只有当客户端重新连接后，若在必要的情况下，以前注册的监视会重新被注册并触发，对于开发人员来说 这通常是透明的。只有一种情况会导致监视事件的丢失，即：通过 exists() 设置了某个 znode 节点的监视，但是如果某个客户端在此 znode 节点被创建和删除的时间间隔内与 zookeeper 服务器失去了联系，该客户端即使稍后重新连接 zookeeper服务器后也得不到事件通知。</h5><h3 id=\"Zookeeper-C-API-常量与部分结构-struct-介绍\"><a href=\"#Zookeeper-C-API-常量与部分结构-struct-介绍\" class=\"headerlink\" title=\"Zookeeper C API 常量与部分结构(struct)介绍\"></a>Zookeeper C API 常量与部分结构(struct)介绍</h3><h4 id=\"与-ACL-相关的结构与常量：\"><a href=\"#与-ACL-相关的结构与常量：\" class=\"headerlink\" title=\"与 ACL 相关的结构与常量：\"></a>与 ACL 相关的结构与常量：</h4><h5 id=\"struct-Id-结构为：\"><a href=\"#struct-Id-结构为：\" class=\"headerlink\" title=\"struct Id 结构为：\"></a>struct Id 结构为：</h5><pre><code>struct Id {     char * scheme;     char * id; };\n</code></pre><h5 id=\"struct-ACL-结构为：\"><a href=\"#struct-ACL-结构为：\" class=\"headerlink\" title=\"struct ACL 结构为：\"></a>struct ACL 结构为：</h5><pre><code>struct ACL {     int32_t perms;     struct Id id; };\n</code></pre><h5 id=\"struct-ACL-vector-结构为：\"><a href=\"#struct-ACL-vector-结构为：\" class=\"headerlink\" title=\"struct ACL_vector 结构为：\"></a>struct ACL_vector 结构为：</h5><pre><code>struct ACL_vector {     int32_t count;     struct ACL *data; };\n</code></pre><h5 id=\"与-znode-访问权限有关的常量\"><a href=\"#与-znode-访问权限有关的常量\" class=\"headerlink\" title=\"与 znode 访问权限有关的常量\"></a>与 znode 访问权限有关的常量</h5><ul>\n<li>const int ZOO_PERM_READ; //允许客户端读取 znode 节点的值以及子节点列表。</li>\n<li>const int ZOO_PERM_WRITE;// 允许客户端设置 znode 节点的值。</li>\n<li>const int ZOO_PERM_CREATE; //允许客户端在该 znode 节点下创建子节点。</li>\n<li>const int ZOO_PERM_DELETE;//允许客户端删除子节点。</li>\n<li>const int ZOO_PERM_ADMIN; //允许客户端执行 set_acl()。</li>\n<li>const int ZOO_PERM_ALL;//允许客户端执行所有操作，等价与上述所有标志的或(OR) 。</li>\n</ul>\n<h5 id=\"与-ACL-IDs-相关的常量\"><a href=\"#与-ACL-IDs-相关的常量\" class=\"headerlink\" title=\"与 ACL IDs 相关的常量\"></a>与 ACL IDs 相关的常量</h5><ul>\n<li>struct Id ZOO_ANYONE_ID_UNSAFE; //(‘world’,’anyone’)</li>\n<li>struct Id ZOO_AUTH_IDS;// (‘auth’,’’)</li>\n</ul>\n<h5 id=\"三种标准的-ACL\"><a href=\"#三种标准的-ACL\" class=\"headerlink\" title=\"三种标准的 ACL\"></a>三种标准的 ACL</h5><ul>\n<li>struct ACL_vector ZOO_OPEN_ACL_UNSAFE; //(ZOO_PERM_ALL,ZOO_ANYONE_ID_UNSAFE)</li>\n<li>struct ACL_vector ZOO_READ_ACL_UNSAFE;// (ZOO_PERM_READ, ZOO_ANYONE_ID_UNSAFE)</li>\n<li>struct ACL_vector ZOO_CREATOR_ALL_ACL; //(ZOO_PERM_ALL,ZOO_AUTH_IDS)</li>\n</ul>\n<h4 id=\"与-Interest-相关的常量：ZOOKEEPER-WRITE-ZOOKEEPER-READ\"><a href=\"#与-Interest-相关的常量：ZOOKEEPER-WRITE-ZOOKEEPER-READ\" class=\"headerlink\" title=\"与 Interest 相关的常量：ZOOKEEPER_WRITE, ZOOKEEPER_READ\"></a>与 Interest 相关的常量：ZOOKEEPER_WRITE, ZOOKEEPER_READ</h4><h5 id=\"这两个常量用于标识感兴趣的事件并通知zookeeper发生了哪些事件。Interest-常量可以进行组合或（OR）来标识多种兴趣-multiple-interests-write-read-，这两个常量一般用于-zookeeper-interest-和-zookeeper-process-两个函数中。\"><a href=\"#这两个常量用于标识感兴趣的事件并通知zookeeper发生了哪些事件。Interest-常量可以进行组合或（OR）来标识多种兴趣-multiple-interests-write-read-，这两个常量一般用于-zookeeper-interest-和-zookeeper-process-两个函数中。\" class=\"headerlink\" title=\"这两个常量用于标识感兴趣的事件并通知zookeeper发生了哪些事件。Interest 常量可以进行组合或（OR）来标识多种兴趣(multiple interests: write, read)，这两个常量一般用于 zookeeper_interest() 和 zookeeper_process()两个函数中。\"></a>这两个常量用于标识感兴趣的事件并通知zookeeper发生了哪些事件。Interest 常量可以进行组合或（OR）来标识多种兴趣(multiple interests: write, read)，这两个常量一般用于 zookeeper_interest() 和 zookeeper_process()两个函数中。</h5><h4 id=\"与节点创建相关的常量：ZOO-EPHEMERAL-ZOO-SEQUENCE\"><a href=\"#与节点创建相关的常量：ZOO-EPHEMERAL-ZOO-SEQUENCE\" class=\"headerlink\" title=\"与节点创建相关的常量：ZOO_EPHEMERAL, ZOO_SEQUENCE\"></a>与节点创建相关的常量：ZOO_EPHEMERAL, ZOO_SEQUENCE</h4><h5 id=\"zoo-create-函数标志，ZOO-EPHEMERAL-用来标识创建临时节点，ZOO-SEQUENCE-用来标识节点命名具有递增的后缀序号-一般是节点名称后填充-10-位字符的序号，如-xyz0000000000-xyz0000000001-xyz0000000002-…-，同样地，ZOO-EPHEMERAL-ZOO-SEQUENCE-可以组合。\"><a href=\"#zoo-create-函数标志，ZOO-EPHEMERAL-用来标识创建临时节点，ZOO-SEQUENCE-用来标识节点命名具有递增的后缀序号-一般是节点名称后填充-10-位字符的序号，如-xyz0000000000-xyz0000000001-xyz0000000002-…-，同样地，ZOO-EPHEMERAL-ZOO-SEQUENCE-可以组合。\" class=\"headerlink\" title=\"zoo_create 函数标志，ZOO_EPHEMERAL 用来标识创建临时节点，ZOO_SEQUENCE 用来标识节点命名具有递增的后缀序号(一般是节点名称后填充 10 位字符的序号，如 /xyz0000000000, /xyz0000000001, /xyz0000000002, …)，同样地，ZOO_EPHEMERAL, ZOO_SEQUENCE 可以组合。\"></a>zoo_create 函数标志，ZOO_EPHEMERAL 用来标识创建临时节点，ZOO_SEQUENCE 用来标识节点命名具有递增的后缀序号(一般是节点名称后填充 10 位字符的序号，如 /xyz0000000000, /xyz0000000001, /xyz0000000002, …)，同样地，ZOO_EPHEMERAL, ZOO_SEQUENCE 可以组合。</h5><h4 id=\"与连接状态-Stat-相关的常量\"><a href=\"#与连接状态-Stat-相关的常量\" class=\"headerlink\" title=\"与连接状态 Stat 相关的常量\"></a>与连接状态 Stat 相关的常量</h4><h5 id=\"以下常量均与-Zookeeper-连接状态有关，他们通常用作监视器回调函数的参数。\"><a href=\"#以下常量均与-Zookeeper-连接状态有关，他们通常用作监视器回调函数的参数。\" class=\"headerlink\" title=\"以下常量均与 Zookeeper 连接状态有关，他们通常用作监视器回调函数的参数。\"></a>以下常量均与 Zookeeper 连接状态有关，他们通常用作监视器回调函数的参数。</h5><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">ZOOAPI const int</th>\n<th style=\"text-align:left\">ZOO_EXPIRED_SESSION_STATE</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ZOOAPI const int</td>\n<td style=\"text-align:left\">ZOO_AUTH_FAILED_STATE</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ZOOAPI const int</td>\n<td style=\"text-align:left\">ZOO_CONNECTING_STATE</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ZOOAPI const int</td>\n<td style=\"text-align:left\">ZOO_ASSOCIATING_STATE</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ZOOAPI const int</td>\n<td style=\"text-align:left\">ZOO_CONNECTED_STATE</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h4 id=\"与监视类型-Watch-Types-相关的常量\"><a href=\"#与监视类型-Watch-Types-相关的常量\" class=\"headerlink\" title=\"与监视类型(Watch Types)相关的常量\"></a>与监视类型(Watch Types)相关的常量</h4><h5 id=\"以下常量标识监视事件的类型，他们通常用作监视器回调函数的第一个参数。\"><a href=\"#以下常量标识监视事件的类型，他们通常用作监视器回调函数的第一个参数。\" class=\"headerlink\" title=\"以下常量标识监视事件的类型，他们通常用作监视器回调函数的第一个参数。\"></a>以下常量标识监视事件的类型，他们通常用作监视器回调函数的第一个参数。</h5><ul>\n<li>ZOO_CREATED_EVENT; // 节点被创建(此前该节点不存在)，通过 zoo_exists() 设置监视。</li>\n<li>ZOO_DELETED_EVENT; // 节点被删除，通过 zoo_exists() 和 zoo_get() 设置监视。</li>\n<li>ZOO_CHANGED_EVENT; // 节点发生变化，通过 zoo_exists() 和 zoo_get() 设置监视。</li>\n<li>ZOO_CHILD_EVENT; // 子节点事件，通过zoo_get_children() 和 zoo_get_children2()设置监视。</li>\n<li>ZOO_SESSION_EVENT; // 会话丢失</li>\n<li>ZOO_NOTWATCHING_EVENT; // 监视被移除。</li>\n</ul>\n<h4 id=\"Zookeeper-C-API-错误码介绍-ZOO-ERRORS\"><a href=\"#Zookeeper-C-API-错误码介绍-ZOO-ERRORS\" class=\"headerlink\" title=\"Zookeeper C API 错误码介绍 ZOO_ERRORS\"></a>Zookeeper C API 错误码介绍 ZOO_ERRORS</h4><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>ZOK</th>\n<th>正常返回</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ZSYSTEMERROR</td>\n<td>系统或服务器端错误(System and server-side errors)，服务器不会抛出该错误，该错误也只是用来标识错误范围的，即大于该错误值，且小于 ZAPIERROR 都是系统错误。</td>\n</tr>\n<tr>\n<td>ZRUNTIMEINCONSISTENCY</td>\n<td>运行时非一致性错误。</td>\n</tr>\n<tr>\n<td>ZDATAINCONSISTENCY</td>\n<td>数据非一致性错误。</td>\n</tr>\n<tr>\n<td>ZCONNECTIONLOSS</td>\n<td>Zookeeper 客户端与服务器端失去连接</td>\n</tr>\n<tr>\n<td>ZMARSHALLINGERROR</td>\n<td>在 marshalling 和 unmarshalling 数据时出现错误(Error while marshalling or unmarshalling data)</td>\n</tr>\n<tr>\n<td>ZUNIMPLEMENTED</td>\n<td>该操作未实现(Operation is unimplemented)</td>\n</tr>\n<tr>\n<td>ZOPERATIONTIMEOUT</td>\n<td>该操作超时(Operation timeout)</td>\n</tr>\n<tr>\n<td>ZBADARGUMENTS</td>\n<td>非法参数错误(Invalid arguments)</td>\n</tr>\n<tr>\n<td>ZINVALIDSTATE</td>\n<td>非法句柄状态(Invliad zhandle state)</td>\n</tr>\n<tr>\n<td>ZAPIERROR</td>\n<td>API 错误(API errors)，服务器不会抛出该错误，该错误也只是用来标识错误范围的，错误值大于该值的标识 API 错误，而小于该值的标识 ZSYSTEMERROR。</td>\n</tr>\n<tr>\n<td>ZNONODE</td>\n<td>节点不存在(Node does not exist)</td>\n</tr>\n<tr>\n<td>ZNOAUTH</td>\n<td>没有经过授权(Not authenticated)</td>\n</tr>\n<tr>\n<td>ZBADVERSION</td>\n<td>版本冲突(Version conflict)</td>\n</tr>\n<tr>\n<td>ZNOCHILDRENFOREPHEMERALS</td>\n<td>临时节点不能拥有子节点(Ephemeral nodes may not have children)</td>\n</tr>\n<tr>\n<td>ZNODEEXISTS</td>\n<td>节点已经存在(The node already exists)</td>\n</tr>\n<tr>\n<td>ZNOTEMPTY</td>\n<td>该节点具有自身的子节点(The node has children)</td>\n</tr>\n<tr>\n<td>ZSESSIONEXPIRED</td>\n<td>会话过期(The session has been expired by the server)</td>\n</tr>\n<tr>\n<td>ZINVALIDCALLBACK</td>\n<td>非法的回调函数(Invalid callback specified)</td>\n</tr>\n<tr>\n<td>ZINVALIDACL</td>\n<td>非法的ACL(Invalid ACL specified)</td>\n</tr>\n<tr>\n<td>ZAUTHFAILED</td>\n<td>客户端授权失败(Client authentication failed)</td>\n</tr>\n<tr>\n<td>ZCLOSING</td>\n<td>Zookeeper 连接关闭(ZooKeeper is closing)</td>\n</tr>\n<tr>\n<td>ZNOTHING</td>\n<td>并非错误，客户端不需要处理服务器的响应(not error, no server responses to process)</td>\n</tr>\n<tr>\n<td>ZSESSIONMOVED</td>\n<td>会话转移至其他服务器，所以操作被忽略(session moved to another server, so operation is ignored) </td>\n</tr>\n</tbody>\n</table>\n</div>\n<h5 id=\"Watch事件类型：\"><a href=\"#Watch事件类型：\" class=\"headerlink\" title=\"Watch事件类型：\"></a>Watch事件类型：</h5><ul>\n<li>ZOO_CREATED_EVENT：节点创建事件，需要watch一个不存在的节点，当节点被创建时触发，此watch通过zoo_exists()设置</li>\n<li>ZOO_DELETED_EVENT：节点删除事件，此watch通过zoo_exists()或zoo_get()设置</li>\n<li>ZOO_CHANGED_EVENT：节点数据改变事件，此watch通过zoo_exists()或zoo_get()设置</li>\n<li>ZOO_CHILD_EVENT：子节点列表改变事件，此watch通过zoo_get_children()或zoo_get_children2()设置</li>\n<li>ZOO_SESSION_EVENT：会话失效事件，客户端与服务端断开或重连时触发</li>\n<li>ZOO_NOTWATCHING_EVENT：watch移除事件，服务端出于某些原因不再为客户端watch节点时触发</li>\n</ul>"},{"layout":"book","title":"六顶帽思考","author":"爱德华·德·波诺[英]","date":"2017-12-17T16:00:00.000Z","cover":"6hats.jpg","_content":"","source":"_posts/read/6hats.md","raw":"---\nlayout: book\ntitle: 六顶帽思考\nauthor: 爱德华·德·波诺[英]\ndate: 2017/12/18\ncover: 6hats.jpg\ncategories: [read]\n---","slug":"read/6hats","published":1,"updated":"2018-05-08T13:00:14.286Z","comments":1,"photos":[],"link":"","_id":"cjgxop3ld000kjah1x105g93n","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"book","title":"解忧杂货铺","date":"2016-12-14T16:00:00.000Z","cover":"varietyShop.jpeg","_content":"","source":"_posts/read/GriefGroceryStore.md","raw":"---\nlayout: book\ntitle: 解忧杂货铺\ndate: 2016/12/15\ncover: varietyShop.jpeg\ncategories: [read]\n---\n","slug":"read/GriefGroceryStore","published":1,"updated":"2018-05-08T13:00:14.286Z","comments":1,"photos":[],"link":"","_id":"cjgxop3le000mjah1fq4syab8","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"book","title":"独居的一年","date":"2017-10-05T16:00:00.000Z","cover":"AWidowforOneYear.jpg","_content":"","source":"_posts/read/aWidowforOneYear.md","raw":"---\nlayout: book\ntitle: 独居的一年\ndate: 2017/10/06\ncover: AWidowforOneYear.jpg\ncategories: [read]\n---\n","slug":"read/aWidowforOneYear","published":1,"updated":"2018-05-08T13:00:14.287Z","comments":1,"photos":[],"link":"","_id":"cjgxop3lf000pjah1ylifwkt8","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"book","title":"java核心技术 卷I","date":"2016-12-31T16:00:00.000Z","cover":"coreJavaVolume1.jpeg","_content":"","source":"_posts/read/coreJava.md","raw":"---\nlayout: book\ntitle: java核心技术 卷I\ndate: 2017/01/01\ncover: coreJavaVolume1.jpeg\ncategories: [read]\n---\n","slug":"read/coreJava","published":1,"updated":"2018-05-08T13:00:14.287Z","comments":1,"photos":[],"link":"","_id":"cjgxop3lh000sjah13rg1c4qb","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"book","title":"乌合之众","author":"古斯塔夫・勒庞","date":"2016-12-31T16:00:00.000Z","cover":"crowd.png","_content":"","source":"_posts/read/crowd.md","raw":"---\nlayout: book\ntitle: 乌合之众\nauthor: 古斯塔夫・勒庞\ndate: 2017/01/01\ncover: crowd.png\ncategories: [read]\n---\n","slug":"read/crowd","published":1,"updated":"2018-05-08T13:00:14.287Z","comments":1,"photos":[],"link":"","_id":"cjgxop3lj000vjah1aogpaw2o","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"book","title":"岛上书店","author":"加布瑞埃拉·泽文[美]","date":"2017-12-17T16:00:00.000Z","cover":"dssd.jpg","_content":"","source":"_posts/read/dssd.md","raw":"---\nlayout: book\ntitle: 岛上书店\nauthor: 加布瑞埃拉·泽文[美]\ndate: 2017/12/18\ncover: dssd.jpg\ncategories: [read]\n---","slug":"read/dssd","published":1,"updated":"2018-05-08T13:00:14.287Z","comments":1,"photos":[],"link":"","_id":"cjgxop3ll000yjah1xyzoiiz6","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"book","title":"父与子","date":"2016-12-31T16:00:00.000Z","cover":"fatherAndSon.jpeg","_content":"","source":"_posts/read/fatherAndSon.md","raw":"---\nlayout: book\ntitle: 父与子\ndate: 2017/01/01\ncover: fatherAndSon.jpeg\ncategories: [read]\n---\n","slug":"read/fatherAndSon","published":1,"updated":"2018-05-08T13:00:14.288Z","comments":1,"photos":[],"link":"","_id":"cjgxop3lm0012jah1vsmf4gbm","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"book","title":"牛奶可乐经济学","date":"2016-12-14T16:00:00.000Z","cover":"milk.jpeg","_content":"","source":"_posts/read/economics.md","raw":"---\nlayout: book\ntitle: 牛奶可乐经济学\ndate: 2016/12/15\ncover: milk.jpeg\ncategories: [read]\n---\n","slug":"read/economics","published":1,"updated":"2018-05-08T13:00:14.288Z","comments":1,"photos":[],"link":"","_id":"cjgxop3ln0014jah166itohe4","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"book","title":"女神","author":"渡边淳一","date":"2017-12-17T16:00:00.000Z","cover":"goddess.jpg","_content":"","source":"_posts/read/goddess.md","raw":"---\nlayout: book\ntitle: 女神\nauthor: 渡边淳一\ndate: 2017/12/18\ncover: goddess.jpg\ncategories: [read]\n---","slug":"read/goddess","published":1,"updated":"2018-05-08T13:00:14.288Z","comments":1,"photos":[],"link":"","_id":"cjgxop3lo0017jah1bgtf9sbq","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"book","title":"黄金时代","author":"王小波","date":"2017-04-23T16:00:00.000Z","cover":"goldenAge.jpg","color":"#F8CA6B","_content":"\n##### 《黄金时代》包括中篇小说《黄金时代》、《三十而立》、《似水流年》、《革命时期的爱情》和《我的阴阳两界》等。\n\n## 笔记\n\n### 　　\"我是这么想的：假如我想证明她不是破鞋，就能证明她不是破鞋，那事情未免太容易了。实际上我什么都不能证明，除了那些不需要证明的东西。\"\n##### 在某些程度上，我们什么都证明不了。姓名、年龄、经历。因为这些都是建立在一定的某些基础之上，当世界上的人说你不是你自己时，你就不是你自己。你没法证明。\n\n### 　　\"我想到，用不着写诗给别人看，如果一个人来享受静夜，我的诗对他毫无用处。别人念了它，只会妨碍他享受自己的静夜诗。如果一个人不会唱，那么全世界的歌对他毫无用处；如果他会唱，那他一定要唱自己的歌。这就是说，诗人这个行当应该取消，每个人都要做自己的诗人。\"\n##### 从古至今留存下来的诗集，从来都是作者对自己内心的一种情感抒发。每个人都要做自己的诗人\n\n### 　　\"照批者认为，这李先生是无聊之辈，你何必理他？既然理他，你也是无聊之辈。但是李先生对着大字报倒是认真答辩了。他认为大道理管小道理，其实是不讲理。大问题管小问题，实则混淆命题。就算揭批查重要，也不能叫人龟头血肿呀？只论大小重要不重要，不论是非真伪，是混蛋逻辑。\"\n\n### 　　\"文化革命\"到来之时，有些人高兴，有些人不高兴。刘老先生对我说过，一开头他就想自杀。因为他见那势头，总觉得躲不过去。但是他想到再峨嵋酒家还能吃到东坡肘子，又觉得死了太亏。\"\n##### 有时候让你坚持下去往往是一些很不起眼的东西。\n\n### 　　\"我活得很没劲，好像一个没用的人。人到了这步田地，反而会脑子伟大的想法。那时我想：要是发生了战争就好了。\"\n\n### 　　\"人在四十岁之前，过得很慢，过了四十岁，过得就快了。\"\n\n### 　　\"爬铜炉子没有一点好处，只能带来刻骨铭心的痛苦，但我还是要爬。这大概是说明你干的事情越傻，决心就会越大吧。这也说明我喜欢自己愚弄自己，却不喜欢被别人愚弄。\"\n\n### 　　\"在革命时期里，我随时准备承认自己是一只猪，来换取安宁。\"\n\n### 　　\"既然人饿了就要吃饭，渴了就要喝水，到了一定岁数就想性交，上了会场就要发呆，同属万般无奈；所以吃饭喝水性交和发呆，都属天赋人权的范畴。假如人犯了错误，可以用别的方法来惩办，却不能令他不发呆。如不其然，就会引起火灾。\"\n\n### 　　\"对于不能恨的人，我只能用爱来化解仇恨。我爱上她了。\"\n\n### 　　\"人活在世界上，快乐和痛苦本就分不清。所以我只求它货真价实。\"\n\n### 　　\"有关我爸爸打我的事，还有一些要补充的地方。他戴着高帽子游街，我看到他时笑了一笑，于是我就挨了一顿打。由此容易得出一个结论：在那种场合应该苦着脸。但是这个结论是错的，因为哭丧着脸也要挨打。正确的结论是到了我该挨打的时候就会挨打，不管我是哭还是笑。既然活在世界上，不管怎样都要挨打，所以做什么都没有了意义。唯一有意义的事就是寻找神奇。\"\n\n### 　　\"弗洛伊德说，受虐狂是这样形成的：假如人处于一种不能克服的痛苦之中，就会爱上这种痛苦，把它看成幸福。\"\n\n### 　　\"在革命时期自己失掉了一个人，就如损失了十几块钱，有点伤心。这时候我们背上一段毛主席语录：“这种方法也要介绍到老百姓那里去，村上的人死了，开个追悼会，用这种方法寄托我们的哀思……”，然后就一点也不伤心，因为伤心被这种程式消化了。这种种程式就是高级智能。因为有了这种种程式，好多东西失去了它本来的意义——连死都不真了。\"\n\n### 　　\"小孙和我谈恋爱，结果是我们俩都变成了一种气体，叫做什么一氧化二氮，或者说，叫做笑气，人家一见到我们在一起就要笑。\"\n\n### 　　\"李先生见了我就说这件事，同时愁眉苦脸。我就安慰他说：这也好，省得再找我修。我这样安慰过以后，他好像更伤心了。这件事证明了一个道理：萨特先生说得很对，他人是你的地狱。\"\n\n### 　　\"李先生干出了一件大家都干不出的事，这一点没有问题。这证明了他和大家不一样，这一点也没有问题。但是这种不一样是聪明还是有毛病，还没有定论。既然如此，就应该少数服从多数。大家说你聪明，你就是聪明，大家觉得你有毛病，你就是有毛病。\"","source":"_posts/read/goldenAge.md","raw":"---\nlayout: book\ntitle: 黄金时代\nauthor: 王小波\ndate: 2017/04/24\ncover: goldenAge.jpg\ncategories: [read]\ncolor: '#F8CA6B'\n---\n\n##### 《黄金时代》包括中篇小说《黄金时代》、《三十而立》、《似水流年》、《革命时期的爱情》和《我的阴阳两界》等。\n\n## 笔记\n\n### 　　\"我是这么想的：假如我想证明她不是破鞋，就能证明她不是破鞋，那事情未免太容易了。实际上我什么都不能证明，除了那些不需要证明的东西。\"\n##### 在某些程度上，我们什么都证明不了。姓名、年龄、经历。因为这些都是建立在一定的某些基础之上，当世界上的人说你不是你自己时，你就不是你自己。你没法证明。\n\n### 　　\"我想到，用不着写诗给别人看，如果一个人来享受静夜，我的诗对他毫无用处。别人念了它，只会妨碍他享受自己的静夜诗。如果一个人不会唱，那么全世界的歌对他毫无用处；如果他会唱，那他一定要唱自己的歌。这就是说，诗人这个行当应该取消，每个人都要做自己的诗人。\"\n##### 从古至今留存下来的诗集，从来都是作者对自己内心的一种情感抒发。每个人都要做自己的诗人\n\n### 　　\"照批者认为，这李先生是无聊之辈，你何必理他？既然理他，你也是无聊之辈。但是李先生对着大字报倒是认真答辩了。他认为大道理管小道理，其实是不讲理。大问题管小问题，实则混淆命题。就算揭批查重要，也不能叫人龟头血肿呀？只论大小重要不重要，不论是非真伪，是混蛋逻辑。\"\n\n### 　　\"文化革命\"到来之时，有些人高兴，有些人不高兴。刘老先生对我说过，一开头他就想自杀。因为他见那势头，总觉得躲不过去。但是他想到再峨嵋酒家还能吃到东坡肘子，又觉得死了太亏。\"\n##### 有时候让你坚持下去往往是一些很不起眼的东西。\n\n### 　　\"我活得很没劲，好像一个没用的人。人到了这步田地，反而会脑子伟大的想法。那时我想：要是发生了战争就好了。\"\n\n### 　　\"人在四十岁之前，过得很慢，过了四十岁，过得就快了。\"\n\n### 　　\"爬铜炉子没有一点好处，只能带来刻骨铭心的痛苦，但我还是要爬。这大概是说明你干的事情越傻，决心就会越大吧。这也说明我喜欢自己愚弄自己，却不喜欢被别人愚弄。\"\n\n### 　　\"在革命时期里，我随时准备承认自己是一只猪，来换取安宁。\"\n\n### 　　\"既然人饿了就要吃饭，渴了就要喝水，到了一定岁数就想性交，上了会场就要发呆，同属万般无奈；所以吃饭喝水性交和发呆，都属天赋人权的范畴。假如人犯了错误，可以用别的方法来惩办，却不能令他不发呆。如不其然，就会引起火灾。\"\n\n### 　　\"对于不能恨的人，我只能用爱来化解仇恨。我爱上她了。\"\n\n### 　　\"人活在世界上，快乐和痛苦本就分不清。所以我只求它货真价实。\"\n\n### 　　\"有关我爸爸打我的事，还有一些要补充的地方。他戴着高帽子游街，我看到他时笑了一笑，于是我就挨了一顿打。由此容易得出一个结论：在那种场合应该苦着脸。但是这个结论是错的，因为哭丧着脸也要挨打。正确的结论是到了我该挨打的时候就会挨打，不管我是哭还是笑。既然活在世界上，不管怎样都要挨打，所以做什么都没有了意义。唯一有意义的事就是寻找神奇。\"\n\n### 　　\"弗洛伊德说，受虐狂是这样形成的：假如人处于一种不能克服的痛苦之中，就会爱上这种痛苦，把它看成幸福。\"\n\n### 　　\"在革命时期自己失掉了一个人，就如损失了十几块钱，有点伤心。这时候我们背上一段毛主席语录：“这种方法也要介绍到老百姓那里去，村上的人死了，开个追悼会，用这种方法寄托我们的哀思……”，然后就一点也不伤心，因为伤心被这种程式消化了。这种种程式就是高级智能。因为有了这种种程式，好多东西失去了它本来的意义——连死都不真了。\"\n\n### 　　\"小孙和我谈恋爱，结果是我们俩都变成了一种气体，叫做什么一氧化二氮，或者说，叫做笑气，人家一见到我们在一起就要笑。\"\n\n### 　　\"李先生见了我就说这件事，同时愁眉苦脸。我就安慰他说：这也好，省得再找我修。我这样安慰过以后，他好像更伤心了。这件事证明了一个道理：萨特先生说得很对，他人是你的地狱。\"\n\n### 　　\"李先生干出了一件大家都干不出的事，这一点没有问题。这证明了他和大家不一样，这一点也没有问题。但是这种不一样是聪明还是有毛病，还没有定论。既然如此，就应该少数服从多数。大家说你聪明，你就是聪明，大家觉得你有毛病，你就是有毛病。\"","slug":"read/goldenAge","published":1,"updated":"2018-05-08T14:51:18.339Z","_id":"cjgxop3lp001ajah1y2eoi7t7","comments":1,"photos":[],"link":"","content":"<h5 id=\"《黄金时代》包括中篇小说《黄金时代》、《三十而立》、《似水流年》、《革命时期的爱情》和《我的阴阳两界》等。\"><a href=\"#《黄金时代》包括中篇小说《黄金时代》、《三十而立》、《似水流年》、《革命时期的爱情》和《我的阴阳两界》等。\" class=\"headerlink\" title=\"《黄金时代》包括中篇小说《黄金时代》、《三十而立》、《似水流年》、《革命时期的爱情》和《我的阴阳两界》等。\"></a>《黄金时代》包括中篇小说《黄金时代》、《三十而立》、《似水流年》、《革命时期的爱情》和《我的阴阳两界》等。</h5><h2 id=\"笔记\"><a href=\"#笔记\" class=\"headerlink\" title=\"笔记\"></a>笔记</h2><h3 id=\"“我是这么想的：假如我想证明她不是破鞋，就能证明她不是破鞋，那事情未免太容易了。实际上我什么都不能证明，除了那些不需要证明的东西。”\"><a href=\"#“我是这么想的：假如我想证明她不是破鞋，就能证明她不是破鞋，那事情未免太容易了。实际上我什么都不能证明，除了那些不需要证明的东西。”\" class=\"headerlink\" title=\"　　“我是这么想的：假如我想证明她不是破鞋，就能证明她不是破鞋，那事情未免太容易了。实际上我什么都不能证明，除了那些不需要证明的东西。”\"></a>　　“我是这么想的：假如我想证明她不是破鞋，就能证明她不是破鞋，那事情未免太容易了。实际上我什么都不能证明，除了那些不需要证明的东西。”</h3><h5 id=\"在某些程度上，我们什么都证明不了。姓名、年龄、经历。因为这些都是建立在一定的某些基础之上，当世界上的人说你不是你自己时，你就不是你自己。你没法证明。\"><a href=\"#在某些程度上，我们什么都证明不了。姓名、年龄、经历。因为这些都是建立在一定的某些基础之上，当世界上的人说你不是你自己时，你就不是你自己。你没法证明。\" class=\"headerlink\" title=\"在某些程度上，我们什么都证明不了。姓名、年龄、经历。因为这些都是建立在一定的某些基础之上，当世界上的人说你不是你自己时，你就不是你自己。你没法证明。\"></a>在某些程度上，我们什么都证明不了。姓名、年龄、经历。因为这些都是建立在一定的某些基础之上，当世界上的人说你不是你自己时，你就不是你自己。你没法证明。</h5><h3 id=\"“我想到，用不着写诗给别人看，如果一个人来享受静夜，我的诗对他毫无用处。别人念了它，只会妨碍他享受自己的静夜诗。如果一个人不会唱，那么全世界的歌对他毫无用处；如果他会唱，那他一定要唱自己的歌。这就是说，诗人这个行当应该取消，每个人都要做自己的诗人。”\"><a href=\"#“我想到，用不着写诗给别人看，如果一个人来享受静夜，我的诗对他毫无用处。别人念了它，只会妨碍他享受自己的静夜诗。如果一个人不会唱，那么全世界的歌对他毫无用处；如果他会唱，那他一定要唱自己的歌。这就是说，诗人这个行当应该取消，每个人都要做自己的诗人。”\" class=\"headerlink\" title=\"　　“我想到，用不着写诗给别人看，如果一个人来享受静夜，我的诗对他毫无用处。别人念了它，只会妨碍他享受自己的静夜诗。如果一个人不会唱，那么全世界的歌对他毫无用处；如果他会唱，那他一定要唱自己的歌。这就是说，诗人这个行当应该取消，每个人都要做自己的诗人。”\"></a>　　“我想到，用不着写诗给别人看，如果一个人来享受静夜，我的诗对他毫无用处。别人念了它，只会妨碍他享受自己的静夜诗。如果一个人不会唱，那么全世界的歌对他毫无用处；如果他会唱，那他一定要唱自己的歌。这就是说，诗人这个行当应该取消，每个人都要做自己的诗人。”</h3><h5 id=\"从古至今留存下来的诗集，从来都是作者对自己内心的一种情感抒发。每个人都要做自己的诗人\"><a href=\"#从古至今留存下来的诗集，从来都是作者对自己内心的一种情感抒发。每个人都要做自己的诗人\" class=\"headerlink\" title=\"从古至今留存下来的诗集，从来都是作者对自己内心的一种情感抒发。每个人都要做自己的诗人\"></a>从古至今留存下来的诗集，从来都是作者对自己内心的一种情感抒发。每个人都要做自己的诗人</h5><h3 id=\"“照批者认为，这李先生是无聊之辈，你何必理他？既然理他，你也是无聊之辈。但是李先生对着大字报倒是认真答辩了。他认为大道理管小道理，其实是不讲理。大问题管小问题，实则混淆命题。就算揭批查重要，也不能叫人龟头血肿呀？只论大小重要不重要，不论是非真伪，是混蛋逻辑。”\"><a href=\"#“照批者认为，这李先生是无聊之辈，你何必理他？既然理他，你也是无聊之辈。但是李先生对着大字报倒是认真答辩了。他认为大道理管小道理，其实是不讲理。大问题管小问题，实则混淆命题。就算揭批查重要，也不能叫人龟头血肿呀？只论大小重要不重要，不论是非真伪，是混蛋逻辑。”\" class=\"headerlink\" title=\"　　“照批者认为，这李先生是无聊之辈，你何必理他？既然理他，你也是无聊之辈。但是李先生对着大字报倒是认真答辩了。他认为大道理管小道理，其实是不讲理。大问题管小问题，实则混淆命题。就算揭批查重要，也不能叫人龟头血肿呀？只论大小重要不重要，不论是非真伪，是混蛋逻辑。”\"></a>　　“照批者认为，这李先生是无聊之辈，你何必理他？既然理他，你也是无聊之辈。但是李先生对着大字报倒是认真答辩了。他认为大道理管小道理，其实是不讲理。大问题管小问题，实则混淆命题。就算揭批查重要，也不能叫人龟头血肿呀？只论大小重要不重要，不论是非真伪，是混蛋逻辑。”</h3><h3 id=\"“文化革命”到来之时，有些人高兴，有些人不高兴。刘老先生对我说过，一开头他就想自杀。因为他见那势头，总觉得躲不过去。但是他想到再峨嵋酒家还能吃到东坡肘子，又觉得死了太亏。”\"><a href=\"#“文化革命”到来之时，有些人高兴，有些人不高兴。刘老先生对我说过，一开头他就想自杀。因为他见那势头，总觉得躲不过去。但是他想到再峨嵋酒家还能吃到东坡肘子，又觉得死了太亏。”\" class=\"headerlink\" title=\"　　“文化革命”到来之时，有些人高兴，有些人不高兴。刘老先生对我说过，一开头他就想自杀。因为他见那势头，总觉得躲不过去。但是他想到再峨嵋酒家还能吃到东坡肘子，又觉得死了太亏。”\"></a>　　“文化革命”到来之时，有些人高兴，有些人不高兴。刘老先生对我说过，一开头他就想自杀。因为他见那势头，总觉得躲不过去。但是他想到再峨嵋酒家还能吃到东坡肘子，又觉得死了太亏。”</h3><h5 id=\"有时候让你坚持下去往往是一些很不起眼的东西。\"><a href=\"#有时候让你坚持下去往往是一些很不起眼的东西。\" class=\"headerlink\" title=\"有时候让你坚持下去往往是一些很不起眼的东西。\"></a>有时候让你坚持下去往往是一些很不起眼的东西。</h5><h3 id=\"“我活得很没劲，好像一个没用的人。人到了这步田地，反而会脑子伟大的想法。那时我想：要是发生了战争就好了。”\"><a href=\"#“我活得很没劲，好像一个没用的人。人到了这步田地，反而会脑子伟大的想法。那时我想：要是发生了战争就好了。”\" class=\"headerlink\" title=\"　　“我活得很没劲，好像一个没用的人。人到了这步田地，反而会脑子伟大的想法。那时我想：要是发生了战争就好了。”\"></a>　　“我活得很没劲，好像一个没用的人。人到了这步田地，反而会脑子伟大的想法。那时我想：要是发生了战争就好了。”</h3><h3 id=\"“人在四十岁之前，过得很慢，过了四十岁，过得就快了。”\"><a href=\"#“人在四十岁之前，过得很慢，过了四十岁，过得就快了。”\" class=\"headerlink\" title=\"　　“人在四十岁之前，过得很慢，过了四十岁，过得就快了。”\"></a>　　“人在四十岁之前，过得很慢，过了四十岁，过得就快了。”</h3><h3 id=\"“爬铜炉子没有一点好处，只能带来刻骨铭心的痛苦，但我还是要爬。这大概是说明你干的事情越傻，决心就会越大吧。这也说明我喜欢自己愚弄自己，却不喜欢被别人愚弄。”\"><a href=\"#“爬铜炉子没有一点好处，只能带来刻骨铭心的痛苦，但我还是要爬。这大概是说明你干的事情越傻，决心就会越大吧。这也说明我喜欢自己愚弄自己，却不喜欢被别人愚弄。”\" class=\"headerlink\" title=\"　　“爬铜炉子没有一点好处，只能带来刻骨铭心的痛苦，但我还是要爬。这大概是说明你干的事情越傻，决心就会越大吧。这也说明我喜欢自己愚弄自己，却不喜欢被别人愚弄。”\"></a>　　“爬铜炉子没有一点好处，只能带来刻骨铭心的痛苦，但我还是要爬。这大概是说明你干的事情越傻，决心就会越大吧。这也说明我喜欢自己愚弄自己，却不喜欢被别人愚弄。”</h3><h3 id=\"“在革命时期里，我随时准备承认自己是一只猪，来换取安宁。”\"><a href=\"#“在革命时期里，我随时准备承认自己是一只猪，来换取安宁。”\" class=\"headerlink\" title=\"　　“在革命时期里，我随时准备承认自己是一只猪，来换取安宁。”\"></a>　　“在革命时期里，我随时准备承认自己是一只猪，来换取安宁。”</h3><h3 id=\"“既然人饿了就要吃饭，渴了就要喝水，到了一定岁数就想性交，上了会场就要发呆，同属万般无奈；所以吃饭喝水性交和发呆，都属天赋人权的范畴。假如人犯了错误，可以用别的方法来惩办，却不能令他不发呆。如不其然，就会引起火灾。”\"><a href=\"#“既然人饿了就要吃饭，渴了就要喝水，到了一定岁数就想性交，上了会场就要发呆，同属万般无奈；所以吃饭喝水性交和发呆，都属天赋人权的范畴。假如人犯了错误，可以用别的方法来惩办，却不能令他不发呆。如不其然，就会引起火灾。”\" class=\"headerlink\" title=\"　　“既然人饿了就要吃饭，渴了就要喝水，到了一定岁数就想性交，上了会场就要发呆，同属万般无奈；所以吃饭喝水性交和发呆，都属天赋人权的范畴。假如人犯了错误，可以用别的方法来惩办，却不能令他不发呆。如不其然，就会引起火灾。”\"></a>　　“既然人饿了就要吃饭，渴了就要喝水，到了一定岁数就想性交，上了会场就要发呆，同属万般无奈；所以吃饭喝水性交和发呆，都属天赋人权的范畴。假如人犯了错误，可以用别的方法来惩办，却不能令他不发呆。如不其然，就会引起火灾。”</h3><h3 id=\"“对于不能恨的人，我只能用爱来化解仇恨。我爱上她了。”\"><a href=\"#“对于不能恨的人，我只能用爱来化解仇恨。我爱上她了。”\" class=\"headerlink\" title=\"　　“对于不能恨的人，我只能用爱来化解仇恨。我爱上她了。”\"></a>　　“对于不能恨的人，我只能用爱来化解仇恨。我爱上她了。”</h3><h3 id=\"“人活在世界上，快乐和痛苦本就分不清。所以我只求它货真价实。”\"><a href=\"#“人活在世界上，快乐和痛苦本就分不清。所以我只求它货真价实。”\" class=\"headerlink\" title=\"　　“人活在世界上，快乐和痛苦本就分不清。所以我只求它货真价实。”\"></a>　　“人活在世界上，快乐和痛苦本就分不清。所以我只求它货真价实。”</h3><h3 id=\"“有关我爸爸打我的事，还有一些要补充的地方。他戴着高帽子游街，我看到他时笑了一笑，于是我就挨了一顿打。由此容易得出一个结论：在那种场合应该苦着脸。但是这个结论是错的，因为哭丧着脸也要挨打。正确的结论是到了我该挨打的时候就会挨打，不管我是哭还是笑。既然活在世界上，不管怎样都要挨打，所以做什么都没有了意义。唯一有意义的事就是寻找神奇。”\"><a href=\"#“有关我爸爸打我的事，还有一些要补充的地方。他戴着高帽子游街，我看到他时笑了一笑，于是我就挨了一顿打。由此容易得出一个结论：在那种场合应该苦着脸。但是这个结论是错的，因为哭丧着脸也要挨打。正确的结论是到了我该挨打的时候就会挨打，不管我是哭还是笑。既然活在世界上，不管怎样都要挨打，所以做什么都没有了意义。唯一有意义的事就是寻找神奇。”\" class=\"headerlink\" title=\"　　“有关我爸爸打我的事，还有一些要补充的地方。他戴着高帽子游街，我看到他时笑了一笑，于是我就挨了一顿打。由此容易得出一个结论：在那种场合应该苦着脸。但是这个结论是错的，因为哭丧着脸也要挨打。正确的结论是到了我该挨打的时候就会挨打，不管我是哭还是笑。既然活在世界上，不管怎样都要挨打，所以做什么都没有了意义。唯一有意义的事就是寻找神奇。”\"></a>　　“有关我爸爸打我的事，还有一些要补充的地方。他戴着高帽子游街，我看到他时笑了一笑，于是我就挨了一顿打。由此容易得出一个结论：在那种场合应该苦着脸。但是这个结论是错的，因为哭丧着脸也要挨打。正确的结论是到了我该挨打的时候就会挨打，不管我是哭还是笑。既然活在世界上，不管怎样都要挨打，所以做什么都没有了意义。唯一有意义的事就是寻找神奇。”</h3><h3 id=\"“弗洛伊德说，受虐狂是这样形成的：假如人处于一种不能克服的痛苦之中，就会爱上这种痛苦，把它看成幸福。”\"><a href=\"#“弗洛伊德说，受虐狂是这样形成的：假如人处于一种不能克服的痛苦之中，就会爱上这种痛苦，把它看成幸福。”\" class=\"headerlink\" title=\"　　“弗洛伊德说，受虐狂是这样形成的：假如人处于一种不能克服的痛苦之中，就会爱上这种痛苦，把它看成幸福。”\"></a>　　“弗洛伊德说，受虐狂是这样形成的：假如人处于一种不能克服的痛苦之中，就会爱上这种痛苦，把它看成幸福。”</h3><h3 id=\"“在革命时期自己失掉了一个人，就如损失了十几块钱，有点伤心。这时候我们背上一段毛主席语录：“这种方法也要介绍到老百姓那里去，村上的人死了，开个追悼会，用这种方法寄托我们的哀思……”，然后就一点也不伤心，因为伤心被这种程式消化了。这种种程式就是高级智能。因为有了这种种程式，好多东西失去了它本来的意义——连死都不真了。”\"><a href=\"#“在革命时期自己失掉了一个人，就如损失了十几块钱，有点伤心。这时候我们背上一段毛主席语录：“这种方法也要介绍到老百姓那里去，村上的人死了，开个追悼会，用这种方法寄托我们的哀思……”，然后就一点也不伤心，因为伤心被这种程式消化了。这种种程式就是高级智能。因为有了这种种程式，好多东西失去了它本来的意义——连死都不真了。”\" class=\"headerlink\" title=\"　　“在革命时期自己失掉了一个人，就如损失了十几块钱，有点伤心。这时候我们背上一段毛主席语录：“这种方法也要介绍到老百姓那里去，村上的人死了，开个追悼会，用这种方法寄托我们的哀思……”，然后就一点也不伤心，因为伤心被这种程式消化了。这种种程式就是高级智能。因为有了这种种程式，好多东西失去了它本来的意义——连死都不真了。”\"></a>　　“在革命时期自己失掉了一个人，就如损失了十几块钱，有点伤心。这时候我们背上一段毛主席语录：“这种方法也要介绍到老百姓那里去，村上的人死了，开个追悼会，用这种方法寄托我们的哀思……”，然后就一点也不伤心，因为伤心被这种程式消化了。这种种程式就是高级智能。因为有了这种种程式，好多东西失去了它本来的意义——连死都不真了。”</h3><h3 id=\"“小孙和我谈恋爱，结果是我们俩都变成了一种气体，叫做什么一氧化二氮，或者说，叫做笑气，人家一见到我们在一起就要笑。”\"><a href=\"#“小孙和我谈恋爱，结果是我们俩都变成了一种气体，叫做什么一氧化二氮，或者说，叫做笑气，人家一见到我们在一起就要笑。”\" class=\"headerlink\" title=\"　　“小孙和我谈恋爱，结果是我们俩都变成了一种气体，叫做什么一氧化二氮，或者说，叫做笑气，人家一见到我们在一起就要笑。”\"></a>　　“小孙和我谈恋爱，结果是我们俩都变成了一种气体，叫做什么一氧化二氮，或者说，叫做笑气，人家一见到我们在一起就要笑。”</h3><h3 id=\"“李先生见了我就说这件事，同时愁眉苦脸。我就安慰他说：这也好，省得再找我修。我这样安慰过以后，他好像更伤心了。这件事证明了一个道理：萨特先生说得很对，他人是你的地狱。”\"><a href=\"#“李先生见了我就说这件事，同时愁眉苦脸。我就安慰他说：这也好，省得再找我修。我这样安慰过以后，他好像更伤心了。这件事证明了一个道理：萨特先生说得很对，他人是你的地狱。”\" class=\"headerlink\" title=\"　　“李先生见了我就说这件事，同时愁眉苦脸。我就安慰他说：这也好，省得再找我修。我这样安慰过以后，他好像更伤心了。这件事证明了一个道理：萨特先生说得很对，他人是你的地狱。”\"></a>　　“李先生见了我就说这件事，同时愁眉苦脸。我就安慰他说：这也好，省得再找我修。我这样安慰过以后，他好像更伤心了。这件事证明了一个道理：萨特先生说得很对，他人是你的地狱。”</h3><h3 id=\"“李先生干出了一件大家都干不出的事，这一点没有问题。这证明了他和大家不一样，这一点也没有问题。但是这种不一样是聪明还是有毛病，还没有定论。既然如此，就应该少数服从多数。大家说你聪明，你就是聪明，大家觉得你有毛病，你就是有毛病。”\"><a href=\"#“李先生干出了一件大家都干不出的事，这一点没有问题。这证明了他和大家不一样，这一点也没有问题。但是这种不一样是聪明还是有毛病，还没有定论。既然如此，就应该少数服从多数。大家说你聪明，你就是聪明，大家觉得你有毛病，你就是有毛病。”\" class=\"headerlink\" title=\"　　“李先生干出了一件大家都干不出的事，这一点没有问题。这证明了他和大家不一样，这一点也没有问题。但是这种不一样是聪明还是有毛病，还没有定论。既然如此，就应该少数服从多数。大家说你聪明，你就是聪明，大家觉得你有毛病，你就是有毛病。”\"></a>　　“李先生干出了一件大家都干不出的事，这一点没有问题。这证明了他和大家不一样，这一点也没有问题。但是这种不一样是聪明还是有毛病，还没有定论。既然如此，就应该少数服从多数。大家说你聪明，你就是聪明，大家觉得你有毛病，你就是有毛病。”</h3>","site":{"data":{}},"excerpt":"","more":"<h5 id=\"《黄金时代》包括中篇小说《黄金时代》、《三十而立》、《似水流年》、《革命时期的爱情》和《我的阴阳两界》等。\"><a href=\"#《黄金时代》包括中篇小说《黄金时代》、《三十而立》、《似水流年》、《革命时期的爱情》和《我的阴阳两界》等。\" class=\"headerlink\" title=\"《黄金时代》包括中篇小说《黄金时代》、《三十而立》、《似水流年》、《革命时期的爱情》和《我的阴阳两界》等。\"></a>《黄金时代》包括中篇小说《黄金时代》、《三十而立》、《似水流年》、《革命时期的爱情》和《我的阴阳两界》等。</h5><h2 id=\"笔记\"><a href=\"#笔记\" class=\"headerlink\" title=\"笔记\"></a>笔记</h2><h3 id=\"“我是这么想的：假如我想证明她不是破鞋，就能证明她不是破鞋，那事情未免太容易了。实际上我什么都不能证明，除了那些不需要证明的东西。”\"><a href=\"#“我是这么想的：假如我想证明她不是破鞋，就能证明她不是破鞋，那事情未免太容易了。实际上我什么都不能证明，除了那些不需要证明的东西。”\" class=\"headerlink\" title=\"　　“我是这么想的：假如我想证明她不是破鞋，就能证明她不是破鞋，那事情未免太容易了。实际上我什么都不能证明，除了那些不需要证明的东西。”\"></a>　　“我是这么想的：假如我想证明她不是破鞋，就能证明她不是破鞋，那事情未免太容易了。实际上我什么都不能证明，除了那些不需要证明的东西。”</h3><h5 id=\"在某些程度上，我们什么都证明不了。姓名、年龄、经历。因为这些都是建立在一定的某些基础之上，当世界上的人说你不是你自己时，你就不是你自己。你没法证明。\"><a href=\"#在某些程度上，我们什么都证明不了。姓名、年龄、经历。因为这些都是建立在一定的某些基础之上，当世界上的人说你不是你自己时，你就不是你自己。你没法证明。\" class=\"headerlink\" title=\"在某些程度上，我们什么都证明不了。姓名、年龄、经历。因为这些都是建立在一定的某些基础之上，当世界上的人说你不是你自己时，你就不是你自己。你没法证明。\"></a>在某些程度上，我们什么都证明不了。姓名、年龄、经历。因为这些都是建立在一定的某些基础之上，当世界上的人说你不是你自己时，你就不是你自己。你没法证明。</h5><h3 id=\"“我想到，用不着写诗给别人看，如果一个人来享受静夜，我的诗对他毫无用处。别人念了它，只会妨碍他享受自己的静夜诗。如果一个人不会唱，那么全世界的歌对他毫无用处；如果他会唱，那他一定要唱自己的歌。这就是说，诗人这个行当应该取消，每个人都要做自己的诗人。”\"><a href=\"#“我想到，用不着写诗给别人看，如果一个人来享受静夜，我的诗对他毫无用处。别人念了它，只会妨碍他享受自己的静夜诗。如果一个人不会唱，那么全世界的歌对他毫无用处；如果他会唱，那他一定要唱自己的歌。这就是说，诗人这个行当应该取消，每个人都要做自己的诗人。”\" class=\"headerlink\" title=\"　　“我想到，用不着写诗给别人看，如果一个人来享受静夜，我的诗对他毫无用处。别人念了它，只会妨碍他享受自己的静夜诗。如果一个人不会唱，那么全世界的歌对他毫无用处；如果他会唱，那他一定要唱自己的歌。这就是说，诗人这个行当应该取消，每个人都要做自己的诗人。”\"></a>　　“我想到，用不着写诗给别人看，如果一个人来享受静夜，我的诗对他毫无用处。别人念了它，只会妨碍他享受自己的静夜诗。如果一个人不会唱，那么全世界的歌对他毫无用处；如果他会唱，那他一定要唱自己的歌。这就是说，诗人这个行当应该取消，每个人都要做自己的诗人。”</h3><h5 id=\"从古至今留存下来的诗集，从来都是作者对自己内心的一种情感抒发。每个人都要做自己的诗人\"><a href=\"#从古至今留存下来的诗集，从来都是作者对自己内心的一种情感抒发。每个人都要做自己的诗人\" class=\"headerlink\" title=\"从古至今留存下来的诗集，从来都是作者对自己内心的一种情感抒发。每个人都要做自己的诗人\"></a>从古至今留存下来的诗集，从来都是作者对自己内心的一种情感抒发。每个人都要做自己的诗人</h5><h3 id=\"“照批者认为，这李先生是无聊之辈，你何必理他？既然理他，你也是无聊之辈。但是李先生对着大字报倒是认真答辩了。他认为大道理管小道理，其实是不讲理。大问题管小问题，实则混淆命题。就算揭批查重要，也不能叫人龟头血肿呀？只论大小重要不重要，不论是非真伪，是混蛋逻辑。”\"><a href=\"#“照批者认为，这李先生是无聊之辈，你何必理他？既然理他，你也是无聊之辈。但是李先生对着大字报倒是认真答辩了。他认为大道理管小道理，其实是不讲理。大问题管小问题，实则混淆命题。就算揭批查重要，也不能叫人龟头血肿呀？只论大小重要不重要，不论是非真伪，是混蛋逻辑。”\" class=\"headerlink\" title=\"　　“照批者认为，这李先生是无聊之辈，你何必理他？既然理他，你也是无聊之辈。但是李先生对着大字报倒是认真答辩了。他认为大道理管小道理，其实是不讲理。大问题管小问题，实则混淆命题。就算揭批查重要，也不能叫人龟头血肿呀？只论大小重要不重要，不论是非真伪，是混蛋逻辑。”\"></a>　　“照批者认为，这李先生是无聊之辈，你何必理他？既然理他，你也是无聊之辈。但是李先生对着大字报倒是认真答辩了。他认为大道理管小道理，其实是不讲理。大问题管小问题，实则混淆命题。就算揭批查重要，也不能叫人龟头血肿呀？只论大小重要不重要，不论是非真伪，是混蛋逻辑。”</h3><h3 id=\"“文化革命”到来之时，有些人高兴，有些人不高兴。刘老先生对我说过，一开头他就想自杀。因为他见那势头，总觉得躲不过去。但是他想到再峨嵋酒家还能吃到东坡肘子，又觉得死了太亏。”\"><a href=\"#“文化革命”到来之时，有些人高兴，有些人不高兴。刘老先生对我说过，一开头他就想自杀。因为他见那势头，总觉得躲不过去。但是他想到再峨嵋酒家还能吃到东坡肘子，又觉得死了太亏。”\" class=\"headerlink\" title=\"　　“文化革命”到来之时，有些人高兴，有些人不高兴。刘老先生对我说过，一开头他就想自杀。因为他见那势头，总觉得躲不过去。但是他想到再峨嵋酒家还能吃到东坡肘子，又觉得死了太亏。”\"></a>　　“文化革命”到来之时，有些人高兴，有些人不高兴。刘老先生对我说过，一开头他就想自杀。因为他见那势头，总觉得躲不过去。但是他想到再峨嵋酒家还能吃到东坡肘子，又觉得死了太亏。”</h3><h5 id=\"有时候让你坚持下去往往是一些很不起眼的东西。\"><a href=\"#有时候让你坚持下去往往是一些很不起眼的东西。\" class=\"headerlink\" title=\"有时候让你坚持下去往往是一些很不起眼的东西。\"></a>有时候让你坚持下去往往是一些很不起眼的东西。</h5><h3 id=\"“我活得很没劲，好像一个没用的人。人到了这步田地，反而会脑子伟大的想法。那时我想：要是发生了战争就好了。”\"><a href=\"#“我活得很没劲，好像一个没用的人。人到了这步田地，反而会脑子伟大的想法。那时我想：要是发生了战争就好了。”\" class=\"headerlink\" title=\"　　“我活得很没劲，好像一个没用的人。人到了这步田地，反而会脑子伟大的想法。那时我想：要是发生了战争就好了。”\"></a>　　“我活得很没劲，好像一个没用的人。人到了这步田地，反而会脑子伟大的想法。那时我想：要是发生了战争就好了。”</h3><h3 id=\"“人在四十岁之前，过得很慢，过了四十岁，过得就快了。”\"><a href=\"#“人在四十岁之前，过得很慢，过了四十岁，过得就快了。”\" class=\"headerlink\" title=\"　　“人在四十岁之前，过得很慢，过了四十岁，过得就快了。”\"></a>　　“人在四十岁之前，过得很慢，过了四十岁，过得就快了。”</h3><h3 id=\"“爬铜炉子没有一点好处，只能带来刻骨铭心的痛苦，但我还是要爬。这大概是说明你干的事情越傻，决心就会越大吧。这也说明我喜欢自己愚弄自己，却不喜欢被别人愚弄。”\"><a href=\"#“爬铜炉子没有一点好处，只能带来刻骨铭心的痛苦，但我还是要爬。这大概是说明你干的事情越傻，决心就会越大吧。这也说明我喜欢自己愚弄自己，却不喜欢被别人愚弄。”\" class=\"headerlink\" title=\"　　“爬铜炉子没有一点好处，只能带来刻骨铭心的痛苦，但我还是要爬。这大概是说明你干的事情越傻，决心就会越大吧。这也说明我喜欢自己愚弄自己，却不喜欢被别人愚弄。”\"></a>　　“爬铜炉子没有一点好处，只能带来刻骨铭心的痛苦，但我还是要爬。这大概是说明你干的事情越傻，决心就会越大吧。这也说明我喜欢自己愚弄自己，却不喜欢被别人愚弄。”</h3><h3 id=\"“在革命时期里，我随时准备承认自己是一只猪，来换取安宁。”\"><a href=\"#“在革命时期里，我随时准备承认自己是一只猪，来换取安宁。”\" class=\"headerlink\" title=\"　　“在革命时期里，我随时准备承认自己是一只猪，来换取安宁。”\"></a>　　“在革命时期里，我随时准备承认自己是一只猪，来换取安宁。”</h3><h3 id=\"“既然人饿了就要吃饭，渴了就要喝水，到了一定岁数就想性交，上了会场就要发呆，同属万般无奈；所以吃饭喝水性交和发呆，都属天赋人权的范畴。假如人犯了错误，可以用别的方法来惩办，却不能令他不发呆。如不其然，就会引起火灾。”\"><a href=\"#“既然人饿了就要吃饭，渴了就要喝水，到了一定岁数就想性交，上了会场就要发呆，同属万般无奈；所以吃饭喝水性交和发呆，都属天赋人权的范畴。假如人犯了错误，可以用别的方法来惩办，却不能令他不发呆。如不其然，就会引起火灾。”\" class=\"headerlink\" title=\"　　“既然人饿了就要吃饭，渴了就要喝水，到了一定岁数就想性交，上了会场就要发呆，同属万般无奈；所以吃饭喝水性交和发呆，都属天赋人权的范畴。假如人犯了错误，可以用别的方法来惩办，却不能令他不发呆。如不其然，就会引起火灾。”\"></a>　　“既然人饿了就要吃饭，渴了就要喝水，到了一定岁数就想性交，上了会场就要发呆，同属万般无奈；所以吃饭喝水性交和发呆，都属天赋人权的范畴。假如人犯了错误，可以用别的方法来惩办，却不能令他不发呆。如不其然，就会引起火灾。”</h3><h3 id=\"“对于不能恨的人，我只能用爱来化解仇恨。我爱上她了。”\"><a href=\"#“对于不能恨的人，我只能用爱来化解仇恨。我爱上她了。”\" class=\"headerlink\" title=\"　　“对于不能恨的人，我只能用爱来化解仇恨。我爱上她了。”\"></a>　　“对于不能恨的人，我只能用爱来化解仇恨。我爱上她了。”</h3><h3 id=\"“人活在世界上，快乐和痛苦本就分不清。所以我只求它货真价实。”\"><a href=\"#“人活在世界上，快乐和痛苦本就分不清。所以我只求它货真价实。”\" class=\"headerlink\" title=\"　　“人活在世界上，快乐和痛苦本就分不清。所以我只求它货真价实。”\"></a>　　“人活在世界上，快乐和痛苦本就分不清。所以我只求它货真价实。”</h3><h3 id=\"“有关我爸爸打我的事，还有一些要补充的地方。他戴着高帽子游街，我看到他时笑了一笑，于是我就挨了一顿打。由此容易得出一个结论：在那种场合应该苦着脸。但是这个结论是错的，因为哭丧着脸也要挨打。正确的结论是到了我该挨打的时候就会挨打，不管我是哭还是笑。既然活在世界上，不管怎样都要挨打，所以做什么都没有了意义。唯一有意义的事就是寻找神奇。”\"><a href=\"#“有关我爸爸打我的事，还有一些要补充的地方。他戴着高帽子游街，我看到他时笑了一笑，于是我就挨了一顿打。由此容易得出一个结论：在那种场合应该苦着脸。但是这个结论是错的，因为哭丧着脸也要挨打。正确的结论是到了我该挨打的时候就会挨打，不管我是哭还是笑。既然活在世界上，不管怎样都要挨打，所以做什么都没有了意义。唯一有意义的事就是寻找神奇。”\" class=\"headerlink\" title=\"　　“有关我爸爸打我的事，还有一些要补充的地方。他戴着高帽子游街，我看到他时笑了一笑，于是我就挨了一顿打。由此容易得出一个结论：在那种场合应该苦着脸。但是这个结论是错的，因为哭丧着脸也要挨打。正确的结论是到了我该挨打的时候就会挨打，不管我是哭还是笑。既然活在世界上，不管怎样都要挨打，所以做什么都没有了意义。唯一有意义的事就是寻找神奇。”\"></a>　　“有关我爸爸打我的事，还有一些要补充的地方。他戴着高帽子游街，我看到他时笑了一笑，于是我就挨了一顿打。由此容易得出一个结论：在那种场合应该苦着脸。但是这个结论是错的，因为哭丧着脸也要挨打。正确的结论是到了我该挨打的时候就会挨打，不管我是哭还是笑。既然活在世界上，不管怎样都要挨打，所以做什么都没有了意义。唯一有意义的事就是寻找神奇。”</h3><h3 id=\"“弗洛伊德说，受虐狂是这样形成的：假如人处于一种不能克服的痛苦之中，就会爱上这种痛苦，把它看成幸福。”\"><a href=\"#“弗洛伊德说，受虐狂是这样形成的：假如人处于一种不能克服的痛苦之中，就会爱上这种痛苦，把它看成幸福。”\" class=\"headerlink\" title=\"　　“弗洛伊德说，受虐狂是这样形成的：假如人处于一种不能克服的痛苦之中，就会爱上这种痛苦，把它看成幸福。”\"></a>　　“弗洛伊德说，受虐狂是这样形成的：假如人处于一种不能克服的痛苦之中，就会爱上这种痛苦，把它看成幸福。”</h3><h3 id=\"“在革命时期自己失掉了一个人，就如损失了十几块钱，有点伤心。这时候我们背上一段毛主席语录：“这种方法也要介绍到老百姓那里去，村上的人死了，开个追悼会，用这种方法寄托我们的哀思……”，然后就一点也不伤心，因为伤心被这种程式消化了。这种种程式就是高级智能。因为有了这种种程式，好多东西失去了它本来的意义——连死都不真了。”\"><a href=\"#“在革命时期自己失掉了一个人，就如损失了十几块钱，有点伤心。这时候我们背上一段毛主席语录：“这种方法也要介绍到老百姓那里去，村上的人死了，开个追悼会，用这种方法寄托我们的哀思……”，然后就一点也不伤心，因为伤心被这种程式消化了。这种种程式就是高级智能。因为有了这种种程式，好多东西失去了它本来的意义——连死都不真了。”\" class=\"headerlink\" title=\"　　“在革命时期自己失掉了一个人，就如损失了十几块钱，有点伤心。这时候我们背上一段毛主席语录：“这种方法也要介绍到老百姓那里去，村上的人死了，开个追悼会，用这种方法寄托我们的哀思……”，然后就一点也不伤心，因为伤心被这种程式消化了。这种种程式就是高级智能。因为有了这种种程式，好多东西失去了它本来的意义——连死都不真了。”\"></a>　　“在革命时期自己失掉了一个人，就如损失了十几块钱，有点伤心。这时候我们背上一段毛主席语录：“这种方法也要介绍到老百姓那里去，村上的人死了，开个追悼会，用这种方法寄托我们的哀思……”，然后就一点也不伤心，因为伤心被这种程式消化了。这种种程式就是高级智能。因为有了这种种程式，好多东西失去了它本来的意义——连死都不真了。”</h3><h3 id=\"“小孙和我谈恋爱，结果是我们俩都变成了一种气体，叫做什么一氧化二氮，或者说，叫做笑气，人家一见到我们在一起就要笑。”\"><a href=\"#“小孙和我谈恋爱，结果是我们俩都变成了一种气体，叫做什么一氧化二氮，或者说，叫做笑气，人家一见到我们在一起就要笑。”\" class=\"headerlink\" title=\"　　“小孙和我谈恋爱，结果是我们俩都变成了一种气体，叫做什么一氧化二氮，或者说，叫做笑气，人家一见到我们在一起就要笑。”\"></a>　　“小孙和我谈恋爱，结果是我们俩都变成了一种气体，叫做什么一氧化二氮，或者说，叫做笑气，人家一见到我们在一起就要笑。”</h3><h3 id=\"“李先生见了我就说这件事，同时愁眉苦脸。我就安慰他说：这也好，省得再找我修。我这样安慰过以后，他好像更伤心了。这件事证明了一个道理：萨特先生说得很对，他人是你的地狱。”\"><a href=\"#“李先生见了我就说这件事，同时愁眉苦脸。我就安慰他说：这也好，省得再找我修。我这样安慰过以后，他好像更伤心了。这件事证明了一个道理：萨特先生说得很对，他人是你的地狱。”\" class=\"headerlink\" title=\"　　“李先生见了我就说这件事，同时愁眉苦脸。我就安慰他说：这也好，省得再找我修。我这样安慰过以后，他好像更伤心了。这件事证明了一个道理：萨特先生说得很对，他人是你的地狱。”\"></a>　　“李先生见了我就说这件事，同时愁眉苦脸。我就安慰他说：这也好，省得再找我修。我这样安慰过以后，他好像更伤心了。这件事证明了一个道理：萨特先生说得很对，他人是你的地狱。”</h3><h3 id=\"“李先生干出了一件大家都干不出的事，这一点没有问题。这证明了他和大家不一样，这一点也没有问题。但是这种不一样是聪明还是有毛病，还没有定论。既然如此，就应该少数服从多数。大家说你聪明，你就是聪明，大家觉得你有毛病，你就是有毛病。”\"><a href=\"#“李先生干出了一件大家都干不出的事，这一点没有问题。这证明了他和大家不一样，这一点也没有问题。但是这种不一样是聪明还是有毛病，还没有定论。既然如此，就应该少数服从多数。大家说你聪明，你就是聪明，大家觉得你有毛病，你就是有毛病。”\" class=\"headerlink\" title=\"　　“李先生干出了一件大家都干不出的事，这一点没有问题。这证明了他和大家不一样，这一点也没有问题。但是这种不一样是聪明还是有毛病，还没有定论。既然如此，就应该少数服从多数。大家说你聪明，你就是聪明，大家觉得你有毛病，你就是有毛病。”\"></a>　　“李先生干出了一件大家都干不出的事，这一点没有问题。这证明了他和大家不一样，这一点也没有问题。但是这种不一样是聪明还是有毛病，还没有定论。既然如此，就应该少数服从多数。大家说你聪明，你就是聪明，大家觉得你有毛病，你就是有毛病。”</h3>"},{"layout":"book","title":"夹边沟记事","date":"2017-07-06T16:00:00.000Z","cover":"jiabiangou.jpg","_content":"","source":"_posts/read/jiabiangou.md","raw":"---\nlayout: book\ntitle: 夹边沟记事\ndate: 2017/07/07\ncover: jiabiangou.jpg\ncategories: [read]\n---\n","slug":"read/jiabiangou","published":1,"updated":"2018-05-08T13:00:14.289Z","comments":1,"photos":[],"link":"","_id":"cjgxop3lt001ejah1hxibenpb","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"book","title":"深入理解java虚拟机","author":"周志明","date":"2017-12-17T16:00:00.000Z","cover":"jvm.jpeg","_content":"","source":"_posts/read/jvm.md","raw":"---\nlayout: book\ntitle: 深入理解java虚拟机\nauthor: 周志明\ndate: 2017/12/18\ncover: jvm.jpeg\ncategories: [read]\n---","slug":"read/jvm","published":1,"updated":"2018-05-08T13:00:14.289Z","comments":1,"photos":[],"link":"","_id":"cjgxop3lw001hjah1mlaut33h","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"book","title":"当我们谈论爱情时，我们在谈论什么","date":"2016-12-14T16:00:00.000Z","cover":"love.jpeg","_content":"","source":"_posts/read/love.md","raw":"---\nlayout: book\ntitle: 当我们谈论爱情时，我们在谈论什么\ndate: 2016/12/15\ncover: love.jpeg\ncategories: [read]\n---\n","slug":"read/love","published":1,"updated":"2018-05-08T13:00:14.289Z","comments":1,"photos":[],"link":"","_id":"cjgxop3ly001ljah18shb64x1","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"book","title":"爱你就像爱生命","date":"2016-12-14T16:00:00.000Z","cover":"loveYou.jpeg","_content":"","source":"_posts/read/loveYou.md","raw":"---\nlayout: book\ntitle: 爱你就像爱生命\ndate: 2016/12/15\ncover: loveYou.jpeg\ncategories: [read]\n---\n","slug":"read/loveYou","published":1,"updated":"2018-05-08T13:00:14.290Z","comments":1,"photos":[],"link":"","_id":"cjgxop3m1001ojah1mhgpd310","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"book","title":"鼠疫","author":"阿尔贝·加缪","date":"2017-09-27T16:00:00.000Z","cover":"pestis.jpeg","_content":"","source":"_posts/read/pestis.md","raw":"---\nlayout: book\ntitle: 鼠疫\nauthor: 阿尔贝·加缪\ndate: 2017/09/28\ncover: pestis.jpeg\ncategories: [read]\n---","slug":"read/pestis","published":1,"updated":"2018-05-08T13:00:14.290Z","comments":1,"photos":[],"link":"","_id":"cjgxop3m2001rjah19u7yyh3c","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"book","title":"redis实战","author":"Josiah L. Carlson","date":"2018-04-12T16:00:00.000Z","cover":"redisinaction.jpg","_content":"","source":"_posts/read/redisinaction.md","raw":"---\nlayout: book\ntitle: redis实战\nauthor: Josiah L. Carlson\ndate: 2018/04/13\ncover: redisinaction.jpg\ncategories: [read]\n---","slug":"read/redisinaction","published":1,"updated":"2018-05-08T13:00:14.290Z","comments":1,"photos":[],"link":"","_id":"cjgxop3m3001ujah18mo0plc4","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"book","title":"沉默的大多数","author":"王小波","date":"2017-09-17T16:00:00.000Z","cover":"silentMajority.jpeg","_content":"","source":"_posts/read/silentMajority.md","raw":"---\nlayout: book\ntitle: 沉默的大多数\nauthor: 王小波\ndate: 2017/09/18\ncover: silentMajority.jpeg\ncategories: [read]\n---","slug":"read/silentMajority","published":1,"updated":"2018-05-08T13:00:14.291Z","comments":1,"photos":[],"link":"","_id":"cjgxop3m5001xjah1spkcufpa","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"book","title":"白银时代","author":"王小波","date":"2017-12-17T16:00:00.000Z","cover":"silverage.jpeg","_content":"","source":"_posts/read/silverage.md","raw":"---\nlayout: book\ntitle: 白银时代\nauthor: 王小波\ndate: 2017/12/18\ncover: silverage.jpeg\ncategories: [read]\n---","slug":"read/silverage","published":1,"updated":"2018-05-08T13:00:14.291Z","comments":1,"photos":[],"link":"","_id":"cjgxop3m70020jah173h9j47v","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"book","title":"血字的研究","date":"2017-09-30T16:00:00.000Z","cover":"TangledSkein.jpg","_content":"","source":"_posts/read/tangledSkein.md","raw":"---\nlayout: book\ntitle: 血字的研究\ndate: 2017/10/01\ncover: TangledSkein.jpg\ncategories: [read]\n---\n","slug":"read/tangledSkein","published":1,"updated":"2018-05-08T13:00:14.291Z","comments":1,"photos":[],"link":"","_id":"cjgxop3m90022jah1dl7ygtol","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"book","title":"Java编程思想","date":"2016-12-14T16:00:00.000Z","cover":"thinkingInJava.jpeg","_content":"","source":"_posts/read/thinkInJava.md","raw":"---\nlayout: book\ntitle: Java编程思想\ndate: 2016/12/15\ncover: thinkingInJava.jpeg\ncategories: [read]\n---","slug":"read/thinkInJava","published":1,"updated":"2018-05-08T13:00:14.291Z","comments":1,"photos":[],"link":"","_id":"cjgxop3ma0024jah1aw8jm7hz","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"book","title":"边城","date":"2017-03-22T16:00:00.000Z","cover":"town.jpg","_content":"","source":"_posts/read/town.md","raw":"---\nlayout: book\ntitle: 边城\ndate: 2017/03/23\ncover: town.jpg\ncategories: [read]\n---\n","slug":"read/town","published":1,"updated":"2018-05-08T13:00:14.292Z","comments":1,"photos":[],"link":"","_id":"cjgxop3mb0026jah1ilxp44tr","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"book","title":"白夜行","date":"2017-03-14T16:00:00.000Z","cover":"walkAtNight.jpeg","_content":"\n#### 作为一个中国观众，有点没办法接受这样的结局。雪慧居然没有绳之于法。\n##### 东野圭吾的小说看着很舒服，因为作者本身的语言比较简单，但是不代表他所表达的意思简单或者含糊不清。相反，这种简单直白的文字使得作者想要表达的意思很容易就被读者所接收到。\n\n##### 回过头去想，白夜行所讲的故事其实很简单。书中的很多关键信息作者并不会直接给出（那不就成了新闻了，哈哈）。作者通过很多的故事线，去表达人物的情感和内心。","source":"_posts/read/walkAtNight.md","raw":"---\nlayout: book\ntitle: 白夜行\ndate: 2017/03/15\ncover: walkAtNight.jpeg\ncategories: [read]\n---\n\n#### 作为一个中国观众，有点没办法接受这样的结局。雪慧居然没有绳之于法。\n##### 东野圭吾的小说看着很舒服，因为作者本身的语言比较简单，但是不代表他所表达的意思简单或者含糊不清。相反，这种简单直白的文字使得作者想要表达的意思很容易就被读者所接收到。\n\n##### 回过头去想，白夜行所讲的故事其实很简单。书中的很多关键信息作者并不会直接给出（那不就成了新闻了，哈哈）。作者通过很多的故事线，去表达人物的情感和内心。","slug":"read/walkAtNight","published":1,"updated":"2018-05-08T13:00:14.292Z","comments":1,"photos":[],"link":"","_id":"cjgxop3mc0028jah13vnotv6a","content":"<h4 id=\"作为一个中国观众，有点没办法接受这样的结局。雪慧居然没有绳之于法。\"><a href=\"#作为一个中国观众，有点没办法接受这样的结局。雪慧居然没有绳之于法。\" class=\"headerlink\" title=\"作为一个中国观众，有点没办法接受这样的结局。雪慧居然没有绳之于法。\"></a>作为一个中国观众，有点没办法接受这样的结局。雪慧居然没有绳之于法。</h4><h5 id=\"东野圭吾的小说看着很舒服，因为作者本身的语言比较简单，但是不代表他所表达的意思简单或者含糊不清。相反，这种简单直白的文字使得作者想要表达的意思很容易就被读者所接收到。\"><a href=\"#东野圭吾的小说看着很舒服，因为作者本身的语言比较简单，但是不代表他所表达的意思简单或者含糊不清。相反，这种简单直白的文字使得作者想要表达的意思很容易就被读者所接收到。\" class=\"headerlink\" title=\"东野圭吾的小说看着很舒服，因为作者本身的语言比较简单，但是不代表他所表达的意思简单或者含糊不清。相反，这种简单直白的文字使得作者想要表达的意思很容易就被读者所接收到。\"></a>东野圭吾的小说看着很舒服，因为作者本身的语言比较简单，但是不代表他所表达的意思简单或者含糊不清。相反，这种简单直白的文字使得作者想要表达的意思很容易就被读者所接收到。</h5><h5 id=\"回过头去想，白夜行所讲的故事其实很简单。书中的很多关键信息作者并不会直接给出（那不就成了新闻了，哈哈）。作者通过很多的故事线，去表达人物的情感和内心。\"><a href=\"#回过头去想，白夜行所讲的故事其实很简单。书中的很多关键信息作者并不会直接给出（那不就成了新闻了，哈哈）。作者通过很多的故事线，去表达人物的情感和内心。\" class=\"headerlink\" title=\"回过头去想，白夜行所讲的故事其实很简单。书中的很多关键信息作者并不会直接给出（那不就成了新闻了，哈哈）。作者通过很多的故事线，去表达人物的情感和内心。\"></a>回过头去想，白夜行所讲的故事其实很简单。书中的很多关键信息作者并不会直接给出（那不就成了新闻了，哈哈）。作者通过很多的故事线，去表达人物的情感和内心。</h5>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"作为一个中国观众，有点没办法接受这样的结局。雪慧居然没有绳之于法。\"><a href=\"#作为一个中国观众，有点没办法接受这样的结局。雪慧居然没有绳之于法。\" class=\"headerlink\" title=\"作为一个中国观众，有点没办法接受这样的结局。雪慧居然没有绳之于法。\"></a>作为一个中国观众，有点没办法接受这样的结局。雪慧居然没有绳之于法。</h4><h5 id=\"东野圭吾的小说看着很舒服，因为作者本身的语言比较简单，但是不代表他所表达的意思简单或者含糊不清。相反，这种简单直白的文字使得作者想要表达的意思很容易就被读者所接收到。\"><a href=\"#东野圭吾的小说看着很舒服，因为作者本身的语言比较简单，但是不代表他所表达的意思简单或者含糊不清。相反，这种简单直白的文字使得作者想要表达的意思很容易就被读者所接收到。\" class=\"headerlink\" title=\"东野圭吾的小说看着很舒服，因为作者本身的语言比较简单，但是不代表他所表达的意思简单或者含糊不清。相反，这种简单直白的文字使得作者想要表达的意思很容易就被读者所接收到。\"></a>东野圭吾的小说看着很舒服，因为作者本身的语言比较简单，但是不代表他所表达的意思简单或者含糊不清。相反，这种简单直白的文字使得作者想要表达的意思很容易就被读者所接收到。</h5><h5 id=\"回过头去想，白夜行所讲的故事其实很简单。书中的很多关键信息作者并不会直接给出（那不就成了新闻了，哈哈）。作者通过很多的故事线，去表达人物的情感和内心。\"><a href=\"#回过头去想，白夜行所讲的故事其实很简单。书中的很多关键信息作者并不会直接给出（那不就成了新闻了，哈哈）。作者通过很多的故事线，去表达人物的情感和内心。\" class=\"headerlink\" title=\"回过头去想，白夜行所讲的故事其实很简单。书中的很多关键信息作者并不会直接给出（那不就成了新闻了，哈哈）。作者通过很多的故事线，去表达人物的情感和内心。\"></a>回过头去想，白夜行所讲的故事其实很简单。书中的很多关键信息作者并不会直接给出（那不就成了新闻了，哈哈）。作者通过很多的故事线，去表达人物的情感和内心。</h5>"},{"layout":"book","title":"嫌疑人x的现身","author":"东野奎吾","date":"2018-03-25T16:00:00.000Z","cover":"x.jpeg","_content":"","source":"_posts/read/x.md","raw":"---\nlayout: book\ntitle: 嫌疑人x的现身\nauthor: 东野奎吾\ndate: 2018/03/26\ncover: x.jpeg\ncategories: [read]\n---","slug":"read/x","published":1,"updated":"2018-05-08T13:00:14.292Z","comments":1,"photos":[],"link":"","_id":"cjgxop3mc002ajah1fpllmct1","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"post","title":"假设检验中的P值计算-JAVA","date":"2016-12-27T16:00:00.000Z","original":true,"tag":[["算法","arithmetic"]],"_content":"\n##### 最近产品提出需求，对于ab实验，希望能够通过实验数据计算出P值，以对数据的准确性做一个直观判断。最开始不知道P值是一个什么概念，觉得应该很简单，baidu或者google以下应该会有很多开源的代码或者jar包；又或者是自己将P值公式实现便可。但是一番查找后发现没有想的这么简单，网络上对于P值得计算过程大多含糊不清，更别提完整的计算代码。最后没办法，只有通过自己拿起概率论书本重新进行学习，以下便记录自己从P值是什么到java实现的一些细节。\n<!--more-->\n\n## 1. 统计学中P值\n##### P值是指当假设为真时所得到的观察结果的概率，简单讲P值就是概率，反映某一事件发生的可能性大小。下面几个比较重要的基础概念对于理解P值的意义会有帮助。\n### 1.1 概率论中几个比较重要的基础概念\n#### 1.1.1 原假设与备择假设：\n##### __原假设（H<sub>0</sub>）__：通常将研究者想手机证据予以反对的假设称为原假设，用H<sub>0</sub>表示；\n##### __备择假设（H<sub>1</sub>）__：通常将研究者想收集证据予以支持的假设称为备择假设，或称研究假设，用H<sub>1</sub>活H<sub>2</sub>表示。\n\n##### 举个栗子：\n<div class=\"highlighter-rouge\"><pre class=\"highlight\"><code>某品牌洗涤剂在产品说明书中声称：平均净含量不少于500g。从消费者利益出发，有关研究人员要通过抽检其中的一批产品来验证该产品制造商的说明是否属实。    \n解：对于该洗涤剂的平均含量的真值为μ。如果抽检的结果发现μ<500，则表明该产品说明书中关于其净含量的内容是不真实的。一般来说，研究者抽检的意图是倾向于证实这种洗涤剂的平均净含量不符合说明书中的概述，因为这不符合说明书的陈述。如果研究者对于产品说明丝毫没有质疑，也就没有必要抽检了。所以μ<500是研究者想要收集证据支持的观点。    \n<br><h6>H<sub>0</sub>:μ≥500(净含量符合说明书);</h6><h6>H<sub>1</sub>:μ&lt;500(净含量不符合说明书)。</h6></code></pre></div>\n\n\n<div class=\"highlighter-rouge\"><pre class=\"highlight\"><code>一家研究机构估计，某城市中家庭拥有汽车的比例超过30%。为了验证这一估计是否正确，该研究机构随机抽取了一个样本进行检验。     \n解：设该城市中家庭拥有汽车的比例真值为π。显然，研究者想收集证据予以支持的假设是:该城市中家庭拥有汽车的比例超过30%。因此建立的原假设与备择假设应为\n<h6>H<sub>0</sub>:π≤30%（家庭拥有汽车的比例不超过30%）;</h6><h6>H<sub>1</sub>:π>30%（家庭拥有汽车的比例超过30%）。</h6></code></pre></div>\n\n* 原假设和备择假设是一个完备事件组，而且互相对立。也就是说在一项假设检验中，必有且只有一个成立；\n* 在假设检验中，等号\"=\"总是放在原假设上。   \n\n#### 1.1.2 单侧检验和双侧检验：\n##### __单侧检验__：备择假设具有特定的方向性，并含有符号\">\"或\"<\"的假设检验；\n##### __双侧检验__：备择假设没有特定的方向性，并含有符号\"≠\"的假设检验。     \n![假设检验的基本形式](/img/pvalue/pvalue1.png)    <div class='img-note'>假设检验的基本形式</div>\n\n#### 1.1.3 两类错误与显著水平    \n##### 如前所述，原假设与备择假设不能同时成立，我们要么拒绝原假设，要么不拒绝原假设。我们希望的情况是：当原假设正确时没有拒绝它，当原假设不正确时拒绝它。但是我们无法保证不犯错。假设检验中过程中可能发生以下两类错误：    \n##### __I类错误__：当原假设为真是拒绝原假设，所犯的错误称为第I类错误；    \n##### __II类错误__：当原假设为假时没有拒绝原假设，所犯错误称为第II类错误。    \n![假设检验的结论与后果](/img/pvalue/pvalue2.png)   <div class='img-note'>假设检验的结论与后果</div>\n\n##### 只有当原假设被拒绝时，我们才会犯第I类错误；只有当原假设未被拒绝时，我们才会犯第II类错误。因此，我们可以不犯第I类错误或不犯第II类错误，但不可能两类错误都不犯。两类错误就像一个跷跷板，当一个概率增大时，另一个减小。人们只能在两类错误的发生概率之间进行平衡。一般来说，发生哪一类错误的后果更为严重，就应该首要控制哪类错误发生的概率，但由于犯第I类错误的概率是可以又研究者控制的，因为此在假设检验中，人们往往先控制第I类错误的发生概率。\n\n``\n发生第I类错误的概率常被用于度量检验结论的可靠性，并将这一概率称为显著性水平，记为α。\n``\n\n##### __显著水平__ 是人们事先指定的犯第I类错误概率α的最大允许值。显著水平α越小，犯第I类错误的可能性自然就越小，但犯第II类错误的可能性则随之增大。作为一个普遍使用的原则，人们通常选择显著性水平为0.05或比0.05更小的概率。\n\n#### 1.1.4 标准化检测量与拒绝域\n\n##### __检验统计量__ 实际上是总体参数的点估计量，但点估计量并不能直接作为检验的统计量，只有将其标准化后，才能用于度量它与原假设的参数之间的差异程度。实际上，假设检验中所用的检验统计量都是标准化检验统计量，它反映了点估计量（比如样本均值）与假设的总体参数（比如假设的总体均值）相比相差了多少个标准差。\n\n$$标准化检验统计量 = \\frac{点估计量 - 假设值}{点估计量的抽样标准差}$$\n\n##### __拒绝域__ 能够拒绝原假设的检验统计量的所有可能取值的集合。是由显著性水平α所围成的区域。如果利用样本观测结果计算出来的检验统计量的具体数值落在了拒绝域内，就拒绝原假设，否则就不拒绝原假设。\n![显著性水平、拒绝域和临界值](/img/pvalue/pvalue3.jpeg)<div class='img-note'>显著性水平、拒绝域和临界值</div>\n\n##### 当样本容量固定时，拒绝域的面积随α的减小而减小。α值越小，拒绝域假设所需的检验统计量的临界值与原假设的参数值就越远。\n\n### 1.2 利用P值进行决策\n##### 显著性水平α是在检验之前确定的，这也就意味着我们事先确定了拒绝域。这样，不论检验统计量的值是大是小，只要它的值落入拒绝域就拒绝原假设，否者就不拒绝原假设。这种固定的显著性水平α对检验结果只能提供检验结论可靠性的一个大致范围，无法给出观测数据与原假设之间不一致程度的精确度量。\n\n##### __P值__ 在原假设为真的条件下，检验统计量的观察值大于或等于其计算值的概率，称为P值。P值是反映实际观测到的数据与原假设之间不一致程度的一个概率值。P值越小，说明实际观测到的数据与原假设之间不一致的程度就越大，检验的结果也就越显著。\n\n### 1.3 一个总体参数的检验\n##### 当我们研究一个总体时，要检验的参数主要是总体均值μ、总体比例π和总体方差σ<SUP>2</SUP>。由于检验的参数不同，计算检验统计量的方法也有所不同。\n\n#### 1.3.1 总体均值的检验\n##### 对于总体均值进行假设检验，采用什么检验步骤和检验统计量取决于我们所抽取的样本是大样本（n≥30）还是小样本（n<30），此外还需要区分总体是否服从正太分布、总体方差σ<SUP>2</SUP>是否已知等几种情况。\n![大样本情况下一个总体均值的检验方法](/img/pvalue/pvalue4.png)    <div class='img-note'>大样本情况下一个总体均值的检验方法</div>\n![小样本情况下一个总体均值的检验方法](/img/pvalue/pvalue5.png)    <div class='img-note'>小样本情况下一个总体均值的检验方法</div>\n\n##### Z表示转换为标准正太分布下的检验统计量。\n\n#### 1.3.2 总体比例的检验\n##### 总体比例是指总体中具有某种相同特征的个体所占的比例，这些特征可以是数据型的（如一定的重量、一定的厚度或一定规格等），也可以是品质型的（如男女比例、学历等级、职称高低等）。\n##### 在构造检验统计量时，我们仍然利用样本比例p与总体比例π之间的距离等于多少个标准差来衡量，因为在大样本情况下统计量p近似服从正太分布，而统计量\n$$z = \\frac{P - π_0}{\\sqrt{\\frac{π_0(1-π_0)}{n}}}$$\n\n![大样本情况下一个总体比例的检验方法](/img/pvalue/pvalue6.png)    <div class='img-note'>大样本情况下一个总体比例的检验方法</div>\n\n### 1.4 两个总体参数的检验\n##### 在实际研究中，我们常常要比较两个总体的差异，如一所学校的重点班和普通班两个班级学生的英语成绩是否有显著差异；生产企业在改进生产线后的平均产量与原生产线的平均产量相比是否有显著提高等等。\n![两个总体均值之差的三种基本假设检验形式](/img/pvalue/pvalue7.png)    <div class='img-note'>两个总体均值之差的三种基本假设检验形式</div>","source":"_posts/note/arithmetic/JAVA-pValue.md","raw":"---\nlayout: post\ntitle: 假设检验中的P值计算-JAVA\ndate: 2016/12/28\ntags: [tech, arithmetic, index]\noriginal: true\ntag: [[算法, arithmetic]]\n---\n\n##### 最近产品提出需求，对于ab实验，希望能够通过实验数据计算出P值，以对数据的准确性做一个直观判断。最开始不知道P值是一个什么概念，觉得应该很简单，baidu或者google以下应该会有很多开源的代码或者jar包；又或者是自己将P值公式实现便可。但是一番查找后发现没有想的这么简单，网络上对于P值得计算过程大多含糊不清，更别提完整的计算代码。最后没办法，只有通过自己拿起概率论书本重新进行学习，以下便记录自己从P值是什么到java实现的一些细节。\n<!--more-->\n\n## 1. 统计学中P值\n##### P值是指当假设为真时所得到的观察结果的概率，简单讲P值就是概率，反映某一事件发生的可能性大小。下面几个比较重要的基础概念对于理解P值的意义会有帮助。\n### 1.1 概率论中几个比较重要的基础概念\n#### 1.1.1 原假设与备择假设：\n##### __原假设（H<sub>0</sub>）__：通常将研究者想手机证据予以反对的假设称为原假设，用H<sub>0</sub>表示；\n##### __备择假设（H<sub>1</sub>）__：通常将研究者想收集证据予以支持的假设称为备择假设，或称研究假设，用H<sub>1</sub>活H<sub>2</sub>表示。\n\n##### 举个栗子：\n<div class=\"highlighter-rouge\"><pre class=\"highlight\"><code>某品牌洗涤剂在产品说明书中声称：平均净含量不少于500g。从消费者利益出发，有关研究人员要通过抽检其中的一批产品来验证该产品制造商的说明是否属实。    \n解：对于该洗涤剂的平均含量的真值为μ。如果抽检的结果发现μ<500，则表明该产品说明书中关于其净含量的内容是不真实的。一般来说，研究者抽检的意图是倾向于证实这种洗涤剂的平均净含量不符合说明书中的概述，因为这不符合说明书的陈述。如果研究者对于产品说明丝毫没有质疑，也就没有必要抽检了。所以μ<500是研究者想要收集证据支持的观点。    \n<br><h6>H<sub>0</sub>:μ≥500(净含量符合说明书);</h6><h6>H<sub>1</sub>:μ&lt;500(净含量不符合说明书)。</h6></code></pre></div>\n\n\n<div class=\"highlighter-rouge\"><pre class=\"highlight\"><code>一家研究机构估计，某城市中家庭拥有汽车的比例超过30%。为了验证这一估计是否正确，该研究机构随机抽取了一个样本进行检验。     \n解：设该城市中家庭拥有汽车的比例真值为π。显然，研究者想收集证据予以支持的假设是:该城市中家庭拥有汽车的比例超过30%。因此建立的原假设与备择假设应为\n<h6>H<sub>0</sub>:π≤30%（家庭拥有汽车的比例不超过30%）;</h6><h6>H<sub>1</sub>:π>30%（家庭拥有汽车的比例超过30%）。</h6></code></pre></div>\n\n* 原假设和备择假设是一个完备事件组，而且互相对立。也就是说在一项假设检验中，必有且只有一个成立；\n* 在假设检验中，等号\"=\"总是放在原假设上。   \n\n#### 1.1.2 单侧检验和双侧检验：\n##### __单侧检验__：备择假设具有特定的方向性，并含有符号\">\"或\"<\"的假设检验；\n##### __双侧检验__：备择假设没有特定的方向性，并含有符号\"≠\"的假设检验。     \n![假设检验的基本形式](/img/pvalue/pvalue1.png)    <div class='img-note'>假设检验的基本形式</div>\n\n#### 1.1.3 两类错误与显著水平    \n##### 如前所述，原假设与备择假设不能同时成立，我们要么拒绝原假设，要么不拒绝原假设。我们希望的情况是：当原假设正确时没有拒绝它，当原假设不正确时拒绝它。但是我们无法保证不犯错。假设检验中过程中可能发生以下两类错误：    \n##### __I类错误__：当原假设为真是拒绝原假设，所犯的错误称为第I类错误；    \n##### __II类错误__：当原假设为假时没有拒绝原假设，所犯错误称为第II类错误。    \n![假设检验的结论与后果](/img/pvalue/pvalue2.png)   <div class='img-note'>假设检验的结论与后果</div>\n\n##### 只有当原假设被拒绝时，我们才会犯第I类错误；只有当原假设未被拒绝时，我们才会犯第II类错误。因此，我们可以不犯第I类错误或不犯第II类错误，但不可能两类错误都不犯。两类错误就像一个跷跷板，当一个概率增大时，另一个减小。人们只能在两类错误的发生概率之间进行平衡。一般来说，发生哪一类错误的后果更为严重，就应该首要控制哪类错误发生的概率，但由于犯第I类错误的概率是可以又研究者控制的，因为此在假设检验中，人们往往先控制第I类错误的发生概率。\n\n``\n发生第I类错误的概率常被用于度量检验结论的可靠性，并将这一概率称为显著性水平，记为α。\n``\n\n##### __显著水平__ 是人们事先指定的犯第I类错误概率α的最大允许值。显著水平α越小，犯第I类错误的可能性自然就越小，但犯第II类错误的可能性则随之增大。作为一个普遍使用的原则，人们通常选择显著性水平为0.05或比0.05更小的概率。\n\n#### 1.1.4 标准化检测量与拒绝域\n\n##### __检验统计量__ 实际上是总体参数的点估计量，但点估计量并不能直接作为检验的统计量，只有将其标准化后，才能用于度量它与原假设的参数之间的差异程度。实际上，假设检验中所用的检验统计量都是标准化检验统计量，它反映了点估计量（比如样本均值）与假设的总体参数（比如假设的总体均值）相比相差了多少个标准差。\n\n$$标准化检验统计量 = \\frac{点估计量 - 假设值}{点估计量的抽样标准差}$$\n\n##### __拒绝域__ 能够拒绝原假设的检验统计量的所有可能取值的集合。是由显著性水平α所围成的区域。如果利用样本观测结果计算出来的检验统计量的具体数值落在了拒绝域内，就拒绝原假设，否则就不拒绝原假设。\n![显著性水平、拒绝域和临界值](/img/pvalue/pvalue3.jpeg)<div class='img-note'>显著性水平、拒绝域和临界值</div>\n\n##### 当样本容量固定时，拒绝域的面积随α的减小而减小。α值越小，拒绝域假设所需的检验统计量的临界值与原假设的参数值就越远。\n\n### 1.2 利用P值进行决策\n##### 显著性水平α是在检验之前确定的，这也就意味着我们事先确定了拒绝域。这样，不论检验统计量的值是大是小，只要它的值落入拒绝域就拒绝原假设，否者就不拒绝原假设。这种固定的显著性水平α对检验结果只能提供检验结论可靠性的一个大致范围，无法给出观测数据与原假设之间不一致程度的精确度量。\n\n##### __P值__ 在原假设为真的条件下，检验统计量的观察值大于或等于其计算值的概率，称为P值。P值是反映实际观测到的数据与原假设之间不一致程度的一个概率值。P值越小，说明实际观测到的数据与原假设之间不一致的程度就越大，检验的结果也就越显著。\n\n### 1.3 一个总体参数的检验\n##### 当我们研究一个总体时，要检验的参数主要是总体均值μ、总体比例π和总体方差σ<SUP>2</SUP>。由于检验的参数不同，计算检验统计量的方法也有所不同。\n\n#### 1.3.1 总体均值的检验\n##### 对于总体均值进行假设检验，采用什么检验步骤和检验统计量取决于我们所抽取的样本是大样本（n≥30）还是小样本（n<30），此外还需要区分总体是否服从正太分布、总体方差σ<SUP>2</SUP>是否已知等几种情况。\n![大样本情况下一个总体均值的检验方法](/img/pvalue/pvalue4.png)    <div class='img-note'>大样本情况下一个总体均值的检验方法</div>\n![小样本情况下一个总体均值的检验方法](/img/pvalue/pvalue5.png)    <div class='img-note'>小样本情况下一个总体均值的检验方法</div>\n\n##### Z表示转换为标准正太分布下的检验统计量。\n\n#### 1.3.2 总体比例的检验\n##### 总体比例是指总体中具有某种相同特征的个体所占的比例，这些特征可以是数据型的（如一定的重量、一定的厚度或一定规格等），也可以是品质型的（如男女比例、学历等级、职称高低等）。\n##### 在构造检验统计量时，我们仍然利用样本比例p与总体比例π之间的距离等于多少个标准差来衡量，因为在大样本情况下统计量p近似服从正太分布，而统计量\n$$z = \\frac{P - π_0}{\\sqrt{\\frac{π_0(1-π_0)}{n}}}$$\n\n![大样本情况下一个总体比例的检验方法](/img/pvalue/pvalue6.png)    <div class='img-note'>大样本情况下一个总体比例的检验方法</div>\n\n### 1.4 两个总体参数的检验\n##### 在实际研究中，我们常常要比较两个总体的差异，如一所学校的重点班和普通班两个班级学生的英语成绩是否有显著差异；生产企业在改进生产线后的平均产量与原生产线的平均产量相比是否有显著提高等等。\n![两个总体均值之差的三种基本假设检验形式](/img/pvalue/pvalue7.png)    <div class='img-note'>两个总体均值之差的三种基本假设检验形式</div>","slug":"note/arithmetic/JAVA-pValue","published":1,"updated":"2018-05-08T14:51:18.352Z","_id":"cjgxop3mw002hjah1uah7y03z","comments":1,"photos":[],"link":"","content":"<h5 id=\"最近产品提出需求，对于ab实验，希望能够通过实验数据计算出P值，以对数据的准确性做一个直观判断。最开始不知道P值是一个什么概念，觉得应该很简单，baidu或者google以下应该会有很多开源的代码或者jar包；又或者是自己将P值公式实现便可。但是一番查找后发现没有想的这么简单，网络上对于P值得计算过程大多含糊不清，更别提完整的计算代码。最后没办法，只有通过自己拿起概率论书本重新进行学习，以下便记录自己从P值是什么到java实现的一些细节。\"><a href=\"#最近产品提出需求，对于ab实验，希望能够通过实验数据计算出P值，以对数据的准确性做一个直观判断。最开始不知道P值是一个什么概念，觉得应该很简单，baidu或者google以下应该会有很多开源的代码或者jar包；又或者是自己将P值公式实现便可。但是一番查找后发现没有想的这么简单，网络上对于P值得计算过程大多含糊不清，更别提完整的计算代码。最后没办法，只有通过自己拿起概率论书本重新进行学习，以下便记录自己从P值是什么到java实现的一些细节。\" class=\"headerlink\" title=\"最近产品提出需求，对于ab实验，希望能够通过实验数据计算出P值，以对数据的准确性做一个直观判断。最开始不知道P值是一个什么概念，觉得应该很简单，baidu或者google以下应该会有很多开源的代码或者jar包；又或者是自己将P值公式实现便可。但是一番查找后发现没有想的这么简单，网络上对于P值得计算过程大多含糊不清，更别提完整的计算代码。最后没办法，只有通过自己拿起概率论书本重新进行学习，以下便记录自己从P值是什么到java实现的一些细节。\"></a>最近产品提出需求，对于ab实验，希望能够通过实验数据计算出P值，以对数据的准确性做一个直观判断。最开始不知道P值是一个什么概念，觉得应该很简单，baidu或者google以下应该会有很多开源的代码或者jar包；又或者是自己将P值公式实现便可。但是一番查找后发现没有想的这么简单，网络上对于P值得计算过程大多含糊不清，更别提完整的计算代码。最后没办法，只有通过自己拿起概率论书本重新进行学习，以下便记录自己从P值是什么到java实现的一些细节。</h5><a id=\"more\"></a>\n<h2 id=\"1-统计学中P值\"><a href=\"#1-统计学中P值\" class=\"headerlink\" title=\"1. 统计学中P值\"></a>1. 统计学中P值</h2><h5 id=\"P值是指当假设为真时所得到的观察结果的概率，简单讲P值就是概率，反映某一事件发生的可能性大小。下面几个比较重要的基础概念对于理解P值的意义会有帮助。\"><a href=\"#P值是指当假设为真时所得到的观察结果的概率，简单讲P值就是概率，反映某一事件发生的可能性大小。下面几个比较重要的基础概念对于理解P值的意义会有帮助。\" class=\"headerlink\" title=\"P值是指当假设为真时所得到的观察结果的概率，简单讲P值就是概率，反映某一事件发生的可能性大小。下面几个比较重要的基础概念对于理解P值的意义会有帮助。\"></a>P值是指当假设为真时所得到的观察结果的概率，简单讲P值就是概率，反映某一事件发生的可能性大小。下面几个比较重要的基础概念对于理解P值的意义会有帮助。</h5><h3 id=\"1-1-概率论中几个比较重要的基础概念\"><a href=\"#1-1-概率论中几个比较重要的基础概念\" class=\"headerlink\" title=\"1.1 概率论中几个比较重要的基础概念\"></a>1.1 概率论中几个比较重要的基础概念</h3><h4 id=\"1-1-1-原假设与备择假设：\"><a href=\"#1-1-1-原假设与备择假设：\" class=\"headerlink\" title=\"1.1.1 原假设与备择假设：\"></a>1.1.1 原假设与备择假设：</h4><h5 id=\"原假设（H0）：通常将研究者想手机证据予以反对的假设称为原假设，用H0表示；\"><a href=\"#原假设（H0）：通常将研究者想手机证据予以反对的假设称为原假设，用H0表示；\" class=\"headerlink\" title=\"原假设（H0）：通常将研究者想手机证据予以反对的假设称为原假设，用H0表示；\"></a><strong>原假设（H<sub>0</sub>）</strong>：通常将研究者想手机证据予以反对的假设称为原假设，用H<sub>0</sub>表示；</h5><h5 id=\"备择假设（H1）：通常将研究者想收集证据予以支持的假设称为备择假设，或称研究假设，用H1活H2表示。\"><a href=\"#备择假设（H1）：通常将研究者想收集证据予以支持的假设称为备择假设，或称研究假设，用H1活H2表示。\" class=\"headerlink\" title=\"备择假设（H1）：通常将研究者想收集证据予以支持的假设称为备择假设，或称研究假设，用H1活H2表示。\"></a><strong>备择假设（H<sub>1</sub>）</strong>：通常将研究者想收集证据予以支持的假设称为备择假设，或称研究假设，用H<sub>1</sub>活H<sub>2</sub>表示。</h5><h5 id=\"举个栗子：\"><a href=\"#举个栗子：\" class=\"headerlink\" title=\"举个栗子：\"></a>举个栗子：</h5><div class=\"highlighter-rouge\"><pre class=\"highlight\"><code>某品牌洗涤剂在产品说明书中声称：平均净含量不少于500g。从消费者利益出发，有关研究人员要通过抽检其中的一批产品来验证该产品制造商的说明是否属实。    \n解：对于该洗涤剂的平均含量的真值为μ。如果抽检的结果发现μ<500，则表明该产品说明书中关于其净含量的内容是不真实的。一般来说，研究者抽检的意图是倾向于证实这种洗涤剂的平均净含量不符合说明书中的概述，因为这不符合说明书的陈述。如果研究者对于产品说明丝毫没有质疑，也就没有必要抽检了。所以μ<500是研究者想要收集证据支持的观点。 <br=\"\"><h6>H<sub>0</sub>:μ≥500(净含量符合说明书);</h6><h6>H<sub>1</sub>:μ&lt;500(净含量不符合说明书)。</h6></500，则表明该产品说明书中关于其净含量的内容是不真实的。一般来说，研究者抽检的意图是倾向于证实这种洗涤剂的平均净含量不符合说明书中的概述，因为这不符合说明书的陈述。如果研究者对于产品说明丝毫没有质疑，也就没有必要抽检了。所以μ<500是研究者想要收集证据支持的观点。></code></pre></div>\n\n\n<div class=\"highlighter-rouge\"><pre class=\"highlight\"><code>一家研究机构估计，某城市中家庭拥有汽车的比例超过30%。为了验证这一估计是否正确，该研究机构随机抽取了一个样本进行检验。     \n解：设该城市中家庭拥有汽车的比例真值为π。显然，研究者想收集证据予以支持的假设是:该城市中家庭拥有汽车的比例超过30%。因此建立的原假设与备择假设应为\n<h6>H<sub>0</sub>:π≤30%（家庭拥有汽车的比例不超过30%）;</h6><h6>H<sub>1</sub>:π>30%（家庭拥有汽车的比例超过30%）。</h6></code></pre></div>\n\n<ul>\n<li>原假设和备择假设是一个完备事件组，而且互相对立。也就是说在一项假设检验中，必有且只有一个成立；</li>\n<li>在假设检验中，等号”=”总是放在原假设上。   </li>\n</ul>\n<h4 id=\"1-1-2-单侧检验和双侧检验：\"><a href=\"#1-1-2-单侧检验和双侧检验：\" class=\"headerlink\" title=\"1.1.2 单侧检验和双侧检验：\"></a>1.1.2 单侧检验和双侧检验：</h4><h5 id=\"单侧检验：备择假设具有特定的方向性，并含有符号”-gt-”或”-lt-”的假设检验；\"><a href=\"#单侧检验：备择假设具有特定的方向性，并含有符号”-gt-”或”-lt-”的假设检验；\" class=\"headerlink\" title=\"单侧检验：备择假设具有特定的方向性，并含有符号”&gt;”或”&lt;”的假设检验；\"></a><strong>单侧检验</strong>：备择假设具有特定的方向性，并含有符号”&gt;”或”&lt;”的假设检验；</h5><h5 id=\"双侧检验：备择假设没有特定的方向性，并含有符号”≠”的假设检验。\"><a href=\"#双侧检验：备择假设没有特定的方向性，并含有符号”≠”的假设检验。\" class=\"headerlink\" title=\"双侧检验：备择假设没有特定的方向性，并含有符号”≠”的假设检验。\"></a><strong>双侧检验</strong>：备择假设没有特定的方向性，并含有符号”≠”的假设检验。</h5><p><img src=\"/img/pvalue/pvalue1.png\" alt=\"假设检验的基本形式\">    <div class=\"img-note\">假设检验的基本形式</div></p>\n<h4 id=\"1-1-3-两类错误与显著水平\"><a href=\"#1-1-3-两类错误与显著水平\" class=\"headerlink\" title=\"1.1.3 两类错误与显著水平\"></a>1.1.3 两类错误与显著水平</h4><h5 id=\"如前所述，原假设与备择假设不能同时成立，我们要么拒绝原假设，要么不拒绝原假设。我们希望的情况是：当原假设正确时没有拒绝它，当原假设不正确时拒绝它。但是我们无法保证不犯错。假设检验中过程中可能发生以下两类错误：\"><a href=\"#如前所述，原假设与备择假设不能同时成立，我们要么拒绝原假设，要么不拒绝原假设。我们希望的情况是：当原假设正确时没有拒绝它，当原假设不正确时拒绝它。但是我们无法保证不犯错。假设检验中过程中可能发生以下两类错误：\" class=\"headerlink\" title=\"如前所述，原假设与备择假设不能同时成立，我们要么拒绝原假设，要么不拒绝原假设。我们希望的情况是：当原假设正确时没有拒绝它，当原假设不正确时拒绝它。但是我们无法保证不犯错。假设检验中过程中可能发生以下两类错误：\"></a>如前所述，原假设与备择假设不能同时成立，我们要么拒绝原假设，要么不拒绝原假设。我们希望的情况是：当原假设正确时没有拒绝它，当原假设不正确时拒绝它。但是我们无法保证不犯错。假设检验中过程中可能发生以下两类错误：</h5><h5 id=\"I类错误：当原假设为真是拒绝原假设，所犯的错误称为第I类错误；\"><a href=\"#I类错误：当原假设为真是拒绝原假设，所犯的错误称为第I类错误；\" class=\"headerlink\" title=\"I类错误：当原假设为真是拒绝原假设，所犯的错误称为第I类错误；\"></a><strong>I类错误</strong>：当原假设为真是拒绝原假设，所犯的错误称为第I类错误；</h5><h5 id=\"II类错误：当原假设为假时没有拒绝原假设，所犯错误称为第II类错误。\"><a href=\"#II类错误：当原假设为假时没有拒绝原假设，所犯错误称为第II类错误。\" class=\"headerlink\" title=\"II类错误：当原假设为假时没有拒绝原假设，所犯错误称为第II类错误。\"></a><strong>II类错误</strong>：当原假设为假时没有拒绝原假设，所犯错误称为第II类错误。</h5><p><img src=\"/img/pvalue/pvalue2.png\" alt=\"假设检验的结论与后果\">   <div class=\"img-note\">假设检验的结论与后果</div></p>\n<h5 id=\"只有当原假设被拒绝时，我们才会犯第I类错误；只有当原假设未被拒绝时，我们才会犯第II类错误。因此，我们可以不犯第I类错误或不犯第II类错误，但不可能两类错误都不犯。两类错误就像一个跷跷板，当一个概率增大时，另一个减小。人们只能在两类错误的发生概率之间进行平衡。一般来说，发生哪一类错误的后果更为严重，就应该首要控制哪类错误发生的概率，但由于犯第I类错误的概率是可以又研究者控制的，因为此在假设检验中，人们往往先控制第I类错误的发生概率。\"><a href=\"#只有当原假设被拒绝时，我们才会犯第I类错误；只有当原假设未被拒绝时，我们才会犯第II类错误。因此，我们可以不犯第I类错误或不犯第II类错误，但不可能两类错误都不犯。两类错误就像一个跷跷板，当一个概率增大时，另一个减小。人们只能在两类错误的发生概率之间进行平衡。一般来说，发生哪一类错误的后果更为严重，就应该首要控制哪类错误发生的概率，但由于犯第I类错误的概率是可以又研究者控制的，因为此在假设检验中，人们往往先控制第I类错误的发生概率。\" class=\"headerlink\" title=\"只有当原假设被拒绝时，我们才会犯第I类错误；只有当原假设未被拒绝时，我们才会犯第II类错误。因此，我们可以不犯第I类错误或不犯第II类错误，但不可能两类错误都不犯。两类错误就像一个跷跷板，当一个概率增大时，另一个减小。人们只能在两类错误的发生概率之间进行平衡。一般来说，发生哪一类错误的后果更为严重，就应该首要控制哪类错误发生的概率，但由于犯第I类错误的概率是可以又研究者控制的，因为此在假设检验中，人们往往先控制第I类错误的发生概率。\"></a>只有当原假设被拒绝时，我们才会犯第I类错误；只有当原假设未被拒绝时，我们才会犯第II类错误。因此，我们可以不犯第I类错误或不犯第II类错误，但不可能两类错误都不犯。两类错误就像一个跷跷板，当一个概率增大时，另一个减小。人们只能在两类错误的发生概率之间进行平衡。一般来说，发生哪一类错误的后果更为严重，就应该首要控制哪类错误发生的概率，但由于犯第I类错误的概率是可以又研究者控制的，因为此在假设检验中，人们往往先控制第I类错误的发生概率。</h5><p><code>发生第I类错误的概率常被用于度量检验结论的可靠性，并将这一概率称为显著性水平，记为α。</code></p>\n<h5 id=\"显著水平-是人们事先指定的犯第I类错误概率α的最大允许值。显著水平α越小，犯第I类错误的可能性自然就越小，但犯第II类错误的可能性则随之增大。作为一个普遍使用的原则，人们通常选择显著性水平为0-05或比0-05更小的概率。\"><a href=\"#显著水平-是人们事先指定的犯第I类错误概率α的最大允许值。显著水平α越小，犯第I类错误的可能性自然就越小，但犯第II类错误的可能性则随之增大。作为一个普遍使用的原则，人们通常选择显著性水平为0-05或比0-05更小的概率。\" class=\"headerlink\" title=\"显著水平 是人们事先指定的犯第I类错误概率α的最大允许值。显著水平α越小，犯第I类错误的可能性自然就越小，但犯第II类错误的可能性则随之增大。作为一个普遍使用的原则，人们通常选择显著性水平为0.05或比0.05更小的概率。\"></a><strong>显著水平</strong> 是人们事先指定的犯第I类错误概率α的最大允许值。显著水平α越小，犯第I类错误的可能性自然就越小，但犯第II类错误的可能性则随之增大。作为一个普遍使用的原则，人们通常选择显著性水平为0.05或比0.05更小的概率。</h5><h4 id=\"1-1-4-标准化检测量与拒绝域\"><a href=\"#1-1-4-标准化检测量与拒绝域\" class=\"headerlink\" title=\"1.1.4 标准化检测量与拒绝域\"></a>1.1.4 标准化检测量与拒绝域</h4><h5 id=\"检验统计量-实际上是总体参数的点估计量，但点估计量并不能直接作为检验的统计量，只有将其标准化后，才能用于度量它与原假设的参数之间的差异程度。实际上，假设检验中所用的检验统计量都是标准化检验统计量，它反映了点估计量（比如样本均值）与假设的总体参数（比如假设的总体均值）相比相差了多少个标准差。\"><a href=\"#检验统计量-实际上是总体参数的点估计量，但点估计量并不能直接作为检验的统计量，只有将其标准化后，才能用于度量它与原假设的参数之间的差异程度。实际上，假设检验中所用的检验统计量都是标准化检验统计量，它反映了点估计量（比如样本均值）与假设的总体参数（比如假设的总体均值）相比相差了多少个标准差。\" class=\"headerlink\" title=\"检验统计量 实际上是总体参数的点估计量，但点估计量并不能直接作为检验的统计量，只有将其标准化后，才能用于度量它与原假设的参数之间的差异程度。实际上，假设检验中所用的检验统计量都是标准化检验统计量，它反映了点估计量（比如样本均值）与假设的总体参数（比如假设的总体均值）相比相差了多少个标准差。\"></a><strong>检验统计量</strong> 实际上是总体参数的点估计量，但点估计量并不能直接作为检验的统计量，只有将其标准化后，才能用于度量它与原假设的参数之间的差异程度。实际上，假设检验中所用的检验统计量都是标准化检验统计量，它反映了点估计量（比如样本均值）与假设的总体参数（比如假设的总体均值）相比相差了多少个标准差。</h5><script type=\"math/tex; mode=display\">标准化检验统计量 = \\frac{点估计量 - 假设值}{点估计量的抽样标准差}</script><h5 id=\"拒绝域-能够拒绝原假设的检验统计量的所有可能取值的集合。是由显著性水平α所围成的区域。如果利用样本观测结果计算出来的检验统计量的具体数值落在了拒绝域内，就拒绝原假设，否则就不拒绝原假设。\"><a href=\"#拒绝域-能够拒绝原假设的检验统计量的所有可能取值的集合。是由显著性水平α所围成的区域。如果利用样本观测结果计算出来的检验统计量的具体数值落在了拒绝域内，就拒绝原假设，否则就不拒绝原假设。\" class=\"headerlink\" title=\"拒绝域 能够拒绝原假设的检验统计量的所有可能取值的集合。是由显著性水平α所围成的区域。如果利用样本观测结果计算出来的检验统计量的具体数值落在了拒绝域内，就拒绝原假设，否则就不拒绝原假设。\"></a><strong>拒绝域</strong> 能够拒绝原假设的检验统计量的所有可能取值的集合。是由显著性水平α所围成的区域。如果利用样本观测结果计算出来的检验统计量的具体数值落在了拒绝域内，就拒绝原假设，否则就不拒绝原假设。</h5><p><img src=\"/img/pvalue/pvalue3.jpeg\" alt=\"显著性水平、拒绝域和临界值\"><div class=\"img-note\">显著性水平、拒绝域和临界值</div></p>\n<h5 id=\"当样本容量固定时，拒绝域的面积随α的减小而减小。α值越小，拒绝域假设所需的检验统计量的临界值与原假设的参数值就越远。\"><a href=\"#当样本容量固定时，拒绝域的面积随α的减小而减小。α值越小，拒绝域假设所需的检验统计量的临界值与原假设的参数值就越远。\" class=\"headerlink\" title=\"当样本容量固定时，拒绝域的面积随α的减小而减小。α值越小，拒绝域假设所需的检验统计量的临界值与原假设的参数值就越远。\"></a>当样本容量固定时，拒绝域的面积随α的减小而减小。α值越小，拒绝域假设所需的检验统计量的临界值与原假设的参数值就越远。</h5><h3 id=\"1-2-利用P值进行决策\"><a href=\"#1-2-利用P值进行决策\" class=\"headerlink\" title=\"1.2 利用P值进行决策\"></a>1.2 利用P值进行决策</h3><h5 id=\"显著性水平α是在检验之前确定的，这也就意味着我们事先确定了拒绝域。这样，不论检验统计量的值是大是小，只要它的值落入拒绝域就拒绝原假设，否者就不拒绝原假设。这种固定的显著性水平α对检验结果只能提供检验结论可靠性的一个大致范围，无法给出观测数据与原假设之间不一致程度的精确度量。\"><a href=\"#显著性水平α是在检验之前确定的，这也就意味着我们事先确定了拒绝域。这样，不论检验统计量的值是大是小，只要它的值落入拒绝域就拒绝原假设，否者就不拒绝原假设。这种固定的显著性水平α对检验结果只能提供检验结论可靠性的一个大致范围，无法给出观测数据与原假设之间不一致程度的精确度量。\" class=\"headerlink\" title=\"显著性水平α是在检验之前确定的，这也就意味着我们事先确定了拒绝域。这样，不论检验统计量的值是大是小，只要它的值落入拒绝域就拒绝原假设，否者就不拒绝原假设。这种固定的显著性水平α对检验结果只能提供检验结论可靠性的一个大致范围，无法给出观测数据与原假设之间不一致程度的精确度量。\"></a>显著性水平α是在检验之前确定的，这也就意味着我们事先确定了拒绝域。这样，不论检验统计量的值是大是小，只要它的值落入拒绝域就拒绝原假设，否者就不拒绝原假设。这种固定的显著性水平α对检验结果只能提供检验结论可靠性的一个大致范围，无法给出观测数据与原假设之间不一致程度的精确度量。</h5><h5 id=\"P值-在原假设为真的条件下，检验统计量的观察值大于或等于其计算值的概率，称为P值。P值是反映实际观测到的数据与原假设之间不一致程度的一个概率值。P值越小，说明实际观测到的数据与原假设之间不一致的程度就越大，检验的结果也就越显著。\"><a href=\"#P值-在原假设为真的条件下，检验统计量的观察值大于或等于其计算值的概率，称为P值。P值是反映实际观测到的数据与原假设之间不一致程度的一个概率值。P值越小，说明实际观测到的数据与原假设之间不一致的程度就越大，检验的结果也就越显著。\" class=\"headerlink\" title=\"P值 在原假设为真的条件下，检验统计量的观察值大于或等于其计算值的概率，称为P值。P值是反映实际观测到的数据与原假设之间不一致程度的一个概率值。P值越小，说明实际观测到的数据与原假设之间不一致的程度就越大，检验的结果也就越显著。\"></a><strong>P值</strong> 在原假设为真的条件下，检验统计量的观察值大于或等于其计算值的概率，称为P值。P值是反映实际观测到的数据与原假设之间不一致程度的一个概率值。P值越小，说明实际观测到的数据与原假设之间不一致的程度就越大，检验的结果也就越显著。</h5><h3 id=\"1-3-一个总体参数的检验\"><a href=\"#1-3-一个总体参数的检验\" class=\"headerlink\" title=\"1.3 一个总体参数的检验\"></a>1.3 一个总体参数的检验</h3><h5 id=\"当我们研究一个总体时，要检验的参数主要是总体均值μ、总体比例π和总体方差σ2。由于检验的参数不同，计算检验统计量的方法也有所不同。\"><a href=\"#当我们研究一个总体时，要检验的参数主要是总体均值μ、总体比例π和总体方差σ2。由于检验的参数不同，计算检验统计量的方法也有所不同。\" class=\"headerlink\" title=\"当我们研究一个总体时，要检验的参数主要是总体均值μ、总体比例π和总体方差σ2。由于检验的参数不同，计算检验统计量的方法也有所不同。\"></a>当我们研究一个总体时，要检验的参数主要是总体均值μ、总体比例π和总体方差σ<sup>2</sup>。由于检验的参数不同，计算检验统计量的方法也有所不同。</h5><h4 id=\"1-3-1-总体均值的检验\"><a href=\"#1-3-1-总体均值的检验\" class=\"headerlink\" title=\"1.3.1 总体均值的检验\"></a>1.3.1 总体均值的检验</h4><h5 id=\"对于总体均值进行假设检验，采用什么检验步骤和检验统计量取决于我们所抽取的样本是大样本（n≥30）还是小样本（n\"><a href=\"#对于总体均值进行假设检验，采用什么检验步骤和检验统计量取决于我们所抽取的样本是大样本（n≥30）还是小样本（n\" class=\"headerlink\" title=\"对于总体均值进行假设检验，采用什么检验步骤和检验统计量取决于我们所抽取的样本是大样本（n≥30）还是小样本（n\"></a>对于总体均值进行假设检验，采用什么检验步骤和检验统计量取决于我们所抽取的样本是大样本（n≥30）还是小样本（n<30），此外还需要区分总体是否服从正太分布、总体方差σ<sup>2&lt;/SUP&gt;是否已知等几种情况。</30），此外还需要区分总体是否服从正太分布、总体方差σ<sup></h5><p><img src=\"/img/pvalue/pvalue4.png\" alt=\"大样本情况下一个总体均值的检验方法\">    <div class=\"img-note\">大样本情况下一个总体均值的检验方法</div><br><img src=\"/img/pvalue/pvalue5.png\" alt=\"小样本情况下一个总体均值的检验方法\">    <div class=\"img-note\">小样本情况下一个总体均值的检验方法</div></p>\n<h5 id=\"Z表示转换为标准正太分布下的检验统计量。\"><a href=\"#Z表示转换为标准正太分布下的检验统计量。\" class=\"headerlink\" title=\"Z表示转换为标准正太分布下的检验统计量。\"></a>Z表示转换为标准正太分布下的检验统计量。</h5><h4 id=\"1-3-2-总体比例的检验\"><a href=\"#1-3-2-总体比例的检验\" class=\"headerlink\" title=\"1.3.2 总体比例的检验\"></a>1.3.2 总体比例的检验</h4><h5 id=\"总体比例是指总体中具有某种相同特征的个体所占的比例，这些特征可以是数据型的（如一定的重量、一定的厚度或一定规格等），也可以是品质型的（如男女比例、学历等级、职称高低等）。\"><a href=\"#总体比例是指总体中具有某种相同特征的个体所占的比例，这些特征可以是数据型的（如一定的重量、一定的厚度或一定规格等），也可以是品质型的（如男女比例、学历等级、职称高低等）。\" class=\"headerlink\" title=\"总体比例是指总体中具有某种相同特征的个体所占的比例，这些特征可以是数据型的（如一定的重量、一定的厚度或一定规格等），也可以是品质型的（如男女比例、学历等级、职称高低等）。\"></a>总体比例是指总体中具有某种相同特征的个体所占的比例，这些特征可以是数据型的（如一定的重量、一定的厚度或一定规格等），也可以是品质型的（如男女比例、学历等级、职称高低等）。</h5><h5 id=\"在构造检验统计量时，我们仍然利用样本比例p与总体比例π之间的距离等于多少个标准差来衡量，因为在大样本情况下统计量p近似服从正太分布，而统计量\"><a href=\"#在构造检验统计量时，我们仍然利用样本比例p与总体比例π之间的距离等于多少个标准差来衡量，因为在大样本情况下统计量p近似服从正太分布，而统计量\" class=\"headerlink\" title=\"在构造检验统计量时，我们仍然利用样本比例p与总体比例π之间的距离等于多少个标准差来衡量，因为在大样本情况下统计量p近似服从正太分布，而统计量\"></a>在构造检验统计量时，我们仍然利用样本比例p与总体比例π之间的距离等于多少个标准差来衡量，因为在大样本情况下统计量p近似服从正太分布，而统计量</h5><script type=\"math/tex; mode=display\">z = \\frac{P - π_0}{\\sqrt{\\frac{π_0(1-π_0)}{n}}}</script><p><img src=\"/img/pvalue/pvalue6.png\" alt=\"大样本情况下一个总体比例的检验方法\">    <div class=\"img-note\">大样本情况下一个总体比例的检验方法</div></p>\n<h3 id=\"1-4-两个总体参数的检验\"><a href=\"#1-4-两个总体参数的检验\" class=\"headerlink\" title=\"1.4 两个总体参数的检验\"></a>1.4 两个总体参数的检验</h3><h5 id=\"在实际研究中，我们常常要比较两个总体的差异，如一所学校的重点班和普通班两个班级学生的英语成绩是否有显著差异；生产企业在改进生产线后的平均产量与原生产线的平均产量相比是否有显著提高等等。\"><a href=\"#在实际研究中，我们常常要比较两个总体的差异，如一所学校的重点班和普通班两个班级学生的英语成绩是否有显著差异；生产企业在改进生产线后的平均产量与原生产线的平均产量相比是否有显著提高等等。\" class=\"headerlink\" title=\"在实际研究中，我们常常要比较两个总体的差异，如一所学校的重点班和普通班两个班级学生的英语成绩是否有显著差异；生产企业在改进生产线后的平均产量与原生产线的平均产量相比是否有显著提高等等。\"></a>在实际研究中，我们常常要比较两个总体的差异，如一所学校的重点班和普通班两个班级学生的英语成绩是否有显著差异；生产企业在改进生产线后的平均产量与原生产线的平均产量相比是否有显著提高等等。</h5><p><img src=\"/img/pvalue/pvalue7.png\" alt=\"两个总体均值之差的三种基本假设检验形式\">    <div class=\"img-note\">两个总体均值之差的三种基本假设检验形式</div></p>\n","site":{"data":{}},"excerpt":"<h5 id=\"最近产品提出需求，对于ab实验，希望能够通过实验数据计算出P值，以对数据的准确性做一个直观判断。最开始不知道P值是一个什么概念，觉得应该很简单，baidu或者google以下应该会有很多开源的代码或者jar包；又或者是自己将P值公式实现便可。但是一番查找后发现没有想的这么简单，网络上对于P值得计算过程大多含糊不清，更别提完整的计算代码。最后没办法，只有通过自己拿起概率论书本重新进行学习，以下便记录自己从P值是什么到java实现的一些细节。\"><a href=\"#最近产品提出需求，对于ab实验，希望能够通过实验数据计算出P值，以对数据的准确性做一个直观判断。最开始不知道P值是一个什么概念，觉得应该很简单，baidu或者google以下应该会有很多开源的代码或者jar包；又或者是自己将P值公式实现便可。但是一番查找后发现没有想的这么简单，网络上对于P值得计算过程大多含糊不清，更别提完整的计算代码。最后没办法，只有通过自己拿起概率论书本重新进行学习，以下便记录自己从P值是什么到java实现的一些细节。\" class=\"headerlink\" title=\"最近产品提出需求，对于ab实验，希望能够通过实验数据计算出P值，以对数据的准确性做一个直观判断。最开始不知道P值是一个什么概念，觉得应该很简单，baidu或者google以下应该会有很多开源的代码或者jar包；又或者是自己将P值公式实现便可。但是一番查找后发现没有想的这么简单，网络上对于P值得计算过程大多含糊不清，更别提完整的计算代码。最后没办法，只有通过自己拿起概率论书本重新进行学习，以下便记录自己从P值是什么到java实现的一些细节。\"></a>最近产品提出需求，对于ab实验，希望能够通过实验数据计算出P值，以对数据的准确性做一个直观判断。最开始不知道P值是一个什么概念，觉得应该很简单，baidu或者google以下应该会有很多开源的代码或者jar包；又或者是自己将P值公式实现便可。但是一番查找后发现没有想的这么简单，网络上对于P值得计算过程大多含糊不清，更别提完整的计算代码。最后没办法，只有通过自己拿起概率论书本重新进行学习，以下便记录自己从P值是什么到java实现的一些细节。</h5>","more":"<h2 id=\"1-统计学中P值\"><a href=\"#1-统计学中P值\" class=\"headerlink\" title=\"1. 统计学中P值\"></a>1. 统计学中P值</h2><h5 id=\"P值是指当假设为真时所得到的观察结果的概率，简单讲P值就是概率，反映某一事件发生的可能性大小。下面几个比较重要的基础概念对于理解P值的意义会有帮助。\"><a href=\"#P值是指当假设为真时所得到的观察结果的概率，简单讲P值就是概率，反映某一事件发生的可能性大小。下面几个比较重要的基础概念对于理解P值的意义会有帮助。\" class=\"headerlink\" title=\"P值是指当假设为真时所得到的观察结果的概率，简单讲P值就是概率，反映某一事件发生的可能性大小。下面几个比较重要的基础概念对于理解P值的意义会有帮助。\"></a>P值是指当假设为真时所得到的观察结果的概率，简单讲P值就是概率，反映某一事件发生的可能性大小。下面几个比较重要的基础概念对于理解P值的意义会有帮助。</h5><h3 id=\"1-1-概率论中几个比较重要的基础概念\"><a href=\"#1-1-概率论中几个比较重要的基础概念\" class=\"headerlink\" title=\"1.1 概率论中几个比较重要的基础概念\"></a>1.1 概率论中几个比较重要的基础概念</h3><h4 id=\"1-1-1-原假设与备择假设：\"><a href=\"#1-1-1-原假设与备择假设：\" class=\"headerlink\" title=\"1.1.1 原假设与备择假设：\"></a>1.1.1 原假设与备择假设：</h4><h5 id=\"原假设（H0）：通常将研究者想手机证据予以反对的假设称为原假设，用H0表示；\"><a href=\"#原假设（H0）：通常将研究者想手机证据予以反对的假设称为原假设，用H0表示；\" class=\"headerlink\" title=\"原假设（H0）：通常将研究者想手机证据予以反对的假设称为原假设，用H0表示；\"></a><strong>原假设（H<sub>0</sub>）</strong>：通常将研究者想手机证据予以反对的假设称为原假设，用H<sub>0</sub>表示；</h5><h5 id=\"备择假设（H1）：通常将研究者想收集证据予以支持的假设称为备择假设，或称研究假设，用H1活H2表示。\"><a href=\"#备择假设（H1）：通常将研究者想收集证据予以支持的假设称为备择假设，或称研究假设，用H1活H2表示。\" class=\"headerlink\" title=\"备择假设（H1）：通常将研究者想收集证据予以支持的假设称为备择假设，或称研究假设，用H1活H2表示。\"></a><strong>备择假设（H<sub>1</sub>）</strong>：通常将研究者想收集证据予以支持的假设称为备择假设，或称研究假设，用H<sub>1</sub>活H<sub>2</sub>表示。</h5><h5 id=\"举个栗子：\"><a href=\"#举个栗子：\" class=\"headerlink\" title=\"举个栗子：\"></a>举个栗子：</h5><div class=\"highlighter-rouge\"><pre class=\"highlight\"><code>某品牌洗涤剂在产品说明书中声称：平均净含量不少于500g。从消费者利益出发，有关研究人员要通过抽检其中的一批产品来验证该产品制造商的说明是否属实。    \n解：对于该洗涤剂的平均含量的真值为μ。如果抽检的结果发现μ<500，则表明该产品说明书中关于其净含量的内容是不真实的。一般来说，研究者抽检的意图是倾向于证实这种洗涤剂的平均净含量不符合说明书中的概述，因为这不符合说明书的陈述。如果研究者对于产品说明丝毫没有质疑，也就没有必要抽检了。所以μ<500是研究者想要收集证据支持的观点。 <br=\"\"><h6>H<sub>0</sub>:μ≥500(净含量符合说明书);</h6><h6>H<sub>1</sub>:μ&lt;500(净含量不符合说明书)。</h6></500，则表明该产品说明书中关于其净含量的内容是不真实的。一般来说，研究者抽检的意图是倾向于证实这种洗涤剂的平均净含量不符合说明书中的概述，因为这不符合说明书的陈述。如果研究者对于产品说明丝毫没有质疑，也就没有必要抽检了。所以μ<500是研究者想要收集证据支持的观点。></code></pre></div>\n\n\n<div class=\"highlighter-rouge\"><pre class=\"highlight\"><code>一家研究机构估计，某城市中家庭拥有汽车的比例超过30%。为了验证这一估计是否正确，该研究机构随机抽取了一个样本进行检验。     \n解：设该城市中家庭拥有汽车的比例真值为π。显然，研究者想收集证据予以支持的假设是:该城市中家庭拥有汽车的比例超过30%。因此建立的原假设与备择假设应为\n<h6>H<sub>0</sub>:π≤30%（家庭拥有汽车的比例不超过30%）;</h6><h6>H<sub>1</sub>:π>30%（家庭拥有汽车的比例超过30%）。</h6></code></pre></div>\n\n<ul>\n<li>原假设和备择假设是一个完备事件组，而且互相对立。也就是说在一项假设检验中，必有且只有一个成立；</li>\n<li>在假设检验中，等号”=”总是放在原假设上。   </li>\n</ul>\n<h4 id=\"1-1-2-单侧检验和双侧检验：\"><a href=\"#1-1-2-单侧检验和双侧检验：\" class=\"headerlink\" title=\"1.1.2 单侧检验和双侧检验：\"></a>1.1.2 单侧检验和双侧检验：</h4><h5 id=\"单侧检验：备择假设具有特定的方向性，并含有符号”-gt-”或”-lt-”的假设检验；\"><a href=\"#单侧检验：备择假设具有特定的方向性，并含有符号”-gt-”或”-lt-”的假设检验；\" class=\"headerlink\" title=\"单侧检验：备择假设具有特定的方向性，并含有符号”&gt;”或”&lt;”的假设检验；\"></a><strong>单侧检验</strong>：备择假设具有特定的方向性，并含有符号”&gt;”或”&lt;”的假设检验；</h5><h5 id=\"双侧检验：备择假设没有特定的方向性，并含有符号”≠”的假设检验。\"><a href=\"#双侧检验：备择假设没有特定的方向性，并含有符号”≠”的假设检验。\" class=\"headerlink\" title=\"双侧检验：备择假设没有特定的方向性，并含有符号”≠”的假设检验。\"></a><strong>双侧检验</strong>：备择假设没有特定的方向性，并含有符号”≠”的假设检验。</h5><p><img src=\"/img/pvalue/pvalue1.png\" alt=\"假设检验的基本形式\">    <div class=\"img-note\">假设检验的基本形式</div></p>\n<h4 id=\"1-1-3-两类错误与显著水平\"><a href=\"#1-1-3-两类错误与显著水平\" class=\"headerlink\" title=\"1.1.3 两类错误与显著水平\"></a>1.1.3 两类错误与显著水平</h4><h5 id=\"如前所述，原假设与备择假设不能同时成立，我们要么拒绝原假设，要么不拒绝原假设。我们希望的情况是：当原假设正确时没有拒绝它，当原假设不正确时拒绝它。但是我们无法保证不犯错。假设检验中过程中可能发生以下两类错误：\"><a href=\"#如前所述，原假设与备择假设不能同时成立，我们要么拒绝原假设，要么不拒绝原假设。我们希望的情况是：当原假设正确时没有拒绝它，当原假设不正确时拒绝它。但是我们无法保证不犯错。假设检验中过程中可能发生以下两类错误：\" class=\"headerlink\" title=\"如前所述，原假设与备择假设不能同时成立，我们要么拒绝原假设，要么不拒绝原假设。我们希望的情况是：当原假设正确时没有拒绝它，当原假设不正确时拒绝它。但是我们无法保证不犯错。假设检验中过程中可能发生以下两类错误：\"></a>如前所述，原假设与备择假设不能同时成立，我们要么拒绝原假设，要么不拒绝原假设。我们希望的情况是：当原假设正确时没有拒绝它，当原假设不正确时拒绝它。但是我们无法保证不犯错。假设检验中过程中可能发生以下两类错误：</h5><h5 id=\"I类错误：当原假设为真是拒绝原假设，所犯的错误称为第I类错误；\"><a href=\"#I类错误：当原假设为真是拒绝原假设，所犯的错误称为第I类错误；\" class=\"headerlink\" title=\"I类错误：当原假设为真是拒绝原假设，所犯的错误称为第I类错误；\"></a><strong>I类错误</strong>：当原假设为真是拒绝原假设，所犯的错误称为第I类错误；</h5><h5 id=\"II类错误：当原假设为假时没有拒绝原假设，所犯错误称为第II类错误。\"><a href=\"#II类错误：当原假设为假时没有拒绝原假设，所犯错误称为第II类错误。\" class=\"headerlink\" title=\"II类错误：当原假设为假时没有拒绝原假设，所犯错误称为第II类错误。\"></a><strong>II类错误</strong>：当原假设为假时没有拒绝原假设，所犯错误称为第II类错误。</h5><p><img src=\"/img/pvalue/pvalue2.png\" alt=\"假设检验的结论与后果\">   <div class=\"img-note\">假设检验的结论与后果</div></p>\n<h5 id=\"只有当原假设被拒绝时，我们才会犯第I类错误；只有当原假设未被拒绝时，我们才会犯第II类错误。因此，我们可以不犯第I类错误或不犯第II类错误，但不可能两类错误都不犯。两类错误就像一个跷跷板，当一个概率增大时，另一个减小。人们只能在两类错误的发生概率之间进行平衡。一般来说，发生哪一类错误的后果更为严重，就应该首要控制哪类错误发生的概率，但由于犯第I类错误的概率是可以又研究者控制的，因为此在假设检验中，人们往往先控制第I类错误的发生概率。\"><a href=\"#只有当原假设被拒绝时，我们才会犯第I类错误；只有当原假设未被拒绝时，我们才会犯第II类错误。因此，我们可以不犯第I类错误或不犯第II类错误，但不可能两类错误都不犯。两类错误就像一个跷跷板，当一个概率增大时，另一个减小。人们只能在两类错误的发生概率之间进行平衡。一般来说，发生哪一类错误的后果更为严重，就应该首要控制哪类错误发生的概率，但由于犯第I类错误的概率是可以又研究者控制的，因为此在假设检验中，人们往往先控制第I类错误的发生概率。\" class=\"headerlink\" title=\"只有当原假设被拒绝时，我们才会犯第I类错误；只有当原假设未被拒绝时，我们才会犯第II类错误。因此，我们可以不犯第I类错误或不犯第II类错误，但不可能两类错误都不犯。两类错误就像一个跷跷板，当一个概率增大时，另一个减小。人们只能在两类错误的发生概率之间进行平衡。一般来说，发生哪一类错误的后果更为严重，就应该首要控制哪类错误发生的概率，但由于犯第I类错误的概率是可以又研究者控制的，因为此在假设检验中，人们往往先控制第I类错误的发生概率。\"></a>只有当原假设被拒绝时，我们才会犯第I类错误；只有当原假设未被拒绝时，我们才会犯第II类错误。因此，我们可以不犯第I类错误或不犯第II类错误，但不可能两类错误都不犯。两类错误就像一个跷跷板，当一个概率增大时，另一个减小。人们只能在两类错误的发生概率之间进行平衡。一般来说，发生哪一类错误的后果更为严重，就应该首要控制哪类错误发生的概率，但由于犯第I类错误的概率是可以又研究者控制的，因为此在假设检验中，人们往往先控制第I类错误的发生概率。</h5><p><code>发生第I类错误的概率常被用于度量检验结论的可靠性，并将这一概率称为显著性水平，记为α。</code></p>\n<h5 id=\"显著水平-是人们事先指定的犯第I类错误概率α的最大允许值。显著水平α越小，犯第I类错误的可能性自然就越小，但犯第II类错误的可能性则随之增大。作为一个普遍使用的原则，人们通常选择显著性水平为0-05或比0-05更小的概率。\"><a href=\"#显著水平-是人们事先指定的犯第I类错误概率α的最大允许值。显著水平α越小，犯第I类错误的可能性自然就越小，但犯第II类错误的可能性则随之增大。作为一个普遍使用的原则，人们通常选择显著性水平为0-05或比0-05更小的概率。\" class=\"headerlink\" title=\"显著水平 是人们事先指定的犯第I类错误概率α的最大允许值。显著水平α越小，犯第I类错误的可能性自然就越小，但犯第II类错误的可能性则随之增大。作为一个普遍使用的原则，人们通常选择显著性水平为0.05或比0.05更小的概率。\"></a><strong>显著水平</strong> 是人们事先指定的犯第I类错误概率α的最大允许值。显著水平α越小，犯第I类错误的可能性自然就越小，但犯第II类错误的可能性则随之增大。作为一个普遍使用的原则，人们通常选择显著性水平为0.05或比0.05更小的概率。</h5><h4 id=\"1-1-4-标准化检测量与拒绝域\"><a href=\"#1-1-4-标准化检测量与拒绝域\" class=\"headerlink\" title=\"1.1.4 标准化检测量与拒绝域\"></a>1.1.4 标准化检测量与拒绝域</h4><h5 id=\"检验统计量-实际上是总体参数的点估计量，但点估计量并不能直接作为检验的统计量，只有将其标准化后，才能用于度量它与原假设的参数之间的差异程度。实际上，假设检验中所用的检验统计量都是标准化检验统计量，它反映了点估计量（比如样本均值）与假设的总体参数（比如假设的总体均值）相比相差了多少个标准差。\"><a href=\"#检验统计量-实际上是总体参数的点估计量，但点估计量并不能直接作为检验的统计量，只有将其标准化后，才能用于度量它与原假设的参数之间的差异程度。实际上，假设检验中所用的检验统计量都是标准化检验统计量，它反映了点估计量（比如样本均值）与假设的总体参数（比如假设的总体均值）相比相差了多少个标准差。\" class=\"headerlink\" title=\"检验统计量 实际上是总体参数的点估计量，但点估计量并不能直接作为检验的统计量，只有将其标准化后，才能用于度量它与原假设的参数之间的差异程度。实际上，假设检验中所用的检验统计量都是标准化检验统计量，它反映了点估计量（比如样本均值）与假设的总体参数（比如假设的总体均值）相比相差了多少个标准差。\"></a><strong>检验统计量</strong> 实际上是总体参数的点估计量，但点估计量并不能直接作为检验的统计量，只有将其标准化后，才能用于度量它与原假设的参数之间的差异程度。实际上，假设检验中所用的检验统计量都是标准化检验统计量，它反映了点估计量（比如样本均值）与假设的总体参数（比如假设的总体均值）相比相差了多少个标准差。</h5><script type=\"math/tex; mode=display\">标准化检验统计量 = \\frac{点估计量 - 假设值}{点估计量的抽样标准差}</script><h5 id=\"拒绝域-能够拒绝原假设的检验统计量的所有可能取值的集合。是由显著性水平α所围成的区域。如果利用样本观测结果计算出来的检验统计量的具体数值落在了拒绝域内，就拒绝原假设，否则就不拒绝原假设。\"><a href=\"#拒绝域-能够拒绝原假设的检验统计量的所有可能取值的集合。是由显著性水平α所围成的区域。如果利用样本观测结果计算出来的检验统计量的具体数值落在了拒绝域内，就拒绝原假设，否则就不拒绝原假设。\" class=\"headerlink\" title=\"拒绝域 能够拒绝原假设的检验统计量的所有可能取值的集合。是由显著性水平α所围成的区域。如果利用样本观测结果计算出来的检验统计量的具体数值落在了拒绝域内，就拒绝原假设，否则就不拒绝原假设。\"></a><strong>拒绝域</strong> 能够拒绝原假设的检验统计量的所有可能取值的集合。是由显著性水平α所围成的区域。如果利用样本观测结果计算出来的检验统计量的具体数值落在了拒绝域内，就拒绝原假设，否则就不拒绝原假设。</h5><p><img src=\"/img/pvalue/pvalue3.jpeg\" alt=\"显著性水平、拒绝域和临界值\"><div class=\"img-note\">显著性水平、拒绝域和临界值</div></p>\n<h5 id=\"当样本容量固定时，拒绝域的面积随α的减小而减小。α值越小，拒绝域假设所需的检验统计量的临界值与原假设的参数值就越远。\"><a href=\"#当样本容量固定时，拒绝域的面积随α的减小而减小。α值越小，拒绝域假设所需的检验统计量的临界值与原假设的参数值就越远。\" class=\"headerlink\" title=\"当样本容量固定时，拒绝域的面积随α的减小而减小。α值越小，拒绝域假设所需的检验统计量的临界值与原假设的参数值就越远。\"></a>当样本容量固定时，拒绝域的面积随α的减小而减小。α值越小，拒绝域假设所需的检验统计量的临界值与原假设的参数值就越远。</h5><h3 id=\"1-2-利用P值进行决策\"><a href=\"#1-2-利用P值进行决策\" class=\"headerlink\" title=\"1.2 利用P值进行决策\"></a>1.2 利用P值进行决策</h3><h5 id=\"显著性水平α是在检验之前确定的，这也就意味着我们事先确定了拒绝域。这样，不论检验统计量的值是大是小，只要它的值落入拒绝域就拒绝原假设，否者就不拒绝原假设。这种固定的显著性水平α对检验结果只能提供检验结论可靠性的一个大致范围，无法给出观测数据与原假设之间不一致程度的精确度量。\"><a href=\"#显著性水平α是在检验之前确定的，这也就意味着我们事先确定了拒绝域。这样，不论检验统计量的值是大是小，只要它的值落入拒绝域就拒绝原假设，否者就不拒绝原假设。这种固定的显著性水平α对检验结果只能提供检验结论可靠性的一个大致范围，无法给出观测数据与原假设之间不一致程度的精确度量。\" class=\"headerlink\" title=\"显著性水平α是在检验之前确定的，这也就意味着我们事先确定了拒绝域。这样，不论检验统计量的值是大是小，只要它的值落入拒绝域就拒绝原假设，否者就不拒绝原假设。这种固定的显著性水平α对检验结果只能提供检验结论可靠性的一个大致范围，无法给出观测数据与原假设之间不一致程度的精确度量。\"></a>显著性水平α是在检验之前确定的，这也就意味着我们事先确定了拒绝域。这样，不论检验统计量的值是大是小，只要它的值落入拒绝域就拒绝原假设，否者就不拒绝原假设。这种固定的显著性水平α对检验结果只能提供检验结论可靠性的一个大致范围，无法给出观测数据与原假设之间不一致程度的精确度量。</h5><h5 id=\"P值-在原假设为真的条件下，检验统计量的观察值大于或等于其计算值的概率，称为P值。P值是反映实际观测到的数据与原假设之间不一致程度的一个概率值。P值越小，说明实际观测到的数据与原假设之间不一致的程度就越大，检验的结果也就越显著。\"><a href=\"#P值-在原假设为真的条件下，检验统计量的观察值大于或等于其计算值的概率，称为P值。P值是反映实际观测到的数据与原假设之间不一致程度的一个概率值。P值越小，说明实际观测到的数据与原假设之间不一致的程度就越大，检验的结果也就越显著。\" class=\"headerlink\" title=\"P值 在原假设为真的条件下，检验统计量的观察值大于或等于其计算值的概率，称为P值。P值是反映实际观测到的数据与原假设之间不一致程度的一个概率值。P值越小，说明实际观测到的数据与原假设之间不一致的程度就越大，检验的结果也就越显著。\"></a><strong>P值</strong> 在原假设为真的条件下，检验统计量的观察值大于或等于其计算值的概率，称为P值。P值是反映实际观测到的数据与原假设之间不一致程度的一个概率值。P值越小，说明实际观测到的数据与原假设之间不一致的程度就越大，检验的结果也就越显著。</h5><h3 id=\"1-3-一个总体参数的检验\"><a href=\"#1-3-一个总体参数的检验\" class=\"headerlink\" title=\"1.3 一个总体参数的检验\"></a>1.3 一个总体参数的检验</h3><h5 id=\"当我们研究一个总体时，要检验的参数主要是总体均值μ、总体比例π和总体方差σ2。由于检验的参数不同，计算检验统计量的方法也有所不同。\"><a href=\"#当我们研究一个总体时，要检验的参数主要是总体均值μ、总体比例π和总体方差σ2。由于检验的参数不同，计算检验统计量的方法也有所不同。\" class=\"headerlink\" title=\"当我们研究一个总体时，要检验的参数主要是总体均值μ、总体比例π和总体方差σ2。由于检验的参数不同，计算检验统计量的方法也有所不同。\"></a>当我们研究一个总体时，要检验的参数主要是总体均值μ、总体比例π和总体方差σ<sup>2</sup>。由于检验的参数不同，计算检验统计量的方法也有所不同。</h5><h4 id=\"1-3-1-总体均值的检验\"><a href=\"#1-3-1-总体均值的检验\" class=\"headerlink\" title=\"1.3.1 总体均值的检验\"></a>1.3.1 总体均值的检验</h4><h5 id=\"对于总体均值进行假设检验，采用什么检验步骤和检验统计量取决于我们所抽取的样本是大样本（n≥30）还是小样本（n\"><a href=\"#对于总体均值进行假设检验，采用什么检验步骤和检验统计量取决于我们所抽取的样本是大样本（n≥30）还是小样本（n\" class=\"headerlink\" title=\"对于总体均值进行假设检验，采用什么检验步骤和检验统计量取决于我们所抽取的样本是大样本（n≥30）还是小样本（n\"></a>对于总体均值进行假设检验，采用什么检验步骤和检验统计量取决于我们所抽取的样本是大样本（n≥30）还是小样本（n<30），此外还需要区分总体是否服从正太分布、总体方差σ<sup>2&lt;/SUP&gt;是否已知等几种情况。</30），此外还需要区分总体是否服从正太分布、总体方差σ<sup></h5><p><img src=\"/img/pvalue/pvalue4.png\" alt=\"大样本情况下一个总体均值的检验方法\">    <div class=\"img-note\">大样本情况下一个总体均值的检验方法</div><br><img src=\"/img/pvalue/pvalue5.png\" alt=\"小样本情况下一个总体均值的检验方法\">    <div class=\"img-note\">小样本情况下一个总体均值的检验方法</div></p>\n<h5 id=\"Z表示转换为标准正太分布下的检验统计量。\"><a href=\"#Z表示转换为标准正太分布下的检验统计量。\" class=\"headerlink\" title=\"Z表示转换为标准正太分布下的检验统计量。\"></a>Z表示转换为标准正太分布下的检验统计量。</h5><h4 id=\"1-3-2-总体比例的检验\"><a href=\"#1-3-2-总体比例的检验\" class=\"headerlink\" title=\"1.3.2 总体比例的检验\"></a>1.3.2 总体比例的检验</h4><h5 id=\"总体比例是指总体中具有某种相同特征的个体所占的比例，这些特征可以是数据型的（如一定的重量、一定的厚度或一定规格等），也可以是品质型的（如男女比例、学历等级、职称高低等）。\"><a href=\"#总体比例是指总体中具有某种相同特征的个体所占的比例，这些特征可以是数据型的（如一定的重量、一定的厚度或一定规格等），也可以是品质型的（如男女比例、学历等级、职称高低等）。\" class=\"headerlink\" title=\"总体比例是指总体中具有某种相同特征的个体所占的比例，这些特征可以是数据型的（如一定的重量、一定的厚度或一定规格等），也可以是品质型的（如男女比例、学历等级、职称高低等）。\"></a>总体比例是指总体中具有某种相同特征的个体所占的比例，这些特征可以是数据型的（如一定的重量、一定的厚度或一定规格等），也可以是品质型的（如男女比例、学历等级、职称高低等）。</h5><h5 id=\"在构造检验统计量时，我们仍然利用样本比例p与总体比例π之间的距离等于多少个标准差来衡量，因为在大样本情况下统计量p近似服从正太分布，而统计量\"><a href=\"#在构造检验统计量时，我们仍然利用样本比例p与总体比例π之间的距离等于多少个标准差来衡量，因为在大样本情况下统计量p近似服从正太分布，而统计量\" class=\"headerlink\" title=\"在构造检验统计量时，我们仍然利用样本比例p与总体比例π之间的距离等于多少个标准差来衡量，因为在大样本情况下统计量p近似服从正太分布，而统计量\"></a>在构造检验统计量时，我们仍然利用样本比例p与总体比例π之间的距离等于多少个标准差来衡量，因为在大样本情况下统计量p近似服从正太分布，而统计量</h5><script type=\"math/tex; mode=display\">z = \\frac{P - π_0}{\\sqrt{\\frac{π_0(1-π_0)}{n}}}</script><p><img src=\"/img/pvalue/pvalue6.png\" alt=\"大样本情况下一个总体比例的检验方法\">    <div class=\"img-note\">大样本情况下一个总体比例的检验方法</div></p>\n<h3 id=\"1-4-两个总体参数的检验\"><a href=\"#1-4-两个总体参数的检验\" class=\"headerlink\" title=\"1.4 两个总体参数的检验\"></a>1.4 两个总体参数的检验</h3><h5 id=\"在实际研究中，我们常常要比较两个总体的差异，如一所学校的重点班和普通班两个班级学生的英语成绩是否有显著差异；生产企业在改进生产线后的平均产量与原生产线的平均产量相比是否有显著提高等等。\"><a href=\"#在实际研究中，我们常常要比较两个总体的差异，如一所学校的重点班和普通班两个班级学生的英语成绩是否有显著差异；生产企业在改进生产线后的平均产量与原生产线的平均产量相比是否有显著提高等等。\" class=\"headerlink\" title=\"在实际研究中，我们常常要比较两个总体的差异，如一所学校的重点班和普通班两个班级学生的英语成绩是否有显著差异；生产企业在改进生产线后的平均产量与原生产线的平均产量相比是否有显著提高等等。\"></a>在实际研究中，我们常常要比较两个总体的差异，如一所学校的重点班和普通班两个班级学生的英语成绩是否有显著差异；生产企业在改进生产线后的平均产量与原生产线的平均产量相比是否有显著提高等等。</h5><p><img src=\"/img/pvalue/pvalue7.png\" alt=\"两个总体均值之差的三种基本假设检验形式\">    <div class=\"img-note\">两个总体均值之差的三种基本假设检验形式</div></p>"},{"layout":"post","title":"根据上排给出十个数，在其下排填出对应的十个数","date":"2017-02-15T16:00:00.000Z","original":true,"tag":[["算法","arithmetic"]],"_content":"\n## 题目要求：\n##### 给你10分钟时间，根据上排给出十个数，在其下排填出对应的十个数,要求下排每个数都是先前上排那十个数在下排出现的次数。\n##### 上排的十个数如下：【0，1，2，3，4，5，6，7，8，9】\n<!--more-->\n\n### 举个例子，\n##### 上排数值: 0,1,2,3,4,5,6,7,8,9\n##### 下排数值: 6,2,1,0,0,0,1,0,0,0\n##### 0在下排出现了6次，1在下排出现了2次，\n##### 2在下排出现了1次，3在下排出现了0次...\n\n## 分析过程：\n##### 看到题目的时候觉得有一点绕，切没有太理解题目，以为是一直循环输出下排数组，于是有了下面的解题过程。\n### 根据题目得到的一些条件：\n1. 10个数，每个数都大于等于0；\n2. 下排的数字为上排数字出现的次数；\n3. 基于条件2，下排数字相加一定等于10；\n4. 基于条件3，下排数字有0，要么下排全等于1，很明显全等于1就不符合条件2，所以下排数字一定有0；\n5. 根据条件4，上排数字也有0；\n\n#### 基于上面几个条件，做出下面的一些假设：\n##### 上排的10个数中，有n个数字为0，则非0的数有10-n：\n$$ \\underbrace{0...0}_{\\text{n个0}},\\overbrace{v_1...v_i}^{\\text{10-n个非0数字}} $$\n##### 如果上排为0的下排也为0，显然不符合条件2，所以0的下排数字为非0，切所有0的下排数字相等，假设为非0数x,则上排一定有一个数字为x,对应的下排数字为n：\n$$ 上排：0...0,v_1...v_i,x $$\n$$ 下排：\\underbrace{x...x}_{\\text{n个x}},i_1...i_i,n $$\n##### 上排的0在下排为x，则说明下排有x个0,进一步得出下面的组合：\n$$ 上排：0...0,v_1...v_i,v_j...v_k,x $$\n$$ 下排：\\underbrace{x...x}_{\\text{n个x}},\\underbrace{0....0}_{\\text{x个0}},i_i....i_k,n $$\n##### 根据条件1，下排一共10个数，所以：\n$$ n+x+1≤10 $$\n##### 根据条件3，下排数字相加等于10，所以：\n$$ nx+n≤10 $$\n##### 当v<sub>j</sub>到v<sub>k</sub>不存在，也就是个数为0时，上面两个不等式的等号成立，所以有以下两个函数：\n$$\\begin{cases}\nn+x+1=10 \\\\\\\\\nnx+n=10 \\\\\\\\\nx,n 为 正整数\n\\end{cases}\n\\implies\n\\begin{cases}\nn+x+1<10 \\\\\\\\\nnx+n<10 \\\\\\\\\nx,n 为 正整数\n\\end{cases}\n$$\n##### 因为x，n均为正整数，所以枚举所有情况如下：\n$$\nn=\\begin{cases}\n[1,2,3,4] &x=1 \\\\\\\\\n[1,2,3] &x=2 \\\\\\\\\n[1,2,] &x=3 \\\\\\\\\n[1] &x=4 \\\\\\\\\n[1] &x=5 \\\\\\\\\n[1] &x=6 \\\\\\\\\n[1] &x=7 \\\\\\\\\n[1] &x=8\n\\end{cases}\n$$\n##### 于是我基于这种组合，将6,2,1,0,0,0,1,0,0,0默认为上排函数，发现n=6,计算不出下排函数。百度以后发现，人家根本不是按照我的这种方式去计算。下面说一下正确的解题思路.\n\n## 解题：\n##### 它的原型跟八皇后有点类似，都是用回溯递归的方法去一次一次尝试，直到找出正确解。\n##### 具体的想法是：不断的去从下排数组中捉取在上排数组中对应位置中出现的个数，如果个数不对就更新下排数组中对应的值，只到找到正确值。（下排数组先初始为任意值）\n##### 如：\n##### 上排数组A：0,1,2,3,4,5,6,7,8,9\n##### 下排数组B：0,1,2,3,4,5,6,7,8,9\n##### 从上牌数组Index = 0开始，A[0] = 0，0在下排数组中的个数为1，那么下排数组B此时就要更新为：1,1,2,3,4,5,6,7,8,9\n##### Index = 1, A[1] = 1, 1在下排数组中的个数为2，那么下排数组B此时就要更新为：1,2,2,3,4,5,6,7,8,9，从此不断的往下进行，只要找不到正确值就一直往下进行，如果Index >= 数组长度时，那么重新恢复Index = 0再往下进行测试直到找出正确解。\n\n## 最后再说一些：\n##### 其实按照上面的这种解题思路，我的解题过程也不能算是错误的，只是排除了大部分的可能性。并且题目也理解有误，所以以后做题一定要看清楚题，理解题目的正真含义。\n","source":"_posts/note/arithmetic/array.md","raw":"---\nlayout: post\ntitle: 根据上排给出十个数，在其下排填出对应的十个数\ndate: 2017/02/16\ntags: [tech, arithmetic, index]\noriginal: true\ntag: [[算法, arithmetic]]\n---\n\n## 题目要求：\n##### 给你10分钟时间，根据上排给出十个数，在其下排填出对应的十个数,要求下排每个数都是先前上排那十个数在下排出现的次数。\n##### 上排的十个数如下：【0，1，2，3，4，5，6，7，8，9】\n<!--more-->\n\n### 举个例子，\n##### 上排数值: 0,1,2,3,4,5,6,7,8,9\n##### 下排数值: 6,2,1,0,0,0,1,0,0,0\n##### 0在下排出现了6次，1在下排出现了2次，\n##### 2在下排出现了1次，3在下排出现了0次...\n\n## 分析过程：\n##### 看到题目的时候觉得有一点绕，切没有太理解题目，以为是一直循环输出下排数组，于是有了下面的解题过程。\n### 根据题目得到的一些条件：\n1. 10个数，每个数都大于等于0；\n2. 下排的数字为上排数字出现的次数；\n3. 基于条件2，下排数字相加一定等于10；\n4. 基于条件3，下排数字有0，要么下排全等于1，很明显全等于1就不符合条件2，所以下排数字一定有0；\n5. 根据条件4，上排数字也有0；\n\n#### 基于上面几个条件，做出下面的一些假设：\n##### 上排的10个数中，有n个数字为0，则非0的数有10-n：\n$$ \\underbrace{0...0}_{\\text{n个0}},\\overbrace{v_1...v_i}^{\\text{10-n个非0数字}} $$\n##### 如果上排为0的下排也为0，显然不符合条件2，所以0的下排数字为非0，切所有0的下排数字相等，假设为非0数x,则上排一定有一个数字为x,对应的下排数字为n：\n$$ 上排：0...0,v_1...v_i,x $$\n$$ 下排：\\underbrace{x...x}_{\\text{n个x}},i_1...i_i,n $$\n##### 上排的0在下排为x，则说明下排有x个0,进一步得出下面的组合：\n$$ 上排：0...0,v_1...v_i,v_j...v_k,x $$\n$$ 下排：\\underbrace{x...x}_{\\text{n个x}},\\underbrace{0....0}_{\\text{x个0}},i_i....i_k,n $$\n##### 根据条件1，下排一共10个数，所以：\n$$ n+x+1≤10 $$\n##### 根据条件3，下排数字相加等于10，所以：\n$$ nx+n≤10 $$\n##### 当v<sub>j</sub>到v<sub>k</sub>不存在，也就是个数为0时，上面两个不等式的等号成立，所以有以下两个函数：\n$$\\begin{cases}\nn+x+1=10 \\\\\\\\\nnx+n=10 \\\\\\\\\nx,n 为 正整数\n\\end{cases}\n\\implies\n\\begin{cases}\nn+x+1<10 \\\\\\\\\nnx+n<10 \\\\\\\\\nx,n 为 正整数\n\\end{cases}\n$$\n##### 因为x，n均为正整数，所以枚举所有情况如下：\n$$\nn=\\begin{cases}\n[1,2,3,4] &x=1 \\\\\\\\\n[1,2,3] &x=2 \\\\\\\\\n[1,2,] &x=3 \\\\\\\\\n[1] &x=4 \\\\\\\\\n[1] &x=5 \\\\\\\\\n[1] &x=6 \\\\\\\\\n[1] &x=7 \\\\\\\\\n[1] &x=8\n\\end{cases}\n$$\n##### 于是我基于这种组合，将6,2,1,0,0,0,1,0,0,0默认为上排函数，发现n=6,计算不出下排函数。百度以后发现，人家根本不是按照我的这种方式去计算。下面说一下正确的解题思路.\n\n## 解题：\n##### 它的原型跟八皇后有点类似，都是用回溯递归的方法去一次一次尝试，直到找出正确解。\n##### 具体的想法是：不断的去从下排数组中捉取在上排数组中对应位置中出现的个数，如果个数不对就更新下排数组中对应的值，只到找到正确值。（下排数组先初始为任意值）\n##### 如：\n##### 上排数组A：0,1,2,3,4,5,6,7,8,9\n##### 下排数组B：0,1,2,3,4,5,6,7,8,9\n##### 从上牌数组Index = 0开始，A[0] = 0，0在下排数组中的个数为1，那么下排数组B此时就要更新为：1,1,2,3,4,5,6,7,8,9\n##### Index = 1, A[1] = 1, 1在下排数组中的个数为2，那么下排数组B此时就要更新为：1,2,2,3,4,5,6,7,8,9，从此不断的往下进行，只要找不到正确值就一直往下进行，如果Index >= 数组长度时，那么重新恢复Index = 0再往下进行测试直到找出正确解。\n\n## 最后再说一些：\n##### 其实按照上面的这种解题思路，我的解题过程也不能算是错误的，只是排除了大部分的可能性。并且题目也理解有误，所以以后做题一定要看清楚题，理解题目的正真含义。\n","slug":"note/arithmetic/array","published":1,"updated":"2018-05-08T13:00:14.272Z","comments":1,"photos":[],"link":"","_id":"cjgxop3mx002ijah1b38l9vb8","content":"<h2 id=\"题目要求：\"><a href=\"#题目要求：\" class=\"headerlink\" title=\"题目要求：\"></a>题目要求：</h2><h5 id=\"给你10分钟时间，根据上排给出十个数，在其下排填出对应的十个数-要求下排每个数都是先前上排那十个数在下排出现的次数。\"><a href=\"#给你10分钟时间，根据上排给出十个数，在其下排填出对应的十个数-要求下排每个数都是先前上排那十个数在下排出现的次数。\" class=\"headerlink\" title=\"给你10分钟时间，根据上排给出十个数，在其下排填出对应的十个数,要求下排每个数都是先前上排那十个数在下排出现的次数。\"></a>给你10分钟时间，根据上排给出十个数，在其下排填出对应的十个数,要求下排每个数都是先前上排那十个数在下排出现的次数。</h5><h5 id=\"上排的十个数如下：【0，1，2，3，4，5，6，7，8，9】\"><a href=\"#上排的十个数如下：【0，1，2，3，4，5，6，7，8，9】\" class=\"headerlink\" title=\"上排的十个数如下：【0，1，2，3，4，5，6，7，8，9】\"></a>上排的十个数如下：【0，1，2，3，4，5，6，7，8，9】</h5><a id=\"more\"></a>\n<h3 id=\"举个例子，\"><a href=\"#举个例子，\" class=\"headerlink\" title=\"举个例子，\"></a>举个例子，</h3><h5 id=\"上排数值-0-1-2-3-4-5-6-7-8-9\"><a href=\"#上排数值-0-1-2-3-4-5-6-7-8-9\" class=\"headerlink\" title=\"上排数值: 0,1,2,3,4,5,6,7,8,9\"></a>上排数值: 0,1,2,3,4,5,6,7,8,9</h5><h5 id=\"下排数值-6-2-1-0-0-0-1-0-0-0\"><a href=\"#下排数值-6-2-1-0-0-0-1-0-0-0\" class=\"headerlink\" title=\"下排数值: 6,2,1,0,0,0,1,0,0,0\"></a>下排数值: 6,2,1,0,0,0,1,0,0,0</h5><h5 id=\"0在下排出现了6次，1在下排出现了2次，\"><a href=\"#0在下排出现了6次，1在下排出现了2次，\" class=\"headerlink\" title=\"0在下排出现了6次，1在下排出现了2次，\"></a>0在下排出现了6次，1在下排出现了2次，</h5><h5 id=\"2在下排出现了1次，3在下排出现了0次…\"><a href=\"#2在下排出现了1次，3在下排出现了0次…\" class=\"headerlink\" title=\"2在下排出现了1次，3在下排出现了0次…\"></a>2在下排出现了1次，3在下排出现了0次…</h5><h2 id=\"分析过程：\"><a href=\"#分析过程：\" class=\"headerlink\" title=\"分析过程：\"></a>分析过程：</h2><h5 id=\"看到题目的时候觉得有一点绕，切没有太理解题目，以为是一直循环输出下排数组，于是有了下面的解题过程。\"><a href=\"#看到题目的时候觉得有一点绕，切没有太理解题目，以为是一直循环输出下排数组，于是有了下面的解题过程。\" class=\"headerlink\" title=\"看到题目的时候觉得有一点绕，切没有太理解题目，以为是一直循环输出下排数组，于是有了下面的解题过程。\"></a>看到题目的时候觉得有一点绕，切没有太理解题目，以为是一直循环输出下排数组，于是有了下面的解题过程。</h5><h3 id=\"根据题目得到的一些条件：\"><a href=\"#根据题目得到的一些条件：\" class=\"headerlink\" title=\"根据题目得到的一些条件：\"></a>根据题目得到的一些条件：</h3><ol>\n<li>10个数，每个数都大于等于0；</li>\n<li>下排的数字为上排数字出现的次数；</li>\n<li>基于条件2，下排数字相加一定等于10；</li>\n<li>基于条件3，下排数字有0，要么下排全等于1，很明显全等于1就不符合条件2，所以下排数字一定有0；</li>\n<li>根据条件4，上排数字也有0；</li>\n</ol>\n<h4 id=\"基于上面几个条件，做出下面的一些假设：\"><a href=\"#基于上面几个条件，做出下面的一些假设：\" class=\"headerlink\" title=\"基于上面几个条件，做出下面的一些假设：\"></a>基于上面几个条件，做出下面的一些假设：</h4><h5 id=\"上排的10个数中，有n个数字为0，则非0的数有10-n：\"><a href=\"#上排的10个数中，有n个数字为0，则非0的数有10-n：\" class=\"headerlink\" title=\"上排的10个数中，有n个数字为0，则非0的数有10-n：\"></a>上排的10个数中，有n个数字为0，则非0的数有10-n：</h5><script type=\"math/tex; mode=display\">\\underbrace{0...0}_{\\text{n个0}},\\overbrace{v_1...v_i}^{\\text{10-n个非0数字}}</script><h5 id=\"如果上排为0的下排也为0，显然不符合条件2，所以0的下排数字为非0，切所有0的下排数字相等，假设为非0数x-则上排一定有一个数字为x-对应的下排数字为n：\"><a href=\"#如果上排为0的下排也为0，显然不符合条件2，所以0的下排数字为非0，切所有0的下排数字相等，假设为非0数x-则上排一定有一个数字为x-对应的下排数字为n：\" class=\"headerlink\" title=\"如果上排为0的下排也为0，显然不符合条件2，所以0的下排数字为非0，切所有0的下排数字相等，假设为非0数x,则上排一定有一个数字为x,对应的下排数字为n：\"></a>如果上排为0的下排也为0，显然不符合条件2，所以0的下排数字为非0，切所有0的下排数字相等，假设为非0数x,则上排一定有一个数字为x,对应的下排数字为n：</h5><script type=\"math/tex; mode=display\">上排：0...0,v_1...v_i,x</script><script type=\"math/tex; mode=display\">下排：\\underbrace{x...x}_{\\text{n个x}},i_1...i_i,n</script><h5 id=\"上排的0在下排为x，则说明下排有x个0-进一步得出下面的组合：\"><a href=\"#上排的0在下排为x，则说明下排有x个0-进一步得出下面的组合：\" class=\"headerlink\" title=\"上排的0在下排为x，则说明下排有x个0,进一步得出下面的组合：\"></a>上排的0在下排为x，则说明下排有x个0,进一步得出下面的组合：</h5><script type=\"math/tex; mode=display\">上排：0...0,v_1...v_i,v_j...v_k,x</script><script type=\"math/tex; mode=display\">下排：\\underbrace{x...x}_{\\text{n个x}},\\underbrace{0....0}_{\\text{x个0}},i_i....i_k,n</script><h5 id=\"根据条件1，下排一共10个数，所以：\"><a href=\"#根据条件1，下排一共10个数，所以：\" class=\"headerlink\" title=\"根据条件1，下排一共10个数，所以：\"></a>根据条件1，下排一共10个数，所以：</h5><script type=\"math/tex; mode=display\">n+x+1≤10</script><h5 id=\"根据条件3，下排数字相加等于10，所以：\"><a href=\"#根据条件3，下排数字相加等于10，所以：\" class=\"headerlink\" title=\"根据条件3，下排数字相加等于10，所以：\"></a>根据条件3，下排数字相加等于10，所以：</h5><script type=\"math/tex; mode=display\">nx+n≤10</script><h5 id=\"当vj到vk不存在，也就是个数为0时，上面两个不等式的等号成立，所以有以下两个函数：\"><a href=\"#当vj到vk不存在，也就是个数为0时，上面两个不等式的等号成立，所以有以下两个函数：\" class=\"headerlink\" title=\"当vj到vk不存在，也就是个数为0时，上面两个不等式的等号成立，所以有以下两个函数：\"></a>当v<sub>j</sub>到v<sub>k</sub>不存在，也就是个数为0时，上面两个不等式的等号成立，所以有以下两个函数：</h5><script type=\"math/tex; mode=display\">\\begin{cases}\nn+x+1=10 \\\\\\\\\nnx+n=10 \\\\\\\\\nx,n 为 正整数\n\\end{cases}\n\\implies\n\\begin{cases}\nn+x+1<10 \\\\\\\\\nnx+n<10 \\\\\\\\\nx,n 为 正整数\n\\end{cases}</script><h5 id=\"因为x，n均为正整数，所以枚举所有情况如下：\"><a href=\"#因为x，n均为正整数，所以枚举所有情况如下：\" class=\"headerlink\" title=\"因为x，n均为正整数，所以枚举所有情况如下：\"></a>因为x，n均为正整数，所以枚举所有情况如下：</h5><script type=\"math/tex; mode=display\">\nn=\\begin{cases}\n[1,2,3,4] &x=1 \\\\\\\\\n[1,2,3] &x=2 \\\\\\\\\n[1,2,] &x=3 \\\\\\\\\n[1] &x=4 \\\\\\\\\n[1] &x=5 \\\\\\\\\n[1] &x=6 \\\\\\\\\n[1] &x=7 \\\\\\\\\n[1] &x=8\n\\end{cases}</script><h5 id=\"于是我基于这种组合，将6-2-1-0-0-0-1-0-0-0默认为上排函数，发现n-6-计算不出下排函数。百度以后发现，人家根本不是按照我的这种方式去计算。下面说一下正确的解题思路\"><a href=\"#于是我基于这种组合，将6-2-1-0-0-0-1-0-0-0默认为上排函数，发现n-6-计算不出下排函数。百度以后发现，人家根本不是按照我的这种方式去计算。下面说一下正确的解题思路\" class=\"headerlink\" title=\"于是我基于这种组合，将6,2,1,0,0,0,1,0,0,0默认为上排函数，发现n=6,计算不出下排函数。百度以后发现，人家根本不是按照我的这种方式去计算。下面说一下正确的解题思路.\"></a>于是我基于这种组合，将6,2,1,0,0,0,1,0,0,0默认为上排函数，发现n=6,计算不出下排函数。百度以后发现，人家根本不是按照我的这种方式去计算。下面说一下正确的解题思路.</h5><h2 id=\"解题：\"><a href=\"#解题：\" class=\"headerlink\" title=\"解题：\"></a>解题：</h2><h5 id=\"它的原型跟八皇后有点类似，都是用回溯递归的方法去一次一次尝试，直到找出正确解。\"><a href=\"#它的原型跟八皇后有点类似，都是用回溯递归的方法去一次一次尝试，直到找出正确解。\" class=\"headerlink\" title=\"它的原型跟八皇后有点类似，都是用回溯递归的方法去一次一次尝试，直到找出正确解。\"></a>它的原型跟八皇后有点类似，都是用回溯递归的方法去一次一次尝试，直到找出正确解。</h5><h5 id=\"具体的想法是：不断的去从下排数组中捉取在上排数组中对应位置中出现的个数，如果个数不对就更新下排数组中对应的值，只到找到正确值。（下排数组先初始为任意值）\"><a href=\"#具体的想法是：不断的去从下排数组中捉取在上排数组中对应位置中出现的个数，如果个数不对就更新下排数组中对应的值，只到找到正确值。（下排数组先初始为任意值）\" class=\"headerlink\" title=\"具体的想法是：不断的去从下排数组中捉取在上排数组中对应位置中出现的个数，如果个数不对就更新下排数组中对应的值，只到找到正确值。（下排数组先初始为任意值）\"></a>具体的想法是：不断的去从下排数组中捉取在上排数组中对应位置中出现的个数，如果个数不对就更新下排数组中对应的值，只到找到正确值。（下排数组先初始为任意值）</h5><h5 id=\"如：\"><a href=\"#如：\" class=\"headerlink\" title=\"如：\"></a>如：</h5><h5 id=\"上排数组A：0-1-2-3-4-5-6-7-8-9\"><a href=\"#上排数组A：0-1-2-3-4-5-6-7-8-9\" class=\"headerlink\" title=\"上排数组A：0,1,2,3,4,5,6,7,8,9\"></a>上排数组A：0,1,2,3,4,5,6,7,8,9</h5><h5 id=\"下排数组B：0-1-2-3-4-5-6-7-8-9\"><a href=\"#下排数组B：0-1-2-3-4-5-6-7-8-9\" class=\"headerlink\" title=\"下排数组B：0,1,2,3,4,5,6,7,8,9\"></a>下排数组B：0,1,2,3,4,5,6,7,8,9</h5><h5 id=\"从上牌数组Index-0开始，A-0-0，0在下排数组中的个数为1，那么下排数组B此时就要更新为：1-1-2-3-4-5-6-7-8-9\"><a href=\"#从上牌数组Index-0开始，A-0-0，0在下排数组中的个数为1，那么下排数组B此时就要更新为：1-1-2-3-4-5-6-7-8-9\" class=\"headerlink\" title=\"从上牌数组Index = 0开始，A[0] = 0，0在下排数组中的个数为1，那么下排数组B此时就要更新为：1,1,2,3,4,5,6,7,8,9\"></a>从上牌数组Index = 0开始，A[0] = 0，0在下排数组中的个数为1，那么下排数组B此时就要更新为：1,1,2,3,4,5,6,7,8,9</h5><h5 id=\"Index-1-A-1-1-1在下排数组中的个数为2，那么下排数组B此时就要更新为：1-2-2-3-4-5-6-7-8-9，从此不断的往下进行，只要找不到正确值就一直往下进行，如果Index-gt-数组长度时，那么重新恢复Index-0再往下进行测试直到找出正确解。\"><a href=\"#Index-1-A-1-1-1在下排数组中的个数为2，那么下排数组B此时就要更新为：1-2-2-3-4-5-6-7-8-9，从此不断的往下进行，只要找不到正确值就一直往下进行，如果Index-gt-数组长度时，那么重新恢复Index-0再往下进行测试直到找出正确解。\" class=\"headerlink\" title=\"Index = 1, A[1] = 1, 1在下排数组中的个数为2，那么下排数组B此时就要更新为：1,2,2,3,4,5,6,7,8,9，从此不断的往下进行，只要找不到正确值就一直往下进行，如果Index &gt;= 数组长度时，那么重新恢复Index = 0再往下进行测试直到找出正确解。\"></a>Index = 1, A[1] = 1, 1在下排数组中的个数为2，那么下排数组B此时就要更新为：1,2,2,3,4,5,6,7,8,9，从此不断的往下进行，只要找不到正确值就一直往下进行，如果Index &gt;= 数组长度时，那么重新恢复Index = 0再往下进行测试直到找出正确解。</h5><h2 id=\"最后再说一些：\"><a href=\"#最后再说一些：\" class=\"headerlink\" title=\"最后再说一些：\"></a>最后再说一些：</h2><h5 id=\"其实按照上面的这种解题思路，我的解题过程也不能算是错误的，只是排除了大部分的可能性。并且题目也理解有误，所以以后做题一定要看清楚题，理解题目的正真含义。\"><a href=\"#其实按照上面的这种解题思路，我的解题过程也不能算是错误的，只是排除了大部分的可能性。并且题目也理解有误，所以以后做题一定要看清楚题，理解题目的正真含义。\" class=\"headerlink\" title=\"其实按照上面的这种解题思路，我的解题过程也不能算是错误的，只是排除了大部分的可能性。并且题目也理解有误，所以以后做题一定要看清楚题，理解题目的正真含义。\"></a>其实按照上面的这种解题思路，我的解题过程也不能算是错误的，只是排除了大部分的可能性。并且题目也理解有误，所以以后做题一定要看清楚题，理解题目的正真含义。</h5>","site":{"data":{}},"excerpt":"<h2 id=\"题目要求：\"><a href=\"#题目要求：\" class=\"headerlink\" title=\"题目要求：\"></a>题目要求：</h2><h5 id=\"给你10分钟时间，根据上排给出十个数，在其下排填出对应的十个数-要求下排每个数都是先前上排那十个数在下排出现的次数。\"><a href=\"#给你10分钟时间，根据上排给出十个数，在其下排填出对应的十个数-要求下排每个数都是先前上排那十个数在下排出现的次数。\" class=\"headerlink\" title=\"给你10分钟时间，根据上排给出十个数，在其下排填出对应的十个数,要求下排每个数都是先前上排那十个数在下排出现的次数。\"></a>给你10分钟时间，根据上排给出十个数，在其下排填出对应的十个数,要求下排每个数都是先前上排那十个数在下排出现的次数。</h5><h5 id=\"上排的十个数如下：【0，1，2，3，4，5，6，7，8，9】\"><a href=\"#上排的十个数如下：【0，1，2，3，4，5，6，7，8，9】\" class=\"headerlink\" title=\"上排的十个数如下：【0，1，2，3，4，5，6，7，8，9】\"></a>上排的十个数如下：【0，1，2，3，4，5，6，7，8，9】</h5>","more":"<h3 id=\"举个例子，\"><a href=\"#举个例子，\" class=\"headerlink\" title=\"举个例子，\"></a>举个例子，</h3><h5 id=\"上排数值-0-1-2-3-4-5-6-7-8-9\"><a href=\"#上排数值-0-1-2-3-4-5-6-7-8-9\" class=\"headerlink\" title=\"上排数值: 0,1,2,3,4,5,6,7,8,9\"></a>上排数值: 0,1,2,3,4,5,6,7,8,9</h5><h5 id=\"下排数值-6-2-1-0-0-0-1-0-0-0\"><a href=\"#下排数值-6-2-1-0-0-0-1-0-0-0\" class=\"headerlink\" title=\"下排数值: 6,2,1,0,0,0,1,0,0,0\"></a>下排数值: 6,2,1,0,0,0,1,0,0,0</h5><h5 id=\"0在下排出现了6次，1在下排出现了2次，\"><a href=\"#0在下排出现了6次，1在下排出现了2次，\" class=\"headerlink\" title=\"0在下排出现了6次，1在下排出现了2次，\"></a>0在下排出现了6次，1在下排出现了2次，</h5><h5 id=\"2在下排出现了1次，3在下排出现了0次…\"><a href=\"#2在下排出现了1次，3在下排出现了0次…\" class=\"headerlink\" title=\"2在下排出现了1次，3在下排出现了0次…\"></a>2在下排出现了1次，3在下排出现了0次…</h5><h2 id=\"分析过程：\"><a href=\"#分析过程：\" class=\"headerlink\" title=\"分析过程：\"></a>分析过程：</h2><h5 id=\"看到题目的时候觉得有一点绕，切没有太理解题目，以为是一直循环输出下排数组，于是有了下面的解题过程。\"><a href=\"#看到题目的时候觉得有一点绕，切没有太理解题目，以为是一直循环输出下排数组，于是有了下面的解题过程。\" class=\"headerlink\" title=\"看到题目的时候觉得有一点绕，切没有太理解题目，以为是一直循环输出下排数组，于是有了下面的解题过程。\"></a>看到题目的时候觉得有一点绕，切没有太理解题目，以为是一直循环输出下排数组，于是有了下面的解题过程。</h5><h3 id=\"根据题目得到的一些条件：\"><a href=\"#根据题目得到的一些条件：\" class=\"headerlink\" title=\"根据题目得到的一些条件：\"></a>根据题目得到的一些条件：</h3><ol>\n<li>10个数，每个数都大于等于0；</li>\n<li>下排的数字为上排数字出现的次数；</li>\n<li>基于条件2，下排数字相加一定等于10；</li>\n<li>基于条件3，下排数字有0，要么下排全等于1，很明显全等于1就不符合条件2，所以下排数字一定有0；</li>\n<li>根据条件4，上排数字也有0；</li>\n</ol>\n<h4 id=\"基于上面几个条件，做出下面的一些假设：\"><a href=\"#基于上面几个条件，做出下面的一些假设：\" class=\"headerlink\" title=\"基于上面几个条件，做出下面的一些假设：\"></a>基于上面几个条件，做出下面的一些假设：</h4><h5 id=\"上排的10个数中，有n个数字为0，则非0的数有10-n：\"><a href=\"#上排的10个数中，有n个数字为0，则非0的数有10-n：\" class=\"headerlink\" title=\"上排的10个数中，有n个数字为0，则非0的数有10-n：\"></a>上排的10个数中，有n个数字为0，则非0的数有10-n：</h5><script type=\"math/tex; mode=display\">\\underbrace{0...0}_{\\text{n个0}},\\overbrace{v_1...v_i}^{\\text{10-n个非0数字}}</script><h5 id=\"如果上排为0的下排也为0，显然不符合条件2，所以0的下排数字为非0，切所有0的下排数字相等，假设为非0数x-则上排一定有一个数字为x-对应的下排数字为n：\"><a href=\"#如果上排为0的下排也为0，显然不符合条件2，所以0的下排数字为非0，切所有0的下排数字相等，假设为非0数x-则上排一定有一个数字为x-对应的下排数字为n：\" class=\"headerlink\" title=\"如果上排为0的下排也为0，显然不符合条件2，所以0的下排数字为非0，切所有0的下排数字相等，假设为非0数x,则上排一定有一个数字为x,对应的下排数字为n：\"></a>如果上排为0的下排也为0，显然不符合条件2，所以0的下排数字为非0，切所有0的下排数字相等，假设为非0数x,则上排一定有一个数字为x,对应的下排数字为n：</h5><script type=\"math/tex; mode=display\">上排：0...0,v_1...v_i,x</script><script type=\"math/tex; mode=display\">下排：\\underbrace{x...x}_{\\text{n个x}},i_1...i_i,n</script><h5 id=\"上排的0在下排为x，则说明下排有x个0-进一步得出下面的组合：\"><a href=\"#上排的0在下排为x，则说明下排有x个0-进一步得出下面的组合：\" class=\"headerlink\" title=\"上排的0在下排为x，则说明下排有x个0,进一步得出下面的组合：\"></a>上排的0在下排为x，则说明下排有x个0,进一步得出下面的组合：</h5><script type=\"math/tex; mode=display\">上排：0...0,v_1...v_i,v_j...v_k,x</script><script type=\"math/tex; mode=display\">下排：\\underbrace{x...x}_{\\text{n个x}},\\underbrace{0....0}_{\\text{x个0}},i_i....i_k,n</script><h5 id=\"根据条件1，下排一共10个数，所以：\"><a href=\"#根据条件1，下排一共10个数，所以：\" class=\"headerlink\" title=\"根据条件1，下排一共10个数，所以：\"></a>根据条件1，下排一共10个数，所以：</h5><script type=\"math/tex; mode=display\">n+x+1≤10</script><h5 id=\"根据条件3，下排数字相加等于10，所以：\"><a href=\"#根据条件3，下排数字相加等于10，所以：\" class=\"headerlink\" title=\"根据条件3，下排数字相加等于10，所以：\"></a>根据条件3，下排数字相加等于10，所以：</h5><script type=\"math/tex; mode=display\">nx+n≤10</script><h5 id=\"当vj到vk不存在，也就是个数为0时，上面两个不等式的等号成立，所以有以下两个函数：\"><a href=\"#当vj到vk不存在，也就是个数为0时，上面两个不等式的等号成立，所以有以下两个函数：\" class=\"headerlink\" title=\"当vj到vk不存在，也就是个数为0时，上面两个不等式的等号成立，所以有以下两个函数：\"></a>当v<sub>j</sub>到v<sub>k</sub>不存在，也就是个数为0时，上面两个不等式的等号成立，所以有以下两个函数：</h5><script type=\"math/tex; mode=display\">\\begin{cases}\nn+x+1=10 \\\\\\\\\nnx+n=10 \\\\\\\\\nx,n 为 正整数\n\\end{cases}\n\\implies\n\\begin{cases}\nn+x+1<10 \\\\\\\\\nnx+n<10 \\\\\\\\\nx,n 为 正整数\n\\end{cases}</script><h5 id=\"因为x，n均为正整数，所以枚举所有情况如下：\"><a href=\"#因为x，n均为正整数，所以枚举所有情况如下：\" class=\"headerlink\" title=\"因为x，n均为正整数，所以枚举所有情况如下：\"></a>因为x，n均为正整数，所以枚举所有情况如下：</h5><script type=\"math/tex; mode=display\">\nn=\\begin{cases}\n[1,2,3,4] &x=1 \\\\\\\\\n[1,2,3] &x=2 \\\\\\\\\n[1,2,] &x=3 \\\\\\\\\n[1] &x=4 \\\\\\\\\n[1] &x=5 \\\\\\\\\n[1] &x=6 \\\\\\\\\n[1] &x=7 \\\\\\\\\n[1] &x=8\n\\end{cases}</script><h5 id=\"于是我基于这种组合，将6-2-1-0-0-0-1-0-0-0默认为上排函数，发现n-6-计算不出下排函数。百度以后发现，人家根本不是按照我的这种方式去计算。下面说一下正确的解题思路\"><a href=\"#于是我基于这种组合，将6-2-1-0-0-0-1-0-0-0默认为上排函数，发现n-6-计算不出下排函数。百度以后发现，人家根本不是按照我的这种方式去计算。下面说一下正确的解题思路\" class=\"headerlink\" title=\"于是我基于这种组合，将6,2,1,0,0,0,1,0,0,0默认为上排函数，发现n=6,计算不出下排函数。百度以后发现，人家根本不是按照我的这种方式去计算。下面说一下正确的解题思路.\"></a>于是我基于这种组合，将6,2,1,0,0,0,1,0,0,0默认为上排函数，发现n=6,计算不出下排函数。百度以后发现，人家根本不是按照我的这种方式去计算。下面说一下正确的解题思路.</h5><h2 id=\"解题：\"><a href=\"#解题：\" class=\"headerlink\" title=\"解题：\"></a>解题：</h2><h5 id=\"它的原型跟八皇后有点类似，都是用回溯递归的方法去一次一次尝试，直到找出正确解。\"><a href=\"#它的原型跟八皇后有点类似，都是用回溯递归的方法去一次一次尝试，直到找出正确解。\" class=\"headerlink\" title=\"它的原型跟八皇后有点类似，都是用回溯递归的方法去一次一次尝试，直到找出正确解。\"></a>它的原型跟八皇后有点类似，都是用回溯递归的方法去一次一次尝试，直到找出正确解。</h5><h5 id=\"具体的想法是：不断的去从下排数组中捉取在上排数组中对应位置中出现的个数，如果个数不对就更新下排数组中对应的值，只到找到正确值。（下排数组先初始为任意值）\"><a href=\"#具体的想法是：不断的去从下排数组中捉取在上排数组中对应位置中出现的个数，如果个数不对就更新下排数组中对应的值，只到找到正确值。（下排数组先初始为任意值）\" class=\"headerlink\" title=\"具体的想法是：不断的去从下排数组中捉取在上排数组中对应位置中出现的个数，如果个数不对就更新下排数组中对应的值，只到找到正确值。（下排数组先初始为任意值）\"></a>具体的想法是：不断的去从下排数组中捉取在上排数组中对应位置中出现的个数，如果个数不对就更新下排数组中对应的值，只到找到正确值。（下排数组先初始为任意值）</h5><h5 id=\"如：\"><a href=\"#如：\" class=\"headerlink\" title=\"如：\"></a>如：</h5><h5 id=\"上排数组A：0-1-2-3-4-5-6-7-8-9\"><a href=\"#上排数组A：0-1-2-3-4-5-6-7-8-9\" class=\"headerlink\" title=\"上排数组A：0,1,2,3,4,5,6,7,8,9\"></a>上排数组A：0,1,2,3,4,5,6,7,8,9</h5><h5 id=\"下排数组B：0-1-2-3-4-5-6-7-8-9\"><a href=\"#下排数组B：0-1-2-3-4-5-6-7-8-9\" class=\"headerlink\" title=\"下排数组B：0,1,2,3,4,5,6,7,8,9\"></a>下排数组B：0,1,2,3,4,5,6,7,8,9</h5><h5 id=\"从上牌数组Index-0开始，A-0-0，0在下排数组中的个数为1，那么下排数组B此时就要更新为：1-1-2-3-4-5-6-7-8-9\"><a href=\"#从上牌数组Index-0开始，A-0-0，0在下排数组中的个数为1，那么下排数组B此时就要更新为：1-1-2-3-4-5-6-7-8-9\" class=\"headerlink\" title=\"从上牌数组Index = 0开始，A[0] = 0，0在下排数组中的个数为1，那么下排数组B此时就要更新为：1,1,2,3,4,5,6,7,8,9\"></a>从上牌数组Index = 0开始，A[0] = 0，0在下排数组中的个数为1，那么下排数组B此时就要更新为：1,1,2,3,4,5,6,7,8,9</h5><h5 id=\"Index-1-A-1-1-1在下排数组中的个数为2，那么下排数组B此时就要更新为：1-2-2-3-4-5-6-7-8-9，从此不断的往下进行，只要找不到正确值就一直往下进行，如果Index-gt-数组长度时，那么重新恢复Index-0再往下进行测试直到找出正确解。\"><a href=\"#Index-1-A-1-1-1在下排数组中的个数为2，那么下排数组B此时就要更新为：1-2-2-3-4-5-6-7-8-9，从此不断的往下进行，只要找不到正确值就一直往下进行，如果Index-gt-数组长度时，那么重新恢复Index-0再往下进行测试直到找出正确解。\" class=\"headerlink\" title=\"Index = 1, A[1] = 1, 1在下排数组中的个数为2，那么下排数组B此时就要更新为：1,2,2,3,4,5,6,7,8,9，从此不断的往下进行，只要找不到正确值就一直往下进行，如果Index &gt;= 数组长度时，那么重新恢复Index = 0再往下进行测试直到找出正确解。\"></a>Index = 1, A[1] = 1, 1在下排数组中的个数为2，那么下排数组B此时就要更新为：1,2,2,3,4,5,6,7,8,9，从此不断的往下进行，只要找不到正确值就一直往下进行，如果Index &gt;= 数组长度时，那么重新恢复Index = 0再往下进行测试直到找出正确解。</h5><h2 id=\"最后再说一些：\"><a href=\"#最后再说一些：\" class=\"headerlink\" title=\"最后再说一些：\"></a>最后再说一些：</h2><h5 id=\"其实按照上面的这种解题思路，我的解题过程也不能算是错误的，只是排除了大部分的可能性。并且题目也理解有误，所以以后做题一定要看清楚题，理解题目的正真含义。\"><a href=\"#其实按照上面的这种解题思路，我的解题过程也不能算是错误的，只是排除了大部分的可能性。并且题目也理解有误，所以以后做题一定要看清楚题，理解题目的正真含义。\" class=\"headerlink\" title=\"其实按照上面的这种解题思路，我的解题过程也不能算是错误的，只是排除了大部分的可能性。并且题目也理解有误，所以以后做题一定要看清楚题，理解题目的正真含义。\"></a>其实按照上面的这种解题思路，我的解题过程也不能算是错误的，只是排除了大部分的可能性。并且题目也理解有误，所以以后做题一定要看清楚题，理解题目的正真含义。</h5>"},{"layout":"post","title":"等分数组","date":"2017-04-15T16:00:00.000Z","original":true,"tag":[["算法","arithmetic"]],"_content":"\n## 题目要求：\n##### 偶数的数组里面有一些正数，分成两个大小一样的子数组，两个数组之和尽量相等\n<!--more-->\n\n## 分析过程：\n##### 题目要求比较简单，也很容易理解\n### 解法一\n##### 因为是尽量相等，所以最简单的方法就是。依次遍历原数组中的每个数，判断两个子数组的和，将该数放入到和较小的那个数组中。以此类推，直到遍历完成。这样能够在原数组的顺序下，两个数组都是尽量相等的。\n##### 但是问题是如果原数组当中最后一个数比其他数大很多，就会导致子数组在最后一步后相差得比较大。\n\n### 解法二\n##### 解法二是针对解法一的一种优化，为了解决解法一种的问题，需要对原数组进行排序，排序算法这里就不多讲，只需要将原数组排列成从大到小的顺序，然后再按照解法一去等分原数组。\n\n## 最后再说一些：\n##### 解法二的过程很有意思，就像如果要把一个框内尽量多的装水果，应该先装大的水果，再用小的水果将框填满。等分数组也是先将大的数先放入子数组，这样就方便后面的过程去调试和精细话。\n","source":"_posts/note/arithmetic/array1.md","raw":"---\nlayout: post\ntitle: 等分数组\ndate: 2017/04/16\ntags: [tech, arithmetic, index]\noriginal: true\ntag: [[算法, arithmetic]]\n---\n\n## 题目要求：\n##### 偶数的数组里面有一些正数，分成两个大小一样的子数组，两个数组之和尽量相等\n<!--more-->\n\n## 分析过程：\n##### 题目要求比较简单，也很容易理解\n### 解法一\n##### 因为是尽量相等，所以最简单的方法就是。依次遍历原数组中的每个数，判断两个子数组的和，将该数放入到和较小的那个数组中。以此类推，直到遍历完成。这样能够在原数组的顺序下，两个数组都是尽量相等的。\n##### 但是问题是如果原数组当中最后一个数比其他数大很多，就会导致子数组在最后一步后相差得比较大。\n\n### 解法二\n##### 解法二是针对解法一的一种优化，为了解决解法一种的问题，需要对原数组进行排序，排序算法这里就不多讲，只需要将原数组排列成从大到小的顺序，然后再按照解法一去等分原数组。\n\n## 最后再说一些：\n##### 解法二的过程很有意思，就像如果要把一个框内尽量多的装水果，应该先装大的水果，再用小的水果将框填满。等分数组也是先将大的数先放入子数组，这样就方便后面的过程去调试和精细话。\n","slug":"note/arithmetic/array1","published":1,"updated":"2018-05-08T13:00:14.272Z","comments":1,"photos":[],"link":"","_id":"cjgxop3my002kjah10zize4g7","content":"<h2 id=\"题目要求：\"><a href=\"#题目要求：\" class=\"headerlink\" title=\"题目要求：\"></a>题目要求：</h2><h5 id=\"偶数的数组里面有一些正数，分成两个大小一样的子数组，两个数组之和尽量相等\"><a href=\"#偶数的数组里面有一些正数，分成两个大小一样的子数组，两个数组之和尽量相等\" class=\"headerlink\" title=\"偶数的数组里面有一些正数，分成两个大小一样的子数组，两个数组之和尽量相等\"></a>偶数的数组里面有一些正数，分成两个大小一样的子数组，两个数组之和尽量相等</h5><a id=\"more\"></a>\n<h2 id=\"分析过程：\"><a href=\"#分析过程：\" class=\"headerlink\" title=\"分析过程：\"></a>分析过程：</h2><h5 id=\"题目要求比较简单，也很容易理解\"><a href=\"#题目要求比较简单，也很容易理解\" class=\"headerlink\" title=\"题目要求比较简单，也很容易理解\"></a>题目要求比较简单，也很容易理解</h5><h3 id=\"解法一\"><a href=\"#解法一\" class=\"headerlink\" title=\"解法一\"></a>解法一</h3><h5 id=\"因为是尽量相等，所以最简单的方法就是。依次遍历原数组中的每个数，判断两个子数组的和，将该数放入到和较小的那个数组中。以此类推，直到遍历完成。这样能够在原数组的顺序下，两个数组都是尽量相等的。\"><a href=\"#因为是尽量相等，所以最简单的方法就是。依次遍历原数组中的每个数，判断两个子数组的和，将该数放入到和较小的那个数组中。以此类推，直到遍历完成。这样能够在原数组的顺序下，两个数组都是尽量相等的。\" class=\"headerlink\" title=\"因为是尽量相等，所以最简单的方法就是。依次遍历原数组中的每个数，判断两个子数组的和，将该数放入到和较小的那个数组中。以此类推，直到遍历完成。这样能够在原数组的顺序下，两个数组都是尽量相等的。\"></a>因为是尽量相等，所以最简单的方法就是。依次遍历原数组中的每个数，判断两个子数组的和，将该数放入到和较小的那个数组中。以此类推，直到遍历完成。这样能够在原数组的顺序下，两个数组都是尽量相等的。</h5><h5 id=\"但是问题是如果原数组当中最后一个数比其他数大很多，就会导致子数组在最后一步后相差得比较大。\"><a href=\"#但是问题是如果原数组当中最后一个数比其他数大很多，就会导致子数组在最后一步后相差得比较大。\" class=\"headerlink\" title=\"但是问题是如果原数组当中最后一个数比其他数大很多，就会导致子数组在最后一步后相差得比较大。\"></a>但是问题是如果原数组当中最后一个数比其他数大很多，就会导致子数组在最后一步后相差得比较大。</h5><h3 id=\"解法二\"><a href=\"#解法二\" class=\"headerlink\" title=\"解法二\"></a>解法二</h3><h5 id=\"解法二是针对解法一的一种优化，为了解决解法一种的问题，需要对原数组进行排序，排序算法这里就不多讲，只需要将原数组排列成从大到小的顺序，然后再按照解法一去等分原数组。\"><a href=\"#解法二是针对解法一的一种优化，为了解决解法一种的问题，需要对原数组进行排序，排序算法这里就不多讲，只需要将原数组排列成从大到小的顺序，然后再按照解法一去等分原数组。\" class=\"headerlink\" title=\"解法二是针对解法一的一种优化，为了解决解法一种的问题，需要对原数组进行排序，排序算法这里就不多讲，只需要将原数组排列成从大到小的顺序，然后再按照解法一去等分原数组。\"></a>解法二是针对解法一的一种优化，为了解决解法一种的问题，需要对原数组进行排序，排序算法这里就不多讲，只需要将原数组排列成从大到小的顺序，然后再按照解法一去等分原数组。</h5><h2 id=\"最后再说一些：\"><a href=\"#最后再说一些：\" class=\"headerlink\" title=\"最后再说一些：\"></a>最后再说一些：</h2><h5 id=\"解法二的过程很有意思，就像如果要把一个框内尽量多的装水果，应该先装大的水果，再用小的水果将框填满。等分数组也是先将大的数先放入子数组，这样就方便后面的过程去调试和精细话。\"><a href=\"#解法二的过程很有意思，就像如果要把一个框内尽量多的装水果，应该先装大的水果，再用小的水果将框填满。等分数组也是先将大的数先放入子数组，这样就方便后面的过程去调试和精细话。\" class=\"headerlink\" title=\"解法二的过程很有意思，就像如果要把一个框内尽量多的装水果，应该先装大的水果，再用小的水果将框填满。等分数组也是先将大的数先放入子数组，这样就方便后面的过程去调试和精细话。\"></a>解法二的过程很有意思，就像如果要把一个框内尽量多的装水果，应该先装大的水果，再用小的水果将框填满。等分数组也是先将大的数先放入子数组，这样就方便后面的过程去调试和精细话。</h5>","site":{"data":{}},"excerpt":"<h2 id=\"题目要求：\"><a href=\"#题目要求：\" class=\"headerlink\" title=\"题目要求：\"></a>题目要求：</h2><h5 id=\"偶数的数组里面有一些正数，分成两个大小一样的子数组，两个数组之和尽量相等\"><a href=\"#偶数的数组里面有一些正数，分成两个大小一样的子数组，两个数组之和尽量相等\" class=\"headerlink\" title=\"偶数的数组里面有一些正数，分成两个大小一样的子数组，两个数组之和尽量相等\"></a>偶数的数组里面有一些正数，分成两个大小一样的子数组，两个数组之和尽量相等</h5>","more":"<h2 id=\"分析过程：\"><a href=\"#分析过程：\" class=\"headerlink\" title=\"分析过程：\"></a>分析过程：</h2><h5 id=\"题目要求比较简单，也很容易理解\"><a href=\"#题目要求比较简单，也很容易理解\" class=\"headerlink\" title=\"题目要求比较简单，也很容易理解\"></a>题目要求比较简单，也很容易理解</h5><h3 id=\"解法一\"><a href=\"#解法一\" class=\"headerlink\" title=\"解法一\"></a>解法一</h3><h5 id=\"因为是尽量相等，所以最简单的方法就是。依次遍历原数组中的每个数，判断两个子数组的和，将该数放入到和较小的那个数组中。以此类推，直到遍历完成。这样能够在原数组的顺序下，两个数组都是尽量相等的。\"><a href=\"#因为是尽量相等，所以最简单的方法就是。依次遍历原数组中的每个数，判断两个子数组的和，将该数放入到和较小的那个数组中。以此类推，直到遍历完成。这样能够在原数组的顺序下，两个数组都是尽量相等的。\" class=\"headerlink\" title=\"因为是尽量相等，所以最简单的方法就是。依次遍历原数组中的每个数，判断两个子数组的和，将该数放入到和较小的那个数组中。以此类推，直到遍历完成。这样能够在原数组的顺序下，两个数组都是尽量相等的。\"></a>因为是尽量相等，所以最简单的方法就是。依次遍历原数组中的每个数，判断两个子数组的和，将该数放入到和较小的那个数组中。以此类推，直到遍历完成。这样能够在原数组的顺序下，两个数组都是尽量相等的。</h5><h5 id=\"但是问题是如果原数组当中最后一个数比其他数大很多，就会导致子数组在最后一步后相差得比较大。\"><a href=\"#但是问题是如果原数组当中最后一个数比其他数大很多，就会导致子数组在最后一步后相差得比较大。\" class=\"headerlink\" title=\"但是问题是如果原数组当中最后一个数比其他数大很多，就会导致子数组在最后一步后相差得比较大。\"></a>但是问题是如果原数组当中最后一个数比其他数大很多，就会导致子数组在最后一步后相差得比较大。</h5><h3 id=\"解法二\"><a href=\"#解法二\" class=\"headerlink\" title=\"解法二\"></a>解法二</h3><h5 id=\"解法二是针对解法一的一种优化，为了解决解法一种的问题，需要对原数组进行排序，排序算法这里就不多讲，只需要将原数组排列成从大到小的顺序，然后再按照解法一去等分原数组。\"><a href=\"#解法二是针对解法一的一种优化，为了解决解法一种的问题，需要对原数组进行排序，排序算法这里就不多讲，只需要将原数组排列成从大到小的顺序，然后再按照解法一去等分原数组。\" class=\"headerlink\" title=\"解法二是针对解法一的一种优化，为了解决解法一种的问题，需要对原数组进行排序，排序算法这里就不多讲，只需要将原数组排列成从大到小的顺序，然后再按照解法一去等分原数组。\"></a>解法二是针对解法一的一种优化，为了解决解法一种的问题，需要对原数组进行排序，排序算法这里就不多讲，只需要将原数组排列成从大到小的顺序，然后再按照解法一去等分原数组。</h5><h2 id=\"最后再说一些：\"><a href=\"#最后再说一些：\" class=\"headerlink\" title=\"最后再说一些：\"></a>最后再说一些：</h2><h5 id=\"解法二的过程很有意思，就像如果要把一个框内尽量多的装水果，应该先装大的水果，再用小的水果将框填满。等分数组也是先将大的数先放入子数组，这样就方便后面的过程去调试和精细话。\"><a href=\"#解法二的过程很有意思，就像如果要把一个框内尽量多的装水果，应该先装大的水果，再用小的水果将框填满。等分数组也是先将大的数先放入子数组，这样就方便后面的过程去调试和精细话。\" class=\"headerlink\" title=\"解法二的过程很有意思，就像如果要把一个框内尽量多的装水果，应该先装大的水果，再用小的水果将框填满。等分数组也是先将大的数先放入子数组，这样就方便后面的过程去调试和精细话。\"></a>解法二的过程很有意思，就像如果要把一个框内尽量多的装水果，应该先装大的水果，再用小的水果将框填满。等分数组也是先将大的数先放入子数组，这样就方便后面的过程去调试和精细话。</h5>"},{"layout":"post","title":"将二元查找树转变成排序的双向链表","date":"2017-02-17T16:00:00.000Z","original":true,"tag":[["算法","arithmetic"]],"_content":"\n## 题目要求：\n##### 输入一棵二元查找树，将该二元查找树转换成一个排序的双向链表。\n##### 要求不能创建任何新的结点，只调整指针的指向。\n<!--more-->\n#### 举个例子\n![二元查找树](/img/arithmetic/BinaryTree.png)\n##### 转换成双向链表\n##### 4=6=8=10=12=14=16\n#### 首先我们定义的二元查找树 节点的数据结构如下：\n``\nstruct BSTreeNode\n{\n  int m_nValue; // value of node\n  BSTreeNode *m_pLeft;\n  BSTreeNode *m_pRight; // right child of node\n};*\n``\n\n## 分析过程：\n##### 二元查找树的特征比较明显，每个节点最多有两个子节点，分别为左节点和右节点，左节点的所有值都小于该节点，右节点的值大于该节点。这个题目其实很简单，就是实现二叉树的中序遍历。中序遍历就是左中右遍历。\n\n### 遍历过程，利用数据结构——栈实现，从根节点开始遍历\n1. 判断是否有左节点，\n　　1.1 如果有，则将该节点如栈，然后左节点重复流程1\n　　1.2 如果没有，则将本节点写入链表尾部\n　　1.3 判断是否有右节点\n　　1.4 如果有，将右节点重复流程1\n　　1.5 如果没有，执行流程2\n2. 从栈顶拿出一个节点，如果没有节点，则遍历结束\n　　2.1 将节点插入链表尾部\n　　2.2 判断节点是否有右节点\n　　2.3 有右节点，将右节点重复流程1\n　　2.4 如果没有，执行流程2\n\n#### 实例查找树的遍历过程\n##### 1.根节点10开始遍历，判断有左节点，将10压入栈中\n|&nbsp;&nbsp;|\n| --- |\n|&nbsp;10&nbsp;|\n##### 2. 将左节点6重复流程1\n|&nbsp;&nbsp;|\n| --- |\n|&nbsp;6&nbsp;|\n|&nbsp;10&nbsp;|\n##### 3. 将左节点4重复流程1，因为4没有做子节点，所以将4插入链表\n|&nbsp;&nbsp;|\n| --- |\n|&nbsp;6&nbsp;|\n|&nbsp;10&nbsp;|\n　　　链表：4\n##### 4. 4没有右节点，所以从栈顶中取出节点6进行流程2\n|&nbsp;&nbsp;|\n| --- |\n|&nbsp;10&nbsp;|\n　　　链表：4=6\n##### 5. 6的右节点8执行流程1，8没有左节点，直接加入链表\n|&nbsp;&nbsp;|\n| --- |\n|&nbsp;10&nbsp;|\n　　　链表：4=6=8\n##### 6. 8没有右节点，进入流程2，从栈顶取出\n|&nbsp;&nbsp;|\n| --- |\n|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|\n　　　链表：4=6=8=10\n##### 7. 10有右节点，10的右节点14进入流程1，14有左节点，所以压入栈中\n|&nbsp;&nbsp;|\n| --- |\n|&nbsp;14&nbsp;|\n　　　链表：4=6=8=10\n##### 8. 14的左节点12进入流程1，12没有左节点，直接插入链表\n|&nbsp;&nbsp;|\n| --- |\n|&nbsp;14&nbsp;|\n　　　链表：4=6=8=10=12\n##### 9. 12没有右节点，所以进入流程2，从栈顶中取出14并加入链表，14有右节点16，所以16进入流程1\n|&nbsp;&nbsp;|\n| --- |\n|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|\n　　　链表：4=6=8=10=12=14=16\n##### 10. 16没有右节点，进入流程2，栈中没有元素，流程结束\n　　　最终链表：4=6=8=10=12=14=16\n\n## python实现：\n```python\n#!/usr/bin/env python\n# -*- coding:utf-8 -*-\n\n\"\"\"节点属性\"\"\"\nclass BSTreeNode (object):\n\n    def __init__(self, value, left, right):\n        self.value = value\n        self.left = left\n        self.right = right\n\nclass Stack:\n    \"\"\"模拟栈\"\"\"\n    def __init__(self):\n        self.items = []\n\n    def isEmpty(self):\n        return len(self.items)==0\n\n    def push(self, item):\n        self.items.append(item)\n\n    def pop(self):\n        return self.items.pop()\n\n    def size(self):\n        return len(self.items)\nnow = 0\n\n\"\"\"链表插入节点\"\"\"\ndef __addNode(node):\n    global now\n    if now != 0:\n        now.right = node\n        node.left = now\n    now = node\n\n\"\"\"初始化查找树\"\"\"\ndef __initTree():\n    t4 = BSTreeNode(4, None, None)\n    t8 = BSTreeNode(8, None, None)\n    t6 = BSTreeNode(6, t4, t8)\n    t12 = BSTreeNode(12, None, None)\n    t16 = BSTreeNode(16, None, None)\n    t14 = BSTreeNode(14, t12, t16)\n    t10 = BSTreeNode(10, t6, t14)\n    return t10\n\nstack = Stack()\n\n\"\"\"流程1\"\"\"\ndef __sort(tree):\n    global stack\n    if tree.left != None:\n        stack.push(tree)\n        return __sort(tree.left)\n    else:\n        __addNode(tree)\n    if tree.right != None:\n        __sort(tree.right)\n    else:\n        __fromStack()\n\n\"\"\"流程2\"\"\"\ndef __fromStack():\n    global stack\n    if stack.isEmpty():\n        return\n    node = stack.pop()\n    __addNode(node)\n    if node.right != None:\n        __sort(node.right)\n    else:\n        __fromStack()\n\ndef __print():\n    global now\n    while now.left != None:\n        print now.value\n        now = now.left\n    print now\n\n\nif __name__ == \"__main__\":\n    tree = __initTree()\n    __sort(tree)\n    __print()\n```\n## 最后再说一些：\n##### 本身题目不是很难，把大学学习的数据结构拿出来看一看就明白了，完成之后我也去网络中找了找这道题，其他人也基本是用中序遍历的方法，大多只有代码，没有解题思路，所以我也没有仔细去看，默认自己是对的。这题目比较麻烦的是代码的编写上面，需要用到递归和一些数据结构的代码实现。加上我之前python用的不多，在调试代码中还是花了一些功夫的（主要在语法的学习上）。所以今后还是要多用python写一写，多熟悉一下。\n","source":"_posts/note/arithmetic/binaryTree.md","raw":"---\nlayout: post\ntitle: 将二元查找树转变成排序的双向链表\ndate: 2017/02/18\ntags: [tech, arithmetic, index]\noriginal: true\ntag: [[算法, arithmetic]]\n---\n\n## 题目要求：\n##### 输入一棵二元查找树，将该二元查找树转换成一个排序的双向链表。\n##### 要求不能创建任何新的结点，只调整指针的指向。\n<!--more-->\n#### 举个例子\n![二元查找树](/img/arithmetic/BinaryTree.png)\n##### 转换成双向链表\n##### 4=6=8=10=12=14=16\n#### 首先我们定义的二元查找树 节点的数据结构如下：\n``\nstruct BSTreeNode\n{\n  int m_nValue; // value of node\n  BSTreeNode *m_pLeft;\n  BSTreeNode *m_pRight; // right child of node\n};*\n``\n\n## 分析过程：\n##### 二元查找树的特征比较明显，每个节点最多有两个子节点，分别为左节点和右节点，左节点的所有值都小于该节点，右节点的值大于该节点。这个题目其实很简单，就是实现二叉树的中序遍历。中序遍历就是左中右遍历。\n\n### 遍历过程，利用数据结构——栈实现，从根节点开始遍历\n1. 判断是否有左节点，\n　　1.1 如果有，则将该节点如栈，然后左节点重复流程1\n　　1.2 如果没有，则将本节点写入链表尾部\n　　1.3 判断是否有右节点\n　　1.4 如果有，将右节点重复流程1\n　　1.5 如果没有，执行流程2\n2. 从栈顶拿出一个节点，如果没有节点，则遍历结束\n　　2.1 将节点插入链表尾部\n　　2.2 判断节点是否有右节点\n　　2.3 有右节点，将右节点重复流程1\n　　2.4 如果没有，执行流程2\n\n#### 实例查找树的遍历过程\n##### 1.根节点10开始遍历，判断有左节点，将10压入栈中\n|&nbsp;&nbsp;|\n| --- |\n|&nbsp;10&nbsp;|\n##### 2. 将左节点6重复流程1\n|&nbsp;&nbsp;|\n| --- |\n|&nbsp;6&nbsp;|\n|&nbsp;10&nbsp;|\n##### 3. 将左节点4重复流程1，因为4没有做子节点，所以将4插入链表\n|&nbsp;&nbsp;|\n| --- |\n|&nbsp;6&nbsp;|\n|&nbsp;10&nbsp;|\n　　　链表：4\n##### 4. 4没有右节点，所以从栈顶中取出节点6进行流程2\n|&nbsp;&nbsp;|\n| --- |\n|&nbsp;10&nbsp;|\n　　　链表：4=6\n##### 5. 6的右节点8执行流程1，8没有左节点，直接加入链表\n|&nbsp;&nbsp;|\n| --- |\n|&nbsp;10&nbsp;|\n　　　链表：4=6=8\n##### 6. 8没有右节点，进入流程2，从栈顶取出\n|&nbsp;&nbsp;|\n| --- |\n|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|\n　　　链表：4=6=8=10\n##### 7. 10有右节点，10的右节点14进入流程1，14有左节点，所以压入栈中\n|&nbsp;&nbsp;|\n| --- |\n|&nbsp;14&nbsp;|\n　　　链表：4=6=8=10\n##### 8. 14的左节点12进入流程1，12没有左节点，直接插入链表\n|&nbsp;&nbsp;|\n| --- |\n|&nbsp;14&nbsp;|\n　　　链表：4=6=8=10=12\n##### 9. 12没有右节点，所以进入流程2，从栈顶中取出14并加入链表，14有右节点16，所以16进入流程1\n|&nbsp;&nbsp;|\n| --- |\n|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|\n　　　链表：4=6=8=10=12=14=16\n##### 10. 16没有右节点，进入流程2，栈中没有元素，流程结束\n　　　最终链表：4=6=8=10=12=14=16\n\n## python实现：\n```python\n#!/usr/bin/env python\n# -*- coding:utf-8 -*-\n\n\"\"\"节点属性\"\"\"\nclass BSTreeNode (object):\n\n    def __init__(self, value, left, right):\n        self.value = value\n        self.left = left\n        self.right = right\n\nclass Stack:\n    \"\"\"模拟栈\"\"\"\n    def __init__(self):\n        self.items = []\n\n    def isEmpty(self):\n        return len(self.items)==0\n\n    def push(self, item):\n        self.items.append(item)\n\n    def pop(self):\n        return self.items.pop()\n\n    def size(self):\n        return len(self.items)\nnow = 0\n\n\"\"\"链表插入节点\"\"\"\ndef __addNode(node):\n    global now\n    if now != 0:\n        now.right = node\n        node.left = now\n    now = node\n\n\"\"\"初始化查找树\"\"\"\ndef __initTree():\n    t4 = BSTreeNode(4, None, None)\n    t8 = BSTreeNode(8, None, None)\n    t6 = BSTreeNode(6, t4, t8)\n    t12 = BSTreeNode(12, None, None)\n    t16 = BSTreeNode(16, None, None)\n    t14 = BSTreeNode(14, t12, t16)\n    t10 = BSTreeNode(10, t6, t14)\n    return t10\n\nstack = Stack()\n\n\"\"\"流程1\"\"\"\ndef __sort(tree):\n    global stack\n    if tree.left != None:\n        stack.push(tree)\n        return __sort(tree.left)\n    else:\n        __addNode(tree)\n    if tree.right != None:\n        __sort(tree.right)\n    else:\n        __fromStack()\n\n\"\"\"流程2\"\"\"\ndef __fromStack():\n    global stack\n    if stack.isEmpty():\n        return\n    node = stack.pop()\n    __addNode(node)\n    if node.right != None:\n        __sort(node.right)\n    else:\n        __fromStack()\n\ndef __print():\n    global now\n    while now.left != None:\n        print now.value\n        now = now.left\n    print now\n\n\nif __name__ == \"__main__\":\n    tree = __initTree()\n    __sort(tree)\n    __print()\n```\n## 最后再说一些：\n##### 本身题目不是很难，把大学学习的数据结构拿出来看一看就明白了，完成之后我也去网络中找了找这道题，其他人也基本是用中序遍历的方法，大多只有代码，没有解题思路，所以我也没有仔细去看，默认自己是对的。这题目比较麻烦的是代码的编写上面，需要用到递归和一些数据结构的代码实现。加上我之前python用的不多，在调试代码中还是花了一些功夫的（主要在语法的学习上）。所以今后还是要多用python写一写，多熟悉一下。\n","slug":"note/arithmetic/binaryTree","published":1,"updated":"2018-05-08T14:24:22.671Z","_id":"cjgxop3mz002ljah1srcjb5ya","comments":1,"photos":[],"link":"","content":"<h2 id=\"题目要求：\"><a href=\"#题目要求：\" class=\"headerlink\" title=\"题目要求：\"></a>题目要求：</h2><h5 id=\"输入一棵二元查找树，将该二元查找树转换成一个排序的双向链表。\"><a href=\"#输入一棵二元查找树，将该二元查找树转换成一个排序的双向链表。\" class=\"headerlink\" title=\"输入一棵二元查找树，将该二元查找树转换成一个排序的双向链表。\"></a>输入一棵二元查找树，将该二元查找树转换成一个排序的双向链表。</h5><h5 id=\"要求不能创建任何新的结点，只调整指针的指向。\"><a href=\"#要求不能创建任何新的结点，只调整指针的指向。\" class=\"headerlink\" title=\"要求不能创建任何新的结点，只调整指针的指向。\"></a>要求不能创建任何新的结点，只调整指针的指向。</h5><a id=\"more\"></a>\n<h4 id=\"举个例子\"><a href=\"#举个例子\" class=\"headerlink\" title=\"举个例子\"></a>举个例子</h4><p><img src=\"/img/arithmetic/BinaryTree.png\" alt=\"二元查找树\"></p>\n<h5 id=\"转换成双向链表\"><a href=\"#转换成双向链表\" class=\"headerlink\" title=\"转换成双向链表\"></a>转换成双向链表</h5><h5 id=\"4-6-8-10-12-14-16\"><a href=\"#4-6-8-10-12-14-16\" class=\"headerlink\" title=\"4=6=8=10=12=14=16\"></a>4=6=8=10=12=14=16</h5><h4 id=\"首先我们定义的二元查找树-节点的数据结构如下：\"><a href=\"#首先我们定义的二元查找树-节点的数据结构如下：\" class=\"headerlink\" title=\"首先我们定义的二元查找树 节点的数据结构如下：\"></a>首先我们定义的二元查找树 节点的数据结构如下：</h4><p><code>struct BSTreeNode\n{\n  int m_nValue; // value of node\n  BSTreeNode *m_pLeft;\n  BSTreeNode *m_pRight; // right child of node\n};*</code></p>\n<h2 id=\"分析过程：\"><a href=\"#分析过程：\" class=\"headerlink\" title=\"分析过程：\"></a>分析过程：</h2><h5 id=\"二元查找树的特征比较明显，每个节点最多有两个子节点，分别为左节点和右节点，左节点的所有值都小于该节点，右节点的值大于该节点。这个题目其实很简单，就是实现二叉树的中序遍历。中序遍历就是左中右遍历。\"><a href=\"#二元查找树的特征比较明显，每个节点最多有两个子节点，分别为左节点和右节点，左节点的所有值都小于该节点，右节点的值大于该节点。这个题目其实很简单，就是实现二叉树的中序遍历。中序遍历就是左中右遍历。\" class=\"headerlink\" title=\"二元查找树的特征比较明显，每个节点最多有两个子节点，分别为左节点和右节点，左节点的所有值都小于该节点，右节点的值大于该节点。这个题目其实很简单，就是实现二叉树的中序遍历。中序遍历就是左中右遍历。\"></a>二元查找树的特征比较明显，每个节点最多有两个子节点，分别为左节点和右节点，左节点的所有值都小于该节点，右节点的值大于该节点。这个题目其实很简单，就是实现二叉树的中序遍历。中序遍历就是左中右遍历。</h5><h3 id=\"遍历过程，利用数据结构——栈实现，从根节点开始遍历\"><a href=\"#遍历过程，利用数据结构——栈实现，从根节点开始遍历\" class=\"headerlink\" title=\"遍历过程，利用数据结构——栈实现，从根节点开始遍历\"></a>遍历过程，利用数据结构——栈实现，从根节点开始遍历</h3><ol>\n<li>判断是否有左节点，<br>　　1.1 如果有，则将该节点如栈，然后左节点重复流程1<br>　　1.2 如果没有，则将本节点写入链表尾部<br>　　1.3 判断是否有右节点<br>　　1.4 如果有，将右节点重复流程1<br>　　1.5 如果没有，执行流程2</li>\n<li>从栈顶拿出一个节点，如果没有节点，则遍历结束<br>　　2.1 将节点插入链表尾部<br>　　2.2 判断节点是否有右节点<br>　　2.3 有右节点，将右节点重复流程1<br>　　2.4 如果没有，执行流程2</li>\n</ol>\n<h4 id=\"实例查找树的遍历过程\"><a href=\"#实例查找树的遍历过程\" class=\"headerlink\" title=\"实例查找树的遍历过程\"></a>实例查找树的遍历过程</h4><h5 id=\"1-根节点10开始遍历，判断有左节点，将10压入栈中\"><a href=\"#1-根节点10开始遍历，判断有左节点，将10压入栈中\" class=\"headerlink\" title=\"1.根节点10开始遍历，判断有左节点，将10压入栈中\"></a>1.根节点10开始遍历，判断有左节点，将10压入栈中</h5><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>&nbsp;&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>&nbsp;10&nbsp;</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h5 id=\"2-将左节点6重复流程1\"><a href=\"#2-将左节点6重复流程1\" class=\"headerlink\" title=\"2. 将左节点6重复流程1\"></a>2. 将左节点6重复流程1</h5><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>&nbsp;&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>&nbsp;6&nbsp;</td>\n</tr>\n<tr>\n<td>&nbsp;10&nbsp;</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h5 id=\"3-将左节点4重复流程1，因为4没有做子节点，所以将4插入链表\"><a href=\"#3-将左节点4重复流程1，因为4没有做子节点，所以将4插入链表\" class=\"headerlink\" title=\"3. 将左节点4重复流程1，因为4没有做子节点，所以将4插入链表\"></a>3. 将左节点4重复流程1，因为4没有做子节点，所以将4插入链表</h5><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>&nbsp;&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>&nbsp;6&nbsp;</td>\n</tr>\n<tr>\n<td>&nbsp;10&nbsp;</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>　　　链表：4</p>\n<h5 id=\"4-4没有右节点，所以从栈顶中取出节点6进行流程2\"><a href=\"#4-4没有右节点，所以从栈顶中取出节点6进行流程2\" class=\"headerlink\" title=\"4. 4没有右节点，所以从栈顶中取出节点6进行流程2\"></a>4. 4没有右节点，所以从栈顶中取出节点6进行流程2</h5><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>&nbsp;&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>&nbsp;10&nbsp;</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>　　　链表：4=6</p>\n<h5 id=\"5-6的右节点8执行流程1，8没有左节点，直接加入链表\"><a href=\"#5-6的右节点8执行流程1，8没有左节点，直接加入链表\" class=\"headerlink\" title=\"5. 6的右节点8执行流程1，8没有左节点，直接加入链表\"></a>5. 6的右节点8执行流程1，8没有左节点，直接加入链表</h5><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>&nbsp;&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>&nbsp;10&nbsp;</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>　　　链表：4=6=8</p>\n<h5 id=\"6-8没有右节点，进入流程2，从栈顶取出\"><a href=\"#6-8没有右节点，进入流程2，从栈顶取出\" class=\"headerlink\" title=\"6. 8没有右节点，进入流程2，从栈顶取出\"></a>6. 8没有右节点，进入流程2，从栈顶取出</h5><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>&nbsp;&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>　　　链表：4=6=8=10</p>\n<h5 id=\"7-10有右节点，10的右节点14进入流程1，14有左节点，所以压入栈中\"><a href=\"#7-10有右节点，10的右节点14进入流程1，14有左节点，所以压入栈中\" class=\"headerlink\" title=\"7. 10有右节点，10的右节点14进入流程1，14有左节点，所以压入栈中\"></a>7. 10有右节点，10的右节点14进入流程1，14有左节点，所以压入栈中</h5><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>&nbsp;&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>&nbsp;14&nbsp;</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>　　　链表：4=6=8=10</p>\n<h5 id=\"8-14的左节点12进入流程1，12没有左节点，直接插入链表\"><a href=\"#8-14的左节点12进入流程1，12没有左节点，直接插入链表\" class=\"headerlink\" title=\"8. 14的左节点12进入流程1，12没有左节点，直接插入链表\"></a>8. 14的左节点12进入流程1，12没有左节点，直接插入链表</h5><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>&nbsp;&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>&nbsp;14&nbsp;</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>　　　链表：4=6=8=10=12</p>\n<h5 id=\"9-12没有右节点，所以进入流程2，从栈顶中取出14并加入链表，14有右节点16，所以16进入流程1\"><a href=\"#9-12没有右节点，所以进入流程2，从栈顶中取出14并加入链表，14有右节点16，所以16进入流程1\" class=\"headerlink\" title=\"9. 12没有右节点，所以进入流程2，从栈顶中取出14并加入链表，14有右节点16，所以16进入流程1\"></a>9. 12没有右节点，所以进入流程2，从栈顶中取出14并加入链表，14有右节点16，所以16进入流程1</h5><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>&nbsp;&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>　　　链表：4=6=8=10=12=14=16</p>\n<h5 id=\"10-16没有右节点，进入流程2，栈中没有元素，流程结束\"><a href=\"#10-16没有右节点，进入流程2，栈中没有元素，流程结束\" class=\"headerlink\" title=\"10. 16没有右节点，进入流程2，栈中没有元素，流程结束\"></a>10. 16没有右节点，进入流程2，栈中没有元素，流程结束</h5><p>　　　最终链表：4=6=8=10=12=14=16</p>\n<h2 id=\"python实现：\"><a href=\"#python实现：\" class=\"headerlink\" title=\"python实现：\"></a>python实现：</h2><pre><code class=\"lang-python\">#!/usr/bin/env python\n# -*- coding:utf-8 -*-\n\n&quot;&quot;&quot;节点属性&quot;&quot;&quot;\nclass BSTreeNode (object):\n\n    def __init__(self, value, left, right):\n        self.value = value\n        self.left = left\n        self.right = right\n\nclass Stack:\n    &quot;&quot;&quot;模拟栈&quot;&quot;&quot;\n    def __init__(self):\n        self.items = []\n\n    def isEmpty(self):\n        return len(self.items)==0\n\n    def push(self, item):\n        self.items.append(item)\n\n    def pop(self):\n        return self.items.pop()\n\n    def size(self):\n        return len(self.items)\nnow = 0\n\n&quot;&quot;&quot;链表插入节点&quot;&quot;&quot;\ndef __addNode(node):\n    global now\n    if now != 0:\n        now.right = node\n        node.left = now\n    now = node\n\n&quot;&quot;&quot;初始化查找树&quot;&quot;&quot;\ndef __initTree():\n    t4 = BSTreeNode(4, None, None)\n    t8 = BSTreeNode(8, None, None)\n    t6 = BSTreeNode(6, t4, t8)\n    t12 = BSTreeNode(12, None, None)\n    t16 = BSTreeNode(16, None, None)\n    t14 = BSTreeNode(14, t12, t16)\n    t10 = BSTreeNode(10, t6, t14)\n    return t10\n\nstack = Stack()\n\n&quot;&quot;&quot;流程1&quot;&quot;&quot;\ndef __sort(tree):\n    global stack\n    if tree.left != None:\n        stack.push(tree)\n        return __sort(tree.left)\n    else:\n        __addNode(tree)\n    if tree.right != None:\n        __sort(tree.right)\n    else:\n        __fromStack()\n\n&quot;&quot;&quot;流程2&quot;&quot;&quot;\ndef __fromStack():\n    global stack\n    if stack.isEmpty():\n        return\n    node = stack.pop()\n    __addNode(node)\n    if node.right != None:\n        __sort(node.right)\n    else:\n        __fromStack()\n\ndef __print():\n    global now\n    while now.left != None:\n        print now.value\n        now = now.left\n    print now\n\n\nif __name__ == &quot;__main__&quot;:\n    tree = __initTree()\n    __sort(tree)\n    __print()\n</code></pre>\n<h2 id=\"最后再说一些：\"><a href=\"#最后再说一些：\" class=\"headerlink\" title=\"最后再说一些：\"></a>最后再说一些：</h2><h5 id=\"本身题目不是很难，把大学学习的数据结构拿出来看一看就明白了，完成之后我也去网络中找了找这道题，其他人也基本是用中序遍历的方法，大多只有代码，没有解题思路，所以我也没有仔细去看，默认自己是对的。这题目比较麻烦的是代码的编写上面，需要用到递归和一些数据结构的代码实现。加上我之前python用的不多，在调试代码中还是花了一些功夫的（主要在语法的学习上）。所以今后还是要多用python写一写，多熟悉一下。\"><a href=\"#本身题目不是很难，把大学学习的数据结构拿出来看一看就明白了，完成之后我也去网络中找了找这道题，其他人也基本是用中序遍历的方法，大多只有代码，没有解题思路，所以我也没有仔细去看，默认自己是对的。这题目比较麻烦的是代码的编写上面，需要用到递归和一些数据结构的代码实现。加上我之前python用的不多，在调试代码中还是花了一些功夫的（主要在语法的学习上）。所以今后还是要多用python写一写，多熟悉一下。\" class=\"headerlink\" title=\"本身题目不是很难，把大学学习的数据结构拿出来看一看就明白了，完成之后我也去网络中找了找这道题，其他人也基本是用中序遍历的方法，大多只有代码，没有解题思路，所以我也没有仔细去看，默认自己是对的。这题目比较麻烦的是代码的编写上面，需要用到递归和一些数据结构的代码实现。加上我之前python用的不多，在调试代码中还是花了一些功夫的（主要在语法的学习上）。所以今后还是要多用python写一写，多熟悉一下。\"></a>本身题目不是很难，把大学学习的数据结构拿出来看一看就明白了，完成之后我也去网络中找了找这道题，其他人也基本是用中序遍历的方法，大多只有代码，没有解题思路，所以我也没有仔细去看，默认自己是对的。这题目比较麻烦的是代码的编写上面，需要用到递归和一些数据结构的代码实现。加上我之前python用的不多，在调试代码中还是花了一些功夫的（主要在语法的学习上）。所以今后还是要多用python写一写，多熟悉一下。</h5>","site":{"data":{}},"excerpt":"<h2 id=\"题目要求：\"><a href=\"#题目要求：\" class=\"headerlink\" title=\"题目要求：\"></a>题目要求：</h2><h5 id=\"输入一棵二元查找树，将该二元查找树转换成一个排序的双向链表。\"><a href=\"#输入一棵二元查找树，将该二元查找树转换成一个排序的双向链表。\" class=\"headerlink\" title=\"输入一棵二元查找树，将该二元查找树转换成一个排序的双向链表。\"></a>输入一棵二元查找树，将该二元查找树转换成一个排序的双向链表。</h5><h5 id=\"要求不能创建任何新的结点，只调整指针的指向。\"><a href=\"#要求不能创建任何新的结点，只调整指针的指向。\" class=\"headerlink\" title=\"要求不能创建任何新的结点，只调整指针的指向。\"></a>要求不能创建任何新的结点，只调整指针的指向。</h5>","more":"<h4 id=\"举个例子\"><a href=\"#举个例子\" class=\"headerlink\" title=\"举个例子\"></a>举个例子</h4><p><img src=\"/img/arithmetic/BinaryTree.png\" alt=\"二元查找树\"></p>\n<h5 id=\"转换成双向链表\"><a href=\"#转换成双向链表\" class=\"headerlink\" title=\"转换成双向链表\"></a>转换成双向链表</h5><h5 id=\"4-6-8-10-12-14-16\"><a href=\"#4-6-8-10-12-14-16\" class=\"headerlink\" title=\"4=6=8=10=12=14=16\"></a>4=6=8=10=12=14=16</h5><h4 id=\"首先我们定义的二元查找树-节点的数据结构如下：\"><a href=\"#首先我们定义的二元查找树-节点的数据结构如下：\" class=\"headerlink\" title=\"首先我们定义的二元查找树 节点的数据结构如下：\"></a>首先我们定义的二元查找树 节点的数据结构如下：</h4><p><code>struct BSTreeNode\n{\n  int m_nValue; // value of node\n  BSTreeNode *m_pLeft;\n  BSTreeNode *m_pRight; // right child of node\n};*</code></p>\n<h2 id=\"分析过程：\"><a href=\"#分析过程：\" class=\"headerlink\" title=\"分析过程：\"></a>分析过程：</h2><h5 id=\"二元查找树的特征比较明显，每个节点最多有两个子节点，分别为左节点和右节点，左节点的所有值都小于该节点，右节点的值大于该节点。这个题目其实很简单，就是实现二叉树的中序遍历。中序遍历就是左中右遍历。\"><a href=\"#二元查找树的特征比较明显，每个节点最多有两个子节点，分别为左节点和右节点，左节点的所有值都小于该节点，右节点的值大于该节点。这个题目其实很简单，就是实现二叉树的中序遍历。中序遍历就是左中右遍历。\" class=\"headerlink\" title=\"二元查找树的特征比较明显，每个节点最多有两个子节点，分别为左节点和右节点，左节点的所有值都小于该节点，右节点的值大于该节点。这个题目其实很简单，就是实现二叉树的中序遍历。中序遍历就是左中右遍历。\"></a>二元查找树的特征比较明显，每个节点最多有两个子节点，分别为左节点和右节点，左节点的所有值都小于该节点，右节点的值大于该节点。这个题目其实很简单，就是实现二叉树的中序遍历。中序遍历就是左中右遍历。</h5><h3 id=\"遍历过程，利用数据结构——栈实现，从根节点开始遍历\"><a href=\"#遍历过程，利用数据结构——栈实现，从根节点开始遍历\" class=\"headerlink\" title=\"遍历过程，利用数据结构——栈实现，从根节点开始遍历\"></a>遍历过程，利用数据结构——栈实现，从根节点开始遍历</h3><ol>\n<li>判断是否有左节点，<br>　　1.1 如果有，则将该节点如栈，然后左节点重复流程1<br>　　1.2 如果没有，则将本节点写入链表尾部<br>　　1.3 判断是否有右节点<br>　　1.4 如果有，将右节点重复流程1<br>　　1.5 如果没有，执行流程2</li>\n<li>从栈顶拿出一个节点，如果没有节点，则遍历结束<br>　　2.1 将节点插入链表尾部<br>　　2.2 判断节点是否有右节点<br>　　2.3 有右节点，将右节点重复流程1<br>　　2.4 如果没有，执行流程2</li>\n</ol>\n<h4 id=\"实例查找树的遍历过程\"><a href=\"#实例查找树的遍历过程\" class=\"headerlink\" title=\"实例查找树的遍历过程\"></a>实例查找树的遍历过程</h4><h5 id=\"1-根节点10开始遍历，判断有左节点，将10压入栈中\"><a href=\"#1-根节点10开始遍历，判断有左节点，将10压入栈中\" class=\"headerlink\" title=\"1.根节点10开始遍历，判断有左节点，将10压入栈中\"></a>1.根节点10开始遍历，判断有左节点，将10压入栈中</h5><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>&nbsp;&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>&nbsp;10&nbsp;</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h5 id=\"2-将左节点6重复流程1\"><a href=\"#2-将左节点6重复流程1\" class=\"headerlink\" title=\"2. 将左节点6重复流程1\"></a>2. 将左节点6重复流程1</h5><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>&nbsp;&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>&nbsp;6&nbsp;</td>\n</tr>\n<tr>\n<td>&nbsp;10&nbsp;</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h5 id=\"3-将左节点4重复流程1，因为4没有做子节点，所以将4插入链表\"><a href=\"#3-将左节点4重复流程1，因为4没有做子节点，所以将4插入链表\" class=\"headerlink\" title=\"3. 将左节点4重复流程1，因为4没有做子节点，所以将4插入链表\"></a>3. 将左节点4重复流程1，因为4没有做子节点，所以将4插入链表</h5><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>&nbsp;&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>&nbsp;6&nbsp;</td>\n</tr>\n<tr>\n<td>&nbsp;10&nbsp;</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>　　　链表：4</p>\n<h5 id=\"4-4没有右节点，所以从栈顶中取出节点6进行流程2\"><a href=\"#4-4没有右节点，所以从栈顶中取出节点6进行流程2\" class=\"headerlink\" title=\"4. 4没有右节点，所以从栈顶中取出节点6进行流程2\"></a>4. 4没有右节点，所以从栈顶中取出节点6进行流程2</h5><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>&nbsp;&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>&nbsp;10&nbsp;</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>　　　链表：4=6</p>\n<h5 id=\"5-6的右节点8执行流程1，8没有左节点，直接加入链表\"><a href=\"#5-6的右节点8执行流程1，8没有左节点，直接加入链表\" class=\"headerlink\" title=\"5. 6的右节点8执行流程1，8没有左节点，直接加入链表\"></a>5. 6的右节点8执行流程1，8没有左节点，直接加入链表</h5><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>&nbsp;&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>&nbsp;10&nbsp;</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>　　　链表：4=6=8</p>\n<h5 id=\"6-8没有右节点，进入流程2，从栈顶取出\"><a href=\"#6-8没有右节点，进入流程2，从栈顶取出\" class=\"headerlink\" title=\"6. 8没有右节点，进入流程2，从栈顶取出\"></a>6. 8没有右节点，进入流程2，从栈顶取出</h5><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>&nbsp;&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>　　　链表：4=6=8=10</p>\n<h5 id=\"7-10有右节点，10的右节点14进入流程1，14有左节点，所以压入栈中\"><a href=\"#7-10有右节点，10的右节点14进入流程1，14有左节点，所以压入栈中\" class=\"headerlink\" title=\"7. 10有右节点，10的右节点14进入流程1，14有左节点，所以压入栈中\"></a>7. 10有右节点，10的右节点14进入流程1，14有左节点，所以压入栈中</h5><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>&nbsp;&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>&nbsp;14&nbsp;</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>　　　链表：4=6=8=10</p>\n<h5 id=\"8-14的左节点12进入流程1，12没有左节点，直接插入链表\"><a href=\"#8-14的左节点12进入流程1，12没有左节点，直接插入链表\" class=\"headerlink\" title=\"8. 14的左节点12进入流程1，12没有左节点，直接插入链表\"></a>8. 14的左节点12进入流程1，12没有左节点，直接插入链表</h5><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>&nbsp;&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>&nbsp;14&nbsp;</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>　　　链表：4=6=8=10=12</p>\n<h5 id=\"9-12没有右节点，所以进入流程2，从栈顶中取出14并加入链表，14有右节点16，所以16进入流程1\"><a href=\"#9-12没有右节点，所以进入流程2，从栈顶中取出14并加入链表，14有右节点16，所以16进入流程1\" class=\"headerlink\" title=\"9. 12没有右节点，所以进入流程2，从栈顶中取出14并加入链表，14有右节点16，所以16进入流程1\"></a>9. 12没有右节点，所以进入流程2，从栈顶中取出14并加入链表，14有右节点16，所以16进入流程1</h5><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>&nbsp;&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>　　　链表：4=6=8=10=12=14=16</p>\n<h5 id=\"10-16没有右节点，进入流程2，栈中没有元素，流程结束\"><a href=\"#10-16没有右节点，进入流程2，栈中没有元素，流程结束\" class=\"headerlink\" title=\"10. 16没有右节点，进入流程2，栈中没有元素，流程结束\"></a>10. 16没有右节点，进入流程2，栈中没有元素，流程结束</h5><p>　　　最终链表：4=6=8=10=12=14=16</p>\n<h2 id=\"python实现：\"><a href=\"#python实现：\" class=\"headerlink\" title=\"python实现：\"></a>python实现：</h2><pre><code class=\"lang-python\">#!/usr/bin/env python\n# -*- coding:utf-8 -*-\n\n&quot;&quot;&quot;节点属性&quot;&quot;&quot;\nclass BSTreeNode (object):\n\n    def __init__(self, value, left, right):\n        self.value = value\n        self.left = left\n        self.right = right\n\nclass Stack:\n    &quot;&quot;&quot;模拟栈&quot;&quot;&quot;\n    def __init__(self):\n        self.items = []\n\n    def isEmpty(self):\n        return len(self.items)==0\n\n    def push(self, item):\n        self.items.append(item)\n\n    def pop(self):\n        return self.items.pop()\n\n    def size(self):\n        return len(self.items)\nnow = 0\n\n&quot;&quot;&quot;链表插入节点&quot;&quot;&quot;\ndef __addNode(node):\n    global now\n    if now != 0:\n        now.right = node\n        node.left = now\n    now = node\n\n&quot;&quot;&quot;初始化查找树&quot;&quot;&quot;\ndef __initTree():\n    t4 = BSTreeNode(4, None, None)\n    t8 = BSTreeNode(8, None, None)\n    t6 = BSTreeNode(6, t4, t8)\n    t12 = BSTreeNode(12, None, None)\n    t16 = BSTreeNode(16, None, None)\n    t14 = BSTreeNode(14, t12, t16)\n    t10 = BSTreeNode(10, t6, t14)\n    return t10\n\nstack = Stack()\n\n&quot;&quot;&quot;流程1&quot;&quot;&quot;\ndef __sort(tree):\n    global stack\n    if tree.left != None:\n        stack.push(tree)\n        return __sort(tree.left)\n    else:\n        __addNode(tree)\n    if tree.right != None:\n        __sort(tree.right)\n    else:\n        __fromStack()\n\n&quot;&quot;&quot;流程2&quot;&quot;&quot;\ndef __fromStack():\n    global stack\n    if stack.isEmpty():\n        return\n    node = stack.pop()\n    __addNode(node)\n    if node.right != None:\n        __sort(node.right)\n    else:\n        __fromStack()\n\ndef __print():\n    global now\n    while now.left != None:\n        print now.value\n        now = now.left\n    print now\n\n\nif __name__ == &quot;__main__&quot;:\n    tree = __initTree()\n    __sort(tree)\n    __print()\n</code></pre>\n<h2 id=\"最后再说一些：\"><a href=\"#最后再说一些：\" class=\"headerlink\" title=\"最后再说一些：\"></a>最后再说一些：</h2><h5 id=\"本身题目不是很难，把大学学习的数据结构拿出来看一看就明白了，完成之后我也去网络中找了找这道题，其他人也基本是用中序遍历的方法，大多只有代码，没有解题思路，所以我也没有仔细去看，默认自己是对的。这题目比较麻烦的是代码的编写上面，需要用到递归和一些数据结构的代码实现。加上我之前python用的不多，在调试代码中还是花了一些功夫的（主要在语法的学习上）。所以今后还是要多用python写一写，多熟悉一下。\"><a href=\"#本身题目不是很难，把大学学习的数据结构拿出来看一看就明白了，完成之后我也去网络中找了找这道题，其他人也基本是用中序遍历的方法，大多只有代码，没有解题思路，所以我也没有仔细去看，默认自己是对的。这题目比较麻烦的是代码的编写上面，需要用到递归和一些数据结构的代码实现。加上我之前python用的不多，在调试代码中还是花了一些功夫的（主要在语法的学习上）。所以今后还是要多用python写一写，多熟悉一下。\" class=\"headerlink\" title=\"本身题目不是很难，把大学学习的数据结构拿出来看一看就明白了，完成之后我也去网络中找了找这道题，其他人也基本是用中序遍历的方法，大多只有代码，没有解题思路，所以我也没有仔细去看，默认自己是对的。这题目比较麻烦的是代码的编写上面，需要用到递归和一些数据结构的代码实现。加上我之前python用的不多，在调试代码中还是花了一些功夫的（主要在语法的学习上）。所以今后还是要多用python写一写，多熟悉一下。\"></a>本身题目不是很难，把大学学习的数据结构拿出来看一看就明白了，完成之后我也去网络中找了找这道题，其他人也基本是用中序遍历的方法，大多只有代码，没有解题思路，所以我也没有仔细去看，默认自己是对的。这题目比较麻烦的是代码的编写上面，需要用到递归和一些数据结构的代码实现。加上我之前python用的不多，在调试代码中还是花了一些功夫的（主要在语法的学习上）。所以今后还是要多用python写一写，多熟悉一下。</h5>"},{"layout":"post","title":"Canopy聚类算法","date":"2018-04-12T16:00:00.000Z","original":true,"tag":[["算法","arithmetic"]],"_content":"\ntodo","source":"_posts/note/arithmetic/canopy.md","raw":"---\nlayout: post\ntitle: Canopy聚类算法\ndate: 2018/04/13\noriginal: true\ntags: [tech, arithmetic, index]\ntag: [[算法, arithmetic]]\n---\n\ntodo","slug":"note/arithmetic/canopy","published":1,"updated":"2018-05-08T13:00:14.273Z","comments":1,"photos":[],"link":"","_id":"cjgxop3n0002mjah1gl17offp","content":"<p>todo</p>\n","site":{"data":{}},"excerpt":"","more":"<p>todo</p>\n"},{"layout":"post","title":"DBSCAN聚类算法","date":"2018-04-12T16:00:00.000Z","original":true,"tag":[["算法","arithmetic"]],"_content":"\n##### DBSCAN(Density-Based Spatial Clustering of Applications with Noise，具有噪声的基于密度的聚类方法)是一种很典型的密度聚类算法，和K-Means，BIRCH这些一般只适用于凸样本集的聚类相比，DBSCAN既可以适用于凸样本集，也可以适用于非凸样本集。下面我们就对DBSCAN算法的原理做一个总结。\n<!-- more -->\n\n## 密度聚类原理\n##### DBSCAN是一种基于密度的聚类算法，这类密度聚类算法一般假定类别可以通过样本分布的紧密程度决定。同一类别的样本，他们之间的紧密相连的，也就是说，在该类别任意样本周围不远处一定有同类别的样本存在。\n\n##### 通过将紧密相连的样本划为一类，这样就得到了一个聚类类别。通过将所有各组紧密相连的样本划为各个不同的类别，则我们就得到了最终的所有聚类类别结果。\n\n## DBSCAN密度定义\n##### 假设我的样本集是D=(x<sub>1</sub>,x<sub>2</sub>,...,x<sub>m</sub>),则DBSCAN具体的密度描述定义如下：\n1. **Eps邻域：** 对于x<sub>j</sub> ∈ D，其Eps邻域包含样本集D中与x<sub>j</sub>的距离不大于Eps的子样本集，可以简单理解成半径为Eps内的所有点的集合\n2. **核心对象：** 如果对象的Eps邻域至少包含最小数目MinPts的对象，则称该对象为核心对象;\n3. **边界点（edge point）：** 边界点不是核心点，但落在某个核心点的邻域内;\n4. **噪音点（outlier point）：** 既不是核心点，也不是边界点的任何点;\n5. **直接密度可达(directly density-reachable)：** 给定一个对象集合D，如果p在q的Eps邻域内，而q是一个核心对象，则称对象p从对象q出发时是直接密度可达的;\n6. **密度可达(density-reachable)：** 如果存在一个对象链  p1, …,pi,.., pn，满足p1 = p 和pn = q，pi是从pi+1关于Eps和MinPts直接密度可达的，则对象p是从对象q关于Eps和MinPts密度可达的;\n\n7. **密度相连(density-connected)：** 如果存在对象O∈D，使对象p和q都是从O关于Eps和MinPts密度可达的，那么对象p到q是关于Eps和MinPts密度相连的\n\n##### 从下图可以很容易看出理解上述定义，图中MinPts=5，红色的点都是核心对象，因为其Eps邻域至少有5个样本。黑色的样本是非核心对象。所有核心对象密度直达的样本在以红色核心对象为中心的超球体内，如果不在超球体内，则不能密度直达。图中用绿色箭头连起来的核心对象组成了密度可达的样本序列。在这些密度可达的样本序列的Eps邻域内所有的样本相互都是密度相连的。\n\n![dbscan](/img/arithmetic/dbscan.png)\n\n## DBSCAN密度聚类思想\n##### DBSCAN的聚类定义很简单：由密度可达关系导出的最大密度相连的样本集合，即为我们最终聚类的一个类别，或者说一个簇。\n\n##### 这个DBSCAN的簇里面可以有一个或者多个核心对象。如果只有一个核心对象，则簇里其他的非核心对象样本都在这个核心对象的Eps邻域里；如果有多个核心对象，则簇里的任意一个核心对象的Eps邻域中一定有一个其他的核心对象，否则这两个核心对象无法密度可达。这些核心对象的Eps邻域里所有的样本的集合组成的一个DBSCAN聚类簇。\n\n##### 那么怎么才能找到这样的簇样本集合呢？DBSCAN使用的方法很简单，它任意选择一个没有类别的核心对象作为种子，然后找到所有这个核心对象能够密度可达的样本集合，即为一个聚类簇。接着继续选择另一个没有类别的核心对象去寻找密度可达的样本集合，这样就得到另一个聚类簇。一直运行到所有核心对象都有类别为止。\n\n##### 基本上这就是DBSCAN算法的主要内容了，是不是很简单？但是我们还是有三个问题没有考虑。\n\n1. 第一个是一些异常样本点或者说少量游离于簇外的样本点，这些点不在任何一个核心对象在周围，在DBSCAN中，我们一般将这些样本点标记为噪音点。\n2. 第二个是距离的度量问题，即如何计算某样本和核心对象样本的距离。在DBSCAN中，一般采用最近邻思想，采用某一种距离度量来衡量样本距离，比如欧式距离。这和KNN分类算法的最近邻思想完全相同。对应少量的样本，寻找最近邻可以直接去计算所有样本的距离，如果样本量较大，则一般采用KD树或者球树来快速的搜索最近邻。如果大家对于最近邻的思想，距离度量，KD树和球树不熟悉，可以自行百度学习。\n3. 第三种问题比较特殊，某些样本可能到两个核心对象的距离都小于Eps，但是这两个核心对象由于不是密度直达，又不属于同一个聚类簇，那么如果界定这个样本的类别呢？一般来说，此时DBSCAN采用先来后到，先进行聚类的类别簇会标记这个样本为它的类别。也就是说BDSCAN的算法不是完全稳定的算法。\n\n## python中的DBSCAN\n##### 我们以sklearn.cluster.DBSCAN作为例子，做一些简单的demo：\n```python\nimport matplotlib.pyplot as plt\nfrom  sklearn.cluster import DBSCAN\n\ndef dbscan(data):\n    result = DBSCAN(eps=2, min_samples=2).fit(data)\n    components_ = result.components_\n    plt.subplot(2, 1, 1)\n    plt.scatter([x[0] for x in components_], [x[1] for x in components_], c=result.labels_)\n    plt.subplot(2, 1, 2)\n    plt.scatter([x[0] for x in data], [x[1] for x in data], c=result.labels_)\n    plt.show()\n\nif __name__ == '__main__':\n    l = [\n        [1,1],\n        [1,2],\n        [2,1],\n        [2,2],\n        [4,10],\n        [8,2],\n        [10,10],\n        [10,11],\n        [11,10],\n        [11,11],\n    ]\n    dbscan(l)\n```\n\n##### 上面代码很简单，构造了一些简单的点，按照参数Eps=2和最小数目MinPts=2将点进行聚类计算。\n\n![dbscan](/img/arithmetic/dbscanR.png)\n\n## DBSCAN小结\n\n##### 和传统的K-Means算法相比，DBSCAN最大的不同就是不需要输入类别数k，当然它最大的优势是可以发现任意形状的聚类簇，而不是像K-Means，一般仅仅使用于凸的样本集聚类。同时它在聚类的同时还可以找出异常点，这点和BIRCH算法类似。\n\n##### 那么我们什么时候需要用DBSCAN来聚类呢？一般来说，如果数据集是稠密的，并且数据集不是凸的，那么用DBSCAN会比K-Means聚类效果好很多。如果数据集不是稠密的，则不推荐用DBSCAN来聚类。\n\n#### DBSCAN的主要优点有：\n\n1. 可以对任意形状的稠密数据集进行聚类，相对的，K-Means之类的聚类算法一般只适用于凸数据集。\n2. 可以在聚类的同时发现异常点，对数据集中的异常点不敏感。\n3. 聚类结果没有偏倚，相对的，K-Means之类的聚类算法初始值对聚类结果有很大影响。\n\n#### DBSCAN的主要缺点有：\n1. 如果样本集的密度不均匀、聚类间距差相差很大时，聚类质量较差，这时用DBSCAN聚类一般不适合。\n2. 如果样本集较大时，聚类收敛时间较长，此时可以对搜索最近邻时建立的KD树或者球树进行规模限制来改进。\n3. 调参相对于传统的K-Means之类的聚类算法稍复杂，主要需要对距离阈值Eps，邻域样本数阈值MinPts联合调参，不同的参数组合对最后的聚类效果有较大影响。\n\n### 参考文章：\n[https://www.cnblogs.com/pinard/p/6208966.html](https://www.cnblogs.com/pinard/p/6208966.html)\n[https://blog.csdn.net/u013611461/article/details/53639835](https://blog.csdn.net/u013611461/article/details/53639835)","source":"_posts/note/arithmetic/dbscan.md","raw":"---\nlayout: post\ntitle: DBSCAN聚类算法\ndate: 2018/04/13\noriginal: true\ntags: [tech, arithmetic, index]\ntag: [[算法, arithmetic]]\n---\n\n##### DBSCAN(Density-Based Spatial Clustering of Applications with Noise，具有噪声的基于密度的聚类方法)是一种很典型的密度聚类算法，和K-Means，BIRCH这些一般只适用于凸样本集的聚类相比，DBSCAN既可以适用于凸样本集，也可以适用于非凸样本集。下面我们就对DBSCAN算法的原理做一个总结。\n<!-- more -->\n\n## 密度聚类原理\n##### DBSCAN是一种基于密度的聚类算法，这类密度聚类算法一般假定类别可以通过样本分布的紧密程度决定。同一类别的样本，他们之间的紧密相连的，也就是说，在该类别任意样本周围不远处一定有同类别的样本存在。\n\n##### 通过将紧密相连的样本划为一类，这样就得到了一个聚类类别。通过将所有各组紧密相连的样本划为各个不同的类别，则我们就得到了最终的所有聚类类别结果。\n\n## DBSCAN密度定义\n##### 假设我的样本集是D=(x<sub>1</sub>,x<sub>2</sub>,...,x<sub>m</sub>),则DBSCAN具体的密度描述定义如下：\n1. **Eps邻域：** 对于x<sub>j</sub> ∈ D，其Eps邻域包含样本集D中与x<sub>j</sub>的距离不大于Eps的子样本集，可以简单理解成半径为Eps内的所有点的集合\n2. **核心对象：** 如果对象的Eps邻域至少包含最小数目MinPts的对象，则称该对象为核心对象;\n3. **边界点（edge point）：** 边界点不是核心点，但落在某个核心点的邻域内;\n4. **噪音点（outlier point）：** 既不是核心点，也不是边界点的任何点;\n5. **直接密度可达(directly density-reachable)：** 给定一个对象集合D，如果p在q的Eps邻域内，而q是一个核心对象，则称对象p从对象q出发时是直接密度可达的;\n6. **密度可达(density-reachable)：** 如果存在一个对象链  p1, …,pi,.., pn，满足p1 = p 和pn = q，pi是从pi+1关于Eps和MinPts直接密度可达的，则对象p是从对象q关于Eps和MinPts密度可达的;\n\n7. **密度相连(density-connected)：** 如果存在对象O∈D，使对象p和q都是从O关于Eps和MinPts密度可达的，那么对象p到q是关于Eps和MinPts密度相连的\n\n##### 从下图可以很容易看出理解上述定义，图中MinPts=5，红色的点都是核心对象，因为其Eps邻域至少有5个样本。黑色的样本是非核心对象。所有核心对象密度直达的样本在以红色核心对象为中心的超球体内，如果不在超球体内，则不能密度直达。图中用绿色箭头连起来的核心对象组成了密度可达的样本序列。在这些密度可达的样本序列的Eps邻域内所有的样本相互都是密度相连的。\n\n![dbscan](/img/arithmetic/dbscan.png)\n\n## DBSCAN密度聚类思想\n##### DBSCAN的聚类定义很简单：由密度可达关系导出的最大密度相连的样本集合，即为我们最终聚类的一个类别，或者说一个簇。\n\n##### 这个DBSCAN的簇里面可以有一个或者多个核心对象。如果只有一个核心对象，则簇里其他的非核心对象样本都在这个核心对象的Eps邻域里；如果有多个核心对象，则簇里的任意一个核心对象的Eps邻域中一定有一个其他的核心对象，否则这两个核心对象无法密度可达。这些核心对象的Eps邻域里所有的样本的集合组成的一个DBSCAN聚类簇。\n\n##### 那么怎么才能找到这样的簇样本集合呢？DBSCAN使用的方法很简单，它任意选择一个没有类别的核心对象作为种子，然后找到所有这个核心对象能够密度可达的样本集合，即为一个聚类簇。接着继续选择另一个没有类别的核心对象去寻找密度可达的样本集合，这样就得到另一个聚类簇。一直运行到所有核心对象都有类别为止。\n\n##### 基本上这就是DBSCAN算法的主要内容了，是不是很简单？但是我们还是有三个问题没有考虑。\n\n1. 第一个是一些异常样本点或者说少量游离于簇外的样本点，这些点不在任何一个核心对象在周围，在DBSCAN中，我们一般将这些样本点标记为噪音点。\n2. 第二个是距离的度量问题，即如何计算某样本和核心对象样本的距离。在DBSCAN中，一般采用最近邻思想，采用某一种距离度量来衡量样本距离，比如欧式距离。这和KNN分类算法的最近邻思想完全相同。对应少量的样本，寻找最近邻可以直接去计算所有样本的距离，如果样本量较大，则一般采用KD树或者球树来快速的搜索最近邻。如果大家对于最近邻的思想，距离度量，KD树和球树不熟悉，可以自行百度学习。\n3. 第三种问题比较特殊，某些样本可能到两个核心对象的距离都小于Eps，但是这两个核心对象由于不是密度直达，又不属于同一个聚类簇，那么如果界定这个样本的类别呢？一般来说，此时DBSCAN采用先来后到，先进行聚类的类别簇会标记这个样本为它的类别。也就是说BDSCAN的算法不是完全稳定的算法。\n\n## python中的DBSCAN\n##### 我们以sklearn.cluster.DBSCAN作为例子，做一些简单的demo：\n```python\nimport matplotlib.pyplot as plt\nfrom  sklearn.cluster import DBSCAN\n\ndef dbscan(data):\n    result = DBSCAN(eps=2, min_samples=2).fit(data)\n    components_ = result.components_\n    plt.subplot(2, 1, 1)\n    plt.scatter([x[0] for x in components_], [x[1] for x in components_], c=result.labels_)\n    plt.subplot(2, 1, 2)\n    plt.scatter([x[0] for x in data], [x[1] for x in data], c=result.labels_)\n    plt.show()\n\nif __name__ == '__main__':\n    l = [\n        [1,1],\n        [1,2],\n        [2,1],\n        [2,2],\n        [4,10],\n        [8,2],\n        [10,10],\n        [10,11],\n        [11,10],\n        [11,11],\n    ]\n    dbscan(l)\n```\n\n##### 上面代码很简单，构造了一些简单的点，按照参数Eps=2和最小数目MinPts=2将点进行聚类计算。\n\n![dbscan](/img/arithmetic/dbscanR.png)\n\n## DBSCAN小结\n\n##### 和传统的K-Means算法相比，DBSCAN最大的不同就是不需要输入类别数k，当然它最大的优势是可以发现任意形状的聚类簇，而不是像K-Means，一般仅仅使用于凸的样本集聚类。同时它在聚类的同时还可以找出异常点，这点和BIRCH算法类似。\n\n##### 那么我们什么时候需要用DBSCAN来聚类呢？一般来说，如果数据集是稠密的，并且数据集不是凸的，那么用DBSCAN会比K-Means聚类效果好很多。如果数据集不是稠密的，则不推荐用DBSCAN来聚类。\n\n#### DBSCAN的主要优点有：\n\n1. 可以对任意形状的稠密数据集进行聚类，相对的，K-Means之类的聚类算法一般只适用于凸数据集。\n2. 可以在聚类的同时发现异常点，对数据集中的异常点不敏感。\n3. 聚类结果没有偏倚，相对的，K-Means之类的聚类算法初始值对聚类结果有很大影响。\n\n#### DBSCAN的主要缺点有：\n1. 如果样本集的密度不均匀、聚类间距差相差很大时，聚类质量较差，这时用DBSCAN聚类一般不适合。\n2. 如果样本集较大时，聚类收敛时间较长，此时可以对搜索最近邻时建立的KD树或者球树进行规模限制来改进。\n3. 调参相对于传统的K-Means之类的聚类算法稍复杂，主要需要对距离阈值Eps，邻域样本数阈值MinPts联合调参，不同的参数组合对最后的聚类效果有较大影响。\n\n### 参考文章：\n[https://www.cnblogs.com/pinard/p/6208966.html](https://www.cnblogs.com/pinard/p/6208966.html)\n[https://blog.csdn.net/u013611461/article/details/53639835](https://blog.csdn.net/u013611461/article/details/53639835)","slug":"note/arithmetic/dbscan","published":1,"updated":"2018-05-08T13:00:14.273Z","comments":1,"photos":[],"link":"","_id":"cjgxop3n1002pjah15s9uh2x2","content":"<h5 id=\"DBSCAN-Density-Based-Spatial-Clustering-of-Applications-with-Noise，具有噪声的基于密度的聚类方法-是一种很典型的密度聚类算法，和K-Means，BIRCH这些一般只适用于凸样本集的聚类相比，DBSCAN既可以适用于凸样本集，也可以适用于非凸样本集。下面我们就对DBSCAN算法的原理做一个总结。\"><a href=\"#DBSCAN-Density-Based-Spatial-Clustering-of-Applications-with-Noise，具有噪声的基于密度的聚类方法-是一种很典型的密度聚类算法，和K-Means，BIRCH这些一般只适用于凸样本集的聚类相比，DBSCAN既可以适用于凸样本集，也可以适用于非凸样本集。下面我们就对DBSCAN算法的原理做一个总结。\" class=\"headerlink\" title=\"DBSCAN(Density-Based Spatial Clustering of Applications with Noise，具有噪声的基于密度的聚类方法)是一种很典型的密度聚类算法，和K-Means，BIRCH这些一般只适用于凸样本集的聚类相比，DBSCAN既可以适用于凸样本集，也可以适用于非凸样本集。下面我们就对DBSCAN算法的原理做一个总结。\"></a>DBSCAN(Density-Based Spatial Clustering of Applications with Noise，具有噪声的基于密度的聚类方法)是一种很典型的密度聚类算法，和K-Means，BIRCH这些一般只适用于凸样本集的聚类相比，DBSCAN既可以适用于凸样本集，也可以适用于非凸样本集。下面我们就对DBSCAN算法的原理做一个总结。</h5><a id=\"more\"></a>\n<h2 id=\"密度聚类原理\"><a href=\"#密度聚类原理\" class=\"headerlink\" title=\"密度聚类原理\"></a>密度聚类原理</h2><h5 id=\"DBSCAN是一种基于密度的聚类算法，这类密度聚类算法一般假定类别可以通过样本分布的紧密程度决定。同一类别的样本，他们之间的紧密相连的，也就是说，在该类别任意样本周围不远处一定有同类别的样本存在。\"><a href=\"#DBSCAN是一种基于密度的聚类算法，这类密度聚类算法一般假定类别可以通过样本分布的紧密程度决定。同一类别的样本，他们之间的紧密相连的，也就是说，在该类别任意样本周围不远处一定有同类别的样本存在。\" class=\"headerlink\" title=\"DBSCAN是一种基于密度的聚类算法，这类密度聚类算法一般假定类别可以通过样本分布的紧密程度决定。同一类别的样本，他们之间的紧密相连的，也就是说，在该类别任意样本周围不远处一定有同类别的样本存在。\"></a>DBSCAN是一种基于密度的聚类算法，这类密度聚类算法一般假定类别可以通过样本分布的紧密程度决定。同一类别的样本，他们之间的紧密相连的，也就是说，在该类别任意样本周围不远处一定有同类别的样本存在。</h5><h5 id=\"通过将紧密相连的样本划为一类，这样就得到了一个聚类类别。通过将所有各组紧密相连的样本划为各个不同的类别，则我们就得到了最终的所有聚类类别结果。\"><a href=\"#通过将紧密相连的样本划为一类，这样就得到了一个聚类类别。通过将所有各组紧密相连的样本划为各个不同的类别，则我们就得到了最终的所有聚类类别结果。\" class=\"headerlink\" title=\"通过将紧密相连的样本划为一类，这样就得到了一个聚类类别。通过将所有各组紧密相连的样本划为各个不同的类别，则我们就得到了最终的所有聚类类别结果。\"></a>通过将紧密相连的样本划为一类，这样就得到了一个聚类类别。通过将所有各组紧密相连的样本划为各个不同的类别，则我们就得到了最终的所有聚类类别结果。</h5><h2 id=\"DBSCAN密度定义\"><a href=\"#DBSCAN密度定义\" class=\"headerlink\" title=\"DBSCAN密度定义\"></a>DBSCAN密度定义</h2><h5 id=\"假设我的样本集是D-x1-x2-…-xm-则DBSCAN具体的密度描述定义如下：\"><a href=\"#假设我的样本集是D-x1-x2-…-xm-则DBSCAN具体的密度描述定义如下：\" class=\"headerlink\" title=\"假设我的样本集是D=(x1,x2,…,xm),则DBSCAN具体的密度描述定义如下：\"></a>假设我的样本集是D=(x<sub>1</sub>,x<sub>2</sub>,…,x<sub>m</sub>),则DBSCAN具体的密度描述定义如下：</h5><ol>\n<li><strong>Eps邻域：</strong> 对于x<sub>j</sub> ∈ D，其Eps邻域包含样本集D中与x<sub>j</sub>的距离不大于Eps的子样本集，可以简单理解成半径为Eps内的所有点的集合</li>\n<li><strong>核心对象：</strong> 如果对象的Eps邻域至少包含最小数目MinPts的对象，则称该对象为核心对象;</li>\n<li><strong>边界点（edge point）：</strong> 边界点不是核心点，但落在某个核心点的邻域内;</li>\n<li><strong>噪音点（outlier point）：</strong> 既不是核心点，也不是边界点的任何点;</li>\n<li><strong>直接密度可达(directly density-reachable)：</strong> 给定一个对象集合D，如果p在q的Eps邻域内，而q是一个核心对象，则称对象p从对象q出发时是直接密度可达的;</li>\n<li><p><strong>密度可达(density-reachable)：</strong> 如果存在一个对象链  p1, …,pi,.., pn，满足p1 = p 和pn = q，pi是从pi+1关于Eps和MinPts直接密度可达的，则对象p是从对象q关于Eps和MinPts密度可达的;</p>\n</li>\n<li><p><strong>密度相连(density-connected)：</strong> 如果存在对象O∈D，使对象p和q都是从O关于Eps和MinPts密度可达的，那么对象p到q是关于Eps和MinPts密度相连的</p>\n</li>\n</ol>\n<h5 id=\"从下图可以很容易看出理解上述定义，图中MinPts-5，红色的点都是核心对象，因为其Eps邻域至少有5个样本。黑色的样本是非核心对象。所有核心对象密度直达的样本在以红色核心对象为中心的超球体内，如果不在超球体内，则不能密度直达。图中用绿色箭头连起来的核心对象组成了密度可达的样本序列。在这些密度可达的样本序列的Eps邻域内所有的样本相互都是密度相连的。\"><a href=\"#从下图可以很容易看出理解上述定义，图中MinPts-5，红色的点都是核心对象，因为其Eps邻域至少有5个样本。黑色的样本是非核心对象。所有核心对象密度直达的样本在以红色核心对象为中心的超球体内，如果不在超球体内，则不能密度直达。图中用绿色箭头连起来的核心对象组成了密度可达的样本序列。在这些密度可达的样本序列的Eps邻域内所有的样本相互都是密度相连的。\" class=\"headerlink\" title=\"从下图可以很容易看出理解上述定义，图中MinPts=5，红色的点都是核心对象，因为其Eps邻域至少有5个样本。黑色的样本是非核心对象。所有核心对象密度直达的样本在以红色核心对象为中心的超球体内，如果不在超球体内，则不能密度直达。图中用绿色箭头连起来的核心对象组成了密度可达的样本序列。在这些密度可达的样本序列的Eps邻域内所有的样本相互都是密度相连的。\"></a>从下图可以很容易看出理解上述定义，图中MinPts=5，红色的点都是核心对象，因为其Eps邻域至少有5个样本。黑色的样本是非核心对象。所有核心对象密度直达的样本在以红色核心对象为中心的超球体内，如果不在超球体内，则不能密度直达。图中用绿色箭头连起来的核心对象组成了密度可达的样本序列。在这些密度可达的样本序列的Eps邻域内所有的样本相互都是密度相连的。</h5><p><img src=\"/img/arithmetic/dbscan.png\" alt=\"dbscan\"></p>\n<h2 id=\"DBSCAN密度聚类思想\"><a href=\"#DBSCAN密度聚类思想\" class=\"headerlink\" title=\"DBSCAN密度聚类思想\"></a>DBSCAN密度聚类思想</h2><h5 id=\"DBSCAN的聚类定义很简单：由密度可达关系导出的最大密度相连的样本集合，即为我们最终聚类的一个类别，或者说一个簇。\"><a href=\"#DBSCAN的聚类定义很简单：由密度可达关系导出的最大密度相连的样本集合，即为我们最终聚类的一个类别，或者说一个簇。\" class=\"headerlink\" title=\"DBSCAN的聚类定义很简单：由密度可达关系导出的最大密度相连的样本集合，即为我们最终聚类的一个类别，或者说一个簇。\"></a>DBSCAN的聚类定义很简单：由密度可达关系导出的最大密度相连的样本集合，即为我们最终聚类的一个类别，或者说一个簇。</h5><h5 id=\"这个DBSCAN的簇里面可以有一个或者多个核心对象。如果只有一个核心对象，则簇里其他的非核心对象样本都在这个核心对象的Eps邻域里；如果有多个核心对象，则簇里的任意一个核心对象的Eps邻域中一定有一个其他的核心对象，否则这两个核心对象无法密度可达。这些核心对象的Eps邻域里所有的样本的集合组成的一个DBSCAN聚类簇。\"><a href=\"#这个DBSCAN的簇里面可以有一个或者多个核心对象。如果只有一个核心对象，则簇里其他的非核心对象样本都在这个核心对象的Eps邻域里；如果有多个核心对象，则簇里的任意一个核心对象的Eps邻域中一定有一个其他的核心对象，否则这两个核心对象无法密度可达。这些核心对象的Eps邻域里所有的样本的集合组成的一个DBSCAN聚类簇。\" class=\"headerlink\" title=\"这个DBSCAN的簇里面可以有一个或者多个核心对象。如果只有一个核心对象，则簇里其他的非核心对象样本都在这个核心对象的Eps邻域里；如果有多个核心对象，则簇里的任意一个核心对象的Eps邻域中一定有一个其他的核心对象，否则这两个核心对象无法密度可达。这些核心对象的Eps邻域里所有的样本的集合组成的一个DBSCAN聚类簇。\"></a>这个DBSCAN的簇里面可以有一个或者多个核心对象。如果只有一个核心对象，则簇里其他的非核心对象样本都在这个核心对象的Eps邻域里；如果有多个核心对象，则簇里的任意一个核心对象的Eps邻域中一定有一个其他的核心对象，否则这两个核心对象无法密度可达。这些核心对象的Eps邻域里所有的样本的集合组成的一个DBSCAN聚类簇。</h5><h5 id=\"那么怎么才能找到这样的簇样本集合呢？DBSCAN使用的方法很简单，它任意选择一个没有类别的核心对象作为种子，然后找到所有这个核心对象能够密度可达的样本集合，即为一个聚类簇。接着继续选择另一个没有类别的核心对象去寻找密度可达的样本集合，这样就得到另一个聚类簇。一直运行到所有核心对象都有类别为止。\"><a href=\"#那么怎么才能找到这样的簇样本集合呢？DBSCAN使用的方法很简单，它任意选择一个没有类别的核心对象作为种子，然后找到所有这个核心对象能够密度可达的样本集合，即为一个聚类簇。接着继续选择另一个没有类别的核心对象去寻找密度可达的样本集合，这样就得到另一个聚类簇。一直运行到所有核心对象都有类别为止。\" class=\"headerlink\" title=\"那么怎么才能找到这样的簇样本集合呢？DBSCAN使用的方法很简单，它任意选择一个没有类别的核心对象作为种子，然后找到所有这个核心对象能够密度可达的样本集合，即为一个聚类簇。接着继续选择另一个没有类别的核心对象去寻找密度可达的样本集合，这样就得到另一个聚类簇。一直运行到所有核心对象都有类别为止。\"></a>那么怎么才能找到这样的簇样本集合呢？DBSCAN使用的方法很简单，它任意选择一个没有类别的核心对象作为种子，然后找到所有这个核心对象能够密度可达的样本集合，即为一个聚类簇。接着继续选择另一个没有类别的核心对象去寻找密度可达的样本集合，这样就得到另一个聚类簇。一直运行到所有核心对象都有类别为止。</h5><h5 id=\"基本上这就是DBSCAN算法的主要内容了，是不是很简单？但是我们还是有三个问题没有考虑。\"><a href=\"#基本上这就是DBSCAN算法的主要内容了，是不是很简单？但是我们还是有三个问题没有考虑。\" class=\"headerlink\" title=\"基本上这就是DBSCAN算法的主要内容了，是不是很简单？但是我们还是有三个问题没有考虑。\"></a>基本上这就是DBSCAN算法的主要内容了，是不是很简单？但是我们还是有三个问题没有考虑。</h5><ol>\n<li>第一个是一些异常样本点或者说少量游离于簇外的样本点，这些点不在任何一个核心对象在周围，在DBSCAN中，我们一般将这些样本点标记为噪音点。</li>\n<li>第二个是距离的度量问题，即如何计算某样本和核心对象样本的距离。在DBSCAN中，一般采用最近邻思想，采用某一种距离度量来衡量样本距离，比如欧式距离。这和KNN分类算法的最近邻思想完全相同。对应少量的样本，寻找最近邻可以直接去计算所有样本的距离，如果样本量较大，则一般采用KD树或者球树来快速的搜索最近邻。如果大家对于最近邻的思想，距离度量，KD树和球树不熟悉，可以自行百度学习。</li>\n<li>第三种问题比较特殊，某些样本可能到两个核心对象的距离都小于Eps，但是这两个核心对象由于不是密度直达，又不属于同一个聚类簇，那么如果界定这个样本的类别呢？一般来说，此时DBSCAN采用先来后到，先进行聚类的类别簇会标记这个样本为它的类别。也就是说BDSCAN的算法不是完全稳定的算法。</li>\n</ol>\n<h2 id=\"python中的DBSCAN\"><a href=\"#python中的DBSCAN\" class=\"headerlink\" title=\"python中的DBSCAN\"></a>python中的DBSCAN</h2><h5 id=\"我们以sklearn-cluster-DBSCAN作为例子，做一些简单的demo：\"><a href=\"#我们以sklearn-cluster-DBSCAN作为例子，做一些简单的demo：\" class=\"headerlink\" title=\"我们以sklearn.cluster.DBSCAN作为例子，做一些简单的demo：\"></a>我们以sklearn.cluster.DBSCAN作为例子，做一些简单的demo：</h5><pre><code class=\"lang-python\">import matplotlib.pyplot as plt\nfrom  sklearn.cluster import DBSCAN\n\ndef dbscan(data):\n    result = DBSCAN(eps=2, min_samples=2).fit(data)\n    components_ = result.components_\n    plt.subplot(2, 1, 1)\n    plt.scatter([x[0] for x in components_], [x[1] for x in components_], c=result.labels_)\n    plt.subplot(2, 1, 2)\n    plt.scatter([x[0] for x in data], [x[1] for x in data], c=result.labels_)\n    plt.show()\n\nif __name__ == &#39;__main__&#39;:\n    l = [\n        [1,1],\n        [1,2],\n        [2,1],\n        [2,2],\n        [4,10],\n        [8,2],\n        [10,10],\n        [10,11],\n        [11,10],\n        [11,11],\n    ]\n    dbscan(l)\n</code></pre>\n<h5 id=\"上面代码很简单，构造了一些简单的点，按照参数Eps-2和最小数目MinPts-2将点进行聚类计算。\"><a href=\"#上面代码很简单，构造了一些简单的点，按照参数Eps-2和最小数目MinPts-2将点进行聚类计算。\" class=\"headerlink\" title=\"上面代码很简单，构造了一些简单的点，按照参数Eps=2和最小数目MinPts=2将点进行聚类计算。\"></a>上面代码很简单，构造了一些简单的点，按照参数Eps=2和最小数目MinPts=2将点进行聚类计算。</h5><p><img src=\"/img/arithmetic/dbscanR.png\" alt=\"dbscan\"></p>\n<h2 id=\"DBSCAN小结\"><a href=\"#DBSCAN小结\" class=\"headerlink\" title=\"DBSCAN小结\"></a>DBSCAN小结</h2><h5 id=\"和传统的K-Means算法相比，DBSCAN最大的不同就是不需要输入类别数k，当然它最大的优势是可以发现任意形状的聚类簇，而不是像K-Means，一般仅仅使用于凸的样本集聚类。同时它在聚类的同时还可以找出异常点，这点和BIRCH算法类似。\"><a href=\"#和传统的K-Means算法相比，DBSCAN最大的不同就是不需要输入类别数k，当然它最大的优势是可以发现任意形状的聚类簇，而不是像K-Means，一般仅仅使用于凸的样本集聚类。同时它在聚类的同时还可以找出异常点，这点和BIRCH算法类似。\" class=\"headerlink\" title=\"和传统的K-Means算法相比，DBSCAN最大的不同就是不需要输入类别数k，当然它最大的优势是可以发现任意形状的聚类簇，而不是像K-Means，一般仅仅使用于凸的样本集聚类。同时它在聚类的同时还可以找出异常点，这点和BIRCH算法类似。\"></a>和传统的K-Means算法相比，DBSCAN最大的不同就是不需要输入类别数k，当然它最大的优势是可以发现任意形状的聚类簇，而不是像K-Means，一般仅仅使用于凸的样本集聚类。同时它在聚类的同时还可以找出异常点，这点和BIRCH算法类似。</h5><h5 id=\"那么我们什么时候需要用DBSCAN来聚类呢？一般来说，如果数据集是稠密的，并且数据集不是凸的，那么用DBSCAN会比K-Means聚类效果好很多。如果数据集不是稠密的，则不推荐用DBSCAN来聚类。\"><a href=\"#那么我们什么时候需要用DBSCAN来聚类呢？一般来说，如果数据集是稠密的，并且数据集不是凸的，那么用DBSCAN会比K-Means聚类效果好很多。如果数据集不是稠密的，则不推荐用DBSCAN来聚类。\" class=\"headerlink\" title=\"那么我们什么时候需要用DBSCAN来聚类呢？一般来说，如果数据集是稠密的，并且数据集不是凸的，那么用DBSCAN会比K-Means聚类效果好很多。如果数据集不是稠密的，则不推荐用DBSCAN来聚类。\"></a>那么我们什么时候需要用DBSCAN来聚类呢？一般来说，如果数据集是稠密的，并且数据集不是凸的，那么用DBSCAN会比K-Means聚类效果好很多。如果数据集不是稠密的，则不推荐用DBSCAN来聚类。</h5><h4 id=\"DBSCAN的主要优点有：\"><a href=\"#DBSCAN的主要优点有：\" class=\"headerlink\" title=\"DBSCAN的主要优点有：\"></a>DBSCAN的主要优点有：</h4><ol>\n<li>可以对任意形状的稠密数据集进行聚类，相对的，K-Means之类的聚类算法一般只适用于凸数据集。</li>\n<li>可以在聚类的同时发现异常点，对数据集中的异常点不敏感。</li>\n<li>聚类结果没有偏倚，相对的，K-Means之类的聚类算法初始值对聚类结果有很大影响。</li>\n</ol>\n<h4 id=\"DBSCAN的主要缺点有：\"><a href=\"#DBSCAN的主要缺点有：\" class=\"headerlink\" title=\"DBSCAN的主要缺点有：\"></a>DBSCAN的主要缺点有：</h4><ol>\n<li>如果样本集的密度不均匀、聚类间距差相差很大时，聚类质量较差，这时用DBSCAN聚类一般不适合。</li>\n<li>如果样本集较大时，聚类收敛时间较长，此时可以对搜索最近邻时建立的KD树或者球树进行规模限制来改进。</li>\n<li>调参相对于传统的K-Means之类的聚类算法稍复杂，主要需要对距离阈值Eps，邻域样本数阈值MinPts联合调参，不同的参数组合对最后的聚类效果有较大影响。</li>\n</ol>\n<h3 id=\"参考文章：\"><a href=\"#参考文章：\" class=\"headerlink\" title=\"参考文章：\"></a>参考文章：</h3><p><a href=\"https://www.cnblogs.com/pinard/p/6208966.html\" target=\"_blank\" rel=\"external\">https://www.cnblogs.com/pinard/p/6208966.html</a><br><a href=\"https://blog.csdn.net/u013611461/article/details/53639835\" target=\"_blank\" rel=\"external\">https://blog.csdn.net/u013611461/article/details/53639835</a></p>\n","site":{"data":{}},"excerpt":"<h5 id=\"DBSCAN-Density-Based-Spatial-Clustering-of-Applications-with-Noise，具有噪声的基于密度的聚类方法-是一种很典型的密度聚类算法，和K-Means，BIRCH这些一般只适用于凸样本集的聚类相比，DBSCAN既可以适用于凸样本集，也可以适用于非凸样本集。下面我们就对DBSCAN算法的原理做一个总结。\"><a href=\"#DBSCAN-Density-Based-Spatial-Clustering-of-Applications-with-Noise，具有噪声的基于密度的聚类方法-是一种很典型的密度聚类算法，和K-Means，BIRCH这些一般只适用于凸样本集的聚类相比，DBSCAN既可以适用于凸样本集，也可以适用于非凸样本集。下面我们就对DBSCAN算法的原理做一个总结。\" class=\"headerlink\" title=\"DBSCAN(Density-Based Spatial Clustering of Applications with Noise，具有噪声的基于密度的聚类方法)是一种很典型的密度聚类算法，和K-Means，BIRCH这些一般只适用于凸样本集的聚类相比，DBSCAN既可以适用于凸样本集，也可以适用于非凸样本集。下面我们就对DBSCAN算法的原理做一个总结。\"></a>DBSCAN(Density-Based Spatial Clustering of Applications with Noise，具有噪声的基于密度的聚类方法)是一种很典型的密度聚类算法，和K-Means，BIRCH这些一般只适用于凸样本集的聚类相比，DBSCAN既可以适用于凸样本集，也可以适用于非凸样本集。下面我们就对DBSCAN算法的原理做一个总结。</h5>","more":"<h2 id=\"密度聚类原理\"><a href=\"#密度聚类原理\" class=\"headerlink\" title=\"密度聚类原理\"></a>密度聚类原理</h2><h5 id=\"DBSCAN是一种基于密度的聚类算法，这类密度聚类算法一般假定类别可以通过样本分布的紧密程度决定。同一类别的样本，他们之间的紧密相连的，也就是说，在该类别任意样本周围不远处一定有同类别的样本存在。\"><a href=\"#DBSCAN是一种基于密度的聚类算法，这类密度聚类算法一般假定类别可以通过样本分布的紧密程度决定。同一类别的样本，他们之间的紧密相连的，也就是说，在该类别任意样本周围不远处一定有同类别的样本存在。\" class=\"headerlink\" title=\"DBSCAN是一种基于密度的聚类算法，这类密度聚类算法一般假定类别可以通过样本分布的紧密程度决定。同一类别的样本，他们之间的紧密相连的，也就是说，在该类别任意样本周围不远处一定有同类别的样本存在。\"></a>DBSCAN是一种基于密度的聚类算法，这类密度聚类算法一般假定类别可以通过样本分布的紧密程度决定。同一类别的样本，他们之间的紧密相连的，也就是说，在该类别任意样本周围不远处一定有同类别的样本存在。</h5><h5 id=\"通过将紧密相连的样本划为一类，这样就得到了一个聚类类别。通过将所有各组紧密相连的样本划为各个不同的类别，则我们就得到了最终的所有聚类类别结果。\"><a href=\"#通过将紧密相连的样本划为一类，这样就得到了一个聚类类别。通过将所有各组紧密相连的样本划为各个不同的类别，则我们就得到了最终的所有聚类类别结果。\" class=\"headerlink\" title=\"通过将紧密相连的样本划为一类，这样就得到了一个聚类类别。通过将所有各组紧密相连的样本划为各个不同的类别，则我们就得到了最终的所有聚类类别结果。\"></a>通过将紧密相连的样本划为一类，这样就得到了一个聚类类别。通过将所有各组紧密相连的样本划为各个不同的类别，则我们就得到了最终的所有聚类类别结果。</h5><h2 id=\"DBSCAN密度定义\"><a href=\"#DBSCAN密度定义\" class=\"headerlink\" title=\"DBSCAN密度定义\"></a>DBSCAN密度定义</h2><h5 id=\"假设我的样本集是D-x1-x2-…-xm-则DBSCAN具体的密度描述定义如下：\"><a href=\"#假设我的样本集是D-x1-x2-…-xm-则DBSCAN具体的密度描述定义如下：\" class=\"headerlink\" title=\"假设我的样本集是D=(x1,x2,…,xm),则DBSCAN具体的密度描述定义如下：\"></a>假设我的样本集是D=(x<sub>1</sub>,x<sub>2</sub>,…,x<sub>m</sub>),则DBSCAN具体的密度描述定义如下：</h5><ol>\n<li><strong>Eps邻域：</strong> 对于x<sub>j</sub> ∈ D，其Eps邻域包含样本集D中与x<sub>j</sub>的距离不大于Eps的子样本集，可以简单理解成半径为Eps内的所有点的集合</li>\n<li><strong>核心对象：</strong> 如果对象的Eps邻域至少包含最小数目MinPts的对象，则称该对象为核心对象;</li>\n<li><strong>边界点（edge point）：</strong> 边界点不是核心点，但落在某个核心点的邻域内;</li>\n<li><strong>噪音点（outlier point）：</strong> 既不是核心点，也不是边界点的任何点;</li>\n<li><strong>直接密度可达(directly density-reachable)：</strong> 给定一个对象集合D，如果p在q的Eps邻域内，而q是一个核心对象，则称对象p从对象q出发时是直接密度可达的;</li>\n<li><p><strong>密度可达(density-reachable)：</strong> 如果存在一个对象链  p1, …,pi,.., pn，满足p1 = p 和pn = q，pi是从pi+1关于Eps和MinPts直接密度可达的，则对象p是从对象q关于Eps和MinPts密度可达的;</p>\n</li>\n<li><p><strong>密度相连(density-connected)：</strong> 如果存在对象O∈D，使对象p和q都是从O关于Eps和MinPts密度可达的，那么对象p到q是关于Eps和MinPts密度相连的</p>\n</li>\n</ol>\n<h5 id=\"从下图可以很容易看出理解上述定义，图中MinPts-5，红色的点都是核心对象，因为其Eps邻域至少有5个样本。黑色的样本是非核心对象。所有核心对象密度直达的样本在以红色核心对象为中心的超球体内，如果不在超球体内，则不能密度直达。图中用绿色箭头连起来的核心对象组成了密度可达的样本序列。在这些密度可达的样本序列的Eps邻域内所有的样本相互都是密度相连的。\"><a href=\"#从下图可以很容易看出理解上述定义，图中MinPts-5，红色的点都是核心对象，因为其Eps邻域至少有5个样本。黑色的样本是非核心对象。所有核心对象密度直达的样本在以红色核心对象为中心的超球体内，如果不在超球体内，则不能密度直达。图中用绿色箭头连起来的核心对象组成了密度可达的样本序列。在这些密度可达的样本序列的Eps邻域内所有的样本相互都是密度相连的。\" class=\"headerlink\" title=\"从下图可以很容易看出理解上述定义，图中MinPts=5，红色的点都是核心对象，因为其Eps邻域至少有5个样本。黑色的样本是非核心对象。所有核心对象密度直达的样本在以红色核心对象为中心的超球体内，如果不在超球体内，则不能密度直达。图中用绿色箭头连起来的核心对象组成了密度可达的样本序列。在这些密度可达的样本序列的Eps邻域内所有的样本相互都是密度相连的。\"></a>从下图可以很容易看出理解上述定义，图中MinPts=5，红色的点都是核心对象，因为其Eps邻域至少有5个样本。黑色的样本是非核心对象。所有核心对象密度直达的样本在以红色核心对象为中心的超球体内，如果不在超球体内，则不能密度直达。图中用绿色箭头连起来的核心对象组成了密度可达的样本序列。在这些密度可达的样本序列的Eps邻域内所有的样本相互都是密度相连的。</h5><p><img src=\"/img/arithmetic/dbscan.png\" alt=\"dbscan\"></p>\n<h2 id=\"DBSCAN密度聚类思想\"><a href=\"#DBSCAN密度聚类思想\" class=\"headerlink\" title=\"DBSCAN密度聚类思想\"></a>DBSCAN密度聚类思想</h2><h5 id=\"DBSCAN的聚类定义很简单：由密度可达关系导出的最大密度相连的样本集合，即为我们最终聚类的一个类别，或者说一个簇。\"><a href=\"#DBSCAN的聚类定义很简单：由密度可达关系导出的最大密度相连的样本集合，即为我们最终聚类的一个类别，或者说一个簇。\" class=\"headerlink\" title=\"DBSCAN的聚类定义很简单：由密度可达关系导出的最大密度相连的样本集合，即为我们最终聚类的一个类别，或者说一个簇。\"></a>DBSCAN的聚类定义很简单：由密度可达关系导出的最大密度相连的样本集合，即为我们最终聚类的一个类别，或者说一个簇。</h5><h5 id=\"这个DBSCAN的簇里面可以有一个或者多个核心对象。如果只有一个核心对象，则簇里其他的非核心对象样本都在这个核心对象的Eps邻域里；如果有多个核心对象，则簇里的任意一个核心对象的Eps邻域中一定有一个其他的核心对象，否则这两个核心对象无法密度可达。这些核心对象的Eps邻域里所有的样本的集合组成的一个DBSCAN聚类簇。\"><a href=\"#这个DBSCAN的簇里面可以有一个或者多个核心对象。如果只有一个核心对象，则簇里其他的非核心对象样本都在这个核心对象的Eps邻域里；如果有多个核心对象，则簇里的任意一个核心对象的Eps邻域中一定有一个其他的核心对象，否则这两个核心对象无法密度可达。这些核心对象的Eps邻域里所有的样本的集合组成的一个DBSCAN聚类簇。\" class=\"headerlink\" title=\"这个DBSCAN的簇里面可以有一个或者多个核心对象。如果只有一个核心对象，则簇里其他的非核心对象样本都在这个核心对象的Eps邻域里；如果有多个核心对象，则簇里的任意一个核心对象的Eps邻域中一定有一个其他的核心对象，否则这两个核心对象无法密度可达。这些核心对象的Eps邻域里所有的样本的集合组成的一个DBSCAN聚类簇。\"></a>这个DBSCAN的簇里面可以有一个或者多个核心对象。如果只有一个核心对象，则簇里其他的非核心对象样本都在这个核心对象的Eps邻域里；如果有多个核心对象，则簇里的任意一个核心对象的Eps邻域中一定有一个其他的核心对象，否则这两个核心对象无法密度可达。这些核心对象的Eps邻域里所有的样本的集合组成的一个DBSCAN聚类簇。</h5><h5 id=\"那么怎么才能找到这样的簇样本集合呢？DBSCAN使用的方法很简单，它任意选择一个没有类别的核心对象作为种子，然后找到所有这个核心对象能够密度可达的样本集合，即为一个聚类簇。接着继续选择另一个没有类别的核心对象去寻找密度可达的样本集合，这样就得到另一个聚类簇。一直运行到所有核心对象都有类别为止。\"><a href=\"#那么怎么才能找到这样的簇样本集合呢？DBSCAN使用的方法很简单，它任意选择一个没有类别的核心对象作为种子，然后找到所有这个核心对象能够密度可达的样本集合，即为一个聚类簇。接着继续选择另一个没有类别的核心对象去寻找密度可达的样本集合，这样就得到另一个聚类簇。一直运行到所有核心对象都有类别为止。\" class=\"headerlink\" title=\"那么怎么才能找到这样的簇样本集合呢？DBSCAN使用的方法很简单，它任意选择一个没有类别的核心对象作为种子，然后找到所有这个核心对象能够密度可达的样本集合，即为一个聚类簇。接着继续选择另一个没有类别的核心对象去寻找密度可达的样本集合，这样就得到另一个聚类簇。一直运行到所有核心对象都有类别为止。\"></a>那么怎么才能找到这样的簇样本集合呢？DBSCAN使用的方法很简单，它任意选择一个没有类别的核心对象作为种子，然后找到所有这个核心对象能够密度可达的样本集合，即为一个聚类簇。接着继续选择另一个没有类别的核心对象去寻找密度可达的样本集合，这样就得到另一个聚类簇。一直运行到所有核心对象都有类别为止。</h5><h5 id=\"基本上这就是DBSCAN算法的主要内容了，是不是很简单？但是我们还是有三个问题没有考虑。\"><a href=\"#基本上这就是DBSCAN算法的主要内容了，是不是很简单？但是我们还是有三个问题没有考虑。\" class=\"headerlink\" title=\"基本上这就是DBSCAN算法的主要内容了，是不是很简单？但是我们还是有三个问题没有考虑。\"></a>基本上这就是DBSCAN算法的主要内容了，是不是很简单？但是我们还是有三个问题没有考虑。</h5><ol>\n<li>第一个是一些异常样本点或者说少量游离于簇外的样本点，这些点不在任何一个核心对象在周围，在DBSCAN中，我们一般将这些样本点标记为噪音点。</li>\n<li>第二个是距离的度量问题，即如何计算某样本和核心对象样本的距离。在DBSCAN中，一般采用最近邻思想，采用某一种距离度量来衡量样本距离，比如欧式距离。这和KNN分类算法的最近邻思想完全相同。对应少量的样本，寻找最近邻可以直接去计算所有样本的距离，如果样本量较大，则一般采用KD树或者球树来快速的搜索最近邻。如果大家对于最近邻的思想，距离度量，KD树和球树不熟悉，可以自行百度学习。</li>\n<li>第三种问题比较特殊，某些样本可能到两个核心对象的距离都小于Eps，但是这两个核心对象由于不是密度直达，又不属于同一个聚类簇，那么如果界定这个样本的类别呢？一般来说，此时DBSCAN采用先来后到，先进行聚类的类别簇会标记这个样本为它的类别。也就是说BDSCAN的算法不是完全稳定的算法。</li>\n</ol>\n<h2 id=\"python中的DBSCAN\"><a href=\"#python中的DBSCAN\" class=\"headerlink\" title=\"python中的DBSCAN\"></a>python中的DBSCAN</h2><h5 id=\"我们以sklearn-cluster-DBSCAN作为例子，做一些简单的demo：\"><a href=\"#我们以sklearn-cluster-DBSCAN作为例子，做一些简单的demo：\" class=\"headerlink\" title=\"我们以sklearn.cluster.DBSCAN作为例子，做一些简单的demo：\"></a>我们以sklearn.cluster.DBSCAN作为例子，做一些简单的demo：</h5><pre><code class=\"lang-python\">import matplotlib.pyplot as plt\nfrom  sklearn.cluster import DBSCAN\n\ndef dbscan(data):\n    result = DBSCAN(eps=2, min_samples=2).fit(data)\n    components_ = result.components_\n    plt.subplot(2, 1, 1)\n    plt.scatter([x[0] for x in components_], [x[1] for x in components_], c=result.labels_)\n    plt.subplot(2, 1, 2)\n    plt.scatter([x[0] for x in data], [x[1] for x in data], c=result.labels_)\n    plt.show()\n\nif __name__ == &#39;__main__&#39;:\n    l = [\n        [1,1],\n        [1,2],\n        [2,1],\n        [2,2],\n        [4,10],\n        [8,2],\n        [10,10],\n        [10,11],\n        [11,10],\n        [11,11],\n    ]\n    dbscan(l)\n</code></pre>\n<h5 id=\"上面代码很简单，构造了一些简单的点，按照参数Eps-2和最小数目MinPts-2将点进行聚类计算。\"><a href=\"#上面代码很简单，构造了一些简单的点，按照参数Eps-2和最小数目MinPts-2将点进行聚类计算。\" class=\"headerlink\" title=\"上面代码很简单，构造了一些简单的点，按照参数Eps=2和最小数目MinPts=2将点进行聚类计算。\"></a>上面代码很简单，构造了一些简单的点，按照参数Eps=2和最小数目MinPts=2将点进行聚类计算。</h5><p><img src=\"/img/arithmetic/dbscanR.png\" alt=\"dbscan\"></p>\n<h2 id=\"DBSCAN小结\"><a href=\"#DBSCAN小结\" class=\"headerlink\" title=\"DBSCAN小结\"></a>DBSCAN小结</h2><h5 id=\"和传统的K-Means算法相比，DBSCAN最大的不同就是不需要输入类别数k，当然它最大的优势是可以发现任意形状的聚类簇，而不是像K-Means，一般仅仅使用于凸的样本集聚类。同时它在聚类的同时还可以找出异常点，这点和BIRCH算法类似。\"><a href=\"#和传统的K-Means算法相比，DBSCAN最大的不同就是不需要输入类别数k，当然它最大的优势是可以发现任意形状的聚类簇，而不是像K-Means，一般仅仅使用于凸的样本集聚类。同时它在聚类的同时还可以找出异常点，这点和BIRCH算法类似。\" class=\"headerlink\" title=\"和传统的K-Means算法相比，DBSCAN最大的不同就是不需要输入类别数k，当然它最大的优势是可以发现任意形状的聚类簇，而不是像K-Means，一般仅仅使用于凸的样本集聚类。同时它在聚类的同时还可以找出异常点，这点和BIRCH算法类似。\"></a>和传统的K-Means算法相比，DBSCAN最大的不同就是不需要输入类别数k，当然它最大的优势是可以发现任意形状的聚类簇，而不是像K-Means，一般仅仅使用于凸的样本集聚类。同时它在聚类的同时还可以找出异常点，这点和BIRCH算法类似。</h5><h5 id=\"那么我们什么时候需要用DBSCAN来聚类呢？一般来说，如果数据集是稠密的，并且数据集不是凸的，那么用DBSCAN会比K-Means聚类效果好很多。如果数据集不是稠密的，则不推荐用DBSCAN来聚类。\"><a href=\"#那么我们什么时候需要用DBSCAN来聚类呢？一般来说，如果数据集是稠密的，并且数据集不是凸的，那么用DBSCAN会比K-Means聚类效果好很多。如果数据集不是稠密的，则不推荐用DBSCAN来聚类。\" class=\"headerlink\" title=\"那么我们什么时候需要用DBSCAN来聚类呢？一般来说，如果数据集是稠密的，并且数据集不是凸的，那么用DBSCAN会比K-Means聚类效果好很多。如果数据集不是稠密的，则不推荐用DBSCAN来聚类。\"></a>那么我们什么时候需要用DBSCAN来聚类呢？一般来说，如果数据集是稠密的，并且数据集不是凸的，那么用DBSCAN会比K-Means聚类效果好很多。如果数据集不是稠密的，则不推荐用DBSCAN来聚类。</h5><h4 id=\"DBSCAN的主要优点有：\"><a href=\"#DBSCAN的主要优点有：\" class=\"headerlink\" title=\"DBSCAN的主要优点有：\"></a>DBSCAN的主要优点有：</h4><ol>\n<li>可以对任意形状的稠密数据集进行聚类，相对的，K-Means之类的聚类算法一般只适用于凸数据集。</li>\n<li>可以在聚类的同时发现异常点，对数据集中的异常点不敏感。</li>\n<li>聚类结果没有偏倚，相对的，K-Means之类的聚类算法初始值对聚类结果有很大影响。</li>\n</ol>\n<h4 id=\"DBSCAN的主要缺点有：\"><a href=\"#DBSCAN的主要缺点有：\" class=\"headerlink\" title=\"DBSCAN的主要缺点有：\"></a>DBSCAN的主要缺点有：</h4><ol>\n<li>如果样本集的密度不均匀、聚类间距差相差很大时，聚类质量较差，这时用DBSCAN聚类一般不适合。</li>\n<li>如果样本集较大时，聚类收敛时间较长，此时可以对搜索最近邻时建立的KD树或者球树进行规模限制来改进。</li>\n<li>调参相对于传统的K-Means之类的聚类算法稍复杂，主要需要对距离阈值Eps，邻域样本数阈值MinPts联合调参，不同的参数组合对最后的聚类效果有较大影响。</li>\n</ol>\n<h3 id=\"参考文章：\"><a href=\"#参考文章：\" class=\"headerlink\" title=\"参考文章：\"></a>参考文章：</h3><p><a href=\"https://www.cnblogs.com/pinard/p/6208966.html\" target=\"_blank\" rel=\"external\">https://www.cnblogs.com/pinard/p/6208966.html</a><br><a href=\"https://blog.csdn.net/u013611461/article/details/53639835\" target=\"_blank\" rel=\"external\">https://blog.csdn.net/u013611461/article/details/53639835</a></p>"},{"layout":"post","title":"切金条","date":"2017-02-22T16:00:00.000Z","original":true,"tag":[["算法","arithmetic"]],"_content":"\n## 题目要求：\n##### 你让一些人为你工作了七天，你要用一根金条作为报酬。金条被分成七小块，每天给出一块。如果你只能将金条切割两次，你怎样分给这些工人?\n<!--more-->\n\n## 分析过程：\n##### 这道题目一看就知道要按照二进制的方式去分割，因为切分的块数比较少，所以后面几次的报酬一定是需要将之前的报酬拿回才能做到的。\n##### 所以按照题目要求切割两次，要么把金条分成三份，要么分成四份（第二次两块叠在一起）。所以前三块部分一定是按照1：2：4来分，因为加起来已经等于7了，所以只需要分成三分就够了。这道题目就这么简单。\n\n##### 这让我想到了另外一道题，将1000个球，放在10个箱子里。需要达到一种效果，就是任取1至1000的数字，能够从10个箱子中取出n个箱子，这n个箱子里面的球加起来刚好等于这个数字。这题和上面那题其实是一样的，没接触过一些算法的人会觉得特别难喝复杂，稍微认真想一想的童鞋也可以通过下面的方式得出答案：\n#### 首先是取一个球的时候：\n##### 所以一定有一个箱子里面是1个球。\n#### 取两个球：\n##### 前面那个箱子里是1个球，当需要两个球的时候，再添加一个一个球的箱子明显是不理智的，所以再拿一个箱子放两个球。\n#### 三个球：\n##### 前面两个箱子加起来刚好就是三个球，所以这种情况就已经包含在前面的答案里面了。\n#### 四个球呢：\n##### 之前两个箱子加起来才3个球，所以再拿一个箱子放4个球。\n#### 五个球，六个球，七个球之后的所有情况都按照这种逻辑推演下去，就可以得出答案\n##### 按照1、2、4、8、16...这种规律放球，就能够做到题目的要求。切2<sup>10</sup> = 1024,所以10个箱子是能够支持这种放球的方式的。\n\n## 为什么这组数字这么神奇\n##### 1、2、4、8、16 可以组合成1到31之间的任意一个数，为什么会这么神奇。\n##### 任何一个10进制数都可以转换成相应的二进制数。\n$$8\\qquad4\\qquad\\quad2\\qquad1$$\n$$1000\\quad0100\\quad0010\\quad0001$$\n\n##### 所以4位的2进制每一位转换成10进制分别是8、4、2、1。就好像4位的10进制每一位分别表示为千、百、十、个。但是你要是说把9999个球放到4个箱子里，任取一个数都能拿出n个箱子，加起来刚好是这个数。但是按照二进制的方法，4位二进制转换成10进制最多为15，所以15个球是能够实现这种规律的。\n##### 能够达到这种神奇效果，是因为和二进制的特征有关，二进制只有0和1两个数字，这就表示二进制的每一位只有两种状态。我们可以简单的分为有（1）和没有（0）。所以4位的二进制，放到4个箱子里面，每个箱子分别放入对应的二进制位数表示的数，然后拿箱子表示为1，不拿表示为0，其实组合出来的结果就是一个二进制的数。而十进制的每一位则有10种状态之多，一个箱子要产生10种状态，以拿到不同的球数，在这道题里面是不存在的。\n\n## 题外话\n##### 其实计算机的计算依赖于二进制也和此有关，因为以前的计算机对信号的读取和产生并没有那么灵敏，它只能识别有或者没有，转换成二进制就是1和0，如果以16进制为基础，则需要区分信号的强弱，这对以前的系统灵敏度来说是比较难的。（意淫一下，如果现在重新以16进制为基础编写计算机底层，计算效率和传输效率是不是有质的飞越呢）。\n","source":"_posts/note/arithmetic/glodBars.md","raw":"---\nlayout: post\ntitle: 切金条\ndate: 2017/02/23\ntags: [tech, arithmetic, index]\noriginal: true\ntag: [[算法, arithmetic]]\n---\n\n## 题目要求：\n##### 你让一些人为你工作了七天，你要用一根金条作为报酬。金条被分成七小块，每天给出一块。如果你只能将金条切割两次，你怎样分给这些工人?\n<!--more-->\n\n## 分析过程：\n##### 这道题目一看就知道要按照二进制的方式去分割，因为切分的块数比较少，所以后面几次的报酬一定是需要将之前的报酬拿回才能做到的。\n##### 所以按照题目要求切割两次，要么把金条分成三份，要么分成四份（第二次两块叠在一起）。所以前三块部分一定是按照1：2：4来分，因为加起来已经等于7了，所以只需要分成三分就够了。这道题目就这么简单。\n\n##### 这让我想到了另外一道题，将1000个球，放在10个箱子里。需要达到一种效果，就是任取1至1000的数字，能够从10个箱子中取出n个箱子，这n个箱子里面的球加起来刚好等于这个数字。这题和上面那题其实是一样的，没接触过一些算法的人会觉得特别难喝复杂，稍微认真想一想的童鞋也可以通过下面的方式得出答案：\n#### 首先是取一个球的时候：\n##### 所以一定有一个箱子里面是1个球。\n#### 取两个球：\n##### 前面那个箱子里是1个球，当需要两个球的时候，再添加一个一个球的箱子明显是不理智的，所以再拿一个箱子放两个球。\n#### 三个球：\n##### 前面两个箱子加起来刚好就是三个球，所以这种情况就已经包含在前面的答案里面了。\n#### 四个球呢：\n##### 之前两个箱子加起来才3个球，所以再拿一个箱子放4个球。\n#### 五个球，六个球，七个球之后的所有情况都按照这种逻辑推演下去，就可以得出答案\n##### 按照1、2、4、8、16...这种规律放球，就能够做到题目的要求。切2<sup>10</sup> = 1024,所以10个箱子是能够支持这种放球的方式的。\n\n## 为什么这组数字这么神奇\n##### 1、2、4、8、16 可以组合成1到31之间的任意一个数，为什么会这么神奇。\n##### 任何一个10进制数都可以转换成相应的二进制数。\n$$8\\qquad4\\qquad\\quad2\\qquad1$$\n$$1000\\quad0100\\quad0010\\quad0001$$\n\n##### 所以4位的2进制每一位转换成10进制分别是8、4、2、1。就好像4位的10进制每一位分别表示为千、百、十、个。但是你要是说把9999个球放到4个箱子里，任取一个数都能拿出n个箱子，加起来刚好是这个数。但是按照二进制的方法，4位二进制转换成10进制最多为15，所以15个球是能够实现这种规律的。\n##### 能够达到这种神奇效果，是因为和二进制的特征有关，二进制只有0和1两个数字，这就表示二进制的每一位只有两种状态。我们可以简单的分为有（1）和没有（0）。所以4位的二进制，放到4个箱子里面，每个箱子分别放入对应的二进制位数表示的数，然后拿箱子表示为1，不拿表示为0，其实组合出来的结果就是一个二进制的数。而十进制的每一位则有10种状态之多，一个箱子要产生10种状态，以拿到不同的球数，在这道题里面是不存在的。\n\n## 题外话\n##### 其实计算机的计算依赖于二进制也和此有关，因为以前的计算机对信号的读取和产生并没有那么灵敏，它只能识别有或者没有，转换成二进制就是1和0，如果以16进制为基础，则需要区分信号的强弱，这对以前的系统灵敏度来说是比较难的。（意淫一下，如果现在重新以16进制为基础编写计算机底层，计算效率和传输效率是不是有质的飞越呢）。\n","slug":"note/arithmetic/glodBars","published":1,"updated":"2018-05-08T13:00:14.273Z","comments":1,"photos":[],"link":"","_id":"cjgxop3n3002rjah1ukljja90","content":"<h2 id=\"题目要求：\"><a href=\"#题目要求：\" class=\"headerlink\" title=\"题目要求：\"></a>题目要求：</h2><h5 id=\"你让一些人为你工作了七天，你要用一根金条作为报酬。金条被分成七小块，每天给出一块。如果你只能将金条切割两次，你怎样分给这些工人\"><a href=\"#你让一些人为你工作了七天，你要用一根金条作为报酬。金条被分成七小块，每天给出一块。如果你只能将金条切割两次，你怎样分给这些工人\" class=\"headerlink\" title=\"你让一些人为你工作了七天，你要用一根金条作为报酬。金条被分成七小块，每天给出一块。如果你只能将金条切割两次，你怎样分给这些工人?\"></a>你让一些人为你工作了七天，你要用一根金条作为报酬。金条被分成七小块，每天给出一块。如果你只能将金条切割两次，你怎样分给这些工人?</h5><a id=\"more\"></a>\n<h2 id=\"分析过程：\"><a href=\"#分析过程：\" class=\"headerlink\" title=\"分析过程：\"></a>分析过程：</h2><h5 id=\"这道题目一看就知道要按照二进制的方式去分割，因为切分的块数比较少，所以后面几次的报酬一定是需要将之前的报酬拿回才能做到的。\"><a href=\"#这道题目一看就知道要按照二进制的方式去分割，因为切分的块数比较少，所以后面几次的报酬一定是需要将之前的报酬拿回才能做到的。\" class=\"headerlink\" title=\"这道题目一看就知道要按照二进制的方式去分割，因为切分的块数比较少，所以后面几次的报酬一定是需要将之前的报酬拿回才能做到的。\"></a>这道题目一看就知道要按照二进制的方式去分割，因为切分的块数比较少，所以后面几次的报酬一定是需要将之前的报酬拿回才能做到的。</h5><h5 id=\"所以按照题目要求切割两次，要么把金条分成三份，要么分成四份（第二次两块叠在一起）。所以前三块部分一定是按照1：2：4来分，因为加起来已经等于7了，所以只需要分成三分就够了。这道题目就这么简单。\"><a href=\"#所以按照题目要求切割两次，要么把金条分成三份，要么分成四份（第二次两块叠在一起）。所以前三块部分一定是按照1：2：4来分，因为加起来已经等于7了，所以只需要分成三分就够了。这道题目就这么简单。\" class=\"headerlink\" title=\"所以按照题目要求切割两次，要么把金条分成三份，要么分成四份（第二次两块叠在一起）。所以前三块部分一定是按照1：2：4来分，因为加起来已经等于7了，所以只需要分成三分就够了。这道题目就这么简单。\"></a>所以按照题目要求切割两次，要么把金条分成三份，要么分成四份（第二次两块叠在一起）。所以前三块部分一定是按照1：2：4来分，因为加起来已经等于7了，所以只需要分成三分就够了。这道题目就这么简单。</h5><h5 id=\"这让我想到了另外一道题，将1000个球，放在10个箱子里。需要达到一种效果，就是任取1至1000的数字，能够从10个箱子中取出n个箱子，这n个箱子里面的球加起来刚好等于这个数字。这题和上面那题其实是一样的，没接触过一些算法的人会觉得特别难喝复杂，稍微认真想一想的童鞋也可以通过下面的方式得出答案：\"><a href=\"#这让我想到了另外一道题，将1000个球，放在10个箱子里。需要达到一种效果，就是任取1至1000的数字，能够从10个箱子中取出n个箱子，这n个箱子里面的球加起来刚好等于这个数字。这题和上面那题其实是一样的，没接触过一些算法的人会觉得特别难喝复杂，稍微认真想一想的童鞋也可以通过下面的方式得出答案：\" class=\"headerlink\" title=\"这让我想到了另外一道题，将1000个球，放在10个箱子里。需要达到一种效果，就是任取1至1000的数字，能够从10个箱子中取出n个箱子，这n个箱子里面的球加起来刚好等于这个数字。这题和上面那题其实是一样的，没接触过一些算法的人会觉得特别难喝复杂，稍微认真想一想的童鞋也可以通过下面的方式得出答案：\"></a>这让我想到了另外一道题，将1000个球，放在10个箱子里。需要达到一种效果，就是任取1至1000的数字，能够从10个箱子中取出n个箱子，这n个箱子里面的球加起来刚好等于这个数字。这题和上面那题其实是一样的，没接触过一些算法的人会觉得特别难喝复杂，稍微认真想一想的童鞋也可以通过下面的方式得出答案：</h5><h4 id=\"首先是取一个球的时候：\"><a href=\"#首先是取一个球的时候：\" class=\"headerlink\" title=\"首先是取一个球的时候：\"></a>首先是取一个球的时候：</h4><h5 id=\"所以一定有一个箱子里面是1个球。\"><a href=\"#所以一定有一个箱子里面是1个球。\" class=\"headerlink\" title=\"所以一定有一个箱子里面是1个球。\"></a>所以一定有一个箱子里面是1个球。</h5><h4 id=\"取两个球：\"><a href=\"#取两个球：\" class=\"headerlink\" title=\"取两个球：\"></a>取两个球：</h4><h5 id=\"前面那个箱子里是1个球，当需要两个球的时候，再添加一个一个球的箱子明显是不理智的，所以再拿一个箱子放两个球。\"><a href=\"#前面那个箱子里是1个球，当需要两个球的时候，再添加一个一个球的箱子明显是不理智的，所以再拿一个箱子放两个球。\" class=\"headerlink\" title=\"前面那个箱子里是1个球，当需要两个球的时候，再添加一个一个球的箱子明显是不理智的，所以再拿一个箱子放两个球。\"></a>前面那个箱子里是1个球，当需要两个球的时候，再添加一个一个球的箱子明显是不理智的，所以再拿一个箱子放两个球。</h5><h4 id=\"三个球：\"><a href=\"#三个球：\" class=\"headerlink\" title=\"三个球：\"></a>三个球：</h4><h5 id=\"前面两个箱子加起来刚好就是三个球，所以这种情况就已经包含在前面的答案里面了。\"><a href=\"#前面两个箱子加起来刚好就是三个球，所以这种情况就已经包含在前面的答案里面了。\" class=\"headerlink\" title=\"前面两个箱子加起来刚好就是三个球，所以这种情况就已经包含在前面的答案里面了。\"></a>前面两个箱子加起来刚好就是三个球，所以这种情况就已经包含在前面的答案里面了。</h5><h4 id=\"四个球呢：\"><a href=\"#四个球呢：\" class=\"headerlink\" title=\"四个球呢：\"></a>四个球呢：</h4><h5 id=\"之前两个箱子加起来才3个球，所以再拿一个箱子放4个球。\"><a href=\"#之前两个箱子加起来才3个球，所以再拿一个箱子放4个球。\" class=\"headerlink\" title=\"之前两个箱子加起来才3个球，所以再拿一个箱子放4个球。\"></a>之前两个箱子加起来才3个球，所以再拿一个箱子放4个球。</h5><h4 id=\"五个球，六个球，七个球之后的所有情况都按照这种逻辑推演下去，就可以得出答案\"><a href=\"#五个球，六个球，七个球之后的所有情况都按照这种逻辑推演下去，就可以得出答案\" class=\"headerlink\" title=\"五个球，六个球，七个球之后的所有情况都按照这种逻辑推演下去，就可以得出答案\"></a>五个球，六个球，七个球之后的所有情况都按照这种逻辑推演下去，就可以得出答案</h4><h5 id=\"按照1、2、4、8、16…这种规律放球，就能够做到题目的要求。切210-1024-所以10个箱子是能够支持这种放球的方式的。\"><a href=\"#按照1、2、4、8、16…这种规律放球，就能够做到题目的要求。切210-1024-所以10个箱子是能够支持这种放球的方式的。\" class=\"headerlink\" title=\"按照1、2、4、8、16…这种规律放球，就能够做到题目的要求。切210 = 1024,所以10个箱子是能够支持这种放球的方式的。\"></a>按照1、2、4、8、16…这种规律放球，就能够做到题目的要求。切2<sup>10</sup> = 1024,所以10个箱子是能够支持这种放球的方式的。</h5><h2 id=\"为什么这组数字这么神奇\"><a href=\"#为什么这组数字这么神奇\" class=\"headerlink\" title=\"为什么这组数字这么神奇\"></a>为什么这组数字这么神奇</h2><h5 id=\"1、2、4、8、16-可以组合成1到31之间的任意一个数，为什么会这么神奇。\"><a href=\"#1、2、4、8、16-可以组合成1到31之间的任意一个数，为什么会这么神奇。\" class=\"headerlink\" title=\"1、2、4、8、16 可以组合成1到31之间的任意一个数，为什么会这么神奇。\"></a>1、2、4、8、16 可以组合成1到31之间的任意一个数，为什么会这么神奇。</h5><h5 id=\"任何一个10进制数都可以转换成相应的二进制数。\"><a href=\"#任何一个10进制数都可以转换成相应的二进制数。\" class=\"headerlink\" title=\"任何一个10进制数都可以转换成相应的二进制数。\"></a>任何一个10进制数都可以转换成相应的二进制数。</h5><script type=\"math/tex; mode=display\">8\\qquad4\\qquad\\quad2\\qquad1</script><script type=\"math/tex; mode=display\">1000\\quad0100\\quad0010\\quad0001</script><h5 id=\"所以4位的2进制每一位转换成10进制分别是8、4、2、1。就好像4位的10进制每一位分别表示为千、百、十、个。但是你要是说把9999个球放到4个箱子里，任取一个数都能拿出n个箱子，加起来刚好是这个数。但是按照二进制的方法，4位二进制转换成10进制最多为15，所以15个球是能够实现这种规律的。\"><a href=\"#所以4位的2进制每一位转换成10进制分别是8、4、2、1。就好像4位的10进制每一位分别表示为千、百、十、个。但是你要是说把9999个球放到4个箱子里，任取一个数都能拿出n个箱子，加起来刚好是这个数。但是按照二进制的方法，4位二进制转换成10进制最多为15，所以15个球是能够实现这种规律的。\" class=\"headerlink\" title=\"所以4位的2进制每一位转换成10进制分别是8、4、2、1。就好像4位的10进制每一位分别表示为千、百、十、个。但是你要是说把9999个球放到4个箱子里，任取一个数都能拿出n个箱子，加起来刚好是这个数。但是按照二进制的方法，4位二进制转换成10进制最多为15，所以15个球是能够实现这种规律的。\"></a>所以4位的2进制每一位转换成10进制分别是8、4、2、1。就好像4位的10进制每一位分别表示为千、百、十、个。但是你要是说把9999个球放到4个箱子里，任取一个数都能拿出n个箱子，加起来刚好是这个数。但是按照二进制的方法，4位二进制转换成10进制最多为15，所以15个球是能够实现这种规律的。</h5><h5 id=\"能够达到这种神奇效果，是因为和二进制的特征有关，二进制只有0和1两个数字，这就表示二进制的每一位只有两种状态。我们可以简单的分为有（1）和没有（0）。所以4位的二进制，放到4个箱子里面，每个箱子分别放入对应的二进制位数表示的数，然后拿箱子表示为1，不拿表示为0，其实组合出来的结果就是一个二进制的数。而十进制的每一位则有10种状态之多，一个箱子要产生10种状态，以拿到不同的球数，在这道题里面是不存在的。\"><a href=\"#能够达到这种神奇效果，是因为和二进制的特征有关，二进制只有0和1两个数字，这就表示二进制的每一位只有两种状态。我们可以简单的分为有（1）和没有（0）。所以4位的二进制，放到4个箱子里面，每个箱子分别放入对应的二进制位数表示的数，然后拿箱子表示为1，不拿表示为0，其实组合出来的结果就是一个二进制的数。而十进制的每一位则有10种状态之多，一个箱子要产生10种状态，以拿到不同的球数，在这道题里面是不存在的。\" class=\"headerlink\" title=\"能够达到这种神奇效果，是因为和二进制的特征有关，二进制只有0和1两个数字，这就表示二进制的每一位只有两种状态。我们可以简单的分为有（1）和没有（0）。所以4位的二进制，放到4个箱子里面，每个箱子分别放入对应的二进制位数表示的数，然后拿箱子表示为1，不拿表示为0，其实组合出来的结果就是一个二进制的数。而十进制的每一位则有10种状态之多，一个箱子要产生10种状态，以拿到不同的球数，在这道题里面是不存在的。\"></a>能够达到这种神奇效果，是因为和二进制的特征有关，二进制只有0和1两个数字，这就表示二进制的每一位只有两种状态。我们可以简单的分为有（1）和没有（0）。所以4位的二进制，放到4个箱子里面，每个箱子分别放入对应的二进制位数表示的数，然后拿箱子表示为1，不拿表示为0，其实组合出来的结果就是一个二进制的数。而十进制的每一位则有10种状态之多，一个箱子要产生10种状态，以拿到不同的球数，在这道题里面是不存在的。</h5><h2 id=\"题外话\"><a href=\"#题外话\" class=\"headerlink\" title=\"题外话\"></a>题外话</h2><h5 id=\"其实计算机的计算依赖于二进制也和此有关，因为以前的计算机对信号的读取和产生并没有那么灵敏，它只能识别有或者没有，转换成二进制就是1和0，如果以16进制为基础，则需要区分信号的强弱，这对以前的系统灵敏度来说是比较难的。（意淫一下，如果现在重新以16进制为基础编写计算机底层，计算效率和传输效率是不是有质的飞越呢）。\"><a href=\"#其实计算机的计算依赖于二进制也和此有关，因为以前的计算机对信号的读取和产生并没有那么灵敏，它只能识别有或者没有，转换成二进制就是1和0，如果以16进制为基础，则需要区分信号的强弱，这对以前的系统灵敏度来说是比较难的。（意淫一下，如果现在重新以16进制为基础编写计算机底层，计算效率和传输效率是不是有质的飞越呢）。\" class=\"headerlink\" title=\"其实计算机的计算依赖于二进制也和此有关，因为以前的计算机对信号的读取和产生并没有那么灵敏，它只能识别有或者没有，转换成二进制就是1和0，如果以16进制为基础，则需要区分信号的强弱，这对以前的系统灵敏度来说是比较难的。（意淫一下，如果现在重新以16进制为基础编写计算机底层，计算效率和传输效率是不是有质的飞越呢）。\"></a>其实计算机的计算依赖于二进制也和此有关，因为以前的计算机对信号的读取和产生并没有那么灵敏，它只能识别有或者没有，转换成二进制就是1和0，如果以16进制为基础，则需要区分信号的强弱，这对以前的系统灵敏度来说是比较难的。（意淫一下，如果现在重新以16进制为基础编写计算机底层，计算效率和传输效率是不是有质的飞越呢）。</h5>","site":{"data":{}},"excerpt":"<h2 id=\"题目要求：\"><a href=\"#题目要求：\" class=\"headerlink\" title=\"题目要求：\"></a>题目要求：</h2><h5 id=\"你让一些人为你工作了七天，你要用一根金条作为报酬。金条被分成七小块，每天给出一块。如果你只能将金条切割两次，你怎样分给这些工人\"><a href=\"#你让一些人为你工作了七天，你要用一根金条作为报酬。金条被分成七小块，每天给出一块。如果你只能将金条切割两次，你怎样分给这些工人\" class=\"headerlink\" title=\"你让一些人为你工作了七天，你要用一根金条作为报酬。金条被分成七小块，每天给出一块。如果你只能将金条切割两次，你怎样分给这些工人?\"></a>你让一些人为你工作了七天，你要用一根金条作为报酬。金条被分成七小块，每天给出一块。如果你只能将金条切割两次，你怎样分给这些工人?</h5>","more":"<h2 id=\"分析过程：\"><a href=\"#分析过程：\" class=\"headerlink\" title=\"分析过程：\"></a>分析过程：</h2><h5 id=\"这道题目一看就知道要按照二进制的方式去分割，因为切分的块数比较少，所以后面几次的报酬一定是需要将之前的报酬拿回才能做到的。\"><a href=\"#这道题目一看就知道要按照二进制的方式去分割，因为切分的块数比较少，所以后面几次的报酬一定是需要将之前的报酬拿回才能做到的。\" class=\"headerlink\" title=\"这道题目一看就知道要按照二进制的方式去分割，因为切分的块数比较少，所以后面几次的报酬一定是需要将之前的报酬拿回才能做到的。\"></a>这道题目一看就知道要按照二进制的方式去分割，因为切分的块数比较少，所以后面几次的报酬一定是需要将之前的报酬拿回才能做到的。</h5><h5 id=\"所以按照题目要求切割两次，要么把金条分成三份，要么分成四份（第二次两块叠在一起）。所以前三块部分一定是按照1：2：4来分，因为加起来已经等于7了，所以只需要分成三分就够了。这道题目就这么简单。\"><a href=\"#所以按照题目要求切割两次，要么把金条分成三份，要么分成四份（第二次两块叠在一起）。所以前三块部分一定是按照1：2：4来分，因为加起来已经等于7了，所以只需要分成三分就够了。这道题目就这么简单。\" class=\"headerlink\" title=\"所以按照题目要求切割两次，要么把金条分成三份，要么分成四份（第二次两块叠在一起）。所以前三块部分一定是按照1：2：4来分，因为加起来已经等于7了，所以只需要分成三分就够了。这道题目就这么简单。\"></a>所以按照题目要求切割两次，要么把金条分成三份，要么分成四份（第二次两块叠在一起）。所以前三块部分一定是按照1：2：4来分，因为加起来已经等于7了，所以只需要分成三分就够了。这道题目就这么简单。</h5><h5 id=\"这让我想到了另外一道题，将1000个球，放在10个箱子里。需要达到一种效果，就是任取1至1000的数字，能够从10个箱子中取出n个箱子，这n个箱子里面的球加起来刚好等于这个数字。这题和上面那题其实是一样的，没接触过一些算法的人会觉得特别难喝复杂，稍微认真想一想的童鞋也可以通过下面的方式得出答案：\"><a href=\"#这让我想到了另外一道题，将1000个球，放在10个箱子里。需要达到一种效果，就是任取1至1000的数字，能够从10个箱子中取出n个箱子，这n个箱子里面的球加起来刚好等于这个数字。这题和上面那题其实是一样的，没接触过一些算法的人会觉得特别难喝复杂，稍微认真想一想的童鞋也可以通过下面的方式得出答案：\" class=\"headerlink\" title=\"这让我想到了另外一道题，将1000个球，放在10个箱子里。需要达到一种效果，就是任取1至1000的数字，能够从10个箱子中取出n个箱子，这n个箱子里面的球加起来刚好等于这个数字。这题和上面那题其实是一样的，没接触过一些算法的人会觉得特别难喝复杂，稍微认真想一想的童鞋也可以通过下面的方式得出答案：\"></a>这让我想到了另外一道题，将1000个球，放在10个箱子里。需要达到一种效果，就是任取1至1000的数字，能够从10个箱子中取出n个箱子，这n个箱子里面的球加起来刚好等于这个数字。这题和上面那题其实是一样的，没接触过一些算法的人会觉得特别难喝复杂，稍微认真想一想的童鞋也可以通过下面的方式得出答案：</h5><h4 id=\"首先是取一个球的时候：\"><a href=\"#首先是取一个球的时候：\" class=\"headerlink\" title=\"首先是取一个球的时候：\"></a>首先是取一个球的时候：</h4><h5 id=\"所以一定有一个箱子里面是1个球。\"><a href=\"#所以一定有一个箱子里面是1个球。\" class=\"headerlink\" title=\"所以一定有一个箱子里面是1个球。\"></a>所以一定有一个箱子里面是1个球。</h5><h4 id=\"取两个球：\"><a href=\"#取两个球：\" class=\"headerlink\" title=\"取两个球：\"></a>取两个球：</h4><h5 id=\"前面那个箱子里是1个球，当需要两个球的时候，再添加一个一个球的箱子明显是不理智的，所以再拿一个箱子放两个球。\"><a href=\"#前面那个箱子里是1个球，当需要两个球的时候，再添加一个一个球的箱子明显是不理智的，所以再拿一个箱子放两个球。\" class=\"headerlink\" title=\"前面那个箱子里是1个球，当需要两个球的时候，再添加一个一个球的箱子明显是不理智的，所以再拿一个箱子放两个球。\"></a>前面那个箱子里是1个球，当需要两个球的时候，再添加一个一个球的箱子明显是不理智的，所以再拿一个箱子放两个球。</h5><h4 id=\"三个球：\"><a href=\"#三个球：\" class=\"headerlink\" title=\"三个球：\"></a>三个球：</h4><h5 id=\"前面两个箱子加起来刚好就是三个球，所以这种情况就已经包含在前面的答案里面了。\"><a href=\"#前面两个箱子加起来刚好就是三个球，所以这种情况就已经包含在前面的答案里面了。\" class=\"headerlink\" title=\"前面两个箱子加起来刚好就是三个球，所以这种情况就已经包含在前面的答案里面了。\"></a>前面两个箱子加起来刚好就是三个球，所以这种情况就已经包含在前面的答案里面了。</h5><h4 id=\"四个球呢：\"><a href=\"#四个球呢：\" class=\"headerlink\" title=\"四个球呢：\"></a>四个球呢：</h4><h5 id=\"之前两个箱子加起来才3个球，所以再拿一个箱子放4个球。\"><a href=\"#之前两个箱子加起来才3个球，所以再拿一个箱子放4个球。\" class=\"headerlink\" title=\"之前两个箱子加起来才3个球，所以再拿一个箱子放4个球。\"></a>之前两个箱子加起来才3个球，所以再拿一个箱子放4个球。</h5><h4 id=\"五个球，六个球，七个球之后的所有情况都按照这种逻辑推演下去，就可以得出答案\"><a href=\"#五个球，六个球，七个球之后的所有情况都按照这种逻辑推演下去，就可以得出答案\" class=\"headerlink\" title=\"五个球，六个球，七个球之后的所有情况都按照这种逻辑推演下去，就可以得出答案\"></a>五个球，六个球，七个球之后的所有情况都按照这种逻辑推演下去，就可以得出答案</h4><h5 id=\"按照1、2、4、8、16…这种规律放球，就能够做到题目的要求。切210-1024-所以10个箱子是能够支持这种放球的方式的。\"><a href=\"#按照1、2、4、8、16…这种规律放球，就能够做到题目的要求。切210-1024-所以10个箱子是能够支持这种放球的方式的。\" class=\"headerlink\" title=\"按照1、2、4、8、16…这种规律放球，就能够做到题目的要求。切210 = 1024,所以10个箱子是能够支持这种放球的方式的。\"></a>按照1、2、4、8、16…这种规律放球，就能够做到题目的要求。切2<sup>10</sup> = 1024,所以10个箱子是能够支持这种放球的方式的。</h5><h2 id=\"为什么这组数字这么神奇\"><a href=\"#为什么这组数字这么神奇\" class=\"headerlink\" title=\"为什么这组数字这么神奇\"></a>为什么这组数字这么神奇</h2><h5 id=\"1、2、4、8、16-可以组合成1到31之间的任意一个数，为什么会这么神奇。\"><a href=\"#1、2、4、8、16-可以组合成1到31之间的任意一个数，为什么会这么神奇。\" class=\"headerlink\" title=\"1、2、4、8、16 可以组合成1到31之间的任意一个数，为什么会这么神奇。\"></a>1、2、4、8、16 可以组合成1到31之间的任意一个数，为什么会这么神奇。</h5><h5 id=\"任何一个10进制数都可以转换成相应的二进制数。\"><a href=\"#任何一个10进制数都可以转换成相应的二进制数。\" class=\"headerlink\" title=\"任何一个10进制数都可以转换成相应的二进制数。\"></a>任何一个10进制数都可以转换成相应的二进制数。</h5><script type=\"math/tex; mode=display\">8\\qquad4\\qquad\\quad2\\qquad1</script><script type=\"math/tex; mode=display\">1000\\quad0100\\quad0010\\quad0001</script><h5 id=\"所以4位的2进制每一位转换成10进制分别是8、4、2、1。就好像4位的10进制每一位分别表示为千、百、十、个。但是你要是说把9999个球放到4个箱子里，任取一个数都能拿出n个箱子，加起来刚好是这个数。但是按照二进制的方法，4位二进制转换成10进制最多为15，所以15个球是能够实现这种规律的。\"><a href=\"#所以4位的2进制每一位转换成10进制分别是8、4、2、1。就好像4位的10进制每一位分别表示为千、百、十、个。但是你要是说把9999个球放到4个箱子里，任取一个数都能拿出n个箱子，加起来刚好是这个数。但是按照二进制的方法，4位二进制转换成10进制最多为15，所以15个球是能够实现这种规律的。\" class=\"headerlink\" title=\"所以4位的2进制每一位转换成10进制分别是8、4、2、1。就好像4位的10进制每一位分别表示为千、百、十、个。但是你要是说把9999个球放到4个箱子里，任取一个数都能拿出n个箱子，加起来刚好是这个数。但是按照二进制的方法，4位二进制转换成10进制最多为15，所以15个球是能够实现这种规律的。\"></a>所以4位的2进制每一位转换成10进制分别是8、4、2、1。就好像4位的10进制每一位分别表示为千、百、十、个。但是你要是说把9999个球放到4个箱子里，任取一个数都能拿出n个箱子，加起来刚好是这个数。但是按照二进制的方法，4位二进制转换成10进制最多为15，所以15个球是能够实现这种规律的。</h5><h5 id=\"能够达到这种神奇效果，是因为和二进制的特征有关，二进制只有0和1两个数字，这就表示二进制的每一位只有两种状态。我们可以简单的分为有（1）和没有（0）。所以4位的二进制，放到4个箱子里面，每个箱子分别放入对应的二进制位数表示的数，然后拿箱子表示为1，不拿表示为0，其实组合出来的结果就是一个二进制的数。而十进制的每一位则有10种状态之多，一个箱子要产生10种状态，以拿到不同的球数，在这道题里面是不存在的。\"><a href=\"#能够达到这种神奇效果，是因为和二进制的特征有关，二进制只有0和1两个数字，这就表示二进制的每一位只有两种状态。我们可以简单的分为有（1）和没有（0）。所以4位的二进制，放到4个箱子里面，每个箱子分别放入对应的二进制位数表示的数，然后拿箱子表示为1，不拿表示为0，其实组合出来的结果就是一个二进制的数。而十进制的每一位则有10种状态之多，一个箱子要产生10种状态，以拿到不同的球数，在这道题里面是不存在的。\" class=\"headerlink\" title=\"能够达到这种神奇效果，是因为和二进制的特征有关，二进制只有0和1两个数字，这就表示二进制的每一位只有两种状态。我们可以简单的分为有（1）和没有（0）。所以4位的二进制，放到4个箱子里面，每个箱子分别放入对应的二进制位数表示的数，然后拿箱子表示为1，不拿表示为0，其实组合出来的结果就是一个二进制的数。而十进制的每一位则有10种状态之多，一个箱子要产生10种状态，以拿到不同的球数，在这道题里面是不存在的。\"></a>能够达到这种神奇效果，是因为和二进制的特征有关，二进制只有0和1两个数字，这就表示二进制的每一位只有两种状态。我们可以简单的分为有（1）和没有（0）。所以4位的二进制，放到4个箱子里面，每个箱子分别放入对应的二进制位数表示的数，然后拿箱子表示为1，不拿表示为0，其实组合出来的结果就是一个二进制的数。而十进制的每一位则有10种状态之多，一个箱子要产生10种状态，以拿到不同的球数，在这道题里面是不存在的。</h5><h2 id=\"题外话\"><a href=\"#题外话\" class=\"headerlink\" title=\"题外话\"></a>题外话</h2><h5 id=\"其实计算机的计算依赖于二进制也和此有关，因为以前的计算机对信号的读取和产生并没有那么灵敏，它只能识别有或者没有，转换成二进制就是1和0，如果以16进制为基础，则需要区分信号的强弱，这对以前的系统灵敏度来说是比较难的。（意淫一下，如果现在重新以16进制为基础编写计算机底层，计算效率和传输效率是不是有质的飞越呢）。\"><a href=\"#其实计算机的计算依赖于二进制也和此有关，因为以前的计算机对信号的读取和产生并没有那么灵敏，它只能识别有或者没有，转换成二进制就是1和0，如果以16进制为基础，则需要区分信号的强弱，这对以前的系统灵敏度来说是比较难的。（意淫一下，如果现在重新以16进制为基础编写计算机底层，计算效率和传输效率是不是有质的飞越呢）。\" class=\"headerlink\" title=\"其实计算机的计算依赖于二进制也和此有关，因为以前的计算机对信号的读取和产生并没有那么灵敏，它只能识别有或者没有，转换成二进制就是1和0，如果以16进制为基础，则需要区分信号的强弱，这对以前的系统灵敏度来说是比较难的。（意淫一下，如果现在重新以16进制为基础编写计算机底层，计算效率和传输效率是不是有质的飞越呢）。\"></a>其实计算机的计算依赖于二进制也和此有关，因为以前的计算机对信号的读取和产生并没有那么灵敏，它只能识别有或者没有，转换成二进制就是1和0，如果以16进制为基础，则需要区分信号的强弱，这对以前的系统灵敏度来说是比较难的。（意淫一下，如果现在重新以16进制为基础编写计算机底层，计算效率和传输效率是不是有质的飞越呢）。</h5>"},{"layout":"post","title":"KMeans聚类算法","date":"2018-04-12T16:00:00.000Z","original":true,"tag":[["算法","arithmetic"]],"_content":"\ntodo","source":"_posts/note/arithmetic/kmeans.md","raw":"---\nlayout: post\ntitle: KMeans聚类算法\ndate: 2018/04/13\noriginal: true\ntags: [tech, arithmetic, index]\ntag: [[算法, arithmetic]]\n---\n\ntodo","slug":"note/arithmetic/kmeans","published":1,"updated":"2018-05-08T13:00:14.274Z","comments":1,"photos":[],"link":"","_id":"cjgxop3n5002ujah1uo4ej4fq","content":"<p>todo</p>\n","site":{"data":{}},"excerpt":"","more":"<p>todo</p>\n"},{"layout":"post","title":"左旋转字符串","date":"2017-03-05T16:00:00.000Z","original":true,"tag":[["算法","arithmetic"]],"_content":"\n## 题目要求：\n##### 定义字符串的左旋转操作：把字符串前面的若干个字符移动到字符串的尾部。\n##### 如把字符串abcdef左旋转2位得到字符串cdefab。请实现字符串左旋转的函数。\n##### 要求时间对长度为n的字符串操作的复杂度为O(n)，辅助内存为O(1)。\n<!--more-->\n\n## 分析过程：\n#####  题目要求很简单，其实就是字符串的位置交换，一个长度为n的字符串，将字符串的前面m个字符的子串和后面的字符进行位置交换。如果用普通的java代码进行编写的话，会非常简单\n\n```JAVA\nString result = start.substring(m,n) + start.substring(0, m);\n```\n\n##### java对数组的复制使用System.arraycopy的本地方法， 以这种方式实现的话，时间复杂度是符合O(n)要求的，但是空间复杂度却要大于O(1)。这明显是不符合题意的。\n##### 首先，能够想到的是，字符串的左旋转，其实就是对字符数组的左旋转。既然是对数组的位置交换，则数组的每个位置的字符在交换之后的位置是已经确定的，并且能够找到一定的规律的。比如题目中的例子，把字符串abcdef左旋转2位得到字符串cdefab；\n##### 假设字符串的数组为arry,字符串的长度为6（n=6），左旋转2位（m=2），则数组中每一位的位置相应的转换为\n###### a:array[0] -> array[0+4] -> array[4]\n###### b:array[1] -> array[1+4] -> array[5]\n###### c:array[2] -> array[2-2] -> array[0]\n###### d:array[3] -> array[3-2] -> array[1]\n###### e:array[4] -> array[4-2] -> array[2]\n###### f:array[5] -> array[5-2] -> array[3]\n##### 可以看出，字符位置的交换是很有规律的，对于字符长度为n，左旋m位的数组\n1. 前面m个字符，左旋后的位置为i+(n-m)\n2. 后面n-m个字符，左旋后的位置为j-m\n\n#### 基于这套交换逻辑，想要实现如下算法，却发现不符合题目要求：\n##### 1. 初始字符串为abcdef，左旋转2位得到字符串cdefab\n<table><tr>\n<td>&nbsp;a&nbsp;</td>\n<td>&nbsp;b&nbsp;</td>\n<td>&nbsp;c&nbsp;</td>\n<td>&nbsp;d&nbsp;</td>\n<td>&nbsp;e&nbsp;</td>\n<td>&nbsp;f&nbsp;</td>\n</tr></table>\n\n##### 2. 将array[0]写入到到array[4]， 用tmp记录array[4]\n<table><tr>\n<td>&nbsp;a&nbsp;</td>\n<td>&nbsp;b&nbsp;</td>\n<td>&nbsp;c&nbsp;</td>\n<td>&nbsp;d&nbsp;</td>\n<td>&nbsp;<font color='red'>a</font>&nbsp;</td>\n<td>&nbsp;f&nbsp;</td>\n</tr></table>\n\n　　　tmp = e\n\n##### 3. 将array[4]写入到到array[2]， 用tmp记录array[2]\n<table><tr>\n<td>&nbsp;a&nbsp;</td>\n<td>&nbsp;b&nbsp;</td>\n<td>&nbsp;<font color='red'>e</font>&nbsp;</td>\n<td>&nbsp;d&nbsp;</td>\n<td>&nbsp;a&nbsp;</td>\n<td>&nbsp;f&nbsp;</td>\n</tr></table>\n\n　　　tmp = c\n\n##### 4. 将array[2]写入到到array[0]， 用tmp记录array[0]\n<table><tr>\n<td>&nbsp;<font color='red'>c</font>&nbsp;</td>\n<td>&nbsp;b&nbsp;</td>\n<td>&nbsp;e&nbsp;</td>\n<td>&nbsp;d&nbsp;</td>\n<td>&nbsp;a&nbsp;</td>\n<td>&nbsp;f&nbsp;</td>\n</tr></table>\n\n　　　tmp = a\n\n##### 问题就出在第四步，回到起点后，继续交换显然是错误的，这就需要额外的空间去记录那些位置是已经交换的，并且需要的额外空间随着原始字符串长度的增加而线性增长，所以这种方式的空间复杂度为O(n),不符合O(1)的要求。\n\n#### 于是想到的另外一种解题方式，依次将数组元素与之后的第m位交换：\n##### 1. 初始字符串为abcdef，\n<table><tr>\n<td>&nbsp;a&nbsp;</td>\n<td>&nbsp;b&nbsp;</td>\n<td>&nbsp;c&nbsp;</td>\n<td>&nbsp;d&nbsp;</td>\n<td>&nbsp;e&nbsp;</td>\n<td>&nbsp;f&nbsp;</td>\n</tr></table>\n\n##### 2. 将array[0]与array[2]交换\n\n<table><tr>\n<td>&nbsp;<font color='red'>c</font>&nbsp;</td>\n<td>&nbsp;b&nbsp;</td>\n<td>&nbsp;<font color='red'>a</font>&nbsp;</td>\n<td>&nbsp;d&nbsp;</td>\n<td>&nbsp;e&nbsp;</td>\n<td>&nbsp;f&nbsp;</td>\n</tr></table>\n\n##### 3.  将array[1]与array[3]交换\n<table><tr>\n<td>&nbsp;c&nbsp;</td>\n<td>&nbsp;<font color='red'>d</font>&nbsp;</td>\n<td>&nbsp;a&nbsp;</td>\n<td>&nbsp;<font color='red'>b</font>&nbsp;</td>\n<td>&nbsp;e&nbsp;</td>\n<td>&nbsp;f&nbsp;</td>\n</tr></table>\n\n##### 4. 将array[2]与array[4]交换\n<table><tr>\n<td>&nbsp;c&nbsp;</td>\n<td>&nbsp;d&nbsp;</td>\n<td>&nbsp;<font color='red'>e</font>&nbsp;</td>\n<td>&nbsp;b&nbsp;</td>\n<td>&nbsp;<font color='red'>a</font>&nbsp;</td>\n<td>&nbsp;f&nbsp;</td>\n</tr></table>\n\n##### 5. 将array[3]与array[5]交换\n<table><tr>\n<td>&nbsp;c&nbsp;</td>\n<td>&nbsp;d&nbsp;</td>\n<td>&nbsp;e&nbsp;</td>\n<td>&nbsp;<font color='red'>f</font>&nbsp;</td>\n<td>&nbsp;a&nbsp;</td>\n<td>&nbsp;<font color='red'>b</font>&nbsp;</td>\n</tr></table>\n\n##### 这种实现方式需要进行n-m次交换，时间复杂度为O(n),需要两个额外空间，分别是交换数组元素的tmp指针，和记录当前交换位置的指针，这也符合常数空间复杂度O(1)。\n\n## 解题：\n#### 看了网络上的一些其他解法，也比较巧妙:\n1. 首先将原字符串分为两个部分，即X:ab，Y:cdef；\n2. 将X反转，X->X^T，即得：ab->ba；将Y反转，Y->Y^T，即得：cdef->fedc。\n3. 反转上述步骤得到的结果字符串X^TY^T，即反转字符串bafedc的两部分（ba和fedc）给予反转，bafedc得到cdefab，形式化表示为(X^TY^T)^T=YX，这就实现了整个反转。\n\n```C\nvoid ReverseString(char* s,int from,int to)\n{\n    while (from < to)\n    {\n        char t = s[from];\n        s[from++] = s[to];\n        s[to--] = t;\n    }\n}\n\nvoid LeftRotateString(char* s,int n,int m)\n{\n    m %= n;               //若要左移动大于n位，那么和%n 是等价的\n    ReverseString(s, 0, m - 1); //反转[0..m - 1]，套用到上面举的例子中，就是X->X^T，即 abc->cba\n    ReverseString(s, m, n - 1); //反转[m..n - 1]，例如Y->Y^T，即 def->fed\n    ReverseString(s, 0, n - 1); //反转[0..n - 1]，即如整个反转，(X^TY^T)^T=YX，即 cbafed->defabc。\n}\n```\n\n##### 调用3次此方法即可左旋字符串\n\n## 最后再说一些：\n##### 对于时间复杂度和空间复杂度的计算，需要去低阶项，去掉常数项，去掉高阶项，T(n)=(2n<sup>2</sup>+n+1)=O(n<sup>2</sup>);若执行时间是一个与问题规模n无关的常数，算法的时间复杂度为常数阶，记作T(n)=O(1)。\n\n### 参考链接：\n[http://taop.marchtea.com/01.01.html](http://taop.marchtea.com/01.01.html)","source":"_posts/note/arithmetic/leftString.md","raw":"---\nlayout: post\ntitle: 左旋转字符串\ndate: 2017/03/06\ntags: [tech, arithmetic, index]\noriginal: true\ntag: [[算法, arithmetic]]\n---\n\n## 题目要求：\n##### 定义字符串的左旋转操作：把字符串前面的若干个字符移动到字符串的尾部。\n##### 如把字符串abcdef左旋转2位得到字符串cdefab。请实现字符串左旋转的函数。\n##### 要求时间对长度为n的字符串操作的复杂度为O(n)，辅助内存为O(1)。\n<!--more-->\n\n## 分析过程：\n#####  题目要求很简单，其实就是字符串的位置交换，一个长度为n的字符串，将字符串的前面m个字符的子串和后面的字符进行位置交换。如果用普通的java代码进行编写的话，会非常简单\n\n```JAVA\nString result = start.substring(m,n) + start.substring(0, m);\n```\n\n##### java对数组的复制使用System.arraycopy的本地方法， 以这种方式实现的话，时间复杂度是符合O(n)要求的，但是空间复杂度却要大于O(1)。这明显是不符合题意的。\n##### 首先，能够想到的是，字符串的左旋转，其实就是对字符数组的左旋转。既然是对数组的位置交换，则数组的每个位置的字符在交换之后的位置是已经确定的，并且能够找到一定的规律的。比如题目中的例子，把字符串abcdef左旋转2位得到字符串cdefab；\n##### 假设字符串的数组为arry,字符串的长度为6（n=6），左旋转2位（m=2），则数组中每一位的位置相应的转换为\n###### a:array[0] -> array[0+4] -> array[4]\n###### b:array[1] -> array[1+4] -> array[5]\n###### c:array[2] -> array[2-2] -> array[0]\n###### d:array[3] -> array[3-2] -> array[1]\n###### e:array[4] -> array[4-2] -> array[2]\n###### f:array[5] -> array[5-2] -> array[3]\n##### 可以看出，字符位置的交换是很有规律的，对于字符长度为n，左旋m位的数组\n1. 前面m个字符，左旋后的位置为i+(n-m)\n2. 后面n-m个字符，左旋后的位置为j-m\n\n#### 基于这套交换逻辑，想要实现如下算法，却发现不符合题目要求：\n##### 1. 初始字符串为abcdef，左旋转2位得到字符串cdefab\n<table><tr>\n<td>&nbsp;a&nbsp;</td>\n<td>&nbsp;b&nbsp;</td>\n<td>&nbsp;c&nbsp;</td>\n<td>&nbsp;d&nbsp;</td>\n<td>&nbsp;e&nbsp;</td>\n<td>&nbsp;f&nbsp;</td>\n</tr></table>\n\n##### 2. 将array[0]写入到到array[4]， 用tmp记录array[4]\n<table><tr>\n<td>&nbsp;a&nbsp;</td>\n<td>&nbsp;b&nbsp;</td>\n<td>&nbsp;c&nbsp;</td>\n<td>&nbsp;d&nbsp;</td>\n<td>&nbsp;<font color='red'>a</font>&nbsp;</td>\n<td>&nbsp;f&nbsp;</td>\n</tr></table>\n\n　　　tmp = e\n\n##### 3. 将array[4]写入到到array[2]， 用tmp记录array[2]\n<table><tr>\n<td>&nbsp;a&nbsp;</td>\n<td>&nbsp;b&nbsp;</td>\n<td>&nbsp;<font color='red'>e</font>&nbsp;</td>\n<td>&nbsp;d&nbsp;</td>\n<td>&nbsp;a&nbsp;</td>\n<td>&nbsp;f&nbsp;</td>\n</tr></table>\n\n　　　tmp = c\n\n##### 4. 将array[2]写入到到array[0]， 用tmp记录array[0]\n<table><tr>\n<td>&nbsp;<font color='red'>c</font>&nbsp;</td>\n<td>&nbsp;b&nbsp;</td>\n<td>&nbsp;e&nbsp;</td>\n<td>&nbsp;d&nbsp;</td>\n<td>&nbsp;a&nbsp;</td>\n<td>&nbsp;f&nbsp;</td>\n</tr></table>\n\n　　　tmp = a\n\n##### 问题就出在第四步，回到起点后，继续交换显然是错误的，这就需要额外的空间去记录那些位置是已经交换的，并且需要的额外空间随着原始字符串长度的增加而线性增长，所以这种方式的空间复杂度为O(n),不符合O(1)的要求。\n\n#### 于是想到的另外一种解题方式，依次将数组元素与之后的第m位交换：\n##### 1. 初始字符串为abcdef，\n<table><tr>\n<td>&nbsp;a&nbsp;</td>\n<td>&nbsp;b&nbsp;</td>\n<td>&nbsp;c&nbsp;</td>\n<td>&nbsp;d&nbsp;</td>\n<td>&nbsp;e&nbsp;</td>\n<td>&nbsp;f&nbsp;</td>\n</tr></table>\n\n##### 2. 将array[0]与array[2]交换\n\n<table><tr>\n<td>&nbsp;<font color='red'>c</font>&nbsp;</td>\n<td>&nbsp;b&nbsp;</td>\n<td>&nbsp;<font color='red'>a</font>&nbsp;</td>\n<td>&nbsp;d&nbsp;</td>\n<td>&nbsp;e&nbsp;</td>\n<td>&nbsp;f&nbsp;</td>\n</tr></table>\n\n##### 3.  将array[1]与array[3]交换\n<table><tr>\n<td>&nbsp;c&nbsp;</td>\n<td>&nbsp;<font color='red'>d</font>&nbsp;</td>\n<td>&nbsp;a&nbsp;</td>\n<td>&nbsp;<font color='red'>b</font>&nbsp;</td>\n<td>&nbsp;e&nbsp;</td>\n<td>&nbsp;f&nbsp;</td>\n</tr></table>\n\n##### 4. 将array[2]与array[4]交换\n<table><tr>\n<td>&nbsp;c&nbsp;</td>\n<td>&nbsp;d&nbsp;</td>\n<td>&nbsp;<font color='red'>e</font>&nbsp;</td>\n<td>&nbsp;b&nbsp;</td>\n<td>&nbsp;<font color='red'>a</font>&nbsp;</td>\n<td>&nbsp;f&nbsp;</td>\n</tr></table>\n\n##### 5. 将array[3]与array[5]交换\n<table><tr>\n<td>&nbsp;c&nbsp;</td>\n<td>&nbsp;d&nbsp;</td>\n<td>&nbsp;e&nbsp;</td>\n<td>&nbsp;<font color='red'>f</font>&nbsp;</td>\n<td>&nbsp;a&nbsp;</td>\n<td>&nbsp;<font color='red'>b</font>&nbsp;</td>\n</tr></table>\n\n##### 这种实现方式需要进行n-m次交换，时间复杂度为O(n),需要两个额外空间，分别是交换数组元素的tmp指针，和记录当前交换位置的指针，这也符合常数空间复杂度O(1)。\n\n## 解题：\n#### 看了网络上的一些其他解法，也比较巧妙:\n1. 首先将原字符串分为两个部分，即X:ab，Y:cdef；\n2. 将X反转，X->X^T，即得：ab->ba；将Y反转，Y->Y^T，即得：cdef->fedc。\n3. 反转上述步骤得到的结果字符串X^TY^T，即反转字符串bafedc的两部分（ba和fedc）给予反转，bafedc得到cdefab，形式化表示为(X^TY^T)^T=YX，这就实现了整个反转。\n\n```C\nvoid ReverseString(char* s,int from,int to)\n{\n    while (from < to)\n    {\n        char t = s[from];\n        s[from++] = s[to];\n        s[to--] = t;\n    }\n}\n\nvoid LeftRotateString(char* s,int n,int m)\n{\n    m %= n;               //若要左移动大于n位，那么和%n 是等价的\n    ReverseString(s, 0, m - 1); //反转[0..m - 1]，套用到上面举的例子中，就是X->X^T，即 abc->cba\n    ReverseString(s, m, n - 1); //反转[m..n - 1]，例如Y->Y^T，即 def->fed\n    ReverseString(s, 0, n - 1); //反转[0..n - 1]，即如整个反转，(X^TY^T)^T=YX，即 cbafed->defabc。\n}\n```\n\n##### 调用3次此方法即可左旋字符串\n\n## 最后再说一些：\n##### 对于时间复杂度和空间复杂度的计算，需要去低阶项，去掉常数项，去掉高阶项，T(n)=(2n<sup>2</sup>+n+1)=O(n<sup>2</sup>);若执行时间是一个与问题规模n无关的常数，算法的时间复杂度为常数阶，记作T(n)=O(1)。\n\n### 参考链接：\n[http://taop.marchtea.com/01.01.html](http://taop.marchtea.com/01.01.html)","slug":"note/arithmetic/leftString","published":1,"updated":"2018-05-08T13:00:14.274Z","comments":1,"photos":[],"link":"","_id":"cjgxop3n6002wjah1q41yrj0t","content":"<h2 id=\"题目要求：\"><a href=\"#题目要求：\" class=\"headerlink\" title=\"题目要求：\"></a>题目要求：</h2><h5 id=\"定义字符串的左旋转操作：把字符串前面的若干个字符移动到字符串的尾部。\"><a href=\"#定义字符串的左旋转操作：把字符串前面的若干个字符移动到字符串的尾部。\" class=\"headerlink\" title=\"定义字符串的左旋转操作：把字符串前面的若干个字符移动到字符串的尾部。\"></a>定义字符串的左旋转操作：把字符串前面的若干个字符移动到字符串的尾部。</h5><h5 id=\"如把字符串abcdef左旋转2位得到字符串cdefab。请实现字符串左旋转的函数。\"><a href=\"#如把字符串abcdef左旋转2位得到字符串cdefab。请实现字符串左旋转的函数。\" class=\"headerlink\" title=\"如把字符串abcdef左旋转2位得到字符串cdefab。请实现字符串左旋转的函数。\"></a>如把字符串abcdef左旋转2位得到字符串cdefab。请实现字符串左旋转的函数。</h5><h5 id=\"要求时间对长度为n的字符串操作的复杂度为O-n-，辅助内存为O-1-。\"><a href=\"#要求时间对长度为n的字符串操作的复杂度为O-n-，辅助内存为O-1-。\" class=\"headerlink\" title=\"要求时间对长度为n的字符串操作的复杂度为O(n)，辅助内存为O(1)。\"></a>要求时间对长度为n的字符串操作的复杂度为O(n)，辅助内存为O(1)。</h5><a id=\"more\"></a>\n<h2 id=\"分析过程：\"><a href=\"#分析过程：\" class=\"headerlink\" title=\"分析过程：\"></a>分析过程：</h2><h5 id=\"题目要求很简单，其实就是字符串的位置交换，一个长度为n的字符串，将字符串的前面m个字符的子串和后面的字符进行位置交换。如果用普通的java代码进行编写的话，会非常简单\"><a href=\"#题目要求很简单，其实就是字符串的位置交换，一个长度为n的字符串，将字符串的前面m个字符的子串和后面的字符进行位置交换。如果用普通的java代码进行编写的话，会非常简单\" class=\"headerlink\" title=\"题目要求很简单，其实就是字符串的位置交换，一个长度为n的字符串，将字符串的前面m个字符的子串和后面的字符进行位置交换。如果用普通的java代码进行编写的话，会非常简单\"></a>题目要求很简单，其实就是字符串的位置交换，一个长度为n的字符串，将字符串的前面m个字符的子串和后面的字符进行位置交换。如果用普通的java代码进行编写的话，会非常简单</h5><pre><code class=\"lang-JAVA\">String result = start.substring(m,n) + start.substring(0, m);\n</code></pre>\n<h5 id=\"java对数组的复制使用System-arraycopy的本地方法，-以这种方式实现的话，时间复杂度是符合O-n-要求的，但是空间复杂度却要大于O-1-。这明显是不符合题意的。\"><a href=\"#java对数组的复制使用System-arraycopy的本地方法，-以这种方式实现的话，时间复杂度是符合O-n-要求的，但是空间复杂度却要大于O-1-。这明显是不符合题意的。\" class=\"headerlink\" title=\"java对数组的复制使用System.arraycopy的本地方法， 以这种方式实现的话，时间复杂度是符合O(n)要求的，但是空间复杂度却要大于O(1)。这明显是不符合题意的。\"></a>java对数组的复制使用System.arraycopy的本地方法， 以这种方式实现的话，时间复杂度是符合O(n)要求的，但是空间复杂度却要大于O(1)。这明显是不符合题意的。</h5><h5 id=\"首先，能够想到的是，字符串的左旋转，其实就是对字符数组的左旋转。既然是对数组的位置交换，则数组的每个位置的字符在交换之后的位置是已经确定的，并且能够找到一定的规律的。比如题目中的例子，把字符串abcdef左旋转2位得到字符串cdefab；\"><a href=\"#首先，能够想到的是，字符串的左旋转，其实就是对字符数组的左旋转。既然是对数组的位置交换，则数组的每个位置的字符在交换之后的位置是已经确定的，并且能够找到一定的规律的。比如题目中的例子，把字符串abcdef左旋转2位得到字符串cdefab；\" class=\"headerlink\" title=\"首先，能够想到的是，字符串的左旋转，其实就是对字符数组的左旋转。既然是对数组的位置交换，则数组的每个位置的字符在交换之后的位置是已经确定的，并且能够找到一定的规律的。比如题目中的例子，把字符串abcdef左旋转2位得到字符串cdefab；\"></a>首先，能够想到的是，字符串的左旋转，其实就是对字符数组的左旋转。既然是对数组的位置交换，则数组的每个位置的字符在交换之后的位置是已经确定的，并且能够找到一定的规律的。比如题目中的例子，把字符串abcdef左旋转2位得到字符串cdefab；</h5><h5 id=\"假设字符串的数组为arry-字符串的长度为6（n-6），左旋转2位（m-2），则数组中每一位的位置相应的转换为\"><a href=\"#假设字符串的数组为arry-字符串的长度为6（n-6），左旋转2位（m-2），则数组中每一位的位置相应的转换为\" class=\"headerlink\" title=\"假设字符串的数组为arry,字符串的长度为6（n=6），左旋转2位（m=2），则数组中每一位的位置相应的转换为\"></a>假设字符串的数组为arry,字符串的长度为6（n=6），左旋转2位（m=2），则数组中每一位的位置相应的转换为</h5><h6 id=\"a-array-0-gt-array-0-4-gt-array-4\"><a href=\"#a-array-0-gt-array-0-4-gt-array-4\" class=\"headerlink\" title=\"a:array[0] -&gt; array[0+4] -&gt; array[4]\"></a>a:array[0] -&gt; array[0+4] -&gt; array[4]</h6><h6 id=\"b-array-1-gt-array-1-4-gt-array-5\"><a href=\"#b-array-1-gt-array-1-4-gt-array-5\" class=\"headerlink\" title=\"b:array[1] -&gt; array[1+4] -&gt; array[5]\"></a>b:array[1] -&gt; array[1+4] -&gt; array[5]</h6><h6 id=\"c-array-2-gt-array-2-2-gt-array-0\"><a href=\"#c-array-2-gt-array-2-2-gt-array-0\" class=\"headerlink\" title=\"c:array[2] -&gt; array[2-2] -&gt; array[0]\"></a>c:array[2] -&gt; array[2-2] -&gt; array[0]</h6><h6 id=\"d-array-3-gt-array-3-2-gt-array-1\"><a href=\"#d-array-3-gt-array-3-2-gt-array-1\" class=\"headerlink\" title=\"d:array[3] -&gt; array[3-2] -&gt; array[1]\"></a>d:array[3] -&gt; array[3-2] -&gt; array[1]</h6><h6 id=\"e-array-4-gt-array-4-2-gt-array-2\"><a href=\"#e-array-4-gt-array-4-2-gt-array-2\" class=\"headerlink\" title=\"e:array[4] -&gt; array[4-2] -&gt; array[2]\"></a>e:array[4] -&gt; array[4-2] -&gt; array[2]</h6><h6 id=\"f-array-5-gt-array-5-2-gt-array-3\"><a href=\"#f-array-5-gt-array-5-2-gt-array-3\" class=\"headerlink\" title=\"f:array[5] -&gt; array[5-2] -&gt; array[3]\"></a>f:array[5] -&gt; array[5-2] -&gt; array[3]</h6><h5 id=\"可以看出，字符位置的交换是很有规律的，对于字符长度为n，左旋m位的数组\"><a href=\"#可以看出，字符位置的交换是很有规律的，对于字符长度为n，左旋m位的数组\" class=\"headerlink\" title=\"可以看出，字符位置的交换是很有规律的，对于字符长度为n，左旋m位的数组\"></a>可以看出，字符位置的交换是很有规律的，对于字符长度为n，左旋m位的数组</h5><ol>\n<li>前面m个字符，左旋后的位置为i+(n-m)</li>\n<li>后面n-m个字符，左旋后的位置为j-m</li>\n</ol>\n<h4 id=\"基于这套交换逻辑，想要实现如下算法，却发现不符合题目要求：\"><a href=\"#基于这套交换逻辑，想要实现如下算法，却发现不符合题目要求：\" class=\"headerlink\" title=\"基于这套交换逻辑，想要实现如下算法，却发现不符合题目要求：\"></a>基于这套交换逻辑，想要实现如下算法，却发现不符合题目要求：</h4><h5 id=\"1-初始字符串为abcdef，左旋转2位得到字符串cdefab\"><a href=\"#1-初始字符串为abcdef，左旋转2位得到字符串cdefab\" class=\"headerlink\" title=\"1. 初始字符串为abcdef，左旋转2位得到字符串cdefab\"></a>1. 初始字符串为abcdef，左旋转2位得到字符串cdefab</h5><table><tr>\n<td>&nbsp;a&nbsp;</td>\n<td>&nbsp;b&nbsp;</td>\n<td>&nbsp;c&nbsp;</td>\n<td>&nbsp;d&nbsp;</td>\n<td>&nbsp;e&nbsp;</td>\n<td>&nbsp;f&nbsp;</td>\n</tr></table>\n\n<h5 id=\"2-将array-0-写入到到array-4-，-用tmp记录array-4\"><a href=\"#2-将array-0-写入到到array-4-，-用tmp记录array-4\" class=\"headerlink\" title=\"2. 将array[0]写入到到array[4]， 用tmp记录array[4]\"></a>2. 将array[0]写入到到array[4]， 用tmp记录array[4]</h5><table><tr>\n<td>&nbsp;a&nbsp;</td>\n<td>&nbsp;b&nbsp;</td>\n<td>&nbsp;c&nbsp;</td>\n<td>&nbsp;d&nbsp;</td>\n<td>&nbsp;<font color=\"red\">a</font>&nbsp;</td>\n<td>&nbsp;f&nbsp;</td>\n</tr></table>\n\n<p>　　　tmp = e</p>\n<h5 id=\"3-将array-4-写入到到array-2-，-用tmp记录array-2\"><a href=\"#3-将array-4-写入到到array-2-，-用tmp记录array-2\" class=\"headerlink\" title=\"3. 将array[4]写入到到array[2]， 用tmp记录array[2]\"></a>3. 将array[4]写入到到array[2]， 用tmp记录array[2]</h5><table><tr>\n<td>&nbsp;a&nbsp;</td>\n<td>&nbsp;b&nbsp;</td>\n<td>&nbsp;<font color=\"red\">e</font>&nbsp;</td>\n<td>&nbsp;d&nbsp;</td>\n<td>&nbsp;a&nbsp;</td>\n<td>&nbsp;f&nbsp;</td>\n</tr></table>\n\n<p>　　　tmp = c</p>\n<h5 id=\"4-将array-2-写入到到array-0-，-用tmp记录array-0\"><a href=\"#4-将array-2-写入到到array-0-，-用tmp记录array-0\" class=\"headerlink\" title=\"4. 将array[2]写入到到array[0]， 用tmp记录array[0]\"></a>4. 将array[2]写入到到array[0]， 用tmp记录array[0]</h5><table><tr>\n<td>&nbsp;<font color=\"red\">c</font>&nbsp;</td>\n<td>&nbsp;b&nbsp;</td>\n<td>&nbsp;e&nbsp;</td>\n<td>&nbsp;d&nbsp;</td>\n<td>&nbsp;a&nbsp;</td>\n<td>&nbsp;f&nbsp;</td>\n</tr></table>\n\n<p>　　　tmp = a</p>\n<h5 id=\"问题就出在第四步，回到起点后，继续交换显然是错误的，这就需要额外的空间去记录那些位置是已经交换的，并且需要的额外空间随着原始字符串长度的增加而线性增长，所以这种方式的空间复杂度为O-n-不符合O-1-的要求。\"><a href=\"#问题就出在第四步，回到起点后，继续交换显然是错误的，这就需要额外的空间去记录那些位置是已经交换的，并且需要的额外空间随着原始字符串长度的增加而线性增长，所以这种方式的空间复杂度为O-n-不符合O-1-的要求。\" class=\"headerlink\" title=\"问题就出在第四步，回到起点后，继续交换显然是错误的，这就需要额外的空间去记录那些位置是已经交换的，并且需要的额外空间随着原始字符串长度的增加而线性增长，所以这种方式的空间复杂度为O(n),不符合O(1)的要求。\"></a>问题就出在第四步，回到起点后，继续交换显然是错误的，这就需要额外的空间去记录那些位置是已经交换的，并且需要的额外空间随着原始字符串长度的增加而线性增长，所以这种方式的空间复杂度为O(n),不符合O(1)的要求。</h5><h4 id=\"于是想到的另外一种解题方式，依次将数组元素与之后的第m位交换：\"><a href=\"#于是想到的另外一种解题方式，依次将数组元素与之后的第m位交换：\" class=\"headerlink\" title=\"于是想到的另外一种解题方式，依次将数组元素与之后的第m位交换：\"></a>于是想到的另外一种解题方式，依次将数组元素与之后的第m位交换：</h4><h5 id=\"1-初始字符串为abcdef，\"><a href=\"#1-初始字符串为abcdef，\" class=\"headerlink\" title=\"1. 初始字符串为abcdef，\"></a>1. 初始字符串为abcdef，</h5><table><tr>\n<td>&nbsp;a&nbsp;</td>\n<td>&nbsp;b&nbsp;</td>\n<td>&nbsp;c&nbsp;</td>\n<td>&nbsp;d&nbsp;</td>\n<td>&nbsp;e&nbsp;</td>\n<td>&nbsp;f&nbsp;</td>\n</tr></table>\n\n<h5 id=\"2-将array-0-与array-2-交换\"><a href=\"#2-将array-0-与array-2-交换\" class=\"headerlink\" title=\"2. 将array[0]与array[2]交换\"></a>2. 将array[0]与array[2]交换</h5><table><tr>\n<td>&nbsp;<font color=\"red\">c</font>&nbsp;</td>\n<td>&nbsp;b&nbsp;</td>\n<td>&nbsp;<font color=\"red\">a</font>&nbsp;</td>\n<td>&nbsp;d&nbsp;</td>\n<td>&nbsp;e&nbsp;</td>\n<td>&nbsp;f&nbsp;</td>\n</tr></table>\n\n<h5 id=\"3-将array-1-与array-3-交换\"><a href=\"#3-将array-1-与array-3-交换\" class=\"headerlink\" title=\"3.  将array[1]与array[3]交换\"></a>3.  将array[1]与array[3]交换</h5><table><tr>\n<td>&nbsp;c&nbsp;</td>\n<td>&nbsp;<font color=\"red\">d</font>&nbsp;</td>\n<td>&nbsp;a&nbsp;</td>\n<td>&nbsp;<font color=\"red\">b</font>&nbsp;</td>\n<td>&nbsp;e&nbsp;</td>\n<td>&nbsp;f&nbsp;</td>\n</tr></table>\n\n<h5 id=\"4-将array-2-与array-4-交换\"><a href=\"#4-将array-2-与array-4-交换\" class=\"headerlink\" title=\"4. 将array[2]与array[4]交换\"></a>4. 将array[2]与array[4]交换</h5><table><tr>\n<td>&nbsp;c&nbsp;</td>\n<td>&nbsp;d&nbsp;</td>\n<td>&nbsp;<font color=\"red\">e</font>&nbsp;</td>\n<td>&nbsp;b&nbsp;</td>\n<td>&nbsp;<font color=\"red\">a</font>&nbsp;</td>\n<td>&nbsp;f&nbsp;</td>\n</tr></table>\n\n<h5 id=\"5-将array-3-与array-5-交换\"><a href=\"#5-将array-3-与array-5-交换\" class=\"headerlink\" title=\"5. 将array[3]与array[5]交换\"></a>5. 将array[3]与array[5]交换</h5><table><tr>\n<td>&nbsp;c&nbsp;</td>\n<td>&nbsp;d&nbsp;</td>\n<td>&nbsp;e&nbsp;</td>\n<td>&nbsp;<font color=\"red\">f</font>&nbsp;</td>\n<td>&nbsp;a&nbsp;</td>\n<td>&nbsp;<font color=\"red\">b</font>&nbsp;</td>\n</tr></table>\n\n<h5 id=\"这种实现方式需要进行n-m次交换，时间复杂度为O-n-需要两个额外空间，分别是交换数组元素的tmp指针，和记录当前交换位置的指针，这也符合常数空间复杂度O-1-。\"><a href=\"#这种实现方式需要进行n-m次交换，时间复杂度为O-n-需要两个额外空间，分别是交换数组元素的tmp指针，和记录当前交换位置的指针，这也符合常数空间复杂度O-1-。\" class=\"headerlink\" title=\"这种实现方式需要进行n-m次交换，时间复杂度为O(n),需要两个额外空间，分别是交换数组元素的tmp指针，和记录当前交换位置的指针，这也符合常数空间复杂度O(1)。\"></a>这种实现方式需要进行n-m次交换，时间复杂度为O(n),需要两个额外空间，分别是交换数组元素的tmp指针，和记录当前交换位置的指针，这也符合常数空间复杂度O(1)。</h5><h2 id=\"解题：\"><a href=\"#解题：\" class=\"headerlink\" title=\"解题：\"></a>解题：</h2><h4 id=\"看了网络上的一些其他解法，也比较巧妙\"><a href=\"#看了网络上的一些其他解法，也比较巧妙\" class=\"headerlink\" title=\"看了网络上的一些其他解法，也比较巧妙:\"></a>看了网络上的一些其他解法，也比较巧妙:</h4><ol>\n<li>首先将原字符串分为两个部分，即X:ab，Y:cdef；</li>\n<li>将X反转，X-&gt;X^T，即得：ab-&gt;ba；将Y反转，Y-&gt;Y^T，即得：cdef-&gt;fedc。</li>\n<li>反转上述步骤得到的结果字符串X^TY^T，即反转字符串bafedc的两部分（ba和fedc）给予反转，bafedc得到cdefab，形式化表示为(X^TY^T)^T=YX，这就实现了整个反转。</li>\n</ol>\n<pre><code class=\"lang-C\">void ReverseString(char* s,int from,int to)\n{\n    while (from &lt; to)\n    {\n        char t = s[from];\n        s[from++] = s[to];\n        s[to--] = t;\n    }\n}\n\nvoid LeftRotateString(char* s,int n,int m)\n{\n    m %= n;               //若要左移动大于n位，那么和%n 是等价的\n    ReverseString(s, 0, m - 1); //反转[0..m - 1]，套用到上面举的例子中，就是X-&gt;X^T，即 abc-&gt;cba\n    ReverseString(s, m, n - 1); //反转[m..n - 1]，例如Y-&gt;Y^T，即 def-&gt;fed\n    ReverseString(s, 0, n - 1); //反转[0..n - 1]，即如整个反转，(X^TY^T)^T=YX，即 cbafed-&gt;defabc。\n}\n</code></pre>\n<h5 id=\"调用3次此方法即可左旋字符串\"><a href=\"#调用3次此方法即可左旋字符串\" class=\"headerlink\" title=\"调用3次此方法即可左旋字符串\"></a>调用3次此方法即可左旋字符串</h5><h2 id=\"最后再说一些：\"><a href=\"#最后再说一些：\" class=\"headerlink\" title=\"最后再说一些：\"></a>最后再说一些：</h2><h5 id=\"对于时间复杂度和空间复杂度的计算，需要去低阶项，去掉常数项，去掉高阶项，T-n-2n2-n-1-O-n2-若执行时间是一个与问题规模n无关的常数，算法的时间复杂度为常数阶，记作T-n-O-1-。\"><a href=\"#对于时间复杂度和空间复杂度的计算，需要去低阶项，去掉常数项，去掉高阶项，T-n-2n2-n-1-O-n2-若执行时间是一个与问题规模n无关的常数，算法的时间复杂度为常数阶，记作T-n-O-1-。\" class=\"headerlink\" title=\"对于时间复杂度和空间复杂度的计算，需要去低阶项，去掉常数项，去掉高阶项，T(n)=(2n2+n+1)=O(n2);若执行时间是一个与问题规模n无关的常数，算法的时间复杂度为常数阶，记作T(n)=O(1)。\"></a>对于时间复杂度和空间复杂度的计算，需要去低阶项，去掉常数项，去掉高阶项，T(n)=(2n<sup>2</sup>+n+1)=O(n<sup>2</sup>);若执行时间是一个与问题规模n无关的常数，算法的时间复杂度为常数阶，记作T(n)=O(1)。</h5><h3 id=\"参考链接：\"><a href=\"#参考链接：\" class=\"headerlink\" title=\"参考链接：\"></a>参考链接：</h3><p><a href=\"http://taop.marchtea.com/01.01.html\" target=\"_blank\" rel=\"external\">http://taop.marchtea.com/01.01.html</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"题目要求：\"><a href=\"#题目要求：\" class=\"headerlink\" title=\"题目要求：\"></a>题目要求：</h2><h5 id=\"定义字符串的左旋转操作：把字符串前面的若干个字符移动到字符串的尾部。\"><a href=\"#定义字符串的左旋转操作：把字符串前面的若干个字符移动到字符串的尾部。\" class=\"headerlink\" title=\"定义字符串的左旋转操作：把字符串前面的若干个字符移动到字符串的尾部。\"></a>定义字符串的左旋转操作：把字符串前面的若干个字符移动到字符串的尾部。</h5><h5 id=\"如把字符串abcdef左旋转2位得到字符串cdefab。请实现字符串左旋转的函数。\"><a href=\"#如把字符串abcdef左旋转2位得到字符串cdefab。请实现字符串左旋转的函数。\" class=\"headerlink\" title=\"如把字符串abcdef左旋转2位得到字符串cdefab。请实现字符串左旋转的函数。\"></a>如把字符串abcdef左旋转2位得到字符串cdefab。请实现字符串左旋转的函数。</h5><h5 id=\"要求时间对长度为n的字符串操作的复杂度为O-n-，辅助内存为O-1-。\"><a href=\"#要求时间对长度为n的字符串操作的复杂度为O-n-，辅助内存为O-1-。\" class=\"headerlink\" title=\"要求时间对长度为n的字符串操作的复杂度为O(n)，辅助内存为O(1)。\"></a>要求时间对长度为n的字符串操作的复杂度为O(n)，辅助内存为O(1)。</h5>","more":"<h2 id=\"分析过程：\"><a href=\"#分析过程：\" class=\"headerlink\" title=\"分析过程：\"></a>分析过程：</h2><h5 id=\"题目要求很简单，其实就是字符串的位置交换，一个长度为n的字符串，将字符串的前面m个字符的子串和后面的字符进行位置交换。如果用普通的java代码进行编写的话，会非常简单\"><a href=\"#题目要求很简单，其实就是字符串的位置交换，一个长度为n的字符串，将字符串的前面m个字符的子串和后面的字符进行位置交换。如果用普通的java代码进行编写的话，会非常简单\" class=\"headerlink\" title=\"题目要求很简单，其实就是字符串的位置交换，一个长度为n的字符串，将字符串的前面m个字符的子串和后面的字符进行位置交换。如果用普通的java代码进行编写的话，会非常简单\"></a>题目要求很简单，其实就是字符串的位置交换，一个长度为n的字符串，将字符串的前面m个字符的子串和后面的字符进行位置交换。如果用普通的java代码进行编写的话，会非常简单</h5><pre><code class=\"lang-JAVA\">String result = start.substring(m,n) + start.substring(0, m);\n</code></pre>\n<h5 id=\"java对数组的复制使用System-arraycopy的本地方法，-以这种方式实现的话，时间复杂度是符合O-n-要求的，但是空间复杂度却要大于O-1-。这明显是不符合题意的。\"><a href=\"#java对数组的复制使用System-arraycopy的本地方法，-以这种方式实现的话，时间复杂度是符合O-n-要求的，但是空间复杂度却要大于O-1-。这明显是不符合题意的。\" class=\"headerlink\" title=\"java对数组的复制使用System.arraycopy的本地方法， 以这种方式实现的话，时间复杂度是符合O(n)要求的，但是空间复杂度却要大于O(1)。这明显是不符合题意的。\"></a>java对数组的复制使用System.arraycopy的本地方法， 以这种方式实现的话，时间复杂度是符合O(n)要求的，但是空间复杂度却要大于O(1)。这明显是不符合题意的。</h5><h5 id=\"首先，能够想到的是，字符串的左旋转，其实就是对字符数组的左旋转。既然是对数组的位置交换，则数组的每个位置的字符在交换之后的位置是已经确定的，并且能够找到一定的规律的。比如题目中的例子，把字符串abcdef左旋转2位得到字符串cdefab；\"><a href=\"#首先，能够想到的是，字符串的左旋转，其实就是对字符数组的左旋转。既然是对数组的位置交换，则数组的每个位置的字符在交换之后的位置是已经确定的，并且能够找到一定的规律的。比如题目中的例子，把字符串abcdef左旋转2位得到字符串cdefab；\" class=\"headerlink\" title=\"首先，能够想到的是，字符串的左旋转，其实就是对字符数组的左旋转。既然是对数组的位置交换，则数组的每个位置的字符在交换之后的位置是已经确定的，并且能够找到一定的规律的。比如题目中的例子，把字符串abcdef左旋转2位得到字符串cdefab；\"></a>首先，能够想到的是，字符串的左旋转，其实就是对字符数组的左旋转。既然是对数组的位置交换，则数组的每个位置的字符在交换之后的位置是已经确定的，并且能够找到一定的规律的。比如题目中的例子，把字符串abcdef左旋转2位得到字符串cdefab；</h5><h5 id=\"假设字符串的数组为arry-字符串的长度为6（n-6），左旋转2位（m-2），则数组中每一位的位置相应的转换为\"><a href=\"#假设字符串的数组为arry-字符串的长度为6（n-6），左旋转2位（m-2），则数组中每一位的位置相应的转换为\" class=\"headerlink\" title=\"假设字符串的数组为arry,字符串的长度为6（n=6），左旋转2位（m=2），则数组中每一位的位置相应的转换为\"></a>假设字符串的数组为arry,字符串的长度为6（n=6），左旋转2位（m=2），则数组中每一位的位置相应的转换为</h5><h6 id=\"a-array-0-gt-array-0-4-gt-array-4\"><a href=\"#a-array-0-gt-array-0-4-gt-array-4\" class=\"headerlink\" title=\"a:array[0] -&gt; array[0+4] -&gt; array[4]\"></a>a:array[0] -&gt; array[0+4] -&gt; array[4]</h6><h6 id=\"b-array-1-gt-array-1-4-gt-array-5\"><a href=\"#b-array-1-gt-array-1-4-gt-array-5\" class=\"headerlink\" title=\"b:array[1] -&gt; array[1+4] -&gt; array[5]\"></a>b:array[1] -&gt; array[1+4] -&gt; array[5]</h6><h6 id=\"c-array-2-gt-array-2-2-gt-array-0\"><a href=\"#c-array-2-gt-array-2-2-gt-array-0\" class=\"headerlink\" title=\"c:array[2] -&gt; array[2-2] -&gt; array[0]\"></a>c:array[2] -&gt; array[2-2] -&gt; array[0]</h6><h6 id=\"d-array-3-gt-array-3-2-gt-array-1\"><a href=\"#d-array-3-gt-array-3-2-gt-array-1\" class=\"headerlink\" title=\"d:array[3] -&gt; array[3-2] -&gt; array[1]\"></a>d:array[3] -&gt; array[3-2] -&gt; array[1]</h6><h6 id=\"e-array-4-gt-array-4-2-gt-array-2\"><a href=\"#e-array-4-gt-array-4-2-gt-array-2\" class=\"headerlink\" title=\"e:array[4] -&gt; array[4-2] -&gt; array[2]\"></a>e:array[4] -&gt; array[4-2] -&gt; array[2]</h6><h6 id=\"f-array-5-gt-array-5-2-gt-array-3\"><a href=\"#f-array-5-gt-array-5-2-gt-array-3\" class=\"headerlink\" title=\"f:array[5] -&gt; array[5-2] -&gt; array[3]\"></a>f:array[5] -&gt; array[5-2] -&gt; array[3]</h6><h5 id=\"可以看出，字符位置的交换是很有规律的，对于字符长度为n，左旋m位的数组\"><a href=\"#可以看出，字符位置的交换是很有规律的，对于字符长度为n，左旋m位的数组\" class=\"headerlink\" title=\"可以看出，字符位置的交换是很有规律的，对于字符长度为n，左旋m位的数组\"></a>可以看出，字符位置的交换是很有规律的，对于字符长度为n，左旋m位的数组</h5><ol>\n<li>前面m个字符，左旋后的位置为i+(n-m)</li>\n<li>后面n-m个字符，左旋后的位置为j-m</li>\n</ol>\n<h4 id=\"基于这套交换逻辑，想要实现如下算法，却发现不符合题目要求：\"><a href=\"#基于这套交换逻辑，想要实现如下算法，却发现不符合题目要求：\" class=\"headerlink\" title=\"基于这套交换逻辑，想要实现如下算法，却发现不符合题目要求：\"></a>基于这套交换逻辑，想要实现如下算法，却发现不符合题目要求：</h4><h5 id=\"1-初始字符串为abcdef，左旋转2位得到字符串cdefab\"><a href=\"#1-初始字符串为abcdef，左旋转2位得到字符串cdefab\" class=\"headerlink\" title=\"1. 初始字符串为abcdef，左旋转2位得到字符串cdefab\"></a>1. 初始字符串为abcdef，左旋转2位得到字符串cdefab</h5><table><tr>\n<td>&nbsp;a&nbsp;</td>\n<td>&nbsp;b&nbsp;</td>\n<td>&nbsp;c&nbsp;</td>\n<td>&nbsp;d&nbsp;</td>\n<td>&nbsp;e&nbsp;</td>\n<td>&nbsp;f&nbsp;</td>\n</tr></table>\n\n<h5 id=\"2-将array-0-写入到到array-4-，-用tmp记录array-4\"><a href=\"#2-将array-0-写入到到array-4-，-用tmp记录array-4\" class=\"headerlink\" title=\"2. 将array[0]写入到到array[4]， 用tmp记录array[4]\"></a>2. 将array[0]写入到到array[4]， 用tmp记录array[4]</h5><table><tr>\n<td>&nbsp;a&nbsp;</td>\n<td>&nbsp;b&nbsp;</td>\n<td>&nbsp;c&nbsp;</td>\n<td>&nbsp;d&nbsp;</td>\n<td>&nbsp;<font color=\"red\">a</font>&nbsp;</td>\n<td>&nbsp;f&nbsp;</td>\n</tr></table>\n\n<p>　　　tmp = e</p>\n<h5 id=\"3-将array-4-写入到到array-2-，-用tmp记录array-2\"><a href=\"#3-将array-4-写入到到array-2-，-用tmp记录array-2\" class=\"headerlink\" title=\"3. 将array[4]写入到到array[2]， 用tmp记录array[2]\"></a>3. 将array[4]写入到到array[2]， 用tmp记录array[2]</h5><table><tr>\n<td>&nbsp;a&nbsp;</td>\n<td>&nbsp;b&nbsp;</td>\n<td>&nbsp;<font color=\"red\">e</font>&nbsp;</td>\n<td>&nbsp;d&nbsp;</td>\n<td>&nbsp;a&nbsp;</td>\n<td>&nbsp;f&nbsp;</td>\n</tr></table>\n\n<p>　　　tmp = c</p>\n<h5 id=\"4-将array-2-写入到到array-0-，-用tmp记录array-0\"><a href=\"#4-将array-2-写入到到array-0-，-用tmp记录array-0\" class=\"headerlink\" title=\"4. 将array[2]写入到到array[0]， 用tmp记录array[0]\"></a>4. 将array[2]写入到到array[0]， 用tmp记录array[0]</h5><table><tr>\n<td>&nbsp;<font color=\"red\">c</font>&nbsp;</td>\n<td>&nbsp;b&nbsp;</td>\n<td>&nbsp;e&nbsp;</td>\n<td>&nbsp;d&nbsp;</td>\n<td>&nbsp;a&nbsp;</td>\n<td>&nbsp;f&nbsp;</td>\n</tr></table>\n\n<p>　　　tmp = a</p>\n<h5 id=\"问题就出在第四步，回到起点后，继续交换显然是错误的，这就需要额外的空间去记录那些位置是已经交换的，并且需要的额外空间随着原始字符串长度的增加而线性增长，所以这种方式的空间复杂度为O-n-不符合O-1-的要求。\"><a href=\"#问题就出在第四步，回到起点后，继续交换显然是错误的，这就需要额外的空间去记录那些位置是已经交换的，并且需要的额外空间随着原始字符串长度的增加而线性增长，所以这种方式的空间复杂度为O-n-不符合O-1-的要求。\" class=\"headerlink\" title=\"问题就出在第四步，回到起点后，继续交换显然是错误的，这就需要额外的空间去记录那些位置是已经交换的，并且需要的额外空间随着原始字符串长度的增加而线性增长，所以这种方式的空间复杂度为O(n),不符合O(1)的要求。\"></a>问题就出在第四步，回到起点后，继续交换显然是错误的，这就需要额外的空间去记录那些位置是已经交换的，并且需要的额外空间随着原始字符串长度的增加而线性增长，所以这种方式的空间复杂度为O(n),不符合O(1)的要求。</h5><h4 id=\"于是想到的另外一种解题方式，依次将数组元素与之后的第m位交换：\"><a href=\"#于是想到的另外一种解题方式，依次将数组元素与之后的第m位交换：\" class=\"headerlink\" title=\"于是想到的另外一种解题方式，依次将数组元素与之后的第m位交换：\"></a>于是想到的另外一种解题方式，依次将数组元素与之后的第m位交换：</h4><h5 id=\"1-初始字符串为abcdef，\"><a href=\"#1-初始字符串为abcdef，\" class=\"headerlink\" title=\"1. 初始字符串为abcdef，\"></a>1. 初始字符串为abcdef，</h5><table><tr>\n<td>&nbsp;a&nbsp;</td>\n<td>&nbsp;b&nbsp;</td>\n<td>&nbsp;c&nbsp;</td>\n<td>&nbsp;d&nbsp;</td>\n<td>&nbsp;e&nbsp;</td>\n<td>&nbsp;f&nbsp;</td>\n</tr></table>\n\n<h5 id=\"2-将array-0-与array-2-交换\"><a href=\"#2-将array-0-与array-2-交换\" class=\"headerlink\" title=\"2. 将array[0]与array[2]交换\"></a>2. 将array[0]与array[2]交换</h5><table><tr>\n<td>&nbsp;<font color=\"red\">c</font>&nbsp;</td>\n<td>&nbsp;b&nbsp;</td>\n<td>&nbsp;<font color=\"red\">a</font>&nbsp;</td>\n<td>&nbsp;d&nbsp;</td>\n<td>&nbsp;e&nbsp;</td>\n<td>&nbsp;f&nbsp;</td>\n</tr></table>\n\n<h5 id=\"3-将array-1-与array-3-交换\"><a href=\"#3-将array-1-与array-3-交换\" class=\"headerlink\" title=\"3.  将array[1]与array[3]交换\"></a>3.  将array[1]与array[3]交换</h5><table><tr>\n<td>&nbsp;c&nbsp;</td>\n<td>&nbsp;<font color=\"red\">d</font>&nbsp;</td>\n<td>&nbsp;a&nbsp;</td>\n<td>&nbsp;<font color=\"red\">b</font>&nbsp;</td>\n<td>&nbsp;e&nbsp;</td>\n<td>&nbsp;f&nbsp;</td>\n</tr></table>\n\n<h5 id=\"4-将array-2-与array-4-交换\"><a href=\"#4-将array-2-与array-4-交换\" class=\"headerlink\" title=\"4. 将array[2]与array[4]交换\"></a>4. 将array[2]与array[4]交换</h5><table><tr>\n<td>&nbsp;c&nbsp;</td>\n<td>&nbsp;d&nbsp;</td>\n<td>&nbsp;<font color=\"red\">e</font>&nbsp;</td>\n<td>&nbsp;b&nbsp;</td>\n<td>&nbsp;<font color=\"red\">a</font>&nbsp;</td>\n<td>&nbsp;f&nbsp;</td>\n</tr></table>\n\n<h5 id=\"5-将array-3-与array-5-交换\"><a href=\"#5-将array-3-与array-5-交换\" class=\"headerlink\" title=\"5. 将array[3]与array[5]交换\"></a>5. 将array[3]与array[5]交换</h5><table><tr>\n<td>&nbsp;c&nbsp;</td>\n<td>&nbsp;d&nbsp;</td>\n<td>&nbsp;e&nbsp;</td>\n<td>&nbsp;<font color=\"red\">f</font>&nbsp;</td>\n<td>&nbsp;a&nbsp;</td>\n<td>&nbsp;<font color=\"red\">b</font>&nbsp;</td>\n</tr></table>\n\n<h5 id=\"这种实现方式需要进行n-m次交换，时间复杂度为O-n-需要两个额外空间，分别是交换数组元素的tmp指针，和记录当前交换位置的指针，这也符合常数空间复杂度O-1-。\"><a href=\"#这种实现方式需要进行n-m次交换，时间复杂度为O-n-需要两个额外空间，分别是交换数组元素的tmp指针，和记录当前交换位置的指针，这也符合常数空间复杂度O-1-。\" class=\"headerlink\" title=\"这种实现方式需要进行n-m次交换，时间复杂度为O(n),需要两个额外空间，分别是交换数组元素的tmp指针，和记录当前交换位置的指针，这也符合常数空间复杂度O(1)。\"></a>这种实现方式需要进行n-m次交换，时间复杂度为O(n),需要两个额外空间，分别是交换数组元素的tmp指针，和记录当前交换位置的指针，这也符合常数空间复杂度O(1)。</h5><h2 id=\"解题：\"><a href=\"#解题：\" class=\"headerlink\" title=\"解题：\"></a>解题：</h2><h4 id=\"看了网络上的一些其他解法，也比较巧妙\"><a href=\"#看了网络上的一些其他解法，也比较巧妙\" class=\"headerlink\" title=\"看了网络上的一些其他解法，也比较巧妙:\"></a>看了网络上的一些其他解法，也比较巧妙:</h4><ol>\n<li>首先将原字符串分为两个部分，即X:ab，Y:cdef；</li>\n<li>将X反转，X-&gt;X^T，即得：ab-&gt;ba；将Y反转，Y-&gt;Y^T，即得：cdef-&gt;fedc。</li>\n<li>反转上述步骤得到的结果字符串X^TY^T，即反转字符串bafedc的两部分（ba和fedc）给予反转，bafedc得到cdefab，形式化表示为(X^TY^T)^T=YX，这就实现了整个反转。</li>\n</ol>\n<pre><code class=\"lang-C\">void ReverseString(char* s,int from,int to)\n{\n    while (from &lt; to)\n    {\n        char t = s[from];\n        s[from++] = s[to];\n        s[to--] = t;\n    }\n}\n\nvoid LeftRotateString(char* s,int n,int m)\n{\n    m %= n;               //若要左移动大于n位，那么和%n 是等价的\n    ReverseString(s, 0, m - 1); //反转[0..m - 1]，套用到上面举的例子中，就是X-&gt;X^T，即 abc-&gt;cba\n    ReverseString(s, m, n - 1); //反转[m..n - 1]，例如Y-&gt;Y^T，即 def-&gt;fed\n    ReverseString(s, 0, n - 1); //反转[0..n - 1]，即如整个反转，(X^TY^T)^T=YX，即 cbafed-&gt;defabc。\n}\n</code></pre>\n<h5 id=\"调用3次此方法即可左旋字符串\"><a href=\"#调用3次此方法即可左旋字符串\" class=\"headerlink\" title=\"调用3次此方法即可左旋字符串\"></a>调用3次此方法即可左旋字符串</h5><h2 id=\"最后再说一些：\"><a href=\"#最后再说一些：\" class=\"headerlink\" title=\"最后再说一些：\"></a>最后再说一些：</h2><h5 id=\"对于时间复杂度和空间复杂度的计算，需要去低阶项，去掉常数项，去掉高阶项，T-n-2n2-n-1-O-n2-若执行时间是一个与问题规模n无关的常数，算法的时间复杂度为常数阶，记作T-n-O-1-。\"><a href=\"#对于时间复杂度和空间复杂度的计算，需要去低阶项，去掉常数项，去掉高阶项，T-n-2n2-n-1-O-n2-若执行时间是一个与问题规模n无关的常数，算法的时间复杂度为常数阶，记作T-n-O-1-。\" class=\"headerlink\" title=\"对于时间复杂度和空间复杂度的计算，需要去低阶项，去掉常数项，去掉高阶项，T(n)=(2n2+n+1)=O(n2);若执行时间是一个与问题规模n无关的常数，算法的时间复杂度为常数阶，记作T(n)=O(1)。\"></a>对于时间复杂度和空间复杂度的计算，需要去低阶项，去掉常数项，去掉高阶项，T(n)=(2n<sup>2</sup>+n+1)=O(n<sup>2</sup>);若执行时间是一个与问题规模n无关的常数，算法的时间复杂度为常数阶，记作T(n)=O(1)。</h5><h3 id=\"参考链接：\"><a href=\"#参考链接：\" class=\"headerlink\" title=\"参考链接：\"></a>参考链接：</h3><p><a href=\"http://taop.marchtea.com/01.01.html\" target=\"_blank\" rel=\"external\">http://taop.marchtea.com/01.01.html</a></p>"},{"layout":"post","title":"判断两个链表是否相交","date":"2017-02-24T16:00:00.000Z","original":true,"tag":[["算法","arithmetic"]],"_content":"\n## 题目要求：\n##### 给出俩个单向链表的头指针，比如h1，h2，判断这俩个链表是否相交。\n##### 这个题目可以扩展成很多问题，每个子问题都值得学习。\n<!--more-->\n## 题目扩展（均为单链表）：\n1. 判断这俩个链表是否相交（无环）\n2. 判断链表是否有环\n3. 如何知道环的长度？\n4. 如何找出环的连接点在哪里？\n5. 带环链表的长度是多少？\n6. 链表有环，判断相交\n7. 判断两个链表相交的第一个节点\n##### 下面我们一个一个的来解决这些问题\n\n### 问题1：判断这俩个链表是否相交（无环）\n##### 两个无环链表的相交问题，如果两个链表相交，则他们一定存在公共节点，且公共节点之后的节点全部都是相交的。则他们的结构为：\n![二元查找树](/img/arithmetic/linked.jpg)\n##### 如果两个链表相交，则他们的尾节点一定是同一个节点，所以可以直接对比两个链表的尾部节点是否相。时间复杂度为两个链表的长度之和O(m+n)。\n##### 这种解法比较简单，只要想到最后一个节点相等就可以，后面还会有一些其他的解法介绍。\n\n### 问题2：判断链表是否有环\n##### 对于这个问题，可以使用一种追赶的方法。设定两个指针slow、fast，从头指针开始，每次分别前进1步、2步。如存在环，则两者相遇；如不存在环，fast遇到NULL退出。\n##### 这个过程比较好理解，如果存在环，所以fast指针则会在环内循环，直至slow指针进入环内，并且追赶上slow指针。因为fast每次两部，slow每次一步，试验后发现fast指针不会跳过slow指针，因此如果有换，则必定会在一个节点相交。\n\n### 问题3：如何知道环的长度？\n##### 基于上一步，我们已经判断一个链表是否有环，如果有环的话，如何判断环的长度呢。\n##### 还是一样的方法，在上一个问题中，fast和slow将相交于环内一点，fast的速度是slow的两倍，则只需要fast和slow继续以原速度前进，当他们再次相交时，slow所走了步数为环的长度。\n\n### 问题4：如何找出环的连接点在哪里？\n##### 相对于上面两个问题，这个问题相对更复杂一些。回到问题\"判断链表是否有环\"。\n##### 当fast指针和slow指针相交时，slow指针必定未走完一圈，因为在slow进入环入口时，fast指针已经在环内，这就成了一个fast追赶slow的问题，除了fast和slow已经相交，否则fast追赶上slow，slow用不了一周。因此此时slow还未第二次经过入口节点。\n1. 假设slow进过的节点数量为r，则fast为2r\n2. 假设环的长度为s，因为slow和fast已经在同一点，而fast比slow多走了r个节点，所以r = ns。n为常数，大于等于1，代表的是fast绕环的次数。\n3. 假设头节点为点a，入口节点为b，fast和slow相遇节点为c，则ac = r = ns = ab + bc；bc + cb = s；（bc表示从入口节点至相遇节点，cb表示从相遇节点至入口节点） ab = r - bc；所以，ab - cb = (n-1)s；\n![单链表带环](/img/arithmetic/linked2.jpg)\n##### 因此，从头节点a和相遇节点c重新开始走，第一次相遇的节点为入口节点b。从a节点走的指针步数为1，从c节点走的指针步数则大于等于1,因为大于1时，无非就是n大一些，多走了几圈。\n\n### 问题5：带环链表的长度是多少？\n##### 问题4可以求出头节点到入口节点的长度，加上问题3的环长度，等于链表长度。或者问题4求出入口节点，以及问题2的相遇节点。都可以求出链表长度。\n\n### 问题6：链表有环，判断相交\n##### 一个链表有环，一个链表无环的情况下。两个链表不可能相交。\n##### 两个链表均有环，则两个链表的环一定是共有的。则可以判断一个链表的相遇点，相遇点一定处于环内，再判断该点是否存在于另一个链表当中。","source":"_posts/note/arithmetic/linkedList.md","raw":"---\nlayout: post\ntitle: 判断两个链表是否相交\ndate: 2017/02/25\ntags: [tech, arithmetic, index]\noriginal: true\ntag: [[算法, arithmetic]]\n---\n\n## 题目要求：\n##### 给出俩个单向链表的头指针，比如h1，h2，判断这俩个链表是否相交。\n##### 这个题目可以扩展成很多问题，每个子问题都值得学习。\n<!--more-->\n## 题目扩展（均为单链表）：\n1. 判断这俩个链表是否相交（无环）\n2. 判断链表是否有环\n3. 如何知道环的长度？\n4. 如何找出环的连接点在哪里？\n5. 带环链表的长度是多少？\n6. 链表有环，判断相交\n7. 判断两个链表相交的第一个节点\n##### 下面我们一个一个的来解决这些问题\n\n### 问题1：判断这俩个链表是否相交（无环）\n##### 两个无环链表的相交问题，如果两个链表相交，则他们一定存在公共节点，且公共节点之后的节点全部都是相交的。则他们的结构为：\n![二元查找树](/img/arithmetic/linked.jpg)\n##### 如果两个链表相交，则他们的尾节点一定是同一个节点，所以可以直接对比两个链表的尾部节点是否相。时间复杂度为两个链表的长度之和O(m+n)。\n##### 这种解法比较简单，只要想到最后一个节点相等就可以，后面还会有一些其他的解法介绍。\n\n### 问题2：判断链表是否有环\n##### 对于这个问题，可以使用一种追赶的方法。设定两个指针slow、fast，从头指针开始，每次分别前进1步、2步。如存在环，则两者相遇；如不存在环，fast遇到NULL退出。\n##### 这个过程比较好理解，如果存在环，所以fast指针则会在环内循环，直至slow指针进入环内，并且追赶上slow指针。因为fast每次两部，slow每次一步，试验后发现fast指针不会跳过slow指针，因此如果有换，则必定会在一个节点相交。\n\n### 问题3：如何知道环的长度？\n##### 基于上一步，我们已经判断一个链表是否有环，如果有环的话，如何判断环的长度呢。\n##### 还是一样的方法，在上一个问题中，fast和slow将相交于环内一点，fast的速度是slow的两倍，则只需要fast和slow继续以原速度前进，当他们再次相交时，slow所走了步数为环的长度。\n\n### 问题4：如何找出环的连接点在哪里？\n##### 相对于上面两个问题，这个问题相对更复杂一些。回到问题\"判断链表是否有环\"。\n##### 当fast指针和slow指针相交时，slow指针必定未走完一圈，因为在slow进入环入口时，fast指针已经在环内，这就成了一个fast追赶slow的问题，除了fast和slow已经相交，否则fast追赶上slow，slow用不了一周。因此此时slow还未第二次经过入口节点。\n1. 假设slow进过的节点数量为r，则fast为2r\n2. 假设环的长度为s，因为slow和fast已经在同一点，而fast比slow多走了r个节点，所以r = ns。n为常数，大于等于1，代表的是fast绕环的次数。\n3. 假设头节点为点a，入口节点为b，fast和slow相遇节点为c，则ac = r = ns = ab + bc；bc + cb = s；（bc表示从入口节点至相遇节点，cb表示从相遇节点至入口节点） ab = r - bc；所以，ab - cb = (n-1)s；\n![单链表带环](/img/arithmetic/linked2.jpg)\n##### 因此，从头节点a和相遇节点c重新开始走，第一次相遇的节点为入口节点b。从a节点走的指针步数为1，从c节点走的指针步数则大于等于1,因为大于1时，无非就是n大一些，多走了几圈。\n\n### 问题5：带环链表的长度是多少？\n##### 问题4可以求出头节点到入口节点的长度，加上问题3的环长度，等于链表长度。或者问题4求出入口节点，以及问题2的相遇节点。都可以求出链表长度。\n\n### 问题6：链表有环，判断相交\n##### 一个链表有环，一个链表无环的情况下。两个链表不可能相交。\n##### 两个链表均有环，则两个链表的环一定是共有的。则可以判断一个链表的相遇点，相遇点一定处于环内，再判断该点是否存在于另一个链表当中。","slug":"note/arithmetic/linkedList","published":1,"updated":"2018-05-08T14:24:22.683Z","_id":"cjgxop3n8002yjah1l7wzgheb","comments":1,"photos":[],"link":"","content":"<h2 id=\"题目要求：\"><a href=\"#题目要求：\" class=\"headerlink\" title=\"题目要求：\"></a>题目要求：</h2><h5 id=\"给出俩个单向链表的头指针，比如h1，h2，判断这俩个链表是否相交。\"><a href=\"#给出俩个单向链表的头指针，比如h1，h2，判断这俩个链表是否相交。\" class=\"headerlink\" title=\"给出俩个单向链表的头指针，比如h1，h2，判断这俩个链表是否相交。\"></a>给出俩个单向链表的头指针，比如h1，h2，判断这俩个链表是否相交。</h5><h5 id=\"这个题目可以扩展成很多问题，每个子问题都值得学习。\"><a href=\"#这个题目可以扩展成很多问题，每个子问题都值得学习。\" class=\"headerlink\" title=\"这个题目可以扩展成很多问题，每个子问题都值得学习。\"></a>这个题目可以扩展成很多问题，每个子问题都值得学习。</h5><a id=\"more\"></a>\n<h2 id=\"题目扩展（均为单链表）：\"><a href=\"#题目扩展（均为单链表）：\" class=\"headerlink\" title=\"题目扩展（均为单链表）：\"></a>题目扩展（均为单链表）：</h2><ol>\n<li>判断这俩个链表是否相交（无环）</li>\n<li>判断链表是否有环</li>\n<li>如何知道环的长度？</li>\n<li>如何找出环的连接点在哪里？</li>\n<li>带环链表的长度是多少？</li>\n<li>链表有环，判断相交</li>\n<li>判断两个链表相交的第一个节点<h5 id=\"下面我们一个一个的来解决这些问题\"><a href=\"#下面我们一个一个的来解决这些问题\" class=\"headerlink\" title=\"下面我们一个一个的来解决这些问题\"></a>下面我们一个一个的来解决这些问题</h5></li>\n</ol>\n<h3 id=\"问题1：判断这俩个链表是否相交（无环）\"><a href=\"#问题1：判断这俩个链表是否相交（无环）\" class=\"headerlink\" title=\"问题1：判断这俩个链表是否相交（无环）\"></a>问题1：判断这俩个链表是否相交（无环）</h3><h5 id=\"两个无环链表的相交问题，如果两个链表相交，则他们一定存在公共节点，且公共节点之后的节点全部都是相交的。则他们的结构为：\"><a href=\"#两个无环链表的相交问题，如果两个链表相交，则他们一定存在公共节点，且公共节点之后的节点全部都是相交的。则他们的结构为：\" class=\"headerlink\" title=\"两个无环链表的相交问题，如果两个链表相交，则他们一定存在公共节点，且公共节点之后的节点全部都是相交的。则他们的结构为：\"></a>两个无环链表的相交问题，如果两个链表相交，则他们一定存在公共节点，且公共节点之后的节点全部都是相交的。则他们的结构为：</h5><p><img src=\"/img/arithmetic/linked.jpg\" alt=\"二元查找树\"></p>\n<h5 id=\"如果两个链表相交，则他们的尾节点一定是同一个节点，所以可以直接对比两个链表的尾部节点是否相。时间复杂度为两个链表的长度之和O-m-n-。\"><a href=\"#如果两个链表相交，则他们的尾节点一定是同一个节点，所以可以直接对比两个链表的尾部节点是否相。时间复杂度为两个链表的长度之和O-m-n-。\" class=\"headerlink\" title=\"如果两个链表相交，则他们的尾节点一定是同一个节点，所以可以直接对比两个链表的尾部节点是否相。时间复杂度为两个链表的长度之和O(m+n)。\"></a>如果两个链表相交，则他们的尾节点一定是同一个节点，所以可以直接对比两个链表的尾部节点是否相。时间复杂度为两个链表的长度之和O(m+n)。</h5><h5 id=\"这种解法比较简单，只要想到最后一个节点相等就可以，后面还会有一些其他的解法介绍。\"><a href=\"#这种解法比较简单，只要想到最后一个节点相等就可以，后面还会有一些其他的解法介绍。\" class=\"headerlink\" title=\"这种解法比较简单，只要想到最后一个节点相等就可以，后面还会有一些其他的解法介绍。\"></a>这种解法比较简单，只要想到最后一个节点相等就可以，后面还会有一些其他的解法介绍。</h5><h3 id=\"问题2：判断链表是否有环\"><a href=\"#问题2：判断链表是否有环\" class=\"headerlink\" title=\"问题2：判断链表是否有环\"></a>问题2：判断链表是否有环</h3><h5 id=\"对于这个问题，可以使用一种追赶的方法。设定两个指针slow、fast，从头指针开始，每次分别前进1步、2步。如存在环，则两者相遇；如不存在环，fast遇到NULL退出。\"><a href=\"#对于这个问题，可以使用一种追赶的方法。设定两个指针slow、fast，从头指针开始，每次分别前进1步、2步。如存在环，则两者相遇；如不存在环，fast遇到NULL退出。\" class=\"headerlink\" title=\"对于这个问题，可以使用一种追赶的方法。设定两个指针slow、fast，从头指针开始，每次分别前进1步、2步。如存在环，则两者相遇；如不存在环，fast遇到NULL退出。\"></a>对于这个问题，可以使用一种追赶的方法。设定两个指针slow、fast，从头指针开始，每次分别前进1步、2步。如存在环，则两者相遇；如不存在环，fast遇到NULL退出。</h5><h5 id=\"这个过程比较好理解，如果存在环，所以fast指针则会在环内循环，直至slow指针进入环内，并且追赶上slow指针。因为fast每次两部，slow每次一步，试验后发现fast指针不会跳过slow指针，因此如果有换，则必定会在一个节点相交。\"><a href=\"#这个过程比较好理解，如果存在环，所以fast指针则会在环内循环，直至slow指针进入环内，并且追赶上slow指针。因为fast每次两部，slow每次一步，试验后发现fast指针不会跳过slow指针，因此如果有换，则必定会在一个节点相交。\" class=\"headerlink\" title=\"这个过程比较好理解，如果存在环，所以fast指针则会在环内循环，直至slow指针进入环内，并且追赶上slow指针。因为fast每次两部，slow每次一步，试验后发现fast指针不会跳过slow指针，因此如果有换，则必定会在一个节点相交。\"></a>这个过程比较好理解，如果存在环，所以fast指针则会在环内循环，直至slow指针进入环内，并且追赶上slow指针。因为fast每次两部，slow每次一步，试验后发现fast指针不会跳过slow指针，因此如果有换，则必定会在一个节点相交。</h5><h3 id=\"问题3：如何知道环的长度？\"><a href=\"#问题3：如何知道环的长度？\" class=\"headerlink\" title=\"问题3：如何知道环的长度？\"></a>问题3：如何知道环的长度？</h3><h5 id=\"基于上一步，我们已经判断一个链表是否有环，如果有环的话，如何判断环的长度呢。\"><a href=\"#基于上一步，我们已经判断一个链表是否有环，如果有环的话，如何判断环的长度呢。\" class=\"headerlink\" title=\"基于上一步，我们已经判断一个链表是否有环，如果有环的话，如何判断环的长度呢。\"></a>基于上一步，我们已经判断一个链表是否有环，如果有环的话，如何判断环的长度呢。</h5><h5 id=\"还是一样的方法，在上一个问题中，fast和slow将相交于环内一点，fast的速度是slow的两倍，则只需要fast和slow继续以原速度前进，当他们再次相交时，slow所走了步数为环的长度。\"><a href=\"#还是一样的方法，在上一个问题中，fast和slow将相交于环内一点，fast的速度是slow的两倍，则只需要fast和slow继续以原速度前进，当他们再次相交时，slow所走了步数为环的长度。\" class=\"headerlink\" title=\"还是一样的方法，在上一个问题中，fast和slow将相交于环内一点，fast的速度是slow的两倍，则只需要fast和slow继续以原速度前进，当他们再次相交时，slow所走了步数为环的长度。\"></a>还是一样的方法，在上一个问题中，fast和slow将相交于环内一点，fast的速度是slow的两倍，则只需要fast和slow继续以原速度前进，当他们再次相交时，slow所走了步数为环的长度。</h5><h3 id=\"问题4：如何找出环的连接点在哪里？\"><a href=\"#问题4：如何找出环的连接点在哪里？\" class=\"headerlink\" title=\"问题4：如何找出环的连接点在哪里？\"></a>问题4：如何找出环的连接点在哪里？</h3><h5 id=\"相对于上面两个问题，这个问题相对更复杂一些。回到问题”判断链表是否有环”。\"><a href=\"#相对于上面两个问题，这个问题相对更复杂一些。回到问题”判断链表是否有环”。\" class=\"headerlink\" title=\"相对于上面两个问题，这个问题相对更复杂一些。回到问题”判断链表是否有环”。\"></a>相对于上面两个问题，这个问题相对更复杂一些。回到问题”判断链表是否有环”。</h5><h5 id=\"当fast指针和slow指针相交时，slow指针必定未走完一圈，因为在slow进入环入口时，fast指针已经在环内，这就成了一个fast追赶slow的问题，除了fast和slow已经相交，否则fast追赶上slow，slow用不了一周。因此此时slow还未第二次经过入口节点。\"><a href=\"#当fast指针和slow指针相交时，slow指针必定未走完一圈，因为在slow进入环入口时，fast指针已经在环内，这就成了一个fast追赶slow的问题，除了fast和slow已经相交，否则fast追赶上slow，slow用不了一周。因此此时slow还未第二次经过入口节点。\" class=\"headerlink\" title=\"当fast指针和slow指针相交时，slow指针必定未走完一圈，因为在slow进入环入口时，fast指针已经在环内，这就成了一个fast追赶slow的问题，除了fast和slow已经相交，否则fast追赶上slow，slow用不了一周。因此此时slow还未第二次经过入口节点。\"></a>当fast指针和slow指针相交时，slow指针必定未走完一圈，因为在slow进入环入口时，fast指针已经在环内，这就成了一个fast追赶slow的问题，除了fast和slow已经相交，否则fast追赶上slow，slow用不了一周。因此此时slow还未第二次经过入口节点。</h5><ol>\n<li>假设slow进过的节点数量为r，则fast为2r</li>\n<li>假设环的长度为s，因为slow和fast已经在同一点，而fast比slow多走了r个节点，所以r = ns。n为常数，大于等于1，代表的是fast绕环的次数。</li>\n<li>假设头节点为点a，入口节点为b，fast和slow相遇节点为c，则ac = r = ns = ab + bc；bc + cb = s；（bc表示从入口节点至相遇节点，cb表示从相遇节点至入口节点） ab = r - bc；所以，ab - cb = (n-1)s；<br><img src=\"/img/arithmetic/linked2.jpg\" alt=\"单链表带环\"><h5 id=\"因此，从头节点a和相遇节点c重新开始走，第一次相遇的节点为入口节点b。从a节点走的指针步数为1，从c节点走的指针步数则大于等于1-因为大于1时，无非就是n大一些，多走了几圈。\"><a href=\"#因此，从头节点a和相遇节点c重新开始走，第一次相遇的节点为入口节点b。从a节点走的指针步数为1，从c节点走的指针步数则大于等于1-因为大于1时，无非就是n大一些，多走了几圈。\" class=\"headerlink\" title=\"因此，从头节点a和相遇节点c重新开始走，第一次相遇的节点为入口节点b。从a节点走的指针步数为1，从c节点走的指针步数则大于等于1,因为大于1时，无非就是n大一些，多走了几圈。\"></a>因此，从头节点a和相遇节点c重新开始走，第一次相遇的节点为入口节点b。从a节点走的指针步数为1，从c节点走的指针步数则大于等于1,因为大于1时，无非就是n大一些，多走了几圈。</h5></li>\n</ol>\n<h3 id=\"问题5：带环链表的长度是多少？\"><a href=\"#问题5：带环链表的长度是多少？\" class=\"headerlink\" title=\"问题5：带环链表的长度是多少？\"></a>问题5：带环链表的长度是多少？</h3><h5 id=\"问题4可以求出头节点到入口节点的长度，加上问题3的环长度，等于链表长度。或者问题4求出入口节点，以及问题2的相遇节点。都可以求出链表长度。\"><a href=\"#问题4可以求出头节点到入口节点的长度，加上问题3的环长度，等于链表长度。或者问题4求出入口节点，以及问题2的相遇节点。都可以求出链表长度。\" class=\"headerlink\" title=\"问题4可以求出头节点到入口节点的长度，加上问题3的环长度，等于链表长度。或者问题4求出入口节点，以及问题2的相遇节点。都可以求出链表长度。\"></a>问题4可以求出头节点到入口节点的长度，加上问题3的环长度，等于链表长度。或者问题4求出入口节点，以及问题2的相遇节点。都可以求出链表长度。</h5><h3 id=\"问题6：链表有环，判断相交\"><a href=\"#问题6：链表有环，判断相交\" class=\"headerlink\" title=\"问题6：链表有环，判断相交\"></a>问题6：链表有环，判断相交</h3><h5 id=\"一个链表有环，一个链表无环的情况下。两个链表不可能相交。\"><a href=\"#一个链表有环，一个链表无环的情况下。两个链表不可能相交。\" class=\"headerlink\" title=\"一个链表有环，一个链表无环的情况下。两个链表不可能相交。\"></a>一个链表有环，一个链表无环的情况下。两个链表不可能相交。</h5><h5 id=\"两个链表均有环，则两个链表的环一定是共有的。则可以判断一个链表的相遇点，相遇点一定处于环内，再判断该点是否存在于另一个链表当中。\"><a href=\"#两个链表均有环，则两个链表的环一定是共有的。则可以判断一个链表的相遇点，相遇点一定处于环内，再判断该点是否存在于另一个链表当中。\" class=\"headerlink\" title=\"两个链表均有环，则两个链表的环一定是共有的。则可以判断一个链表的相遇点，相遇点一定处于环内，再判断该点是否存在于另一个链表当中。\"></a>两个链表均有环，则两个链表的环一定是共有的。则可以判断一个链表的相遇点，相遇点一定处于环内，再判断该点是否存在于另一个链表当中。</h5>","site":{"data":{}},"excerpt":"<h2 id=\"题目要求：\"><a href=\"#题目要求：\" class=\"headerlink\" title=\"题目要求：\"></a>题目要求：</h2><h5 id=\"给出俩个单向链表的头指针，比如h1，h2，判断这俩个链表是否相交。\"><a href=\"#给出俩个单向链表的头指针，比如h1，h2，判断这俩个链表是否相交。\" class=\"headerlink\" title=\"给出俩个单向链表的头指针，比如h1，h2，判断这俩个链表是否相交。\"></a>给出俩个单向链表的头指针，比如h1，h2，判断这俩个链表是否相交。</h5><h5 id=\"这个题目可以扩展成很多问题，每个子问题都值得学习。\"><a href=\"#这个题目可以扩展成很多问题，每个子问题都值得学习。\" class=\"headerlink\" title=\"这个题目可以扩展成很多问题，每个子问题都值得学习。\"></a>这个题目可以扩展成很多问题，每个子问题都值得学习。</h5>","more":"<h2 id=\"题目扩展（均为单链表）：\"><a href=\"#题目扩展（均为单链表）：\" class=\"headerlink\" title=\"题目扩展（均为单链表）：\"></a>题目扩展（均为单链表）：</h2><ol>\n<li>判断这俩个链表是否相交（无环）</li>\n<li>判断链表是否有环</li>\n<li>如何知道环的长度？</li>\n<li>如何找出环的连接点在哪里？</li>\n<li>带环链表的长度是多少？</li>\n<li>链表有环，判断相交</li>\n<li>判断两个链表相交的第一个节点<h5 id=\"下面我们一个一个的来解决这些问题\"><a href=\"#下面我们一个一个的来解决这些问题\" class=\"headerlink\" title=\"下面我们一个一个的来解决这些问题\"></a>下面我们一个一个的来解决这些问题</h5></li>\n</ol>\n<h3 id=\"问题1：判断这俩个链表是否相交（无环）\"><a href=\"#问题1：判断这俩个链表是否相交（无环）\" class=\"headerlink\" title=\"问题1：判断这俩个链表是否相交（无环）\"></a>问题1：判断这俩个链表是否相交（无环）</h3><h5 id=\"两个无环链表的相交问题，如果两个链表相交，则他们一定存在公共节点，且公共节点之后的节点全部都是相交的。则他们的结构为：\"><a href=\"#两个无环链表的相交问题，如果两个链表相交，则他们一定存在公共节点，且公共节点之后的节点全部都是相交的。则他们的结构为：\" class=\"headerlink\" title=\"两个无环链表的相交问题，如果两个链表相交，则他们一定存在公共节点，且公共节点之后的节点全部都是相交的。则他们的结构为：\"></a>两个无环链表的相交问题，如果两个链表相交，则他们一定存在公共节点，且公共节点之后的节点全部都是相交的。则他们的结构为：</h5><p><img src=\"/img/arithmetic/linked.jpg\" alt=\"二元查找树\"></p>\n<h5 id=\"如果两个链表相交，则他们的尾节点一定是同一个节点，所以可以直接对比两个链表的尾部节点是否相。时间复杂度为两个链表的长度之和O-m-n-。\"><a href=\"#如果两个链表相交，则他们的尾节点一定是同一个节点，所以可以直接对比两个链表的尾部节点是否相。时间复杂度为两个链表的长度之和O-m-n-。\" class=\"headerlink\" title=\"如果两个链表相交，则他们的尾节点一定是同一个节点，所以可以直接对比两个链表的尾部节点是否相。时间复杂度为两个链表的长度之和O(m+n)。\"></a>如果两个链表相交，则他们的尾节点一定是同一个节点，所以可以直接对比两个链表的尾部节点是否相。时间复杂度为两个链表的长度之和O(m+n)。</h5><h5 id=\"这种解法比较简单，只要想到最后一个节点相等就可以，后面还会有一些其他的解法介绍。\"><a href=\"#这种解法比较简单，只要想到最后一个节点相等就可以，后面还会有一些其他的解法介绍。\" class=\"headerlink\" title=\"这种解法比较简单，只要想到最后一个节点相等就可以，后面还会有一些其他的解法介绍。\"></a>这种解法比较简单，只要想到最后一个节点相等就可以，后面还会有一些其他的解法介绍。</h5><h3 id=\"问题2：判断链表是否有环\"><a href=\"#问题2：判断链表是否有环\" class=\"headerlink\" title=\"问题2：判断链表是否有环\"></a>问题2：判断链表是否有环</h3><h5 id=\"对于这个问题，可以使用一种追赶的方法。设定两个指针slow、fast，从头指针开始，每次分别前进1步、2步。如存在环，则两者相遇；如不存在环，fast遇到NULL退出。\"><a href=\"#对于这个问题，可以使用一种追赶的方法。设定两个指针slow、fast，从头指针开始，每次分别前进1步、2步。如存在环，则两者相遇；如不存在环，fast遇到NULL退出。\" class=\"headerlink\" title=\"对于这个问题，可以使用一种追赶的方法。设定两个指针slow、fast，从头指针开始，每次分别前进1步、2步。如存在环，则两者相遇；如不存在环，fast遇到NULL退出。\"></a>对于这个问题，可以使用一种追赶的方法。设定两个指针slow、fast，从头指针开始，每次分别前进1步、2步。如存在环，则两者相遇；如不存在环，fast遇到NULL退出。</h5><h5 id=\"这个过程比较好理解，如果存在环，所以fast指针则会在环内循环，直至slow指针进入环内，并且追赶上slow指针。因为fast每次两部，slow每次一步，试验后发现fast指针不会跳过slow指针，因此如果有换，则必定会在一个节点相交。\"><a href=\"#这个过程比较好理解，如果存在环，所以fast指针则会在环内循环，直至slow指针进入环内，并且追赶上slow指针。因为fast每次两部，slow每次一步，试验后发现fast指针不会跳过slow指针，因此如果有换，则必定会在一个节点相交。\" class=\"headerlink\" title=\"这个过程比较好理解，如果存在环，所以fast指针则会在环内循环，直至slow指针进入环内，并且追赶上slow指针。因为fast每次两部，slow每次一步，试验后发现fast指针不会跳过slow指针，因此如果有换，则必定会在一个节点相交。\"></a>这个过程比较好理解，如果存在环，所以fast指针则会在环内循环，直至slow指针进入环内，并且追赶上slow指针。因为fast每次两部，slow每次一步，试验后发现fast指针不会跳过slow指针，因此如果有换，则必定会在一个节点相交。</h5><h3 id=\"问题3：如何知道环的长度？\"><a href=\"#问题3：如何知道环的长度？\" class=\"headerlink\" title=\"问题3：如何知道环的长度？\"></a>问题3：如何知道环的长度？</h3><h5 id=\"基于上一步，我们已经判断一个链表是否有环，如果有环的话，如何判断环的长度呢。\"><a href=\"#基于上一步，我们已经判断一个链表是否有环，如果有环的话，如何判断环的长度呢。\" class=\"headerlink\" title=\"基于上一步，我们已经判断一个链表是否有环，如果有环的话，如何判断环的长度呢。\"></a>基于上一步，我们已经判断一个链表是否有环，如果有环的话，如何判断环的长度呢。</h5><h5 id=\"还是一样的方法，在上一个问题中，fast和slow将相交于环内一点，fast的速度是slow的两倍，则只需要fast和slow继续以原速度前进，当他们再次相交时，slow所走了步数为环的长度。\"><a href=\"#还是一样的方法，在上一个问题中，fast和slow将相交于环内一点，fast的速度是slow的两倍，则只需要fast和slow继续以原速度前进，当他们再次相交时，slow所走了步数为环的长度。\" class=\"headerlink\" title=\"还是一样的方法，在上一个问题中，fast和slow将相交于环内一点，fast的速度是slow的两倍，则只需要fast和slow继续以原速度前进，当他们再次相交时，slow所走了步数为环的长度。\"></a>还是一样的方法，在上一个问题中，fast和slow将相交于环内一点，fast的速度是slow的两倍，则只需要fast和slow继续以原速度前进，当他们再次相交时，slow所走了步数为环的长度。</h5><h3 id=\"问题4：如何找出环的连接点在哪里？\"><a href=\"#问题4：如何找出环的连接点在哪里？\" class=\"headerlink\" title=\"问题4：如何找出环的连接点在哪里？\"></a>问题4：如何找出环的连接点在哪里？</h3><h5 id=\"相对于上面两个问题，这个问题相对更复杂一些。回到问题”判断链表是否有环”。\"><a href=\"#相对于上面两个问题，这个问题相对更复杂一些。回到问题”判断链表是否有环”。\" class=\"headerlink\" title=\"相对于上面两个问题，这个问题相对更复杂一些。回到问题”判断链表是否有环”。\"></a>相对于上面两个问题，这个问题相对更复杂一些。回到问题”判断链表是否有环”。</h5><h5 id=\"当fast指针和slow指针相交时，slow指针必定未走完一圈，因为在slow进入环入口时，fast指针已经在环内，这就成了一个fast追赶slow的问题，除了fast和slow已经相交，否则fast追赶上slow，slow用不了一周。因此此时slow还未第二次经过入口节点。\"><a href=\"#当fast指针和slow指针相交时，slow指针必定未走完一圈，因为在slow进入环入口时，fast指针已经在环内，这就成了一个fast追赶slow的问题，除了fast和slow已经相交，否则fast追赶上slow，slow用不了一周。因此此时slow还未第二次经过入口节点。\" class=\"headerlink\" title=\"当fast指针和slow指针相交时，slow指针必定未走完一圈，因为在slow进入环入口时，fast指针已经在环内，这就成了一个fast追赶slow的问题，除了fast和slow已经相交，否则fast追赶上slow，slow用不了一周。因此此时slow还未第二次经过入口节点。\"></a>当fast指针和slow指针相交时，slow指针必定未走完一圈，因为在slow进入环入口时，fast指针已经在环内，这就成了一个fast追赶slow的问题，除了fast和slow已经相交，否则fast追赶上slow，slow用不了一周。因此此时slow还未第二次经过入口节点。</h5><ol>\n<li>假设slow进过的节点数量为r，则fast为2r</li>\n<li>假设环的长度为s，因为slow和fast已经在同一点，而fast比slow多走了r个节点，所以r = ns。n为常数，大于等于1，代表的是fast绕环的次数。</li>\n<li>假设头节点为点a，入口节点为b，fast和slow相遇节点为c，则ac = r = ns = ab + bc；bc + cb = s；（bc表示从入口节点至相遇节点，cb表示从相遇节点至入口节点） ab = r - bc；所以，ab - cb = (n-1)s；<br><img src=\"/img/arithmetic/linked2.jpg\" alt=\"单链表带环\"><h5 id=\"因此，从头节点a和相遇节点c重新开始走，第一次相遇的节点为入口节点b。从a节点走的指针步数为1，从c节点走的指针步数则大于等于1-因为大于1时，无非就是n大一些，多走了几圈。\"><a href=\"#因此，从头节点a和相遇节点c重新开始走，第一次相遇的节点为入口节点b。从a节点走的指针步数为1，从c节点走的指针步数则大于等于1-因为大于1时，无非就是n大一些，多走了几圈。\" class=\"headerlink\" title=\"因此，从头节点a和相遇节点c重新开始走，第一次相遇的节点为入口节点b。从a节点走的指针步数为1，从c节点走的指针步数则大于等于1,因为大于1时，无非就是n大一些，多走了几圈。\"></a>因此，从头节点a和相遇节点c重新开始走，第一次相遇的节点为入口节点b。从a节点走的指针步数为1，从c节点走的指针步数则大于等于1,因为大于1时，无非就是n大一些，多走了几圈。</h5></li>\n</ol>\n<h3 id=\"问题5：带环链表的长度是多少？\"><a href=\"#问题5：带环链表的长度是多少？\" class=\"headerlink\" title=\"问题5：带环链表的长度是多少？\"></a>问题5：带环链表的长度是多少？</h3><h5 id=\"问题4可以求出头节点到入口节点的长度，加上问题3的环长度，等于链表长度。或者问题4求出入口节点，以及问题2的相遇节点。都可以求出链表长度。\"><a href=\"#问题4可以求出头节点到入口节点的长度，加上问题3的环长度，等于链表长度。或者问题4求出入口节点，以及问题2的相遇节点。都可以求出链表长度。\" class=\"headerlink\" title=\"问题4可以求出头节点到入口节点的长度，加上问题3的环长度，等于链表长度。或者问题4求出入口节点，以及问题2的相遇节点。都可以求出链表长度。\"></a>问题4可以求出头节点到入口节点的长度，加上问题3的环长度，等于链表长度。或者问题4求出入口节点，以及问题2的相遇节点。都可以求出链表长度。</h5><h3 id=\"问题6：链表有环，判断相交\"><a href=\"#问题6：链表有环，判断相交\" class=\"headerlink\" title=\"问题6：链表有环，判断相交\"></a>问题6：链表有环，判断相交</h3><h5 id=\"一个链表有环，一个链表无环的情况下。两个链表不可能相交。\"><a href=\"#一个链表有环，一个链表无环的情况下。两个链表不可能相交。\" class=\"headerlink\" title=\"一个链表有环，一个链表无环的情况下。两个链表不可能相交。\"></a>一个链表有环，一个链表无环的情况下。两个链表不可能相交。</h5><h5 id=\"两个链表均有环，则两个链表的环一定是共有的。则可以判断一个链表的相遇点，相遇点一定处于环内，再判断该点是否存在于另一个链表当中。\"><a href=\"#两个链表均有环，则两个链表的环一定是共有的。则可以判断一个链表的相遇点，相遇点一定处于环内，再判断该点是否存在于另一个链表当中。\" class=\"headerlink\" title=\"两个链表均有环，则两个链表的环一定是共有的。则可以判断一个链表的相遇点，相遇点一定处于环内，再判断该点是否存在于另一个链表当中。\"></a>两个链表均有环，则两个链表的环一定是共有的。则可以判断一个链表的相遇点，相遇点一定处于环内，再判断该点是否存在于另一个链表当中。</h5>"},{"layout":"post","title":"聚类算法-基于上车地点的区域计算","date":"2018-04-12T16:00:00.000Z","original":true,"tag":[["算法","arithmetic"]],"_content":"\ntodo","source":"_posts/note/arithmetic/point2area.md","raw":"---\nlayout: post\ntitle: 聚类算法-基于上车地点的区域计算\ndate: 2018/04/13\noriginal: true\ntags: [tech, arithmetic, index]\ntag: [[算法, arithmetic]]\n---\n\ntodo","slug":"note/arithmetic/point2area","published":1,"updated":"2018-05-08T13:00:14.275Z","comments":1,"photos":[],"link":"","_id":"cjgxop3na0030jah144qw9b6r","content":"<p>todo</p>\n","site":{"data":{}},"excerpt":"","more":"<p>todo</p>\n"},{"layout":"post","title":"加权轮询算法","date":"2018-03-24T16:00:00.000Z","tag":[["算法","arithmetic"]],"_content":"\n##### 在介绍加权轮询算法(WeightedRound-Robin)之前，首先介绍一下轮询算法(Round-Robin)。\n\n## 轮询算法(Round-Robin)\n##### 轮询算法是最简单的一种负载均衡算法。它的原理是把来自用户的请求轮流分配给内部的服务器：从服务器1开始，直到服务器N，然后重新开始循环。算法的优点是其简洁性，它无需记录当前所有连接的状态，所以它是一种无状态调度。\n<!--more-->\n\n##### 假设有N台服务器：S = {S1, S2, …, Sn}，一个指示变量i表示上一次选择的服务器ID。变量i被初始化为N-1。该算法的伪代码如下：\n```java\nj = i;\ndo\n{\n    j = (j + 1) mod n;\n    i = j;\n    return Si;\n} while (j != i);\nreturn NULL;\n```\n##### 轮询算法假设所有服务器的处理性能都相同，不关心每台服务器的当前连接数和响应速度。当请求服务间隔时间变化比较大时，轮询算法容易导致服务器间的负载不平衡。所以此种均衡算法适合于服务器组中的所有服务器都有相同的软硬件配置并且平均服务请求相对均衡的情况。\n\n## 加权轮询算法(WeightedRound-Robin)\n##### 轮询算法并没有考虑每台服务器的处理能力，实际中可能并不是这种情况。由于每台服务器的配置、安装的业务应用等不同，其处理能力会不一样。所以，加权轮询算法的原理就是：根据服务器的不同处理能力，给每个服务器分配不同的权值，使其能够接受相应权值数的服务请求。\n\n#### 首先看一个简单的Nginx负载均衡配置。\n```nginx\nhttp {\n    upstream cluster {\n        server a weight=1;\n        server b weight=2;\n        server c weight=4;\n    }\n    ...\n}\n```\n\n##### 按照上述配置，Nginx每收到7个客户端的请求，会把其中的1个转发给后端a，把其中的2个转发给后端b，把其中的4个转发给后端c。\n\n##### 加权轮询算法的结果，就是要生成一个服务器序列。每当有请求到来时，就依次从该序列中取出下一个服务器用于处理该请求。比如针对上面的例子，加权轮询算法会生成序列{c, c, b, c, a, b, c}。这样，每收到7个客户端的请求，会把其中的1个转发给后端a，把其中的2个转发给后端b，把其中的4个转发给后端c。收到的第8个请求，重新从该序列的头部开始轮询。\n\n##### 总之，加权轮询算法要生成一个服务器序列，该序列中包含n个服务器。n是所有服务器的权重之和。在该序列中，每个服务器的出现的次数，等于其权重值。并且，生成的序列中，服务器的分布应该尽可能的均匀。比如序列{a, a, a, a, a, b, c}中，前五个请求都会分配给服务器a，这就是一种不均匀的分配方法，更好的序列应该是：{a, a, b, a, c, a, a}。\n\n### 普通加权轮询算法\n* 这种算法的原理是：在服务器数组S中，首先计算所有服务器权重的最大值max(S)，以及所有服务器权重的最大公约数gcd(S)。\n* index表示本次请求到来时，选择的服务器的索引，初始值为-1；current_weight表示当前调度的权值，初始值为max(S)。\n* 当请求到来时，从index+1开始轮询服务器数组S，找到其中权重大于current_weight的第一个服务器，用于处理该请求。记录其索引到结果序列中。\n* 在轮询服务器数组时，如果到达了数组末尾，则重新从头开始搜索，并且减小current_weight的值：current_weight -= gcd(S)。如果current_weight等于0，则将其重置为max(S)。\n\n##### 这背后的数学原理，自己思考了一下，总结如下：\n* current_weight的值，其变化序列就是一个等差序列：max, max-gcd, max-2gcd, …, 0(max)，将current_weight从max变为0的过程，称为一个轮回。\n* 针对每个current_weight，该算法就是要把服务器数组从头到尾扫描一遍，将其中权重大于等于current_weight的所有服务器填充到结果序列中。扫描完一遍服务器数组之后，将current_weight变为下一个值，再一次从头到尾扫描服务器数组。\n* 在current_weight变化过程中，不管current_weight当前为何值，具有max权重的服务器每次肯定会被选中。因此，具有max权重的服务器会在序列中出现max/gcd次（等差序列中的项数）。\n* 更一般的，当current_weight变为x之后，权重为x的服务器，在current_weight接下来的变化过程中，每次都会被选中，因此，具有x权重的服务器，会在序列中出现x/gcd次。所以，每个服务器在结果序列中出现的次数，是与其权重成正比的，这就是符合加权轮询算法的要求了。\n\n### 平滑的加权轮询\n##### 上面的加权轮询算法有个缺陷，就是某些情况下生成的序列是不均匀的。比如针对这样的配置：\n```nginx\nhttp {\n    upstream cluster {\n        server a weight=5;\n        server b weight=1;\n        server c weight=1;\n    }\n    ...\n}\n```\n##### 生成的序列是这样的：{a,a, a, a, a, c, b}。会有5个连续的请求落在后端a上，分布不太均匀。\n##### 在Nginx源码中，实现了一种叫做平滑的加权轮询（smooth weighted round-robin balancing）的算法，它生成的序列更加均匀。比如前面的例子，它生成的序列为{ a, a, b, a, c, a, a}，转发给后端a的5个请求现在分散开来，不再是连续的。\n\n#### 该算法的原理如下：\n##### 每个服务器都有两个权重变量：\n1. weight，配置文件中指定的该服务器的权重，这个值是固定不变的；\n2. current_weight，服务器目前的权重。一开始为0，之后会动态调整。\n\n##### 每次当请求到来，选取服务器时，会遍历数组中所有服务器。对于每个服务器，让它的current_weight增加它的weight；同时累加所有服务器的weight，并保存为total。\n##### 遍历完所有服务器之后，如果该服务器的current_weight是最大的，就选择这个服务器处理本次请求。最后把该服务器的current_weight减去total。\n\n#### 上述描述可能不太直观，来看个例子。比如针对这样的配置：\n```nginx\n\nhttp {\n    upstream cluster {\n        server a weight=4;\n        server b weight=2;\n        server c weight=1;\n    }\n    ...\n}\n```\n\n##### 按照这个配置，每7个客户端请求中，a会被选中4次、b会被选中2次、c会被选中1次，且分布平滑。我们来算算看是不是这样子的。\n![](/img/arithmetic/WeightedRound.png)\n\n##### 通过上述过程，可得以下结论：\n* 7个请求中，a、b、c分别被选取了4、2、1次，符合它们的权重值。\n* 7个请求中，a、b、c被选取的顺序为a, b,a, c, a, b, a，分布均匀，权重大的后端a没有被连续选取。\n* 每经过7个请求后，a、b、c的current_weight又回到初始值{0, 0,0}，因此上述流程是不断循环的。\n\n##### 转载自：[https://blog.csdn.net/gqtcgq/article/details/52076997](https://blog.csdn.net/gqtcgq/article/details/52076997)","source":"_posts/note/arithmetic/roundrobinWeight.md","raw":"---\nlayout: post\ntitle: 加权轮询算法\ndate: 2018/03/25\ntags: [tech, arithmetic, index]\ntag: [[算法, arithmetic]]\n---\n\n##### 在介绍加权轮询算法(WeightedRound-Robin)之前，首先介绍一下轮询算法(Round-Robin)。\n\n## 轮询算法(Round-Robin)\n##### 轮询算法是最简单的一种负载均衡算法。它的原理是把来自用户的请求轮流分配给内部的服务器：从服务器1开始，直到服务器N，然后重新开始循环。算法的优点是其简洁性，它无需记录当前所有连接的状态，所以它是一种无状态调度。\n<!--more-->\n\n##### 假设有N台服务器：S = {S1, S2, …, Sn}，一个指示变量i表示上一次选择的服务器ID。变量i被初始化为N-1。该算法的伪代码如下：\n```java\nj = i;\ndo\n{\n    j = (j + 1) mod n;\n    i = j;\n    return Si;\n} while (j != i);\nreturn NULL;\n```\n##### 轮询算法假设所有服务器的处理性能都相同，不关心每台服务器的当前连接数和响应速度。当请求服务间隔时间变化比较大时，轮询算法容易导致服务器间的负载不平衡。所以此种均衡算法适合于服务器组中的所有服务器都有相同的软硬件配置并且平均服务请求相对均衡的情况。\n\n## 加权轮询算法(WeightedRound-Robin)\n##### 轮询算法并没有考虑每台服务器的处理能力，实际中可能并不是这种情况。由于每台服务器的配置、安装的业务应用等不同，其处理能力会不一样。所以，加权轮询算法的原理就是：根据服务器的不同处理能力，给每个服务器分配不同的权值，使其能够接受相应权值数的服务请求。\n\n#### 首先看一个简单的Nginx负载均衡配置。\n```nginx\nhttp {\n    upstream cluster {\n        server a weight=1;\n        server b weight=2;\n        server c weight=4;\n    }\n    ...\n}\n```\n\n##### 按照上述配置，Nginx每收到7个客户端的请求，会把其中的1个转发给后端a，把其中的2个转发给后端b，把其中的4个转发给后端c。\n\n##### 加权轮询算法的结果，就是要生成一个服务器序列。每当有请求到来时，就依次从该序列中取出下一个服务器用于处理该请求。比如针对上面的例子，加权轮询算法会生成序列{c, c, b, c, a, b, c}。这样，每收到7个客户端的请求，会把其中的1个转发给后端a，把其中的2个转发给后端b，把其中的4个转发给后端c。收到的第8个请求，重新从该序列的头部开始轮询。\n\n##### 总之，加权轮询算法要生成一个服务器序列，该序列中包含n个服务器。n是所有服务器的权重之和。在该序列中，每个服务器的出现的次数，等于其权重值。并且，生成的序列中，服务器的分布应该尽可能的均匀。比如序列{a, a, a, a, a, b, c}中，前五个请求都会分配给服务器a，这就是一种不均匀的分配方法，更好的序列应该是：{a, a, b, a, c, a, a}。\n\n### 普通加权轮询算法\n* 这种算法的原理是：在服务器数组S中，首先计算所有服务器权重的最大值max(S)，以及所有服务器权重的最大公约数gcd(S)。\n* index表示本次请求到来时，选择的服务器的索引，初始值为-1；current_weight表示当前调度的权值，初始值为max(S)。\n* 当请求到来时，从index+1开始轮询服务器数组S，找到其中权重大于current_weight的第一个服务器，用于处理该请求。记录其索引到结果序列中。\n* 在轮询服务器数组时，如果到达了数组末尾，则重新从头开始搜索，并且减小current_weight的值：current_weight -= gcd(S)。如果current_weight等于0，则将其重置为max(S)。\n\n##### 这背后的数学原理，自己思考了一下，总结如下：\n* current_weight的值，其变化序列就是一个等差序列：max, max-gcd, max-2gcd, …, 0(max)，将current_weight从max变为0的过程，称为一个轮回。\n* 针对每个current_weight，该算法就是要把服务器数组从头到尾扫描一遍，将其中权重大于等于current_weight的所有服务器填充到结果序列中。扫描完一遍服务器数组之后，将current_weight变为下一个值，再一次从头到尾扫描服务器数组。\n* 在current_weight变化过程中，不管current_weight当前为何值，具有max权重的服务器每次肯定会被选中。因此，具有max权重的服务器会在序列中出现max/gcd次（等差序列中的项数）。\n* 更一般的，当current_weight变为x之后，权重为x的服务器，在current_weight接下来的变化过程中，每次都会被选中，因此，具有x权重的服务器，会在序列中出现x/gcd次。所以，每个服务器在结果序列中出现的次数，是与其权重成正比的，这就是符合加权轮询算法的要求了。\n\n### 平滑的加权轮询\n##### 上面的加权轮询算法有个缺陷，就是某些情况下生成的序列是不均匀的。比如针对这样的配置：\n```nginx\nhttp {\n    upstream cluster {\n        server a weight=5;\n        server b weight=1;\n        server c weight=1;\n    }\n    ...\n}\n```\n##### 生成的序列是这样的：{a,a, a, a, a, c, b}。会有5个连续的请求落在后端a上，分布不太均匀。\n##### 在Nginx源码中，实现了一种叫做平滑的加权轮询（smooth weighted round-robin balancing）的算法，它生成的序列更加均匀。比如前面的例子，它生成的序列为{ a, a, b, a, c, a, a}，转发给后端a的5个请求现在分散开来，不再是连续的。\n\n#### 该算法的原理如下：\n##### 每个服务器都有两个权重变量：\n1. weight，配置文件中指定的该服务器的权重，这个值是固定不变的；\n2. current_weight，服务器目前的权重。一开始为0，之后会动态调整。\n\n##### 每次当请求到来，选取服务器时，会遍历数组中所有服务器。对于每个服务器，让它的current_weight增加它的weight；同时累加所有服务器的weight，并保存为total。\n##### 遍历完所有服务器之后，如果该服务器的current_weight是最大的，就选择这个服务器处理本次请求。最后把该服务器的current_weight减去total。\n\n#### 上述描述可能不太直观，来看个例子。比如针对这样的配置：\n```nginx\n\nhttp {\n    upstream cluster {\n        server a weight=4;\n        server b weight=2;\n        server c weight=1;\n    }\n    ...\n}\n```\n\n##### 按照这个配置，每7个客户端请求中，a会被选中4次、b会被选中2次、c会被选中1次，且分布平滑。我们来算算看是不是这样子的。\n![](/img/arithmetic/WeightedRound.png)\n\n##### 通过上述过程，可得以下结论：\n* 7个请求中，a、b、c分别被选取了4、2、1次，符合它们的权重值。\n* 7个请求中，a、b、c被选取的顺序为a, b,a, c, a, b, a，分布均匀，权重大的后端a没有被连续选取。\n* 每经过7个请求后，a、b、c的current_weight又回到初始值{0, 0,0}，因此上述流程是不断循环的。\n\n##### 转载自：[https://blog.csdn.net/gqtcgq/article/details/52076997](https://blog.csdn.net/gqtcgq/article/details/52076997)","slug":"note/arithmetic/roundrobinWeight","published":1,"updated":"2018-05-08T13:00:14.275Z","comments":1,"photos":[],"link":"","_id":"cjgxop3nb0032jah1xng2j56a","content":"<h5 id=\"在介绍加权轮询算法-WeightedRound-Robin-之前，首先介绍一下轮询算法-Round-Robin-。\"><a href=\"#在介绍加权轮询算法-WeightedRound-Robin-之前，首先介绍一下轮询算法-Round-Robin-。\" class=\"headerlink\" title=\"在介绍加权轮询算法(WeightedRound-Robin)之前，首先介绍一下轮询算法(Round-Robin)。\"></a>在介绍加权轮询算法(WeightedRound-Robin)之前，首先介绍一下轮询算法(Round-Robin)。</h5><h2 id=\"轮询算法-Round-Robin\"><a href=\"#轮询算法-Round-Robin\" class=\"headerlink\" title=\"轮询算法(Round-Robin)\"></a>轮询算法(Round-Robin)</h2><h5 id=\"轮询算法是最简单的一种负载均衡算法。它的原理是把来自用户的请求轮流分配给内部的服务器：从服务器1开始，直到服务器N，然后重新开始循环。算法的优点是其简洁性，它无需记录当前所有连接的状态，所以它是一种无状态调度。\"><a href=\"#轮询算法是最简单的一种负载均衡算法。它的原理是把来自用户的请求轮流分配给内部的服务器：从服务器1开始，直到服务器N，然后重新开始循环。算法的优点是其简洁性，它无需记录当前所有连接的状态，所以它是一种无状态调度。\" class=\"headerlink\" title=\"轮询算法是最简单的一种负载均衡算法。它的原理是把来自用户的请求轮流分配给内部的服务器：从服务器1开始，直到服务器N，然后重新开始循环。算法的优点是其简洁性，它无需记录当前所有连接的状态，所以它是一种无状态调度。\"></a>轮询算法是最简单的一种负载均衡算法。它的原理是把来自用户的请求轮流分配给内部的服务器：从服务器1开始，直到服务器N，然后重新开始循环。算法的优点是其简洁性，它无需记录当前所有连接的状态，所以它是一种无状态调度。</h5><a id=\"more\"></a>\n<h5 id=\"假设有N台服务器：S-S1-S2-…-Sn-，一个指示变量i表示上一次选择的服务器ID。变量i被初始化为N-1。该算法的伪代码如下：\"><a href=\"#假设有N台服务器：S-S1-S2-…-Sn-，一个指示变量i表示上一次选择的服务器ID。变量i被初始化为N-1。该算法的伪代码如下：\" class=\"headerlink\" title=\"假设有N台服务器：S = {S1, S2, …, Sn}，一个指示变量i表示上一次选择的服务器ID。变量i被初始化为N-1。该算法的伪代码如下：\"></a>假设有N台服务器：S = {S1, S2, …, Sn}，一个指示变量i表示上一次选择的服务器ID。变量i被初始化为N-1。该算法的伪代码如下：</h5><pre><code class=\"lang-java\">j = i;\ndo\n{\n    j = (j + 1) mod n;\n    i = j;\n    return Si;\n} while (j != i);\nreturn NULL;\n</code></pre>\n<h5 id=\"轮询算法假设所有服务器的处理性能都相同，不关心每台服务器的当前连接数和响应速度。当请求服务间隔时间变化比较大时，轮询算法容易导致服务器间的负载不平衡。所以此种均衡算法适合于服务器组中的所有服务器都有相同的软硬件配置并且平均服务请求相对均衡的情况。\"><a href=\"#轮询算法假设所有服务器的处理性能都相同，不关心每台服务器的当前连接数和响应速度。当请求服务间隔时间变化比较大时，轮询算法容易导致服务器间的负载不平衡。所以此种均衡算法适合于服务器组中的所有服务器都有相同的软硬件配置并且平均服务请求相对均衡的情况。\" class=\"headerlink\" title=\"轮询算法假设所有服务器的处理性能都相同，不关心每台服务器的当前连接数和响应速度。当请求服务间隔时间变化比较大时，轮询算法容易导致服务器间的负载不平衡。所以此种均衡算法适合于服务器组中的所有服务器都有相同的软硬件配置并且平均服务请求相对均衡的情况。\"></a>轮询算法假设所有服务器的处理性能都相同，不关心每台服务器的当前连接数和响应速度。当请求服务间隔时间变化比较大时，轮询算法容易导致服务器间的负载不平衡。所以此种均衡算法适合于服务器组中的所有服务器都有相同的软硬件配置并且平均服务请求相对均衡的情况。</h5><h2 id=\"加权轮询算法-WeightedRound-Robin\"><a href=\"#加权轮询算法-WeightedRound-Robin\" class=\"headerlink\" title=\"加权轮询算法(WeightedRound-Robin)\"></a>加权轮询算法(WeightedRound-Robin)</h2><h5 id=\"轮询算法并没有考虑每台服务器的处理能力，实际中可能并不是这种情况。由于每台服务器的配置、安装的业务应用等不同，其处理能力会不一样。所以，加权轮询算法的原理就是：根据服务器的不同处理能力，给每个服务器分配不同的权值，使其能够接受相应权值数的服务请求。\"><a href=\"#轮询算法并没有考虑每台服务器的处理能力，实际中可能并不是这种情况。由于每台服务器的配置、安装的业务应用等不同，其处理能力会不一样。所以，加权轮询算法的原理就是：根据服务器的不同处理能力，给每个服务器分配不同的权值，使其能够接受相应权值数的服务请求。\" class=\"headerlink\" title=\"轮询算法并没有考虑每台服务器的处理能力，实际中可能并不是这种情况。由于每台服务器的配置、安装的业务应用等不同，其处理能力会不一样。所以，加权轮询算法的原理就是：根据服务器的不同处理能力，给每个服务器分配不同的权值，使其能够接受相应权值数的服务请求。\"></a>轮询算法并没有考虑每台服务器的处理能力，实际中可能并不是这种情况。由于每台服务器的配置、安装的业务应用等不同，其处理能力会不一样。所以，加权轮询算法的原理就是：根据服务器的不同处理能力，给每个服务器分配不同的权值，使其能够接受相应权值数的服务请求。</h5><h4 id=\"首先看一个简单的Nginx负载均衡配置。\"><a href=\"#首先看一个简单的Nginx负载均衡配置。\" class=\"headerlink\" title=\"首先看一个简单的Nginx负载均衡配置。\"></a>首先看一个简单的Nginx负载均衡配置。</h4><pre><code class=\"lang-nginx\">http {\n    upstream cluster {\n        server a weight=1;\n        server b weight=2;\n        server c weight=4;\n    }\n    ...\n}\n</code></pre>\n<h5 id=\"按照上述配置，Nginx每收到7个客户端的请求，会把其中的1个转发给后端a，把其中的2个转发给后端b，把其中的4个转发给后端c。\"><a href=\"#按照上述配置，Nginx每收到7个客户端的请求，会把其中的1个转发给后端a，把其中的2个转发给后端b，把其中的4个转发给后端c。\" class=\"headerlink\" title=\"按照上述配置，Nginx每收到7个客户端的请求，会把其中的1个转发给后端a，把其中的2个转发给后端b，把其中的4个转发给后端c。\"></a>按照上述配置，Nginx每收到7个客户端的请求，会把其中的1个转发给后端a，把其中的2个转发给后端b，把其中的4个转发给后端c。</h5><h5 id=\"加权轮询算法的结果，就是要生成一个服务器序列。每当有请求到来时，就依次从该序列中取出下一个服务器用于处理该请求。比如针对上面的例子，加权轮询算法会生成序列-c-c-b-c-a-b-c-。这样，每收到7个客户端的请求，会把其中的1个转发给后端a，把其中的2个转发给后端b，把其中的4个转发给后端c。收到的第8个请求，重新从该序列的头部开始轮询。\"><a href=\"#加权轮询算法的结果，就是要生成一个服务器序列。每当有请求到来时，就依次从该序列中取出下一个服务器用于处理该请求。比如针对上面的例子，加权轮询算法会生成序列-c-c-b-c-a-b-c-。这样，每收到7个客户端的请求，会把其中的1个转发给后端a，把其中的2个转发给后端b，把其中的4个转发给后端c。收到的第8个请求，重新从该序列的头部开始轮询。\" class=\"headerlink\" title=\"加权轮询算法的结果，就是要生成一个服务器序列。每当有请求到来时，就依次从该序列中取出下一个服务器用于处理该请求。比如针对上面的例子，加权轮询算法会生成序列{c, c, b, c, a, b, c}。这样，每收到7个客户端的请求，会把其中的1个转发给后端a，把其中的2个转发给后端b，把其中的4个转发给后端c。收到的第8个请求，重新从该序列的头部开始轮询。\"></a>加权轮询算法的结果，就是要生成一个服务器序列。每当有请求到来时，就依次从该序列中取出下一个服务器用于处理该请求。比如针对上面的例子，加权轮询算法会生成序列{c, c, b, c, a, b, c}。这样，每收到7个客户端的请求，会把其中的1个转发给后端a，把其中的2个转发给后端b，把其中的4个转发给后端c。收到的第8个请求，重新从该序列的头部开始轮询。</h5><h5 id=\"总之，加权轮询算法要生成一个服务器序列，该序列中包含n个服务器。n是所有服务器的权重之和。在该序列中，每个服务器的出现的次数，等于其权重值。并且，生成的序列中，服务器的分布应该尽可能的均匀。比如序列-a-a-a-a-a-b-c-中，前五个请求都会分配给服务器a，这就是一种不均匀的分配方法，更好的序列应该是：-a-a-b-a-c-a-a-。\"><a href=\"#总之，加权轮询算法要生成一个服务器序列，该序列中包含n个服务器。n是所有服务器的权重之和。在该序列中，每个服务器的出现的次数，等于其权重值。并且，生成的序列中，服务器的分布应该尽可能的均匀。比如序列-a-a-a-a-a-b-c-中，前五个请求都会分配给服务器a，这就是一种不均匀的分配方法，更好的序列应该是：-a-a-b-a-c-a-a-。\" class=\"headerlink\" title=\"总之，加权轮询算法要生成一个服务器序列，该序列中包含n个服务器。n是所有服务器的权重之和。在该序列中，每个服务器的出现的次数，等于其权重值。并且，生成的序列中，服务器的分布应该尽可能的均匀。比如序列{a, a, a, a, a, b, c}中，前五个请求都会分配给服务器a，这就是一种不均匀的分配方法，更好的序列应该是：{a, a, b, a, c, a, a}。\"></a>总之，加权轮询算法要生成一个服务器序列，该序列中包含n个服务器。n是所有服务器的权重之和。在该序列中，每个服务器的出现的次数，等于其权重值。并且，生成的序列中，服务器的分布应该尽可能的均匀。比如序列{a, a, a, a, a, b, c}中，前五个请求都会分配给服务器a，这就是一种不均匀的分配方法，更好的序列应该是：{a, a, b, a, c, a, a}。</h5><h3 id=\"普通加权轮询算法\"><a href=\"#普通加权轮询算法\" class=\"headerlink\" title=\"普通加权轮询算法\"></a>普通加权轮询算法</h3><ul>\n<li>这种算法的原理是：在服务器数组S中，首先计算所有服务器权重的最大值max(S)，以及所有服务器权重的最大公约数gcd(S)。</li>\n<li>index表示本次请求到来时，选择的服务器的索引，初始值为-1；current_weight表示当前调度的权值，初始值为max(S)。</li>\n<li>当请求到来时，从index+1开始轮询服务器数组S，找到其中权重大于current_weight的第一个服务器，用于处理该请求。记录其索引到结果序列中。</li>\n<li>在轮询服务器数组时，如果到达了数组末尾，则重新从头开始搜索，并且减小current_weight的值：current_weight -= gcd(S)。如果current_weight等于0，则将其重置为max(S)。</li>\n</ul>\n<h5 id=\"这背后的数学原理，自己思考了一下，总结如下：\"><a href=\"#这背后的数学原理，自己思考了一下，总结如下：\" class=\"headerlink\" title=\"这背后的数学原理，自己思考了一下，总结如下：\"></a>这背后的数学原理，自己思考了一下，总结如下：</h5><ul>\n<li>current_weight的值，其变化序列就是一个等差序列：max, max-gcd, max-2gcd, …, 0(max)，将current_weight从max变为0的过程，称为一个轮回。</li>\n<li>针对每个current_weight，该算法就是要把服务器数组从头到尾扫描一遍，将其中权重大于等于current_weight的所有服务器填充到结果序列中。扫描完一遍服务器数组之后，将current_weight变为下一个值，再一次从头到尾扫描服务器数组。</li>\n<li>在current_weight变化过程中，不管current_weight当前为何值，具有max权重的服务器每次肯定会被选中。因此，具有max权重的服务器会在序列中出现max/gcd次（等差序列中的项数）。</li>\n<li>更一般的，当current_weight变为x之后，权重为x的服务器，在current_weight接下来的变化过程中，每次都会被选中，因此，具有x权重的服务器，会在序列中出现x/gcd次。所以，每个服务器在结果序列中出现的次数，是与其权重成正比的，这就是符合加权轮询算法的要求了。</li>\n</ul>\n<h3 id=\"平滑的加权轮询\"><a href=\"#平滑的加权轮询\" class=\"headerlink\" title=\"平滑的加权轮询\"></a>平滑的加权轮询</h3><h5 id=\"上面的加权轮询算法有个缺陷，就是某些情况下生成的序列是不均匀的。比如针对这样的配置：\"><a href=\"#上面的加权轮询算法有个缺陷，就是某些情况下生成的序列是不均匀的。比如针对这样的配置：\" class=\"headerlink\" title=\"上面的加权轮询算法有个缺陷，就是某些情况下生成的序列是不均匀的。比如针对这样的配置：\"></a>上面的加权轮询算法有个缺陷，就是某些情况下生成的序列是不均匀的。比如针对这样的配置：</h5><pre><code class=\"lang-nginx\">http {\n    upstream cluster {\n        server a weight=5;\n        server b weight=1;\n        server c weight=1;\n    }\n    ...\n}\n</code></pre>\n<h5 id=\"生成的序列是这样的：-a-a-a-a-a-c-b-。会有5个连续的请求落在后端a上，分布不太均匀。\"><a href=\"#生成的序列是这样的：-a-a-a-a-a-c-b-。会有5个连续的请求落在后端a上，分布不太均匀。\" class=\"headerlink\" title=\"生成的序列是这样的：{a,a, a, a, a, c, b}。会有5个连续的请求落在后端a上，分布不太均匀。\"></a>生成的序列是这样的：{a,a, a, a, a, c, b}。会有5个连续的请求落在后端a上，分布不太均匀。</h5><h5 id=\"在Nginx源码中，实现了一种叫做平滑的加权轮询（smooth-weighted-round-robin-balancing）的算法，它生成的序列更加均匀。比如前面的例子，它生成的序列为-a-a-b-a-c-a-a-，转发给后端a的5个请求现在分散开来，不再是连续的。\"><a href=\"#在Nginx源码中，实现了一种叫做平滑的加权轮询（smooth-weighted-round-robin-balancing）的算法，它生成的序列更加均匀。比如前面的例子，它生成的序列为-a-a-b-a-c-a-a-，转发给后端a的5个请求现在分散开来，不再是连续的。\" class=\"headerlink\" title=\"在Nginx源码中，实现了一种叫做平滑的加权轮询（smooth weighted round-robin balancing）的算法，它生成的序列更加均匀。比如前面的例子，它生成的序列为{ a, a, b, a, c, a, a}，转发给后端a的5个请求现在分散开来，不再是连续的。\"></a>在Nginx源码中，实现了一种叫做平滑的加权轮询（smooth weighted round-robin balancing）的算法，它生成的序列更加均匀。比如前面的例子，它生成的序列为{ a, a, b, a, c, a, a}，转发给后端a的5个请求现在分散开来，不再是连续的。</h5><h4 id=\"该算法的原理如下：\"><a href=\"#该算法的原理如下：\" class=\"headerlink\" title=\"该算法的原理如下：\"></a>该算法的原理如下：</h4><h5 id=\"每个服务器都有两个权重变量：\"><a href=\"#每个服务器都有两个权重变量：\" class=\"headerlink\" title=\"每个服务器都有两个权重变量：\"></a>每个服务器都有两个权重变量：</h5><ol>\n<li>weight，配置文件中指定的该服务器的权重，这个值是固定不变的；</li>\n<li>current_weight，服务器目前的权重。一开始为0，之后会动态调整。</li>\n</ol>\n<h5 id=\"每次当请求到来，选取服务器时，会遍历数组中所有服务器。对于每个服务器，让它的current-weight增加它的weight；同时累加所有服务器的weight，并保存为total。\"><a href=\"#每次当请求到来，选取服务器时，会遍历数组中所有服务器。对于每个服务器，让它的current-weight增加它的weight；同时累加所有服务器的weight，并保存为total。\" class=\"headerlink\" title=\"每次当请求到来，选取服务器时，会遍历数组中所有服务器。对于每个服务器，让它的current_weight增加它的weight；同时累加所有服务器的weight，并保存为total。\"></a>每次当请求到来，选取服务器时，会遍历数组中所有服务器。对于每个服务器，让它的current_weight增加它的weight；同时累加所有服务器的weight，并保存为total。</h5><h5 id=\"遍历完所有服务器之后，如果该服务器的current-weight是最大的，就选择这个服务器处理本次请求。最后把该服务器的current-weight减去total。\"><a href=\"#遍历完所有服务器之后，如果该服务器的current-weight是最大的，就选择这个服务器处理本次请求。最后把该服务器的current-weight减去total。\" class=\"headerlink\" title=\"遍历完所有服务器之后，如果该服务器的current_weight是最大的，就选择这个服务器处理本次请求。最后把该服务器的current_weight减去total。\"></a>遍历完所有服务器之后，如果该服务器的current_weight是最大的，就选择这个服务器处理本次请求。最后把该服务器的current_weight减去total。</h5><h4 id=\"上述描述可能不太直观，来看个例子。比如针对这样的配置：\"><a href=\"#上述描述可能不太直观，来看个例子。比如针对这样的配置：\" class=\"headerlink\" title=\"上述描述可能不太直观，来看个例子。比如针对这样的配置：\"></a>上述描述可能不太直观，来看个例子。比如针对这样的配置：</h4><pre><code class=\"lang-nginx\">\nhttp {\n    upstream cluster {\n        server a weight=4;\n        server b weight=2;\n        server c weight=1;\n    }\n    ...\n}\n</code></pre>\n<h5 id=\"按照这个配置，每7个客户端请求中，a会被选中4次、b会被选中2次、c会被选中1次，且分布平滑。我们来算算看是不是这样子的。\"><a href=\"#按照这个配置，每7个客户端请求中，a会被选中4次、b会被选中2次、c会被选中1次，且分布平滑。我们来算算看是不是这样子的。\" class=\"headerlink\" title=\"按照这个配置，每7个客户端请求中，a会被选中4次、b会被选中2次、c会被选中1次，且分布平滑。我们来算算看是不是这样子的。\"></a>按照这个配置，每7个客户端请求中，a会被选中4次、b会被选中2次、c会被选中1次，且分布平滑。我们来算算看是不是这样子的。</h5><p><img src=\"/img/arithmetic/WeightedRound.png\" alt=\"\"></p>\n<h5 id=\"通过上述过程，可得以下结论：\"><a href=\"#通过上述过程，可得以下结论：\" class=\"headerlink\" title=\"通过上述过程，可得以下结论：\"></a>通过上述过程，可得以下结论：</h5><ul>\n<li>7个请求中，a、b、c分别被选取了4、2、1次，符合它们的权重值。</li>\n<li>7个请求中，a、b、c被选取的顺序为a, b,a, c, a, b, a，分布均匀，权重大的后端a没有被连续选取。</li>\n<li>每经过7个请求后，a、b、c的current_weight又回到初始值{0, 0,0}，因此上述流程是不断循环的。</li>\n</ul>\n<h5 id=\"转载自：https-blog-csdn-net-gqtcgq-article-details-52076997\"><a href=\"#转载自：https-blog-csdn-net-gqtcgq-article-details-52076997\" class=\"headerlink\" title=\"转载自：https://blog.csdn.net/gqtcgq/article/details/52076997\"></a>转载自：<a href=\"https://blog.csdn.net/gqtcgq/article/details/52076997\" target=\"_blank\" rel=\"external\">https://blog.csdn.net/gqtcgq/article/details/52076997</a></h5>","site":{"data":{}},"excerpt":"<h5 id=\"在介绍加权轮询算法-WeightedRound-Robin-之前，首先介绍一下轮询算法-Round-Robin-。\"><a href=\"#在介绍加权轮询算法-WeightedRound-Robin-之前，首先介绍一下轮询算法-Round-Robin-。\" class=\"headerlink\" title=\"在介绍加权轮询算法(WeightedRound-Robin)之前，首先介绍一下轮询算法(Round-Robin)。\"></a>在介绍加权轮询算法(WeightedRound-Robin)之前，首先介绍一下轮询算法(Round-Robin)。</h5><h2 id=\"轮询算法-Round-Robin\"><a href=\"#轮询算法-Round-Robin\" class=\"headerlink\" title=\"轮询算法(Round-Robin)\"></a>轮询算法(Round-Robin)</h2><h5 id=\"轮询算法是最简单的一种负载均衡算法。它的原理是把来自用户的请求轮流分配给内部的服务器：从服务器1开始，直到服务器N，然后重新开始循环。算法的优点是其简洁性，它无需记录当前所有连接的状态，所以它是一种无状态调度。\"><a href=\"#轮询算法是最简单的一种负载均衡算法。它的原理是把来自用户的请求轮流分配给内部的服务器：从服务器1开始，直到服务器N，然后重新开始循环。算法的优点是其简洁性，它无需记录当前所有连接的状态，所以它是一种无状态调度。\" class=\"headerlink\" title=\"轮询算法是最简单的一种负载均衡算法。它的原理是把来自用户的请求轮流分配给内部的服务器：从服务器1开始，直到服务器N，然后重新开始循环。算法的优点是其简洁性，它无需记录当前所有连接的状态，所以它是一种无状态调度。\"></a>轮询算法是最简单的一种负载均衡算法。它的原理是把来自用户的请求轮流分配给内部的服务器：从服务器1开始，直到服务器N，然后重新开始循环。算法的优点是其简洁性，它无需记录当前所有连接的状态，所以它是一种无状态调度。</h5>","more":"<h5 id=\"假设有N台服务器：S-S1-S2-…-Sn-，一个指示变量i表示上一次选择的服务器ID。变量i被初始化为N-1。该算法的伪代码如下：\"><a href=\"#假设有N台服务器：S-S1-S2-…-Sn-，一个指示变量i表示上一次选择的服务器ID。变量i被初始化为N-1。该算法的伪代码如下：\" class=\"headerlink\" title=\"假设有N台服务器：S = {S1, S2, …, Sn}，一个指示变量i表示上一次选择的服务器ID。变量i被初始化为N-1。该算法的伪代码如下：\"></a>假设有N台服务器：S = {S1, S2, …, Sn}，一个指示变量i表示上一次选择的服务器ID。变量i被初始化为N-1。该算法的伪代码如下：</h5><pre><code class=\"lang-java\">j = i;\ndo\n{\n    j = (j + 1) mod n;\n    i = j;\n    return Si;\n} while (j != i);\nreturn NULL;\n</code></pre>\n<h5 id=\"轮询算法假设所有服务器的处理性能都相同，不关心每台服务器的当前连接数和响应速度。当请求服务间隔时间变化比较大时，轮询算法容易导致服务器间的负载不平衡。所以此种均衡算法适合于服务器组中的所有服务器都有相同的软硬件配置并且平均服务请求相对均衡的情况。\"><a href=\"#轮询算法假设所有服务器的处理性能都相同，不关心每台服务器的当前连接数和响应速度。当请求服务间隔时间变化比较大时，轮询算法容易导致服务器间的负载不平衡。所以此种均衡算法适合于服务器组中的所有服务器都有相同的软硬件配置并且平均服务请求相对均衡的情况。\" class=\"headerlink\" title=\"轮询算法假设所有服务器的处理性能都相同，不关心每台服务器的当前连接数和响应速度。当请求服务间隔时间变化比较大时，轮询算法容易导致服务器间的负载不平衡。所以此种均衡算法适合于服务器组中的所有服务器都有相同的软硬件配置并且平均服务请求相对均衡的情况。\"></a>轮询算法假设所有服务器的处理性能都相同，不关心每台服务器的当前连接数和响应速度。当请求服务间隔时间变化比较大时，轮询算法容易导致服务器间的负载不平衡。所以此种均衡算法适合于服务器组中的所有服务器都有相同的软硬件配置并且平均服务请求相对均衡的情况。</h5><h2 id=\"加权轮询算法-WeightedRound-Robin\"><a href=\"#加权轮询算法-WeightedRound-Robin\" class=\"headerlink\" title=\"加权轮询算法(WeightedRound-Robin)\"></a>加权轮询算法(WeightedRound-Robin)</h2><h5 id=\"轮询算法并没有考虑每台服务器的处理能力，实际中可能并不是这种情况。由于每台服务器的配置、安装的业务应用等不同，其处理能力会不一样。所以，加权轮询算法的原理就是：根据服务器的不同处理能力，给每个服务器分配不同的权值，使其能够接受相应权值数的服务请求。\"><a href=\"#轮询算法并没有考虑每台服务器的处理能力，实际中可能并不是这种情况。由于每台服务器的配置、安装的业务应用等不同，其处理能力会不一样。所以，加权轮询算法的原理就是：根据服务器的不同处理能力，给每个服务器分配不同的权值，使其能够接受相应权值数的服务请求。\" class=\"headerlink\" title=\"轮询算法并没有考虑每台服务器的处理能力，实际中可能并不是这种情况。由于每台服务器的配置、安装的业务应用等不同，其处理能力会不一样。所以，加权轮询算法的原理就是：根据服务器的不同处理能力，给每个服务器分配不同的权值，使其能够接受相应权值数的服务请求。\"></a>轮询算法并没有考虑每台服务器的处理能力，实际中可能并不是这种情况。由于每台服务器的配置、安装的业务应用等不同，其处理能力会不一样。所以，加权轮询算法的原理就是：根据服务器的不同处理能力，给每个服务器分配不同的权值，使其能够接受相应权值数的服务请求。</h5><h4 id=\"首先看一个简单的Nginx负载均衡配置。\"><a href=\"#首先看一个简单的Nginx负载均衡配置。\" class=\"headerlink\" title=\"首先看一个简单的Nginx负载均衡配置。\"></a>首先看一个简单的Nginx负载均衡配置。</h4><pre><code class=\"lang-nginx\">http {\n    upstream cluster {\n        server a weight=1;\n        server b weight=2;\n        server c weight=4;\n    }\n    ...\n}\n</code></pre>\n<h5 id=\"按照上述配置，Nginx每收到7个客户端的请求，会把其中的1个转发给后端a，把其中的2个转发给后端b，把其中的4个转发给后端c。\"><a href=\"#按照上述配置，Nginx每收到7个客户端的请求，会把其中的1个转发给后端a，把其中的2个转发给后端b，把其中的4个转发给后端c。\" class=\"headerlink\" title=\"按照上述配置，Nginx每收到7个客户端的请求，会把其中的1个转发给后端a，把其中的2个转发给后端b，把其中的4个转发给后端c。\"></a>按照上述配置，Nginx每收到7个客户端的请求，会把其中的1个转发给后端a，把其中的2个转发给后端b，把其中的4个转发给后端c。</h5><h5 id=\"加权轮询算法的结果，就是要生成一个服务器序列。每当有请求到来时，就依次从该序列中取出下一个服务器用于处理该请求。比如针对上面的例子，加权轮询算法会生成序列-c-c-b-c-a-b-c-。这样，每收到7个客户端的请求，会把其中的1个转发给后端a，把其中的2个转发给后端b，把其中的4个转发给后端c。收到的第8个请求，重新从该序列的头部开始轮询。\"><a href=\"#加权轮询算法的结果，就是要生成一个服务器序列。每当有请求到来时，就依次从该序列中取出下一个服务器用于处理该请求。比如针对上面的例子，加权轮询算法会生成序列-c-c-b-c-a-b-c-。这样，每收到7个客户端的请求，会把其中的1个转发给后端a，把其中的2个转发给后端b，把其中的4个转发给后端c。收到的第8个请求，重新从该序列的头部开始轮询。\" class=\"headerlink\" title=\"加权轮询算法的结果，就是要生成一个服务器序列。每当有请求到来时，就依次从该序列中取出下一个服务器用于处理该请求。比如针对上面的例子，加权轮询算法会生成序列{c, c, b, c, a, b, c}。这样，每收到7个客户端的请求，会把其中的1个转发给后端a，把其中的2个转发给后端b，把其中的4个转发给后端c。收到的第8个请求，重新从该序列的头部开始轮询。\"></a>加权轮询算法的结果，就是要生成一个服务器序列。每当有请求到来时，就依次从该序列中取出下一个服务器用于处理该请求。比如针对上面的例子，加权轮询算法会生成序列{c, c, b, c, a, b, c}。这样，每收到7个客户端的请求，会把其中的1个转发给后端a，把其中的2个转发给后端b，把其中的4个转发给后端c。收到的第8个请求，重新从该序列的头部开始轮询。</h5><h5 id=\"总之，加权轮询算法要生成一个服务器序列，该序列中包含n个服务器。n是所有服务器的权重之和。在该序列中，每个服务器的出现的次数，等于其权重值。并且，生成的序列中，服务器的分布应该尽可能的均匀。比如序列-a-a-a-a-a-b-c-中，前五个请求都会分配给服务器a，这就是一种不均匀的分配方法，更好的序列应该是：-a-a-b-a-c-a-a-。\"><a href=\"#总之，加权轮询算法要生成一个服务器序列，该序列中包含n个服务器。n是所有服务器的权重之和。在该序列中，每个服务器的出现的次数，等于其权重值。并且，生成的序列中，服务器的分布应该尽可能的均匀。比如序列-a-a-a-a-a-b-c-中，前五个请求都会分配给服务器a，这就是一种不均匀的分配方法，更好的序列应该是：-a-a-b-a-c-a-a-。\" class=\"headerlink\" title=\"总之，加权轮询算法要生成一个服务器序列，该序列中包含n个服务器。n是所有服务器的权重之和。在该序列中，每个服务器的出现的次数，等于其权重值。并且，生成的序列中，服务器的分布应该尽可能的均匀。比如序列{a, a, a, a, a, b, c}中，前五个请求都会分配给服务器a，这就是一种不均匀的分配方法，更好的序列应该是：{a, a, b, a, c, a, a}。\"></a>总之，加权轮询算法要生成一个服务器序列，该序列中包含n个服务器。n是所有服务器的权重之和。在该序列中，每个服务器的出现的次数，等于其权重值。并且，生成的序列中，服务器的分布应该尽可能的均匀。比如序列{a, a, a, a, a, b, c}中，前五个请求都会分配给服务器a，这就是一种不均匀的分配方法，更好的序列应该是：{a, a, b, a, c, a, a}。</h5><h3 id=\"普通加权轮询算法\"><a href=\"#普通加权轮询算法\" class=\"headerlink\" title=\"普通加权轮询算法\"></a>普通加权轮询算法</h3><ul>\n<li>这种算法的原理是：在服务器数组S中，首先计算所有服务器权重的最大值max(S)，以及所有服务器权重的最大公约数gcd(S)。</li>\n<li>index表示本次请求到来时，选择的服务器的索引，初始值为-1；current_weight表示当前调度的权值，初始值为max(S)。</li>\n<li>当请求到来时，从index+1开始轮询服务器数组S，找到其中权重大于current_weight的第一个服务器，用于处理该请求。记录其索引到结果序列中。</li>\n<li>在轮询服务器数组时，如果到达了数组末尾，则重新从头开始搜索，并且减小current_weight的值：current_weight -= gcd(S)。如果current_weight等于0，则将其重置为max(S)。</li>\n</ul>\n<h5 id=\"这背后的数学原理，自己思考了一下，总结如下：\"><a href=\"#这背后的数学原理，自己思考了一下，总结如下：\" class=\"headerlink\" title=\"这背后的数学原理，自己思考了一下，总结如下：\"></a>这背后的数学原理，自己思考了一下，总结如下：</h5><ul>\n<li>current_weight的值，其变化序列就是一个等差序列：max, max-gcd, max-2gcd, …, 0(max)，将current_weight从max变为0的过程，称为一个轮回。</li>\n<li>针对每个current_weight，该算法就是要把服务器数组从头到尾扫描一遍，将其中权重大于等于current_weight的所有服务器填充到结果序列中。扫描完一遍服务器数组之后，将current_weight变为下一个值，再一次从头到尾扫描服务器数组。</li>\n<li>在current_weight变化过程中，不管current_weight当前为何值，具有max权重的服务器每次肯定会被选中。因此，具有max权重的服务器会在序列中出现max/gcd次（等差序列中的项数）。</li>\n<li>更一般的，当current_weight变为x之后，权重为x的服务器，在current_weight接下来的变化过程中，每次都会被选中，因此，具有x权重的服务器，会在序列中出现x/gcd次。所以，每个服务器在结果序列中出现的次数，是与其权重成正比的，这就是符合加权轮询算法的要求了。</li>\n</ul>\n<h3 id=\"平滑的加权轮询\"><a href=\"#平滑的加权轮询\" class=\"headerlink\" title=\"平滑的加权轮询\"></a>平滑的加权轮询</h3><h5 id=\"上面的加权轮询算法有个缺陷，就是某些情况下生成的序列是不均匀的。比如针对这样的配置：\"><a href=\"#上面的加权轮询算法有个缺陷，就是某些情况下生成的序列是不均匀的。比如针对这样的配置：\" class=\"headerlink\" title=\"上面的加权轮询算法有个缺陷，就是某些情况下生成的序列是不均匀的。比如针对这样的配置：\"></a>上面的加权轮询算法有个缺陷，就是某些情况下生成的序列是不均匀的。比如针对这样的配置：</h5><pre><code class=\"lang-nginx\">http {\n    upstream cluster {\n        server a weight=5;\n        server b weight=1;\n        server c weight=1;\n    }\n    ...\n}\n</code></pre>\n<h5 id=\"生成的序列是这样的：-a-a-a-a-a-c-b-。会有5个连续的请求落在后端a上，分布不太均匀。\"><a href=\"#生成的序列是这样的：-a-a-a-a-a-c-b-。会有5个连续的请求落在后端a上，分布不太均匀。\" class=\"headerlink\" title=\"生成的序列是这样的：{a,a, a, a, a, c, b}。会有5个连续的请求落在后端a上，分布不太均匀。\"></a>生成的序列是这样的：{a,a, a, a, a, c, b}。会有5个连续的请求落在后端a上，分布不太均匀。</h5><h5 id=\"在Nginx源码中，实现了一种叫做平滑的加权轮询（smooth-weighted-round-robin-balancing）的算法，它生成的序列更加均匀。比如前面的例子，它生成的序列为-a-a-b-a-c-a-a-，转发给后端a的5个请求现在分散开来，不再是连续的。\"><a href=\"#在Nginx源码中，实现了一种叫做平滑的加权轮询（smooth-weighted-round-robin-balancing）的算法，它生成的序列更加均匀。比如前面的例子，它生成的序列为-a-a-b-a-c-a-a-，转发给后端a的5个请求现在分散开来，不再是连续的。\" class=\"headerlink\" title=\"在Nginx源码中，实现了一种叫做平滑的加权轮询（smooth weighted round-robin balancing）的算法，它生成的序列更加均匀。比如前面的例子，它生成的序列为{ a, a, b, a, c, a, a}，转发给后端a的5个请求现在分散开来，不再是连续的。\"></a>在Nginx源码中，实现了一种叫做平滑的加权轮询（smooth weighted round-robin balancing）的算法，它生成的序列更加均匀。比如前面的例子，它生成的序列为{ a, a, b, a, c, a, a}，转发给后端a的5个请求现在分散开来，不再是连续的。</h5><h4 id=\"该算法的原理如下：\"><a href=\"#该算法的原理如下：\" class=\"headerlink\" title=\"该算法的原理如下：\"></a>该算法的原理如下：</h4><h5 id=\"每个服务器都有两个权重变量：\"><a href=\"#每个服务器都有两个权重变量：\" class=\"headerlink\" title=\"每个服务器都有两个权重变量：\"></a>每个服务器都有两个权重变量：</h5><ol>\n<li>weight，配置文件中指定的该服务器的权重，这个值是固定不变的；</li>\n<li>current_weight，服务器目前的权重。一开始为0，之后会动态调整。</li>\n</ol>\n<h5 id=\"每次当请求到来，选取服务器时，会遍历数组中所有服务器。对于每个服务器，让它的current-weight增加它的weight；同时累加所有服务器的weight，并保存为total。\"><a href=\"#每次当请求到来，选取服务器时，会遍历数组中所有服务器。对于每个服务器，让它的current-weight增加它的weight；同时累加所有服务器的weight，并保存为total。\" class=\"headerlink\" title=\"每次当请求到来，选取服务器时，会遍历数组中所有服务器。对于每个服务器，让它的current_weight增加它的weight；同时累加所有服务器的weight，并保存为total。\"></a>每次当请求到来，选取服务器时，会遍历数组中所有服务器。对于每个服务器，让它的current_weight增加它的weight；同时累加所有服务器的weight，并保存为total。</h5><h5 id=\"遍历完所有服务器之后，如果该服务器的current-weight是最大的，就选择这个服务器处理本次请求。最后把该服务器的current-weight减去total。\"><a href=\"#遍历完所有服务器之后，如果该服务器的current-weight是最大的，就选择这个服务器处理本次请求。最后把该服务器的current-weight减去total。\" class=\"headerlink\" title=\"遍历完所有服务器之后，如果该服务器的current_weight是最大的，就选择这个服务器处理本次请求。最后把该服务器的current_weight减去total。\"></a>遍历完所有服务器之后，如果该服务器的current_weight是最大的，就选择这个服务器处理本次请求。最后把该服务器的current_weight减去total。</h5><h4 id=\"上述描述可能不太直观，来看个例子。比如针对这样的配置：\"><a href=\"#上述描述可能不太直观，来看个例子。比如针对这样的配置：\" class=\"headerlink\" title=\"上述描述可能不太直观，来看个例子。比如针对这样的配置：\"></a>上述描述可能不太直观，来看个例子。比如针对这样的配置：</h4><pre><code class=\"lang-nginx\">\nhttp {\n    upstream cluster {\n        server a weight=4;\n        server b weight=2;\n        server c weight=1;\n    }\n    ...\n}\n</code></pre>\n<h5 id=\"按照这个配置，每7个客户端请求中，a会被选中4次、b会被选中2次、c会被选中1次，且分布平滑。我们来算算看是不是这样子的。\"><a href=\"#按照这个配置，每7个客户端请求中，a会被选中4次、b会被选中2次、c会被选中1次，且分布平滑。我们来算算看是不是这样子的。\" class=\"headerlink\" title=\"按照这个配置，每7个客户端请求中，a会被选中4次、b会被选中2次、c会被选中1次，且分布平滑。我们来算算看是不是这样子的。\"></a>按照这个配置，每7个客户端请求中，a会被选中4次、b会被选中2次、c会被选中1次，且分布平滑。我们来算算看是不是这样子的。</h5><p><img src=\"/img/arithmetic/WeightedRound.png\" alt=\"\"></p>\n<h5 id=\"通过上述过程，可得以下结论：\"><a href=\"#通过上述过程，可得以下结论：\" class=\"headerlink\" title=\"通过上述过程，可得以下结论：\"></a>通过上述过程，可得以下结论：</h5><ul>\n<li>7个请求中，a、b、c分别被选取了4、2、1次，符合它们的权重值。</li>\n<li>7个请求中，a、b、c被选取的顺序为a, b,a, c, a, b, a，分布均匀，权重大的后端a没有被连续选取。</li>\n<li>每经过7个请求后，a、b、c的current_weight又回到初始值{0, 0,0}，因此上述流程是不断循环的。</li>\n</ul>\n<h5 id=\"转载自：https-blog-csdn-net-gqtcgq-article-details-52076997\"><a href=\"#转载自：https-blog-csdn-net-gqtcgq-article-details-52076997\" class=\"headerlink\" title=\"转载自：https://blog.csdn.net/gqtcgq/article/details/52076997\"></a>转载自：<a href=\"https://blog.csdn.net/gqtcgq/article/details/52076997\" target=\"_blank\" rel=\"external\">https://blog.csdn.net/gqtcgq/article/details/52076997</a></h5>"},{"layout":"post","title":"妇女节快乐，字符串包含","date":"2017-03-07T16:00:00.000Z","original":true,"tag":[["算法","arithmetic"]],"_content":"\n## 题目要求：\n##### 给定两个分别由字母组成的字符串A和字符串B，字符串B的长度比字符串A短。请问，如何最快地判断字符串B中所有字母是否都在字符串A里？\n##### 为了简单起见，我们规定输入的字符串只包含大写英文字母\n<!--more-->\n\n#### 比如\n##### String 1：ABCD\n##### String 2：BAD\n##### 答案是true，即String2里的字母在String1里也都有，或者说String2是String1的真子集。\n##### 如果是下面两个字符串：\n##### String 1：ABCD\n##### String 2：BCE\n##### 答案是false，因为字符串String2里的E字母不在字符串String1里。\n\n\n## 分析过程：\n##### 题目可以简单理解成集合A，集合B。判断集合B是否为集合A的真子集。只是与集合不同的是，在本题中，字符串中是允许存在相同的字符的，这无疑是增加了题目的难度。\n\n### 最简单的解法\n##### 最容易想到的也就是最简单的解决方法当然是依次比较。利用两层循环，遍历字符串B，将字符串B中每一个字符在字符串A中依次比较，看是否存在于字符串A中。\n##### 假设字符串A的长度为n，字符串B的长度为m，则该方法的时间复杂度为O(n*m)。\n\n### 利用排序优化算法时间\n##### 上一种解法的时间复杂度无疑是最长的。我们当然可以利用排序对算法进行优化。方法是先将字符串A进行堆排序，其时间复杂度为O(n log n)。之后再将字符串B中的每个字符在排序后的堆中查找，则时间复杂度为O(m log n)。相加后的时间复杂度O((m+n) log n)\n\n### 最优解法，时间复杂度O(m+n)\n##### 题目到这好像没有办法解决下去，两个字符串的长度分别为n和m。只遍历一遍就得出结果，这种算法真的存在吗？其实这个题目就可以简化成集合元素存在的判断。\n##### 这里又要用到二进制的概念，二进制的一些属性完美的解决了题目中的一些问题。\n#### 1.相同字符的处理\n##### \"或\"操作指的是，两个相应的二进位中只要有一个为1，该位的结果值为1。\n##### 0101 OR 0011 = 0111\n##### 所以当两个相同字符存在时，用或操作，还是得到一个字符的值。\n#### 2.字符的存在问题，如何判断一个字符存在于字符集\n##### \"与\"操作指的是，两个相应的二进位都为1，该位的结果值才为1\n##### 0101 AND 0011 = 0001\n##### 也就是只有两边都存在同一个字符时，才会得出1\n\n##### 因此我们可以将所有字符都进行二进制的编码，因为每一个字符都有两种状态（存在和不存在），所以对应在二进制中，每一个字符都占用一位。\n```c\nbool StringContain(string &a,string &b)\n{\n    int hash = 0;\n    for (int i = 0; i < a.length(); ++i)\n    {\n        hash |= (1 << (a[i] - 'A'));\n    }\n    for (int i = 0; i < b.length(); ++i)\n    {\n        if ((hash & (1 << (b[i] - 'A'))) == 0)\n        {\n            return false;\n        }\n    }\n    return true;\n}\n```\n\n\n## 最后再说一些：\n##### 最后的算法和之前的[切金条](http://localhost:4000/arithmetic/glodBars/)算法有一些相似之处。这是这里对二进制的理解和运用更加灵活。只有对此很熟悉，才能想到这种方法。否则会比较困难。\n","source":"_posts/note/arithmetic/stringContains.md","raw":"---\nlayout: post\ntitle: 妇女节快乐，字符串包含\ndate: 2017/03/08\noriginal: true\ntags: [tech, arithmetic, index]\ntag: [[算法, arithmetic]]\n---\n\n## 题目要求：\n##### 给定两个分别由字母组成的字符串A和字符串B，字符串B的长度比字符串A短。请问，如何最快地判断字符串B中所有字母是否都在字符串A里？\n##### 为了简单起见，我们规定输入的字符串只包含大写英文字母\n<!--more-->\n\n#### 比如\n##### String 1：ABCD\n##### String 2：BAD\n##### 答案是true，即String2里的字母在String1里也都有，或者说String2是String1的真子集。\n##### 如果是下面两个字符串：\n##### String 1：ABCD\n##### String 2：BCE\n##### 答案是false，因为字符串String2里的E字母不在字符串String1里。\n\n\n## 分析过程：\n##### 题目可以简单理解成集合A，集合B。判断集合B是否为集合A的真子集。只是与集合不同的是，在本题中，字符串中是允许存在相同的字符的，这无疑是增加了题目的难度。\n\n### 最简单的解法\n##### 最容易想到的也就是最简单的解决方法当然是依次比较。利用两层循环，遍历字符串B，将字符串B中每一个字符在字符串A中依次比较，看是否存在于字符串A中。\n##### 假设字符串A的长度为n，字符串B的长度为m，则该方法的时间复杂度为O(n*m)。\n\n### 利用排序优化算法时间\n##### 上一种解法的时间复杂度无疑是最长的。我们当然可以利用排序对算法进行优化。方法是先将字符串A进行堆排序，其时间复杂度为O(n log n)。之后再将字符串B中的每个字符在排序后的堆中查找，则时间复杂度为O(m log n)。相加后的时间复杂度O((m+n) log n)\n\n### 最优解法，时间复杂度O(m+n)\n##### 题目到这好像没有办法解决下去，两个字符串的长度分别为n和m。只遍历一遍就得出结果，这种算法真的存在吗？其实这个题目就可以简化成集合元素存在的判断。\n##### 这里又要用到二进制的概念，二进制的一些属性完美的解决了题目中的一些问题。\n#### 1.相同字符的处理\n##### \"或\"操作指的是，两个相应的二进位中只要有一个为1，该位的结果值为1。\n##### 0101 OR 0011 = 0111\n##### 所以当两个相同字符存在时，用或操作，还是得到一个字符的值。\n#### 2.字符的存在问题，如何判断一个字符存在于字符集\n##### \"与\"操作指的是，两个相应的二进位都为1，该位的结果值才为1\n##### 0101 AND 0011 = 0001\n##### 也就是只有两边都存在同一个字符时，才会得出1\n\n##### 因此我们可以将所有字符都进行二进制的编码，因为每一个字符都有两种状态（存在和不存在），所以对应在二进制中，每一个字符都占用一位。\n```c\nbool StringContain(string &a,string &b)\n{\n    int hash = 0;\n    for (int i = 0; i < a.length(); ++i)\n    {\n        hash |= (1 << (a[i] - 'A'));\n    }\n    for (int i = 0; i < b.length(); ++i)\n    {\n        if ((hash & (1 << (b[i] - 'A'))) == 0)\n        {\n            return false;\n        }\n    }\n    return true;\n}\n```\n\n\n## 最后再说一些：\n##### 最后的算法和之前的[切金条](http://localhost:4000/arithmetic/glodBars/)算法有一些相似之处。这是这里对二进制的理解和运用更加灵活。只有对此很熟悉，才能想到这种方法。否则会比较困难。\n","slug":"note/arithmetic/stringContains","published":1,"updated":"2018-05-08T13:00:14.275Z","comments":1,"photos":[],"link":"","_id":"cjgxop3nc0034jah1tji3cycr","content":"<h2 id=\"题目要求：\"><a href=\"#题目要求：\" class=\"headerlink\" title=\"题目要求：\"></a>题目要求：</h2><h5 id=\"给定两个分别由字母组成的字符串A和字符串B，字符串B的长度比字符串A短。请问，如何最快地判断字符串B中所有字母是否都在字符串A里？\"><a href=\"#给定两个分别由字母组成的字符串A和字符串B，字符串B的长度比字符串A短。请问，如何最快地判断字符串B中所有字母是否都在字符串A里？\" class=\"headerlink\" title=\"给定两个分别由字母组成的字符串A和字符串B，字符串B的长度比字符串A短。请问，如何最快地判断字符串B中所有字母是否都在字符串A里？\"></a>给定两个分别由字母组成的字符串A和字符串B，字符串B的长度比字符串A短。请问，如何最快地判断字符串B中所有字母是否都在字符串A里？</h5><h5 id=\"为了简单起见，我们规定输入的字符串只包含大写英文字母\"><a href=\"#为了简单起见，我们规定输入的字符串只包含大写英文字母\" class=\"headerlink\" title=\"为了简单起见，我们规定输入的字符串只包含大写英文字母\"></a>为了简单起见，我们规定输入的字符串只包含大写英文字母</h5><a id=\"more\"></a>\n<h4 id=\"比如\"><a href=\"#比如\" class=\"headerlink\" title=\"比如\"></a>比如</h4><h5 id=\"String-1：ABCD\"><a href=\"#String-1：ABCD\" class=\"headerlink\" title=\"String 1：ABCD\"></a>String 1：ABCD</h5><h5 id=\"String-2：BAD\"><a href=\"#String-2：BAD\" class=\"headerlink\" title=\"String 2：BAD\"></a>String 2：BAD</h5><h5 id=\"答案是true，即String2里的字母在String1里也都有，或者说String2是String1的真子集。\"><a href=\"#答案是true，即String2里的字母在String1里也都有，或者说String2是String1的真子集。\" class=\"headerlink\" title=\"答案是true，即String2里的字母在String1里也都有，或者说String2是String1的真子集。\"></a>答案是true，即String2里的字母在String1里也都有，或者说String2是String1的真子集。</h5><h5 id=\"如果是下面两个字符串：\"><a href=\"#如果是下面两个字符串：\" class=\"headerlink\" title=\"如果是下面两个字符串：\"></a>如果是下面两个字符串：</h5><h5 id=\"String-1：ABCD-1\"><a href=\"#String-1：ABCD-1\" class=\"headerlink\" title=\"String 1：ABCD\"></a>String 1：ABCD</h5><h5 id=\"String-2：BCE\"><a href=\"#String-2：BCE\" class=\"headerlink\" title=\"String 2：BCE\"></a>String 2：BCE</h5><h5 id=\"答案是false，因为字符串String2里的E字母不在字符串String1里。\"><a href=\"#答案是false，因为字符串String2里的E字母不在字符串String1里。\" class=\"headerlink\" title=\"答案是false，因为字符串String2里的E字母不在字符串String1里。\"></a>答案是false，因为字符串String2里的E字母不在字符串String1里。</h5><h2 id=\"分析过程：\"><a href=\"#分析过程：\" class=\"headerlink\" title=\"分析过程：\"></a>分析过程：</h2><h5 id=\"题目可以简单理解成集合A，集合B。判断集合B是否为集合A的真子集。只是与集合不同的是，在本题中，字符串中是允许存在相同的字符的，这无疑是增加了题目的难度。\"><a href=\"#题目可以简单理解成集合A，集合B。判断集合B是否为集合A的真子集。只是与集合不同的是，在本题中，字符串中是允许存在相同的字符的，这无疑是增加了题目的难度。\" class=\"headerlink\" title=\"题目可以简单理解成集合A，集合B。判断集合B是否为集合A的真子集。只是与集合不同的是，在本题中，字符串中是允许存在相同的字符的，这无疑是增加了题目的难度。\"></a>题目可以简单理解成集合A，集合B。判断集合B是否为集合A的真子集。只是与集合不同的是，在本题中，字符串中是允许存在相同的字符的，这无疑是增加了题目的难度。</h5><h3 id=\"最简单的解法\"><a href=\"#最简单的解法\" class=\"headerlink\" title=\"最简单的解法\"></a>最简单的解法</h3><h5 id=\"最容易想到的也就是最简单的解决方法当然是依次比较。利用两层循环，遍历字符串B，将字符串B中每一个字符在字符串A中依次比较，看是否存在于字符串A中。\"><a href=\"#最容易想到的也就是最简单的解决方法当然是依次比较。利用两层循环，遍历字符串B，将字符串B中每一个字符在字符串A中依次比较，看是否存在于字符串A中。\" class=\"headerlink\" title=\"最容易想到的也就是最简单的解决方法当然是依次比较。利用两层循环，遍历字符串B，将字符串B中每一个字符在字符串A中依次比较，看是否存在于字符串A中。\"></a>最容易想到的也就是最简单的解决方法当然是依次比较。利用两层循环，遍历字符串B，将字符串B中每一个字符在字符串A中依次比较，看是否存在于字符串A中。</h5><h5 id=\"假设字符串A的长度为n，字符串B的长度为m，则该方法的时间复杂度为O-n-m-。\"><a href=\"#假设字符串A的长度为n，字符串B的长度为m，则该方法的时间复杂度为O-n-m-。\" class=\"headerlink\" title=\"假设字符串A的长度为n，字符串B的长度为m，则该方法的时间复杂度为O(n*m)。\"></a>假设字符串A的长度为n，字符串B的长度为m，则该方法的时间复杂度为O(n*m)。</h5><h3 id=\"利用排序优化算法时间\"><a href=\"#利用排序优化算法时间\" class=\"headerlink\" title=\"利用排序优化算法时间\"></a>利用排序优化算法时间</h3><h5 id=\"上一种解法的时间复杂度无疑是最长的。我们当然可以利用排序对算法进行优化。方法是先将字符串A进行堆排序，其时间复杂度为O-n-log-n-。之后再将字符串B中的每个字符在排序后的堆中查找，则时间复杂度为O-m-log-n-。相加后的时间复杂度O-m-n-log-n\"><a href=\"#上一种解法的时间复杂度无疑是最长的。我们当然可以利用排序对算法进行优化。方法是先将字符串A进行堆排序，其时间复杂度为O-n-log-n-。之后再将字符串B中的每个字符在排序后的堆中查找，则时间复杂度为O-m-log-n-。相加后的时间复杂度O-m-n-log-n\" class=\"headerlink\" title=\"上一种解法的时间复杂度无疑是最长的。我们当然可以利用排序对算法进行优化。方法是先将字符串A进行堆排序，其时间复杂度为O(n log n)。之后再将字符串B中的每个字符在排序后的堆中查找，则时间复杂度为O(m log n)。相加后的时间复杂度O((m+n) log n)\"></a>上一种解法的时间复杂度无疑是最长的。我们当然可以利用排序对算法进行优化。方法是先将字符串A进行堆排序，其时间复杂度为O(n log n)。之后再将字符串B中的每个字符在排序后的堆中查找，则时间复杂度为O(m log n)。相加后的时间复杂度O((m+n) log n)</h5><h3 id=\"最优解法，时间复杂度O-m-n\"><a href=\"#最优解法，时间复杂度O-m-n\" class=\"headerlink\" title=\"最优解法，时间复杂度O(m+n)\"></a>最优解法，时间复杂度O(m+n)</h3><h5 id=\"题目到这好像没有办法解决下去，两个字符串的长度分别为n和m。只遍历一遍就得出结果，这种算法真的存在吗？其实这个题目就可以简化成集合元素存在的判断。\"><a href=\"#题目到这好像没有办法解决下去，两个字符串的长度分别为n和m。只遍历一遍就得出结果，这种算法真的存在吗？其实这个题目就可以简化成集合元素存在的判断。\" class=\"headerlink\" title=\"题目到这好像没有办法解决下去，两个字符串的长度分别为n和m。只遍历一遍就得出结果，这种算法真的存在吗？其实这个题目就可以简化成集合元素存在的判断。\"></a>题目到这好像没有办法解决下去，两个字符串的长度分别为n和m。只遍历一遍就得出结果，这种算法真的存在吗？其实这个题目就可以简化成集合元素存在的判断。</h5><h5 id=\"这里又要用到二进制的概念，二进制的一些属性完美的解决了题目中的一些问题。\"><a href=\"#这里又要用到二进制的概念，二进制的一些属性完美的解决了题目中的一些问题。\" class=\"headerlink\" title=\"这里又要用到二进制的概念，二进制的一些属性完美的解决了题目中的一些问题。\"></a>这里又要用到二进制的概念，二进制的一些属性完美的解决了题目中的一些问题。</h5><h4 id=\"1-相同字符的处理\"><a href=\"#1-相同字符的处理\" class=\"headerlink\" title=\"1.相同字符的处理\"></a>1.相同字符的处理</h4><h5 id=\"“或”操作指的是，两个相应的二进位中只要有一个为1，该位的结果值为1。\"><a href=\"#“或”操作指的是，两个相应的二进位中只要有一个为1，该位的结果值为1。\" class=\"headerlink\" title=\"“或”操作指的是，两个相应的二进位中只要有一个为1，该位的结果值为1。\"></a>“或”操作指的是，两个相应的二进位中只要有一个为1，该位的结果值为1。</h5><h5 id=\"0101-OR-0011-0111\"><a href=\"#0101-OR-0011-0111\" class=\"headerlink\" title=\"0101 OR 0011 = 0111\"></a>0101 OR 0011 = 0111</h5><h5 id=\"所以当两个相同字符存在时，用或操作，还是得到一个字符的值。\"><a href=\"#所以当两个相同字符存在时，用或操作，还是得到一个字符的值。\" class=\"headerlink\" title=\"所以当两个相同字符存在时，用或操作，还是得到一个字符的值。\"></a>所以当两个相同字符存在时，用或操作，还是得到一个字符的值。</h5><h4 id=\"2-字符的存在问题，如何判断一个字符存在于字符集\"><a href=\"#2-字符的存在问题，如何判断一个字符存在于字符集\" class=\"headerlink\" title=\"2.字符的存在问题，如何判断一个字符存在于字符集\"></a>2.字符的存在问题，如何判断一个字符存在于字符集</h4><h5 id=\"“与”操作指的是，两个相应的二进位都为1，该位的结果值才为1\"><a href=\"#“与”操作指的是，两个相应的二进位都为1，该位的结果值才为1\" class=\"headerlink\" title=\"“与”操作指的是，两个相应的二进位都为1，该位的结果值才为1\"></a>“与”操作指的是，两个相应的二进位都为1，该位的结果值才为1</h5><h5 id=\"0101-AND-0011-0001\"><a href=\"#0101-AND-0011-0001\" class=\"headerlink\" title=\"0101 AND 0011 = 0001\"></a>0101 AND 0011 = 0001</h5><h5 id=\"也就是只有两边都存在同一个字符时，才会得出1\"><a href=\"#也就是只有两边都存在同一个字符时，才会得出1\" class=\"headerlink\" title=\"也就是只有两边都存在同一个字符时，才会得出1\"></a>也就是只有两边都存在同一个字符时，才会得出1</h5><h5 id=\"因此我们可以将所有字符都进行二进制的编码，因为每一个字符都有两种状态（存在和不存在），所以对应在二进制中，每一个字符都占用一位。\"><a href=\"#因此我们可以将所有字符都进行二进制的编码，因为每一个字符都有两种状态（存在和不存在），所以对应在二进制中，每一个字符都占用一位。\" class=\"headerlink\" title=\"因此我们可以将所有字符都进行二进制的编码，因为每一个字符都有两种状态（存在和不存在），所以对应在二进制中，每一个字符都占用一位。\"></a>因此我们可以将所有字符都进行二进制的编码，因为每一个字符都有两种状态（存在和不存在），所以对应在二进制中，每一个字符都占用一位。</h5><pre><code class=\"lang-c\">bool StringContain(string &amp;a,string &amp;b)\n{\n    int hash = 0;\n    for (int i = 0; i &lt; a.length(); ++i)\n    {\n        hash |= (1 &lt;&lt; (a[i] - &#39;A&#39;));\n    }\n    for (int i = 0; i &lt; b.length(); ++i)\n    {\n        if ((hash &amp; (1 &lt;&lt; (b[i] - &#39;A&#39;))) == 0)\n        {\n            return false;\n        }\n    }\n    return true;\n}\n</code></pre>\n<h2 id=\"最后再说一些：\"><a href=\"#最后再说一些：\" class=\"headerlink\" title=\"最后再说一些：\"></a>最后再说一些：</h2><h5 id=\"最后的算法和之前的切金条算法有一些相似之处。这是这里对二进制的理解和运用更加灵活。只有对此很熟悉，才能想到这种方法。否则会比较困难。\"><a href=\"#最后的算法和之前的切金条算法有一些相似之处。这是这里对二进制的理解和运用更加灵活。只有对此很熟悉，才能想到这种方法。否则会比较困难。\" class=\"headerlink\" title=\"最后的算法和之前的切金条算法有一些相似之处。这是这里对二进制的理解和运用更加灵活。只有对此很熟悉，才能想到这种方法。否则会比较困难。\"></a>最后的算法和之前的<a href=\"http://localhost:4000/arithmetic/glodBars/\" target=\"_blank\" rel=\"external\">切金条</a>算法有一些相似之处。这是这里对二进制的理解和运用更加灵活。只有对此很熟悉，才能想到这种方法。否则会比较困难。</h5>","site":{"data":{}},"excerpt":"<h2 id=\"题目要求：\"><a href=\"#题目要求：\" class=\"headerlink\" title=\"题目要求：\"></a>题目要求：</h2><h5 id=\"给定两个分别由字母组成的字符串A和字符串B，字符串B的长度比字符串A短。请问，如何最快地判断字符串B中所有字母是否都在字符串A里？\"><a href=\"#给定两个分别由字母组成的字符串A和字符串B，字符串B的长度比字符串A短。请问，如何最快地判断字符串B中所有字母是否都在字符串A里？\" class=\"headerlink\" title=\"给定两个分别由字母组成的字符串A和字符串B，字符串B的长度比字符串A短。请问，如何最快地判断字符串B中所有字母是否都在字符串A里？\"></a>给定两个分别由字母组成的字符串A和字符串B，字符串B的长度比字符串A短。请问，如何最快地判断字符串B中所有字母是否都在字符串A里？</h5><h5 id=\"为了简单起见，我们规定输入的字符串只包含大写英文字母\"><a href=\"#为了简单起见，我们规定输入的字符串只包含大写英文字母\" class=\"headerlink\" title=\"为了简单起见，我们规定输入的字符串只包含大写英文字母\"></a>为了简单起见，我们规定输入的字符串只包含大写英文字母</h5>","more":"<h4 id=\"比如\"><a href=\"#比如\" class=\"headerlink\" title=\"比如\"></a>比如</h4><h5 id=\"String-1：ABCD\"><a href=\"#String-1：ABCD\" class=\"headerlink\" title=\"String 1：ABCD\"></a>String 1：ABCD</h5><h5 id=\"String-2：BAD\"><a href=\"#String-2：BAD\" class=\"headerlink\" title=\"String 2：BAD\"></a>String 2：BAD</h5><h5 id=\"答案是true，即String2里的字母在String1里也都有，或者说String2是String1的真子集。\"><a href=\"#答案是true，即String2里的字母在String1里也都有，或者说String2是String1的真子集。\" class=\"headerlink\" title=\"答案是true，即String2里的字母在String1里也都有，或者说String2是String1的真子集。\"></a>答案是true，即String2里的字母在String1里也都有，或者说String2是String1的真子集。</h5><h5 id=\"如果是下面两个字符串：\"><a href=\"#如果是下面两个字符串：\" class=\"headerlink\" title=\"如果是下面两个字符串：\"></a>如果是下面两个字符串：</h5><h5 id=\"String-1：ABCD-1\"><a href=\"#String-1：ABCD-1\" class=\"headerlink\" title=\"String 1：ABCD\"></a>String 1：ABCD</h5><h5 id=\"String-2：BCE\"><a href=\"#String-2：BCE\" class=\"headerlink\" title=\"String 2：BCE\"></a>String 2：BCE</h5><h5 id=\"答案是false，因为字符串String2里的E字母不在字符串String1里。\"><a href=\"#答案是false，因为字符串String2里的E字母不在字符串String1里。\" class=\"headerlink\" title=\"答案是false，因为字符串String2里的E字母不在字符串String1里。\"></a>答案是false，因为字符串String2里的E字母不在字符串String1里。</h5><h2 id=\"分析过程：\"><a href=\"#分析过程：\" class=\"headerlink\" title=\"分析过程：\"></a>分析过程：</h2><h5 id=\"题目可以简单理解成集合A，集合B。判断集合B是否为集合A的真子集。只是与集合不同的是，在本题中，字符串中是允许存在相同的字符的，这无疑是增加了题目的难度。\"><a href=\"#题目可以简单理解成集合A，集合B。判断集合B是否为集合A的真子集。只是与集合不同的是，在本题中，字符串中是允许存在相同的字符的，这无疑是增加了题目的难度。\" class=\"headerlink\" title=\"题目可以简单理解成集合A，集合B。判断集合B是否为集合A的真子集。只是与集合不同的是，在本题中，字符串中是允许存在相同的字符的，这无疑是增加了题目的难度。\"></a>题目可以简单理解成集合A，集合B。判断集合B是否为集合A的真子集。只是与集合不同的是，在本题中，字符串中是允许存在相同的字符的，这无疑是增加了题目的难度。</h5><h3 id=\"最简单的解法\"><a href=\"#最简单的解法\" class=\"headerlink\" title=\"最简单的解法\"></a>最简单的解法</h3><h5 id=\"最容易想到的也就是最简单的解决方法当然是依次比较。利用两层循环，遍历字符串B，将字符串B中每一个字符在字符串A中依次比较，看是否存在于字符串A中。\"><a href=\"#最容易想到的也就是最简单的解决方法当然是依次比较。利用两层循环，遍历字符串B，将字符串B中每一个字符在字符串A中依次比较，看是否存在于字符串A中。\" class=\"headerlink\" title=\"最容易想到的也就是最简单的解决方法当然是依次比较。利用两层循环，遍历字符串B，将字符串B中每一个字符在字符串A中依次比较，看是否存在于字符串A中。\"></a>最容易想到的也就是最简单的解决方法当然是依次比较。利用两层循环，遍历字符串B，将字符串B中每一个字符在字符串A中依次比较，看是否存在于字符串A中。</h5><h5 id=\"假设字符串A的长度为n，字符串B的长度为m，则该方法的时间复杂度为O-n-m-。\"><a href=\"#假设字符串A的长度为n，字符串B的长度为m，则该方法的时间复杂度为O-n-m-。\" class=\"headerlink\" title=\"假设字符串A的长度为n，字符串B的长度为m，则该方法的时间复杂度为O(n*m)。\"></a>假设字符串A的长度为n，字符串B的长度为m，则该方法的时间复杂度为O(n*m)。</h5><h3 id=\"利用排序优化算法时间\"><a href=\"#利用排序优化算法时间\" class=\"headerlink\" title=\"利用排序优化算法时间\"></a>利用排序优化算法时间</h3><h5 id=\"上一种解法的时间复杂度无疑是最长的。我们当然可以利用排序对算法进行优化。方法是先将字符串A进行堆排序，其时间复杂度为O-n-log-n-。之后再将字符串B中的每个字符在排序后的堆中查找，则时间复杂度为O-m-log-n-。相加后的时间复杂度O-m-n-log-n\"><a href=\"#上一种解法的时间复杂度无疑是最长的。我们当然可以利用排序对算法进行优化。方法是先将字符串A进行堆排序，其时间复杂度为O-n-log-n-。之后再将字符串B中的每个字符在排序后的堆中查找，则时间复杂度为O-m-log-n-。相加后的时间复杂度O-m-n-log-n\" class=\"headerlink\" title=\"上一种解法的时间复杂度无疑是最长的。我们当然可以利用排序对算法进行优化。方法是先将字符串A进行堆排序，其时间复杂度为O(n log n)。之后再将字符串B中的每个字符在排序后的堆中查找，则时间复杂度为O(m log n)。相加后的时间复杂度O((m+n) log n)\"></a>上一种解法的时间复杂度无疑是最长的。我们当然可以利用排序对算法进行优化。方法是先将字符串A进行堆排序，其时间复杂度为O(n log n)。之后再将字符串B中的每个字符在排序后的堆中查找，则时间复杂度为O(m log n)。相加后的时间复杂度O((m+n) log n)</h5><h3 id=\"最优解法，时间复杂度O-m-n\"><a href=\"#最优解法，时间复杂度O-m-n\" class=\"headerlink\" title=\"最优解法，时间复杂度O(m+n)\"></a>最优解法，时间复杂度O(m+n)</h3><h5 id=\"题目到这好像没有办法解决下去，两个字符串的长度分别为n和m。只遍历一遍就得出结果，这种算法真的存在吗？其实这个题目就可以简化成集合元素存在的判断。\"><a href=\"#题目到这好像没有办法解决下去，两个字符串的长度分别为n和m。只遍历一遍就得出结果，这种算法真的存在吗？其实这个题目就可以简化成集合元素存在的判断。\" class=\"headerlink\" title=\"题目到这好像没有办法解决下去，两个字符串的长度分别为n和m。只遍历一遍就得出结果，这种算法真的存在吗？其实这个题目就可以简化成集合元素存在的判断。\"></a>题目到这好像没有办法解决下去，两个字符串的长度分别为n和m。只遍历一遍就得出结果，这种算法真的存在吗？其实这个题目就可以简化成集合元素存在的判断。</h5><h5 id=\"这里又要用到二进制的概念，二进制的一些属性完美的解决了题目中的一些问题。\"><a href=\"#这里又要用到二进制的概念，二进制的一些属性完美的解决了题目中的一些问题。\" class=\"headerlink\" title=\"这里又要用到二进制的概念，二进制的一些属性完美的解决了题目中的一些问题。\"></a>这里又要用到二进制的概念，二进制的一些属性完美的解决了题目中的一些问题。</h5><h4 id=\"1-相同字符的处理\"><a href=\"#1-相同字符的处理\" class=\"headerlink\" title=\"1.相同字符的处理\"></a>1.相同字符的处理</h4><h5 id=\"“或”操作指的是，两个相应的二进位中只要有一个为1，该位的结果值为1。\"><a href=\"#“或”操作指的是，两个相应的二进位中只要有一个为1，该位的结果值为1。\" class=\"headerlink\" title=\"“或”操作指的是，两个相应的二进位中只要有一个为1，该位的结果值为1。\"></a>“或”操作指的是，两个相应的二进位中只要有一个为1，该位的结果值为1。</h5><h5 id=\"0101-OR-0011-0111\"><a href=\"#0101-OR-0011-0111\" class=\"headerlink\" title=\"0101 OR 0011 = 0111\"></a>0101 OR 0011 = 0111</h5><h5 id=\"所以当两个相同字符存在时，用或操作，还是得到一个字符的值。\"><a href=\"#所以当两个相同字符存在时，用或操作，还是得到一个字符的值。\" class=\"headerlink\" title=\"所以当两个相同字符存在时，用或操作，还是得到一个字符的值。\"></a>所以当两个相同字符存在时，用或操作，还是得到一个字符的值。</h5><h4 id=\"2-字符的存在问题，如何判断一个字符存在于字符集\"><a href=\"#2-字符的存在问题，如何判断一个字符存在于字符集\" class=\"headerlink\" title=\"2.字符的存在问题，如何判断一个字符存在于字符集\"></a>2.字符的存在问题，如何判断一个字符存在于字符集</h4><h5 id=\"“与”操作指的是，两个相应的二进位都为1，该位的结果值才为1\"><a href=\"#“与”操作指的是，两个相应的二进位都为1，该位的结果值才为1\" class=\"headerlink\" title=\"“与”操作指的是，两个相应的二进位都为1，该位的结果值才为1\"></a>“与”操作指的是，两个相应的二进位都为1，该位的结果值才为1</h5><h5 id=\"0101-AND-0011-0001\"><a href=\"#0101-AND-0011-0001\" class=\"headerlink\" title=\"0101 AND 0011 = 0001\"></a>0101 AND 0011 = 0001</h5><h5 id=\"也就是只有两边都存在同一个字符时，才会得出1\"><a href=\"#也就是只有两边都存在同一个字符时，才会得出1\" class=\"headerlink\" title=\"也就是只有两边都存在同一个字符时，才会得出1\"></a>也就是只有两边都存在同一个字符时，才会得出1</h5><h5 id=\"因此我们可以将所有字符都进行二进制的编码，因为每一个字符都有两种状态（存在和不存在），所以对应在二进制中，每一个字符都占用一位。\"><a href=\"#因此我们可以将所有字符都进行二进制的编码，因为每一个字符都有两种状态（存在和不存在），所以对应在二进制中，每一个字符都占用一位。\" class=\"headerlink\" title=\"因此我们可以将所有字符都进行二进制的编码，因为每一个字符都有两种状态（存在和不存在），所以对应在二进制中，每一个字符都占用一位。\"></a>因此我们可以将所有字符都进行二进制的编码，因为每一个字符都有两种状态（存在和不存在），所以对应在二进制中，每一个字符都占用一位。</h5><pre><code class=\"lang-c\">bool StringContain(string &amp;a,string &amp;b)\n{\n    int hash = 0;\n    for (int i = 0; i &lt; a.length(); ++i)\n    {\n        hash |= (1 &lt;&lt; (a[i] - &#39;A&#39;));\n    }\n    for (int i = 0; i &lt; b.length(); ++i)\n    {\n        if ((hash &amp; (1 &lt;&lt; (b[i] - &#39;A&#39;))) == 0)\n        {\n            return false;\n        }\n    }\n    return true;\n}\n</code></pre>\n<h2 id=\"最后再说一些：\"><a href=\"#最后再说一些：\" class=\"headerlink\" title=\"最后再说一些：\"></a>最后再说一些：</h2><h5 id=\"最后的算法和之前的切金条算法有一些相似之处。这是这里对二进制的理解和运用更加灵活。只有对此很熟悉，才能想到这种方法。否则会比较困难。\"><a href=\"#最后的算法和之前的切金条算法有一些相似之处。这是这里对二进制的理解和运用更加灵活。只有对此很熟悉，才能想到这种方法。否则会比较困难。\" class=\"headerlink\" title=\"最后的算法和之前的切金条算法有一些相似之处。这是这里对二进制的理解和运用更加灵活。只有对此很熟悉，才能想到这种方法。否则会比较困难。\"></a>最后的算法和之前的<a href=\"http://localhost:4000/arithmetic/glodBars/\" target=\"_blank\" rel=\"external\">切金条</a>算法有一些相似之处。这是这里对二进制的理解和运用更加灵活。只有对此很熟悉，才能想到这种方法。否则会比较困难。</h5>"},{"layout":"post","title":"dubbo-负载均衡实现","date":"2018-03-22T16:00:00.000Z","tag":[["java","java"],["dubbo","dubbo"]],"original":true,"_content":"\n### 扩展说明\n##### 从多个服务提者方中选择一个进行调用\n\n### 扩展接口\n##### `com.alibaba.dubbo.rpc.cluster.LoadBalance`\n\n### 使用配置\n```xml\n<dubbo:provider loadbalance=\"\" />\n```\n<!--more-->\n\n### 目前已知扩展：\n* random=com.alibaba.dubbo.rpc.cluster.loadbalance.RandomLoadBalance\n* roundrobin=com.alibaba.dubbo.rpc.cluster.loadbalance.RoundRobinLoadBalance\n* leastactive=com.alibaba.dubbo.rpc.cluster.loadbalance.LeastActiveLoadBalance\n* consistenthash=com.alibaba.dubbo.rpc.cluster.loadbalance.ConsistentHashLoadBalance\n\n### 包结构：\n![](/img/note/dubbo/dubbo2.png)\n\n### LoadBalance\n```java\n@SPI(RandomLoadBalance.NAME) //默认为random\npublic interface LoadBalance {\n\n    /**\n     * 从list当中选择一个invoker\n     *\n     * @param invokers   invokers.\n     * @param url        refer url\n     * @param invocation invocation.\n     * @return selected invoker.\n     */\n    @Adaptive(\"loadbalance\")\n    <T> Invoker<T> select(List<Invoker<T>> invokers, URL url, Invocation invocation) throws RpcException;\n}\n```\n##### 只有一个接口，很简单，提供invokers集合，返回其中一个\n\n### AbstractLoadBalance\n```java\npublic abstract class AbstractLoadBalance implements LoadBalance {\n\n    static int calculateWarmupWeight(int uptime, int warmup, int weight) {\n        int ww = (int) ((float) uptime / ((float) warmup / (float) weight));\n        return ww < 1 ? 1 : (ww > weight ? weight : ww);\n    }\n\n    public <T> Invoker<T> select(List<Invoker<T>> invokers, URL url, Invocation invocation) {\n        if (invokers == null || invokers.isEmpty())\n            return null;\n        if (invokers.size() == 1)\n            return invokers.get(0);\n        return doSelect(invokers, url, invocation);\n    }\n\n    protected abstract <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation);\n\n    protected int getWeight(Invoker<?> invoker, Invocation invocation) {\n        int weight = invoker.getUrl().getMethodParameter(invocation.getMethodName(), Constants.WEIGHT_KEY, Constants.DEFAULT_WEIGHT);\n        if (weight > 0) {\n            long timestamp = invoker.getUrl().getParameter(Constants.REMOTE_TIMESTAMP_KEY, 0L);\n            if (timestamp > 0L) {\n                int uptime = (int) (System.currentTimeMillis() - timestamp);\n                int warmup = invoker.getUrl().getParameter(Constants.WARMUP_KEY, Constants.DEFAULT_WARMUP);\n                if (uptime > 0 && uptime < warmup) {\n                    weight = calculateWarmupWeight(uptime, warmup, weight);\n                }\n            }\n        }\n        return weight;\n    }\n\n}\n```\n\n##### 抽象类**AbstractLoadBalance**实现了接口**LoadBalance**的select方法。主要是做了一些边界值的判断，正在的操作在抽象方法doSelect中。\n\n##### **getWeight**方法将从Invoker的url中获取**weight**参数。默认为100\n\n## random 随机\n##### dubbo默认的负载方式，看下**doSelect**方法\n```java\nprotected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) {\n        int length = invokers.size(); // invokers数量\n        int totalWeight = 0; // 总权重\n        boolean sameWeight = true; // 是不是所有的权重都是一样的\n        for (int i = 0; i < length; i++) {\n            int weight = getWeight(invokers.get(i), invocation);\n            totalWeight += weight; // 相加\n            if (sameWeight && i > 0\n                    && weight != getWeight(invokers.get(i - 1), invocation)) {\n                sameWeight = false;\n            }\n        }\n        if (totalWeight > 0 && !sameWeight) {\n            //如果权重不是都相等，则用随机数生成\n            int offset = random.nextInt(totalWeight);\n            // 返回一个在包含该随机值的invoker\n            for (int i = 0; i < length; i++) {\n                offset -= getWeight(invokers.get(i), invocation);\n                if (offset < 0) {\n                    return invokers.get(i);\n                }\n            }\n        }\n        //如果权重都相等或者总和为0，则随机一个\n        return invokers.get(random.nextInt(length));\n    }\n```\n##### 可以看到，dubbo的随机负载均衡策略是包含了权重的概念的。所以也不是完全随机。\n\n\n## roundrobin 轮询\n```java\nprotected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) {\n        //通过serviceKey和方法名构建key\n        String key = invokers.get(0).getUrl().getServiceKey() + \".\" + invocation.getMethodName();\n        int length = invokers.size(); // invokers数量\n        int maxWeight = 0; // 最大的 权重 值\n        int minWeight = Integer.MAX_VALUE; // 最小的 权重 值\n        final LinkedHashMap<Invoker<T>, IntegerWrapper> invokerToWeightMap = new LinkedHashMap<Invoker<T>, IntegerWrapper>();//有序map\n        int weightSum = 0; //权重 总值\n        for (int i = 0; i < length; i++) {\n            int weight = getWeight(invokers.get(i), invocation); //获取单个invoker的权重\n            maxWeight = Math.max(maxWeight, weight); // 是不是最大的\n            minWeight = Math.min(minWeight, weight); // 是不是最小的\n            if (weight > 0) {\n                invokerToWeightMap.put(invokers.get(i), new IntegerWrapper(weight));\n                weightSum += weight;\n            }\n        }\n        AtomicPositiveInteger sequence = sequences.get(key);\n        if (sequence == null) {\n            sequences.putIfAbsent(key, new AtomicPositiveInteger());\n            sequence = sequences.get(key);\n        }\n        //记录该接口的调用次数\n        int currentSequence = sequence.getAndIncrement();\n        if (maxWeight > 0 && minWeight < maxWeight) {\n            int mod = currentSequence % weightSum;\n            for (int i = 0; i < maxWeight; i++) {\n                for (Map.Entry<Invoker<T>, IntegerWrapper> each : invokerToWeightMap.entrySet()) {\n                    final Invoker<T> k = each.getKey();\n                    final IntegerWrapper v = each.getValue();\n                    if (mod == 0 && v.getValue() > 0) {\n                        return k;\n                    }\n                    if (v.getValue() > 0) {\n                        v.decrement();\n                        mod--;\n                    }\n                }\n            }\n        }\n        // 如果权重都一样。或者都小于0。则按照调用次数轮询\n        return invokers.get(currentSequence % length);\n    }\n```\n\n##### 可以看到dubbo的轮询不是完全按照次数轮询的。而是按照公约后的权重设置轮询比率，即权重轮询算法(Weighted Round-Robin) ，它是基于轮询算法改进而来的。具体算法原理可以再网上搜索`权重轮询调度算法`或者见博客[dubbo-动态代理实现](http://localhost:4000/arithmetic/roundrobinWeight/)。\n\n## leastactive 最小活跃数\n```java\nprotected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) {\n        int length = invokers.size(); // invokers数量\n        int leastActive = -1; // 所有invokers中最小的活跃数\n        int leastCount = 0; // invokers当中有多少个invoker的活跃数是leastActive\n        int[] leastIndexs = new int[length]; // 这些活跃数等于leastActive的下标\n        int totalWeight = 0; // 总权重\n        int firstWeight = 0; // Initial value, used for comparision\n        boolean sameWeight = true; // 所有的权重都相等？\n        for (int i = 0; i < length; i++) {\n            Invoker<T> invoker = invokers.get(i);\n            int active = RpcStatus.getStatus(invoker.getUrl(), invocation.getMethodName()).getActive(); // 活跃数\n            int weight = invoker.getUrl().getMethodParameter(invocation.getMethodName(), Constants.WEIGHT_KEY, Constants.DEFAULT_WEIGHT); // 权重\n            if (leastActive == -1 || active < leastActive) { // 如果活跃数比之前的都小\n                leastActive = active; // 记录最小活跃值\n                leastCount = 1; // 重新计算数量\n                leastIndexs[0] = i; // 重置\n                totalWeight = weight; // 重置总权重\n                firstWeight = weight; // 记录为firstWeight\n                sameWeight = true; // 重置，所有的权重相等\n            } else if (active == leastActive) { // 如果和之前的最小活跃值相等\n                leastIndexs[leastCount++] = i; //记录下标\n                totalWeight += weight; // 总权重相加\n                // 在活跃值相等的情况下权重是不是相等\n                if (sameWeight && i > 0\n                        && weight != firstWeight) {\n                    sameWeight = false;\n                }\n            }\n        }\n        // assert(leastCount > 0)\n        if (leastCount == 1) {\n            // 如果最小活跃值的Invoker只有一个，则直接返回\n            return invokers.get(leastIndexs[0]);\n        }\n        if (!sameWeight && totalWeight > 0) {\n            // 如果总权重值大于0并且各个Invoker的权重不相等，则随机取一个，可以看到这里的过程和random的过程是很像的\n            int offsetWeight = random.nextInt(totalWeight);\n            for (int i = 0; i < leastCount; i++) {\n                int leastIndex = leastIndexs[i];\n                offsetWeight -= getWeight(invokers.get(leastIndex), invocation);\n                if (offsetWeight <= 0)\n                    return invokers.get(leastIndex);\n            }\n        }\n        // 如果所有Invoker的权重相等，或者总权重等于0.则随机选取一个\n        return invokers.get(leastIndexs[random.nextInt(leastCount)]);\n    }\n```\n\n##### 在**最小活跃数**的轮询算法中有一个很重要的概念就是活跃数，dubbo的活跃数是如何来的呢。\n### 活跃数的变化\n##### 活跃数的修改发生在com.alibaba.dubbo.rpc.filter.ActiveLimitFilter中。若未配置actives属性，则每进行一次调用前该invoker关联的活跃数加1，调用结束后活跃数减1。\n##### beginCount对活跃数加1，endCount对活跃数减1。\n```java\nlong begin = System.currentTimeMillis();\n            RpcStatus.beginCount(url, methodName);\n            try {\n                Result result = invoker.invoke(invocation);\n                RpcStatus.endCount(url, methodName, System.currentTimeMillis() - begin, true);\n                return result;\n            } catch (RuntimeException t) {\n                RpcStatus.endCount(url, methodName, System.currentTimeMillis() - begin, false);\n                throw t;\n            }\n```\n\n##### 如果使用LeastActive负载均衡，则需要启用ActiveLimitFilter，这样活跃数才会变化。\n##### 因此需要配置filter，filter 为 “activelimit”。\n```xml\n<dubbo:service interface=\"service.DemoService\" ref = \"demoService\" loadbalance=\"leastactive\" filter=\"activelimit\"/>\n```\n\n##### 有了活跃数之后，dubbo所做的操作就是找到最小的活跃数的invokers。找到后再按照权重去随机。可以看到代码中的`totalWeight`指的是相同最小活跃数的权重总和。所以这个一个二维的算法，基于活跃数和权重。\n\n## consistenthash 一致性hash\n```java\nprotected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) {\n        //按照ServiceKey和方法名拼成String key\n        String key = invokers.get(0).getUrl().getServiceKey() + \".\" + invocation.getMethodName();\n        //获取invokers的hashCode\n        int identityHashCode = System.identityHashCode(invokers);\n        //以调用方法名为key,获取一致性hash选择器\n        ConsistentHashSelector<T> selector = (ConsistentHashSelector<T>) selectors.get(key);\n        // 若不存在则创建新的选择器\n        if (selector == null || selector.identityHashCode != identityHashCode) {\n            selectors.put(key, new ConsistentHashSelector<T>(invokers, invocation.getMethodName(), identityHashCode));\n            selector = (ConsistentHashSelector<T>) selectors.get(key);\n        }\n        // 选择结点\n        return selector.select(invocation);\n    }\n```\n\n##### 可以看到doSelect中的方法只是找到或者创建选择器，真正的选择过程在ConsistentHashSelector中\n```java\nprivate static final class ConsistentHashSelector<T> {\n\n        private final TreeMap<Long, Invoker<T>> virtualInvokers; // 虚拟结点\n\n        private final int                       replicaNumber;   // 副本数\n\n        private final int                       identityHashCode;// hashCode\n\n        private final int[]                     argumentIndex;   // 参数索引数组\n\n        public ConsistentHashSelector(List<Invoker<T>> invokers, String methodName, int identityHashCode) {\n            // 创建TreeMap 来保存结点\n            this.virtualInvokers = new TreeMap<Long, Invoker<T>>();\n            // 生成调用结点HashCode\n            this.identityHashCode = System.identityHashCode(invokers);\n            // 获取Url\n            URL url = invokers.get(0).getUrl();\n            // 获取所配置的结点数，如没有设置则使用默认值160\n            this.replicaNumber = url.getMethodParameter(methodName, \"hash.nodes\", 160);\n            // 获取需要进行hash的参数数组索引，默认对第一个参数进行hash\n            String[] index = Constants.COMMA_SPLIT_PATTERN.split(url.getMethodParameter(methodName, \"hash.arguments\", \"0\"));\n            argumentIndex = new int[index.length];\n            for (int i = 0; i < index.length; i ++) {\n                argumentIndex[i] = Integer.parseInt(index[i]);\n            }\n            // 创建虚拟结点\n            // 对每个invoker生成replicaNumber个虚拟结点，并存放于TreeMap中\n            for (Invoker<T> invoker : invokers) {\n\n                for (int i = 0; i < replicaNumber / 4; i++) {\n                    // 根据md5算法为每4个结点生成一个消息摘要，摘要长为16字节128位。\n                    byte[] digest = md5(invoker.getUrl().toFullString() + i);\n                    // 随后将128位分为4部分，0-31,32-63,64-95,95-128，并生成4个32位数，存于long中，long的高32位都为0\n                    // 并作为虚拟结点的key。\n                    for (int h = 0; h < 4; h++) {\n                        long m = hash(digest, h);\n                        virtualInvokers.put(m, invoker);\n                    }\n                }\n            }\n        }\n\n        public int getIdentityHashCode() {\n            return identityHashCode;\n        }\n\n        // 选择结点\n        public Invoker<T> select(Invocation invocation) {\n            // 根据调用参数来生成Key\n            String key = toKey(invocation.getArguments());\n            // 根据这个参数生成消息摘要\n            byte[] digest = md5(key);\n            //调用hash(digest, 0)，将消息摘要转换为hashCode，这里仅取0-31位来生成HashCode\n            //调用sekectForKey方法选择结点。\n            Invoker<T> invoker = sekectForKey(hash(digest, 0));\n            return invoker;\n        }\n\n        private String toKey(Object[] args) {\n            StringBuilder buf = new StringBuilder();\n            // 由于hash.arguments没有进行配置，因为只取方法的第1个参数作为key\n            for (int i : argumentIndex) {\n                if (i >= 0 && i < args.length) {\n                    buf.append(args[i]);\n                }\n            }\n            return buf.toString();\n        }\n\n        //根据hashCode选择结点\n        private Invoker<T> sekectForKey(long hash) {\n            Invoker<T> invoker;\n            Long key = hash;\n            // 若HashCode直接与某个虚拟结点的key一样，则直接返回该结点\n            if (!virtualInvokers.containsKey(key)) {\n                // 若不一致，找到一个最小上届的key所对应的结点。\n                SortedMap<Long, Invoker<T>> tailMap = virtualInvokers.tailMap(key);\n                // 若存在则返回，例如hashCode落在图中[1]的位置\n                // 若不存在，例如hashCode落在[2]的位置，那么选择treeMap中第一个结点\n                // 使用TreeMap的firstKey方法，来选择最小上界。\n                if (tailMap.isEmpty()) {\n                    key = virtualInvokers.firstKey();\n                } else {\n\n                    key = tailMap.firstKey();\n                }\n            }\n            invoker = virtualInvokers.get(key);\n            return invoker;\n        }\n\n        private long hash(byte[] digest, int number) {\n            return (((long) (digest[3 + number * 4] & 0xFF) << 24)\n                    | ((long) (digest[2 + number * 4] & 0xFF) << 16)\n                    | ((long) (digest[1 + number * 4] & 0xFF) << 8)\n                    | (digest[0 + number * 4] & 0xFF))\n                    & 0xFFFFFFFFL;\n        }\n\n        private byte[] md5(String value) {\n            MessageDigest md5;\n            try {\n                md5 = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException e) {\n                throw new IllegalStateException(e.getMessage(), e);\n            }\n            md5.reset();\n            byte[] bytes = null;\n            try {\n                bytes = value.getBytes(\"UTF-8\");\n            } catch (UnsupportedEncodingException e) {\n                throw new IllegalStateException(e.getMessage(), e);\n            }\n            md5.update(bytes);\n            return md5.digest();\n        }\n\n    }\n```\n\n##### 在进行选择时候若HashCode直接与某个虚拟结点的key一样，则直接返回该结点，例如hashCode落在某个结点上(圆圈所表示)。若不在，找到一个最小上届的key所对应的结点。例如进行选择时的key落在图中1所标注的位置。由于利用TreeMap存储，key所落在的位置可能无法找到最小上界，例如图中2所标注的位置。那么需要返回TreeMap中的最小值（构成逻辑环状结构，找不到，则返回最开头的结点）。\n![](/img/note/dubbo/dubbo3.png)\n\n##### 以上为dubbo的一致性hash算法实现，其中涉及到两个主要的配置参数为hash.arguments 与hash.nodes。\n##### **hash.arguments**： 当进行调用时候根据调用方法的哪几个参数生成key，并根据key来通过一致性hash算法来选择调用结点。例如调用方法invoke(String s1,String s2); 若hash.arguments为1(默认值)，则仅取invoke的参数1（s1）来生成hashCode。\n\n##### **hash.nodes**： 为结点的副本数。\n```xml\n缺省只对第一个参数Hash，如果要修改，请配置\n<dubbo:parameter key=\"hash.arguments\" value=\"0,1\" />\n\n缺省用160份虚拟节点，如果要修改，请配置\n<dubbo:parameter key=\"hash.nodes\" value=\"320\" />\n```","source":"_posts/note/dubbo/loadBalance.md","raw":"---\nlayout: post\ntitle: dubbo-负载均衡实现\ndate: 2018/03/23\ntags: [tech, index, dubbo]\ntag: [[java, java], [dubbo, dubbo]]\noriginal: true\n---\n\n### 扩展说明\n##### 从多个服务提者方中选择一个进行调用\n\n### 扩展接口\n##### `com.alibaba.dubbo.rpc.cluster.LoadBalance`\n\n### 使用配置\n```xml\n<dubbo:provider loadbalance=\"\" />\n```\n<!--more-->\n\n### 目前已知扩展：\n* random=com.alibaba.dubbo.rpc.cluster.loadbalance.RandomLoadBalance\n* roundrobin=com.alibaba.dubbo.rpc.cluster.loadbalance.RoundRobinLoadBalance\n* leastactive=com.alibaba.dubbo.rpc.cluster.loadbalance.LeastActiveLoadBalance\n* consistenthash=com.alibaba.dubbo.rpc.cluster.loadbalance.ConsistentHashLoadBalance\n\n### 包结构：\n![](/img/note/dubbo/dubbo2.png)\n\n### LoadBalance\n```java\n@SPI(RandomLoadBalance.NAME) //默认为random\npublic interface LoadBalance {\n\n    /**\n     * 从list当中选择一个invoker\n     *\n     * @param invokers   invokers.\n     * @param url        refer url\n     * @param invocation invocation.\n     * @return selected invoker.\n     */\n    @Adaptive(\"loadbalance\")\n    <T> Invoker<T> select(List<Invoker<T>> invokers, URL url, Invocation invocation) throws RpcException;\n}\n```\n##### 只有一个接口，很简单，提供invokers集合，返回其中一个\n\n### AbstractLoadBalance\n```java\npublic abstract class AbstractLoadBalance implements LoadBalance {\n\n    static int calculateWarmupWeight(int uptime, int warmup, int weight) {\n        int ww = (int) ((float) uptime / ((float) warmup / (float) weight));\n        return ww < 1 ? 1 : (ww > weight ? weight : ww);\n    }\n\n    public <T> Invoker<T> select(List<Invoker<T>> invokers, URL url, Invocation invocation) {\n        if (invokers == null || invokers.isEmpty())\n            return null;\n        if (invokers.size() == 1)\n            return invokers.get(0);\n        return doSelect(invokers, url, invocation);\n    }\n\n    protected abstract <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation);\n\n    protected int getWeight(Invoker<?> invoker, Invocation invocation) {\n        int weight = invoker.getUrl().getMethodParameter(invocation.getMethodName(), Constants.WEIGHT_KEY, Constants.DEFAULT_WEIGHT);\n        if (weight > 0) {\n            long timestamp = invoker.getUrl().getParameter(Constants.REMOTE_TIMESTAMP_KEY, 0L);\n            if (timestamp > 0L) {\n                int uptime = (int) (System.currentTimeMillis() - timestamp);\n                int warmup = invoker.getUrl().getParameter(Constants.WARMUP_KEY, Constants.DEFAULT_WARMUP);\n                if (uptime > 0 && uptime < warmup) {\n                    weight = calculateWarmupWeight(uptime, warmup, weight);\n                }\n            }\n        }\n        return weight;\n    }\n\n}\n```\n\n##### 抽象类**AbstractLoadBalance**实现了接口**LoadBalance**的select方法。主要是做了一些边界值的判断，正在的操作在抽象方法doSelect中。\n\n##### **getWeight**方法将从Invoker的url中获取**weight**参数。默认为100\n\n## random 随机\n##### dubbo默认的负载方式，看下**doSelect**方法\n```java\nprotected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) {\n        int length = invokers.size(); // invokers数量\n        int totalWeight = 0; // 总权重\n        boolean sameWeight = true; // 是不是所有的权重都是一样的\n        for (int i = 0; i < length; i++) {\n            int weight = getWeight(invokers.get(i), invocation);\n            totalWeight += weight; // 相加\n            if (sameWeight && i > 0\n                    && weight != getWeight(invokers.get(i - 1), invocation)) {\n                sameWeight = false;\n            }\n        }\n        if (totalWeight > 0 && !sameWeight) {\n            //如果权重不是都相等，则用随机数生成\n            int offset = random.nextInt(totalWeight);\n            // 返回一个在包含该随机值的invoker\n            for (int i = 0; i < length; i++) {\n                offset -= getWeight(invokers.get(i), invocation);\n                if (offset < 0) {\n                    return invokers.get(i);\n                }\n            }\n        }\n        //如果权重都相等或者总和为0，则随机一个\n        return invokers.get(random.nextInt(length));\n    }\n```\n##### 可以看到，dubbo的随机负载均衡策略是包含了权重的概念的。所以也不是完全随机。\n\n\n## roundrobin 轮询\n```java\nprotected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) {\n        //通过serviceKey和方法名构建key\n        String key = invokers.get(0).getUrl().getServiceKey() + \".\" + invocation.getMethodName();\n        int length = invokers.size(); // invokers数量\n        int maxWeight = 0; // 最大的 权重 值\n        int minWeight = Integer.MAX_VALUE; // 最小的 权重 值\n        final LinkedHashMap<Invoker<T>, IntegerWrapper> invokerToWeightMap = new LinkedHashMap<Invoker<T>, IntegerWrapper>();//有序map\n        int weightSum = 0; //权重 总值\n        for (int i = 0; i < length; i++) {\n            int weight = getWeight(invokers.get(i), invocation); //获取单个invoker的权重\n            maxWeight = Math.max(maxWeight, weight); // 是不是最大的\n            minWeight = Math.min(minWeight, weight); // 是不是最小的\n            if (weight > 0) {\n                invokerToWeightMap.put(invokers.get(i), new IntegerWrapper(weight));\n                weightSum += weight;\n            }\n        }\n        AtomicPositiveInteger sequence = sequences.get(key);\n        if (sequence == null) {\n            sequences.putIfAbsent(key, new AtomicPositiveInteger());\n            sequence = sequences.get(key);\n        }\n        //记录该接口的调用次数\n        int currentSequence = sequence.getAndIncrement();\n        if (maxWeight > 0 && minWeight < maxWeight) {\n            int mod = currentSequence % weightSum;\n            for (int i = 0; i < maxWeight; i++) {\n                for (Map.Entry<Invoker<T>, IntegerWrapper> each : invokerToWeightMap.entrySet()) {\n                    final Invoker<T> k = each.getKey();\n                    final IntegerWrapper v = each.getValue();\n                    if (mod == 0 && v.getValue() > 0) {\n                        return k;\n                    }\n                    if (v.getValue() > 0) {\n                        v.decrement();\n                        mod--;\n                    }\n                }\n            }\n        }\n        // 如果权重都一样。或者都小于0。则按照调用次数轮询\n        return invokers.get(currentSequence % length);\n    }\n```\n\n##### 可以看到dubbo的轮询不是完全按照次数轮询的。而是按照公约后的权重设置轮询比率，即权重轮询算法(Weighted Round-Robin) ，它是基于轮询算法改进而来的。具体算法原理可以再网上搜索`权重轮询调度算法`或者见博客[dubbo-动态代理实现](http://localhost:4000/arithmetic/roundrobinWeight/)。\n\n## leastactive 最小活跃数\n```java\nprotected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) {\n        int length = invokers.size(); // invokers数量\n        int leastActive = -1; // 所有invokers中最小的活跃数\n        int leastCount = 0; // invokers当中有多少个invoker的活跃数是leastActive\n        int[] leastIndexs = new int[length]; // 这些活跃数等于leastActive的下标\n        int totalWeight = 0; // 总权重\n        int firstWeight = 0; // Initial value, used for comparision\n        boolean sameWeight = true; // 所有的权重都相等？\n        for (int i = 0; i < length; i++) {\n            Invoker<T> invoker = invokers.get(i);\n            int active = RpcStatus.getStatus(invoker.getUrl(), invocation.getMethodName()).getActive(); // 活跃数\n            int weight = invoker.getUrl().getMethodParameter(invocation.getMethodName(), Constants.WEIGHT_KEY, Constants.DEFAULT_WEIGHT); // 权重\n            if (leastActive == -1 || active < leastActive) { // 如果活跃数比之前的都小\n                leastActive = active; // 记录最小活跃值\n                leastCount = 1; // 重新计算数量\n                leastIndexs[0] = i; // 重置\n                totalWeight = weight; // 重置总权重\n                firstWeight = weight; // 记录为firstWeight\n                sameWeight = true; // 重置，所有的权重相等\n            } else if (active == leastActive) { // 如果和之前的最小活跃值相等\n                leastIndexs[leastCount++] = i; //记录下标\n                totalWeight += weight; // 总权重相加\n                // 在活跃值相等的情况下权重是不是相等\n                if (sameWeight && i > 0\n                        && weight != firstWeight) {\n                    sameWeight = false;\n                }\n            }\n        }\n        // assert(leastCount > 0)\n        if (leastCount == 1) {\n            // 如果最小活跃值的Invoker只有一个，则直接返回\n            return invokers.get(leastIndexs[0]);\n        }\n        if (!sameWeight && totalWeight > 0) {\n            // 如果总权重值大于0并且各个Invoker的权重不相等，则随机取一个，可以看到这里的过程和random的过程是很像的\n            int offsetWeight = random.nextInt(totalWeight);\n            for (int i = 0; i < leastCount; i++) {\n                int leastIndex = leastIndexs[i];\n                offsetWeight -= getWeight(invokers.get(leastIndex), invocation);\n                if (offsetWeight <= 0)\n                    return invokers.get(leastIndex);\n            }\n        }\n        // 如果所有Invoker的权重相等，或者总权重等于0.则随机选取一个\n        return invokers.get(leastIndexs[random.nextInt(leastCount)]);\n    }\n```\n\n##### 在**最小活跃数**的轮询算法中有一个很重要的概念就是活跃数，dubbo的活跃数是如何来的呢。\n### 活跃数的变化\n##### 活跃数的修改发生在com.alibaba.dubbo.rpc.filter.ActiveLimitFilter中。若未配置actives属性，则每进行一次调用前该invoker关联的活跃数加1，调用结束后活跃数减1。\n##### beginCount对活跃数加1，endCount对活跃数减1。\n```java\nlong begin = System.currentTimeMillis();\n            RpcStatus.beginCount(url, methodName);\n            try {\n                Result result = invoker.invoke(invocation);\n                RpcStatus.endCount(url, methodName, System.currentTimeMillis() - begin, true);\n                return result;\n            } catch (RuntimeException t) {\n                RpcStatus.endCount(url, methodName, System.currentTimeMillis() - begin, false);\n                throw t;\n            }\n```\n\n##### 如果使用LeastActive负载均衡，则需要启用ActiveLimitFilter，这样活跃数才会变化。\n##### 因此需要配置filter，filter 为 “activelimit”。\n```xml\n<dubbo:service interface=\"service.DemoService\" ref = \"demoService\" loadbalance=\"leastactive\" filter=\"activelimit\"/>\n```\n\n##### 有了活跃数之后，dubbo所做的操作就是找到最小的活跃数的invokers。找到后再按照权重去随机。可以看到代码中的`totalWeight`指的是相同最小活跃数的权重总和。所以这个一个二维的算法，基于活跃数和权重。\n\n## consistenthash 一致性hash\n```java\nprotected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) {\n        //按照ServiceKey和方法名拼成String key\n        String key = invokers.get(0).getUrl().getServiceKey() + \".\" + invocation.getMethodName();\n        //获取invokers的hashCode\n        int identityHashCode = System.identityHashCode(invokers);\n        //以调用方法名为key,获取一致性hash选择器\n        ConsistentHashSelector<T> selector = (ConsistentHashSelector<T>) selectors.get(key);\n        // 若不存在则创建新的选择器\n        if (selector == null || selector.identityHashCode != identityHashCode) {\n            selectors.put(key, new ConsistentHashSelector<T>(invokers, invocation.getMethodName(), identityHashCode));\n            selector = (ConsistentHashSelector<T>) selectors.get(key);\n        }\n        // 选择结点\n        return selector.select(invocation);\n    }\n```\n\n##### 可以看到doSelect中的方法只是找到或者创建选择器，真正的选择过程在ConsistentHashSelector中\n```java\nprivate static final class ConsistentHashSelector<T> {\n\n        private final TreeMap<Long, Invoker<T>> virtualInvokers; // 虚拟结点\n\n        private final int                       replicaNumber;   // 副本数\n\n        private final int                       identityHashCode;// hashCode\n\n        private final int[]                     argumentIndex;   // 参数索引数组\n\n        public ConsistentHashSelector(List<Invoker<T>> invokers, String methodName, int identityHashCode) {\n            // 创建TreeMap 来保存结点\n            this.virtualInvokers = new TreeMap<Long, Invoker<T>>();\n            // 生成调用结点HashCode\n            this.identityHashCode = System.identityHashCode(invokers);\n            // 获取Url\n            URL url = invokers.get(0).getUrl();\n            // 获取所配置的结点数，如没有设置则使用默认值160\n            this.replicaNumber = url.getMethodParameter(methodName, \"hash.nodes\", 160);\n            // 获取需要进行hash的参数数组索引，默认对第一个参数进行hash\n            String[] index = Constants.COMMA_SPLIT_PATTERN.split(url.getMethodParameter(methodName, \"hash.arguments\", \"0\"));\n            argumentIndex = new int[index.length];\n            for (int i = 0; i < index.length; i ++) {\n                argumentIndex[i] = Integer.parseInt(index[i]);\n            }\n            // 创建虚拟结点\n            // 对每个invoker生成replicaNumber个虚拟结点，并存放于TreeMap中\n            for (Invoker<T> invoker : invokers) {\n\n                for (int i = 0; i < replicaNumber / 4; i++) {\n                    // 根据md5算法为每4个结点生成一个消息摘要，摘要长为16字节128位。\n                    byte[] digest = md5(invoker.getUrl().toFullString() + i);\n                    // 随后将128位分为4部分，0-31,32-63,64-95,95-128，并生成4个32位数，存于long中，long的高32位都为0\n                    // 并作为虚拟结点的key。\n                    for (int h = 0; h < 4; h++) {\n                        long m = hash(digest, h);\n                        virtualInvokers.put(m, invoker);\n                    }\n                }\n            }\n        }\n\n        public int getIdentityHashCode() {\n            return identityHashCode;\n        }\n\n        // 选择结点\n        public Invoker<T> select(Invocation invocation) {\n            // 根据调用参数来生成Key\n            String key = toKey(invocation.getArguments());\n            // 根据这个参数生成消息摘要\n            byte[] digest = md5(key);\n            //调用hash(digest, 0)，将消息摘要转换为hashCode，这里仅取0-31位来生成HashCode\n            //调用sekectForKey方法选择结点。\n            Invoker<T> invoker = sekectForKey(hash(digest, 0));\n            return invoker;\n        }\n\n        private String toKey(Object[] args) {\n            StringBuilder buf = new StringBuilder();\n            // 由于hash.arguments没有进行配置，因为只取方法的第1个参数作为key\n            for (int i : argumentIndex) {\n                if (i >= 0 && i < args.length) {\n                    buf.append(args[i]);\n                }\n            }\n            return buf.toString();\n        }\n\n        //根据hashCode选择结点\n        private Invoker<T> sekectForKey(long hash) {\n            Invoker<T> invoker;\n            Long key = hash;\n            // 若HashCode直接与某个虚拟结点的key一样，则直接返回该结点\n            if (!virtualInvokers.containsKey(key)) {\n                // 若不一致，找到一个最小上届的key所对应的结点。\n                SortedMap<Long, Invoker<T>> tailMap = virtualInvokers.tailMap(key);\n                // 若存在则返回，例如hashCode落在图中[1]的位置\n                // 若不存在，例如hashCode落在[2]的位置，那么选择treeMap中第一个结点\n                // 使用TreeMap的firstKey方法，来选择最小上界。\n                if (tailMap.isEmpty()) {\n                    key = virtualInvokers.firstKey();\n                } else {\n\n                    key = tailMap.firstKey();\n                }\n            }\n            invoker = virtualInvokers.get(key);\n            return invoker;\n        }\n\n        private long hash(byte[] digest, int number) {\n            return (((long) (digest[3 + number * 4] & 0xFF) << 24)\n                    | ((long) (digest[2 + number * 4] & 0xFF) << 16)\n                    | ((long) (digest[1 + number * 4] & 0xFF) << 8)\n                    | (digest[0 + number * 4] & 0xFF))\n                    & 0xFFFFFFFFL;\n        }\n\n        private byte[] md5(String value) {\n            MessageDigest md5;\n            try {\n                md5 = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException e) {\n                throw new IllegalStateException(e.getMessage(), e);\n            }\n            md5.reset();\n            byte[] bytes = null;\n            try {\n                bytes = value.getBytes(\"UTF-8\");\n            } catch (UnsupportedEncodingException e) {\n                throw new IllegalStateException(e.getMessage(), e);\n            }\n            md5.update(bytes);\n            return md5.digest();\n        }\n\n    }\n```\n\n##### 在进行选择时候若HashCode直接与某个虚拟结点的key一样，则直接返回该结点，例如hashCode落在某个结点上(圆圈所表示)。若不在，找到一个最小上届的key所对应的结点。例如进行选择时的key落在图中1所标注的位置。由于利用TreeMap存储，key所落在的位置可能无法找到最小上界，例如图中2所标注的位置。那么需要返回TreeMap中的最小值（构成逻辑环状结构，找不到，则返回最开头的结点）。\n![](/img/note/dubbo/dubbo3.png)\n\n##### 以上为dubbo的一致性hash算法实现，其中涉及到两个主要的配置参数为hash.arguments 与hash.nodes。\n##### **hash.arguments**： 当进行调用时候根据调用方法的哪几个参数生成key，并根据key来通过一致性hash算法来选择调用结点。例如调用方法invoke(String s1,String s2); 若hash.arguments为1(默认值)，则仅取invoke的参数1（s1）来生成hashCode。\n\n##### **hash.nodes**： 为结点的副本数。\n```xml\n缺省只对第一个参数Hash，如果要修改，请配置\n<dubbo:parameter key=\"hash.arguments\" value=\"0,1\" />\n\n缺省用160份虚拟节点，如果要修改，请配置\n<dubbo:parameter key=\"hash.nodes\" value=\"320\" />\n```","slug":"note/dubbo/loadBalance","published":1,"updated":"2018-05-08T13:00:14.276Z","comments":1,"photos":[],"link":"","_id":"cjgxop3nd0036jah18elfa1cf","content":"<h3 id=\"扩展说明\"><a href=\"#扩展说明\" class=\"headerlink\" title=\"扩展说明\"></a>扩展说明</h3><h5 id=\"从多个服务提者方中选择一个进行调用\"><a href=\"#从多个服务提者方中选择一个进行调用\" class=\"headerlink\" title=\"从多个服务提者方中选择一个进行调用\"></a>从多个服务提者方中选择一个进行调用</h5><h3 id=\"扩展接口\"><a href=\"#扩展接口\" class=\"headerlink\" title=\"扩展接口\"></a>扩展接口</h3><h5 id=\"com-alibaba-dubbo-rpc-cluster-LoadBalance\"><a href=\"#com-alibaba-dubbo-rpc-cluster-LoadBalance\" class=\"headerlink\" title=\"com.alibaba.dubbo.rpc.cluster.LoadBalance\"></a><code>com.alibaba.dubbo.rpc.cluster.LoadBalance</code></h5><h3 id=\"使用配置\"><a href=\"#使用配置\" class=\"headerlink\" title=\"使用配置\"></a>使用配置</h3><pre><code class=\"lang-xml\">&lt;dubbo:provider loadbalance=&quot;&quot; /&gt;\n</code></pre>\n<a id=\"more\"></a>\n<h3 id=\"目前已知扩展：\"><a href=\"#目前已知扩展：\" class=\"headerlink\" title=\"目前已知扩展：\"></a>目前已知扩展：</h3><ul>\n<li>random=com.alibaba.dubbo.rpc.cluster.loadbalance.RandomLoadBalance</li>\n<li>roundrobin=com.alibaba.dubbo.rpc.cluster.loadbalance.RoundRobinLoadBalance</li>\n<li>leastactive=com.alibaba.dubbo.rpc.cluster.loadbalance.LeastActiveLoadBalance</li>\n<li>consistenthash=com.alibaba.dubbo.rpc.cluster.loadbalance.ConsistentHashLoadBalance</li>\n</ul>\n<h3 id=\"包结构：\"><a href=\"#包结构：\" class=\"headerlink\" title=\"包结构：\"></a>包结构：</h3><p><img src=\"/img/note/dubbo/dubbo2.png\" alt=\"\"></p>\n<h3 id=\"LoadBalance\"><a href=\"#LoadBalance\" class=\"headerlink\" title=\"LoadBalance\"></a>LoadBalance</h3><pre><code class=\"lang-java\">@SPI(RandomLoadBalance.NAME) //默认为random\npublic interface LoadBalance {\n\n    /**\n     * 从list当中选择一个invoker\n     *\n     * @param invokers   invokers.\n     * @param url        refer url\n     * @param invocation invocation.\n     * @return selected invoker.\n     */\n    @Adaptive(&quot;loadbalance&quot;)\n    &lt;T&gt; Invoker&lt;T&gt; select(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) throws RpcException;\n}\n</code></pre>\n<h5 id=\"只有一个接口，很简单，提供invokers集合，返回其中一个\"><a href=\"#只有一个接口，很简单，提供invokers集合，返回其中一个\" class=\"headerlink\" title=\"只有一个接口，很简单，提供invokers集合，返回其中一个\"></a>只有一个接口，很简单，提供invokers集合，返回其中一个</h5><h3 id=\"AbstractLoadBalance\"><a href=\"#AbstractLoadBalance\" class=\"headerlink\" title=\"AbstractLoadBalance\"></a>AbstractLoadBalance</h3><pre><code class=\"lang-java\">public abstract class AbstractLoadBalance implements LoadBalance {\n\n    static int calculateWarmupWeight(int uptime, int warmup, int weight) {\n        int ww = (int) ((float) uptime / ((float) warmup / (float) weight));\n        return ww &lt; 1 ? 1 : (ww &gt; weight ? weight : ww);\n    }\n\n    public &lt;T&gt; Invoker&lt;T&gt; select(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) {\n        if (invokers == null || invokers.isEmpty())\n            return null;\n        if (invokers.size() == 1)\n            return invokers.get(0);\n        return doSelect(invokers, url, invocation);\n    }\n\n    protected abstract &lt;T&gt; Invoker&lt;T&gt; doSelect(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation);\n\n    protected int getWeight(Invoker&lt;?&gt; invoker, Invocation invocation) {\n        int weight = invoker.getUrl().getMethodParameter(invocation.getMethodName(), Constants.WEIGHT_KEY, Constants.DEFAULT_WEIGHT);\n        if (weight &gt; 0) {\n            long timestamp = invoker.getUrl().getParameter(Constants.REMOTE_TIMESTAMP_KEY, 0L);\n            if (timestamp &gt; 0L) {\n                int uptime = (int) (System.currentTimeMillis() - timestamp);\n                int warmup = invoker.getUrl().getParameter(Constants.WARMUP_KEY, Constants.DEFAULT_WARMUP);\n                if (uptime &gt; 0 &amp;&amp; uptime &lt; warmup) {\n                    weight = calculateWarmupWeight(uptime, warmup, weight);\n                }\n            }\n        }\n        return weight;\n    }\n\n}\n</code></pre>\n<h5 id=\"抽象类AbstractLoadBalance实现了接口LoadBalance的select方法。主要是做了一些边界值的判断，正在的操作在抽象方法doSelect中。\"><a href=\"#抽象类AbstractLoadBalance实现了接口LoadBalance的select方法。主要是做了一些边界值的判断，正在的操作在抽象方法doSelect中。\" class=\"headerlink\" title=\"抽象类AbstractLoadBalance实现了接口LoadBalance的select方法。主要是做了一些边界值的判断，正在的操作在抽象方法doSelect中。\"></a>抽象类<strong>AbstractLoadBalance</strong>实现了接口<strong>LoadBalance</strong>的select方法。主要是做了一些边界值的判断，正在的操作在抽象方法doSelect中。</h5><h5 id=\"getWeight方法将从Invoker的url中获取weight参数。默认为100\"><a href=\"#getWeight方法将从Invoker的url中获取weight参数。默认为100\" class=\"headerlink\" title=\"getWeight方法将从Invoker的url中获取weight参数。默认为100\"></a><strong>getWeight</strong>方法将从Invoker的url中获取<strong>weight</strong>参数。默认为100</h5><h2 id=\"random-随机\"><a href=\"#random-随机\" class=\"headerlink\" title=\"random 随机\"></a>random 随机</h2><h5 id=\"dubbo默认的负载方式，看下doSelect方法\"><a href=\"#dubbo默认的负载方式，看下doSelect方法\" class=\"headerlink\" title=\"dubbo默认的负载方式，看下doSelect方法\"></a>dubbo默认的负载方式，看下<strong>doSelect</strong>方法</h5><pre><code class=\"lang-java\">protected &lt;T&gt; Invoker&lt;T&gt; doSelect(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) {\n        int length = invokers.size(); // invokers数量\n        int totalWeight = 0; // 总权重\n        boolean sameWeight = true; // 是不是所有的权重都是一样的\n        for (int i = 0; i &lt; length; i++) {\n            int weight = getWeight(invokers.get(i), invocation);\n            totalWeight += weight; // 相加\n            if (sameWeight &amp;&amp; i &gt; 0\n                    &amp;&amp; weight != getWeight(invokers.get(i - 1), invocation)) {\n                sameWeight = false;\n            }\n        }\n        if (totalWeight &gt; 0 &amp;&amp; !sameWeight) {\n            //如果权重不是都相等，则用随机数生成\n            int offset = random.nextInt(totalWeight);\n            // 返回一个在包含该随机值的invoker\n            for (int i = 0; i &lt; length; i++) {\n                offset -= getWeight(invokers.get(i), invocation);\n                if (offset &lt; 0) {\n                    return invokers.get(i);\n                }\n            }\n        }\n        //如果权重都相等或者总和为0，则随机一个\n        return invokers.get(random.nextInt(length));\n    }\n</code></pre>\n<h5 id=\"可以看到，dubbo的随机负载均衡策略是包含了权重的概念的。所以也不是完全随机。\"><a href=\"#可以看到，dubbo的随机负载均衡策略是包含了权重的概念的。所以也不是完全随机。\" class=\"headerlink\" title=\"可以看到，dubbo的随机负载均衡策略是包含了权重的概念的。所以也不是完全随机。\"></a>可以看到，dubbo的随机负载均衡策略是包含了权重的概念的。所以也不是完全随机。</h5><h2 id=\"roundrobin-轮询\"><a href=\"#roundrobin-轮询\" class=\"headerlink\" title=\"roundrobin 轮询\"></a>roundrobin 轮询</h2><pre><code class=\"lang-java\">protected &lt;T&gt; Invoker&lt;T&gt; doSelect(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) {\n        //通过serviceKey和方法名构建key\n        String key = invokers.get(0).getUrl().getServiceKey() + &quot;.&quot; + invocation.getMethodName();\n        int length = invokers.size(); // invokers数量\n        int maxWeight = 0; // 最大的 权重 值\n        int minWeight = Integer.MAX_VALUE; // 最小的 权重 值\n        final LinkedHashMap&lt;Invoker&lt;T&gt;, IntegerWrapper&gt; invokerToWeightMap = new LinkedHashMap&lt;Invoker&lt;T&gt;, IntegerWrapper&gt;();//有序map\n        int weightSum = 0; //权重 总值\n        for (int i = 0; i &lt; length; i++) {\n            int weight = getWeight(invokers.get(i), invocation); //获取单个invoker的权重\n            maxWeight = Math.max(maxWeight, weight); // 是不是最大的\n            minWeight = Math.min(minWeight, weight); // 是不是最小的\n            if (weight &gt; 0) {\n                invokerToWeightMap.put(invokers.get(i), new IntegerWrapper(weight));\n                weightSum += weight;\n            }\n        }\n        AtomicPositiveInteger sequence = sequences.get(key);\n        if (sequence == null) {\n            sequences.putIfAbsent(key, new AtomicPositiveInteger());\n            sequence = sequences.get(key);\n        }\n        //记录该接口的调用次数\n        int currentSequence = sequence.getAndIncrement();\n        if (maxWeight &gt; 0 &amp;&amp; minWeight &lt; maxWeight) {\n            int mod = currentSequence % weightSum;\n            for (int i = 0; i &lt; maxWeight; i++) {\n                for (Map.Entry&lt;Invoker&lt;T&gt;, IntegerWrapper&gt; each : invokerToWeightMap.entrySet()) {\n                    final Invoker&lt;T&gt; k = each.getKey();\n                    final IntegerWrapper v = each.getValue();\n                    if (mod == 0 &amp;&amp; v.getValue() &gt; 0) {\n                        return k;\n                    }\n                    if (v.getValue() &gt; 0) {\n                        v.decrement();\n                        mod--;\n                    }\n                }\n            }\n        }\n        // 如果权重都一样。或者都小于0。则按照调用次数轮询\n        return invokers.get(currentSequence % length);\n    }\n</code></pre>\n<h5 id=\"可以看到dubbo的轮询不是完全按照次数轮询的。而是按照公约后的权重设置轮询比率，即权重轮询算法-Weighted-Round-Robin-，它是基于轮询算法改进而来的。具体算法原理可以再网上搜索权重轮询调度算法或者见博客dubbo-动态代理实现。\"><a href=\"#可以看到dubbo的轮询不是完全按照次数轮询的。而是按照公约后的权重设置轮询比率，即权重轮询算法-Weighted-Round-Robin-，它是基于轮询算法改进而来的。具体算法原理可以再网上搜索权重轮询调度算法或者见博客dubbo-动态代理实现。\" class=\"headerlink\" title=\"可以看到dubbo的轮询不是完全按照次数轮询的。而是按照公约后的权重设置轮询比率，即权重轮询算法(Weighted Round-Robin) ，它是基于轮询算法改进而来的。具体算法原理可以再网上搜索权重轮询调度算法或者见博客dubbo-动态代理实现。\"></a>可以看到dubbo的轮询不是完全按照次数轮询的。而是按照公约后的权重设置轮询比率，即权重轮询算法(Weighted Round-Robin) ，它是基于轮询算法改进而来的。具体算法原理可以再网上搜索<code>权重轮询调度算法</code>或者见博客<a href=\"http://localhost:4000/arithmetic/roundrobinWeight/\" target=\"_blank\" rel=\"external\">dubbo-动态代理实现</a>。</h5><h2 id=\"leastactive-最小活跃数\"><a href=\"#leastactive-最小活跃数\" class=\"headerlink\" title=\"leastactive 最小活跃数\"></a>leastactive 最小活跃数</h2><pre><code class=\"lang-java\">protected &lt;T&gt; Invoker&lt;T&gt; doSelect(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) {\n        int length = invokers.size(); // invokers数量\n        int leastActive = -1; // 所有invokers中最小的活跃数\n        int leastCount = 0; // invokers当中有多少个invoker的活跃数是leastActive\n        int[] leastIndexs = new int[length]; // 这些活跃数等于leastActive的下标\n        int totalWeight = 0; // 总权重\n        int firstWeight = 0; // Initial value, used for comparision\n        boolean sameWeight = true; // 所有的权重都相等？\n        for (int i = 0; i &lt; length; i++) {\n            Invoker&lt;T&gt; invoker = invokers.get(i);\n            int active = RpcStatus.getStatus(invoker.getUrl(), invocation.getMethodName()).getActive(); // 活跃数\n            int weight = invoker.getUrl().getMethodParameter(invocation.getMethodName(), Constants.WEIGHT_KEY, Constants.DEFAULT_WEIGHT); // 权重\n            if (leastActive == -1 || active &lt; leastActive) { // 如果活跃数比之前的都小\n                leastActive = active; // 记录最小活跃值\n                leastCount = 1; // 重新计算数量\n                leastIndexs[0] = i; // 重置\n                totalWeight = weight; // 重置总权重\n                firstWeight = weight; // 记录为firstWeight\n                sameWeight = true; // 重置，所有的权重相等\n            } else if (active == leastActive) { // 如果和之前的最小活跃值相等\n                leastIndexs[leastCount++] = i; //记录下标\n                totalWeight += weight; // 总权重相加\n                // 在活跃值相等的情况下权重是不是相等\n                if (sameWeight &amp;&amp; i &gt; 0\n                        &amp;&amp; weight != firstWeight) {\n                    sameWeight = false;\n                }\n            }\n        }\n        // assert(leastCount &gt; 0)\n        if (leastCount == 1) {\n            // 如果最小活跃值的Invoker只有一个，则直接返回\n            return invokers.get(leastIndexs[0]);\n        }\n        if (!sameWeight &amp;&amp; totalWeight &gt; 0) {\n            // 如果总权重值大于0并且各个Invoker的权重不相等，则随机取一个，可以看到这里的过程和random的过程是很像的\n            int offsetWeight = random.nextInt(totalWeight);\n            for (int i = 0; i &lt; leastCount; i++) {\n                int leastIndex = leastIndexs[i];\n                offsetWeight -= getWeight(invokers.get(leastIndex), invocation);\n                if (offsetWeight &lt;= 0)\n                    return invokers.get(leastIndex);\n            }\n        }\n        // 如果所有Invoker的权重相等，或者总权重等于0.则随机选取一个\n        return invokers.get(leastIndexs[random.nextInt(leastCount)]);\n    }\n</code></pre>\n<h5 id=\"在最小活跃数的轮询算法中有一个很重要的概念就是活跃数，dubbo的活跃数是如何来的呢。\"><a href=\"#在最小活跃数的轮询算法中有一个很重要的概念就是活跃数，dubbo的活跃数是如何来的呢。\" class=\"headerlink\" title=\"在最小活跃数的轮询算法中有一个很重要的概念就是活跃数，dubbo的活跃数是如何来的呢。\"></a>在<strong>最小活跃数</strong>的轮询算法中有一个很重要的概念就是活跃数，dubbo的活跃数是如何来的呢。</h5><h3 id=\"活跃数的变化\"><a href=\"#活跃数的变化\" class=\"headerlink\" title=\"活跃数的变化\"></a>活跃数的变化</h3><h5 id=\"活跃数的修改发生在com-alibaba-dubbo-rpc-filter-ActiveLimitFilter中。若未配置actives属性，则每进行一次调用前该invoker关联的活跃数加1，调用结束后活跃数减1。\"><a href=\"#活跃数的修改发生在com-alibaba-dubbo-rpc-filter-ActiveLimitFilter中。若未配置actives属性，则每进行一次调用前该invoker关联的活跃数加1，调用结束后活跃数减1。\" class=\"headerlink\" title=\"活跃数的修改发生在com.alibaba.dubbo.rpc.filter.ActiveLimitFilter中。若未配置actives属性，则每进行一次调用前该invoker关联的活跃数加1，调用结束后活跃数减1。\"></a>活跃数的修改发生在com.alibaba.dubbo.rpc.filter.ActiveLimitFilter中。若未配置actives属性，则每进行一次调用前该invoker关联的活跃数加1，调用结束后活跃数减1。</h5><h5 id=\"beginCount对活跃数加1，endCount对活跃数减1。\"><a href=\"#beginCount对活跃数加1，endCount对活跃数减1。\" class=\"headerlink\" title=\"beginCount对活跃数加1，endCount对活跃数减1。\"></a>beginCount对活跃数加1，endCount对活跃数减1。</h5><pre><code class=\"lang-java\">long begin = System.currentTimeMillis();\n            RpcStatus.beginCount(url, methodName);\n            try {\n                Result result = invoker.invoke(invocation);\n                RpcStatus.endCount(url, methodName, System.currentTimeMillis() - begin, true);\n                return result;\n            } catch (RuntimeException t) {\n                RpcStatus.endCount(url, methodName, System.currentTimeMillis() - begin, false);\n                throw t;\n            }\n</code></pre>\n<h5 id=\"如果使用LeastActive负载均衡，则需要启用ActiveLimitFilter，这样活跃数才会变化。\"><a href=\"#如果使用LeastActive负载均衡，则需要启用ActiveLimitFilter，这样活跃数才会变化。\" class=\"headerlink\" title=\"如果使用LeastActive负载均衡，则需要启用ActiveLimitFilter，这样活跃数才会变化。\"></a>如果使用LeastActive负载均衡，则需要启用ActiveLimitFilter，这样活跃数才会变化。</h5><h5 id=\"因此需要配置filter，filter-为-“activelimit”。\"><a href=\"#因此需要配置filter，filter-为-“activelimit”。\" class=\"headerlink\" title=\"因此需要配置filter，filter 为 “activelimit”。\"></a>因此需要配置filter，filter 为 “activelimit”。</h5><pre><code class=\"lang-xml\">&lt;dubbo:service interface=&quot;service.DemoService&quot; ref = &quot;demoService&quot; loadbalance=&quot;leastactive&quot; filter=&quot;activelimit&quot;/&gt;\n</code></pre>\n<h5 id=\"有了活跃数之后，dubbo所做的操作就是找到最小的活跃数的invokers。找到后再按照权重去随机。可以看到代码中的totalWeight指的是相同最小活跃数的权重总和。所以这个一个二维的算法，基于活跃数和权重。\"><a href=\"#有了活跃数之后，dubbo所做的操作就是找到最小的活跃数的invokers。找到后再按照权重去随机。可以看到代码中的totalWeight指的是相同最小活跃数的权重总和。所以这个一个二维的算法，基于活跃数和权重。\" class=\"headerlink\" title=\"有了活跃数之后，dubbo所做的操作就是找到最小的活跃数的invokers。找到后再按照权重去随机。可以看到代码中的totalWeight指的是相同最小活跃数的权重总和。所以这个一个二维的算法，基于活跃数和权重。\"></a>有了活跃数之后，dubbo所做的操作就是找到最小的活跃数的invokers。找到后再按照权重去随机。可以看到代码中的<code>totalWeight</code>指的是相同最小活跃数的权重总和。所以这个一个二维的算法，基于活跃数和权重。</h5><h2 id=\"consistenthash-一致性hash\"><a href=\"#consistenthash-一致性hash\" class=\"headerlink\" title=\"consistenthash 一致性hash\"></a>consistenthash 一致性hash</h2><pre><code class=\"lang-java\">protected &lt;T&gt; Invoker&lt;T&gt; doSelect(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) {\n        //按照ServiceKey和方法名拼成String key\n        String key = invokers.get(0).getUrl().getServiceKey() + &quot;.&quot; + invocation.getMethodName();\n        //获取invokers的hashCode\n        int identityHashCode = System.identityHashCode(invokers);\n        //以调用方法名为key,获取一致性hash选择器\n        ConsistentHashSelector&lt;T&gt; selector = (ConsistentHashSelector&lt;T&gt;) selectors.get(key);\n        // 若不存在则创建新的选择器\n        if (selector == null || selector.identityHashCode != identityHashCode) {\n            selectors.put(key, new ConsistentHashSelector&lt;T&gt;(invokers, invocation.getMethodName(), identityHashCode));\n            selector = (ConsistentHashSelector&lt;T&gt;) selectors.get(key);\n        }\n        // 选择结点\n        return selector.select(invocation);\n    }\n</code></pre>\n<h5 id=\"可以看到doSelect中的方法只是找到或者创建选择器，真正的选择过程在ConsistentHashSelector中\"><a href=\"#可以看到doSelect中的方法只是找到或者创建选择器，真正的选择过程在ConsistentHashSelector中\" class=\"headerlink\" title=\"可以看到doSelect中的方法只是找到或者创建选择器，真正的选择过程在ConsistentHashSelector中\"></a>可以看到doSelect中的方法只是找到或者创建选择器，真正的选择过程在ConsistentHashSelector中</h5><pre><code class=\"lang-java\">private static final class ConsistentHashSelector&lt;T&gt; {\n\n        private final TreeMap&lt;Long, Invoker&lt;T&gt;&gt; virtualInvokers; // 虚拟结点\n\n        private final int                       replicaNumber;   // 副本数\n\n        private final int                       identityHashCode;// hashCode\n\n        private final int[]                     argumentIndex;   // 参数索引数组\n\n        public ConsistentHashSelector(List&lt;Invoker&lt;T&gt;&gt; invokers, String methodName, int identityHashCode) {\n            // 创建TreeMap 来保存结点\n            this.virtualInvokers = new TreeMap&lt;Long, Invoker&lt;T&gt;&gt;();\n            // 生成调用结点HashCode\n            this.identityHashCode = System.identityHashCode(invokers);\n            // 获取Url\n            URL url = invokers.get(0).getUrl();\n            // 获取所配置的结点数，如没有设置则使用默认值160\n            this.replicaNumber = url.getMethodParameter(methodName, &quot;hash.nodes&quot;, 160);\n            // 获取需要进行hash的参数数组索引，默认对第一个参数进行hash\n            String[] index = Constants.COMMA_SPLIT_PATTERN.split(url.getMethodParameter(methodName, &quot;hash.arguments&quot;, &quot;0&quot;));\n            argumentIndex = new int[index.length];\n            for (int i = 0; i &lt; index.length; i ++) {\n                argumentIndex[i] = Integer.parseInt(index[i]);\n            }\n            // 创建虚拟结点\n            // 对每个invoker生成replicaNumber个虚拟结点，并存放于TreeMap中\n            for (Invoker&lt;T&gt; invoker : invokers) {\n\n                for (int i = 0; i &lt; replicaNumber / 4; i++) {\n                    // 根据md5算法为每4个结点生成一个消息摘要，摘要长为16字节128位。\n                    byte[] digest = md5(invoker.getUrl().toFullString() + i);\n                    // 随后将128位分为4部分，0-31,32-63,64-95,95-128，并生成4个32位数，存于long中，long的高32位都为0\n                    // 并作为虚拟结点的key。\n                    for (int h = 0; h &lt; 4; h++) {\n                        long m = hash(digest, h);\n                        virtualInvokers.put(m, invoker);\n                    }\n                }\n            }\n        }\n\n        public int getIdentityHashCode() {\n            return identityHashCode;\n        }\n\n        // 选择结点\n        public Invoker&lt;T&gt; select(Invocation invocation) {\n            // 根据调用参数来生成Key\n            String key = toKey(invocation.getArguments());\n            // 根据这个参数生成消息摘要\n            byte[] digest = md5(key);\n            //调用hash(digest, 0)，将消息摘要转换为hashCode，这里仅取0-31位来生成HashCode\n            //调用sekectForKey方法选择结点。\n            Invoker&lt;T&gt; invoker = sekectForKey(hash(digest, 0));\n            return invoker;\n        }\n\n        private String toKey(Object[] args) {\n            StringBuilder buf = new StringBuilder();\n            // 由于hash.arguments没有进行配置，因为只取方法的第1个参数作为key\n            for (int i : argumentIndex) {\n                if (i &gt;= 0 &amp;&amp; i &lt; args.length) {\n                    buf.append(args[i]);\n                }\n            }\n            return buf.toString();\n        }\n\n        //根据hashCode选择结点\n        private Invoker&lt;T&gt; sekectForKey(long hash) {\n            Invoker&lt;T&gt; invoker;\n            Long key = hash;\n            // 若HashCode直接与某个虚拟结点的key一样，则直接返回该结点\n            if (!virtualInvokers.containsKey(key)) {\n                // 若不一致，找到一个最小上届的key所对应的结点。\n                SortedMap&lt;Long, Invoker&lt;T&gt;&gt; tailMap = virtualInvokers.tailMap(key);\n                // 若存在则返回，例如hashCode落在图中[1]的位置\n                // 若不存在，例如hashCode落在[2]的位置，那么选择treeMap中第一个结点\n                // 使用TreeMap的firstKey方法，来选择最小上界。\n                if (tailMap.isEmpty()) {\n                    key = virtualInvokers.firstKey();\n                } else {\n\n                    key = tailMap.firstKey();\n                }\n            }\n            invoker = virtualInvokers.get(key);\n            return invoker;\n        }\n\n        private long hash(byte[] digest, int number) {\n            return (((long) (digest[3 + number * 4] &amp; 0xFF) &lt;&lt; 24)\n                    | ((long) (digest[2 + number * 4] &amp; 0xFF) &lt;&lt; 16)\n                    | ((long) (digest[1 + number * 4] &amp; 0xFF) &lt;&lt; 8)\n                    | (digest[0 + number * 4] &amp; 0xFF))\n                    &amp; 0xFFFFFFFFL;\n        }\n\n        private byte[] md5(String value) {\n            MessageDigest md5;\n            try {\n                md5 = MessageDigest.getInstance(&quot;MD5&quot;);\n            } catch (NoSuchAlgorithmException e) {\n                throw new IllegalStateException(e.getMessage(), e);\n            }\n            md5.reset();\n            byte[] bytes = null;\n            try {\n                bytes = value.getBytes(&quot;UTF-8&quot;);\n            } catch (UnsupportedEncodingException e) {\n                throw new IllegalStateException(e.getMessage(), e);\n            }\n            md5.update(bytes);\n            return md5.digest();\n        }\n\n    }\n</code></pre>\n<h5 id=\"在进行选择时候若HashCode直接与某个虚拟结点的key一样，则直接返回该结点，例如hashCode落在某个结点上-圆圈所表示-。若不在，找到一个最小上届的key所对应的结点。例如进行选择时的key落在图中1所标注的位置。由于利用TreeMap存储，key所落在的位置可能无法找到最小上界，例如图中2所标注的位置。那么需要返回TreeMap中的最小值（构成逻辑环状结构，找不到，则返回最开头的结点）。\"><a href=\"#在进行选择时候若HashCode直接与某个虚拟结点的key一样，则直接返回该结点，例如hashCode落在某个结点上-圆圈所表示-。若不在，找到一个最小上届的key所对应的结点。例如进行选择时的key落在图中1所标注的位置。由于利用TreeMap存储，key所落在的位置可能无法找到最小上界，例如图中2所标注的位置。那么需要返回TreeMap中的最小值（构成逻辑环状结构，找不到，则返回最开头的结点）。\" class=\"headerlink\" title=\"在进行选择时候若HashCode直接与某个虚拟结点的key一样，则直接返回该结点，例如hashCode落在某个结点上(圆圈所表示)。若不在，找到一个最小上届的key所对应的结点。例如进行选择时的key落在图中1所标注的位置。由于利用TreeMap存储，key所落在的位置可能无法找到最小上界，例如图中2所标注的位置。那么需要返回TreeMap中的最小值（构成逻辑环状结构，找不到，则返回最开头的结点）。\"></a>在进行选择时候若HashCode直接与某个虚拟结点的key一样，则直接返回该结点，例如hashCode落在某个结点上(圆圈所表示)。若不在，找到一个最小上届的key所对应的结点。例如进行选择时的key落在图中1所标注的位置。由于利用TreeMap存储，key所落在的位置可能无法找到最小上界，例如图中2所标注的位置。那么需要返回TreeMap中的最小值（构成逻辑环状结构，找不到，则返回最开头的结点）。</h5><p><img src=\"/img/note/dubbo/dubbo3.png\" alt=\"\"></p>\n<h5 id=\"以上为dubbo的一致性hash算法实现，其中涉及到两个主要的配置参数为hash-arguments-与hash-nodes。\"><a href=\"#以上为dubbo的一致性hash算法实现，其中涉及到两个主要的配置参数为hash-arguments-与hash-nodes。\" class=\"headerlink\" title=\"以上为dubbo的一致性hash算法实现，其中涉及到两个主要的配置参数为hash.arguments 与hash.nodes。\"></a>以上为dubbo的一致性hash算法实现，其中涉及到两个主要的配置参数为hash.arguments 与hash.nodes。</h5><h5 id=\"hash-arguments：-当进行调用时候根据调用方法的哪几个参数生成key，并根据key来通过一致性hash算法来选择调用结点。例如调用方法invoke-String-s1-String-s2-若hash-arguments为1-默认值-，则仅取invoke的参数1（s1）来生成hashCode。\"><a href=\"#hash-arguments：-当进行调用时候根据调用方法的哪几个参数生成key，并根据key来通过一致性hash算法来选择调用结点。例如调用方法invoke-String-s1-String-s2-若hash-arguments为1-默认值-，则仅取invoke的参数1（s1）来生成hashCode。\" class=\"headerlink\" title=\"hash.arguments： 当进行调用时候根据调用方法的哪几个参数生成key，并根据key来通过一致性hash算法来选择调用结点。例如调用方法invoke(String s1,String s2); 若hash.arguments为1(默认值)，则仅取invoke的参数1（s1）来生成hashCode。\"></a><strong>hash.arguments</strong>： 当进行调用时候根据调用方法的哪几个参数生成key，并根据key来通过一致性hash算法来选择调用结点。例如调用方法invoke(String s1,String s2); 若hash.arguments为1(默认值)，则仅取invoke的参数1（s1）来生成hashCode。</h5><h5 id=\"hash-nodes：-为结点的副本数。\"><a href=\"#hash-nodes：-为结点的副本数。\" class=\"headerlink\" title=\"hash.nodes： 为结点的副本数。\"></a><strong>hash.nodes</strong>： 为结点的副本数。</h5><pre><code class=\"lang-xml\">缺省只对第一个参数Hash，如果要修改，请配置\n&lt;dubbo:parameter key=&quot;hash.arguments&quot; value=&quot;0,1&quot; /&gt;\n\n缺省用160份虚拟节点，如果要修改，请配置\n&lt;dubbo:parameter key=&quot;hash.nodes&quot; value=&quot;320&quot; /&gt;\n</code></pre>\n","site":{"data":{}},"excerpt":"<h3 id=\"扩展说明\"><a href=\"#扩展说明\" class=\"headerlink\" title=\"扩展说明\"></a>扩展说明</h3><h5 id=\"从多个服务提者方中选择一个进行调用\"><a href=\"#从多个服务提者方中选择一个进行调用\" class=\"headerlink\" title=\"从多个服务提者方中选择一个进行调用\"></a>从多个服务提者方中选择一个进行调用</h5><h3 id=\"扩展接口\"><a href=\"#扩展接口\" class=\"headerlink\" title=\"扩展接口\"></a>扩展接口</h3><h5 id=\"com-alibaba-dubbo-rpc-cluster-LoadBalance\"><a href=\"#com-alibaba-dubbo-rpc-cluster-LoadBalance\" class=\"headerlink\" title=\"com.alibaba.dubbo.rpc.cluster.LoadBalance\"></a><code>com.alibaba.dubbo.rpc.cluster.LoadBalance</code></h5><h3 id=\"使用配置\"><a href=\"#使用配置\" class=\"headerlink\" title=\"使用配置\"></a>使用配置</h3><pre><code class=\"lang-xml\">&lt;dubbo:provider loadbalance=&quot;&quot; /&gt;\n</code></pre>","more":"<h3 id=\"目前已知扩展：\"><a href=\"#目前已知扩展：\" class=\"headerlink\" title=\"目前已知扩展：\"></a>目前已知扩展：</h3><ul>\n<li>random=com.alibaba.dubbo.rpc.cluster.loadbalance.RandomLoadBalance</li>\n<li>roundrobin=com.alibaba.dubbo.rpc.cluster.loadbalance.RoundRobinLoadBalance</li>\n<li>leastactive=com.alibaba.dubbo.rpc.cluster.loadbalance.LeastActiveLoadBalance</li>\n<li>consistenthash=com.alibaba.dubbo.rpc.cluster.loadbalance.ConsistentHashLoadBalance</li>\n</ul>\n<h3 id=\"包结构：\"><a href=\"#包结构：\" class=\"headerlink\" title=\"包结构：\"></a>包结构：</h3><p><img src=\"/img/note/dubbo/dubbo2.png\" alt=\"\"></p>\n<h3 id=\"LoadBalance\"><a href=\"#LoadBalance\" class=\"headerlink\" title=\"LoadBalance\"></a>LoadBalance</h3><pre><code class=\"lang-java\">@SPI(RandomLoadBalance.NAME) //默认为random\npublic interface LoadBalance {\n\n    /**\n     * 从list当中选择一个invoker\n     *\n     * @param invokers   invokers.\n     * @param url        refer url\n     * @param invocation invocation.\n     * @return selected invoker.\n     */\n    @Adaptive(&quot;loadbalance&quot;)\n    &lt;T&gt; Invoker&lt;T&gt; select(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) throws RpcException;\n}\n</code></pre>\n<h5 id=\"只有一个接口，很简单，提供invokers集合，返回其中一个\"><a href=\"#只有一个接口，很简单，提供invokers集合，返回其中一个\" class=\"headerlink\" title=\"只有一个接口，很简单，提供invokers集合，返回其中一个\"></a>只有一个接口，很简单，提供invokers集合，返回其中一个</h5><h3 id=\"AbstractLoadBalance\"><a href=\"#AbstractLoadBalance\" class=\"headerlink\" title=\"AbstractLoadBalance\"></a>AbstractLoadBalance</h3><pre><code class=\"lang-java\">public abstract class AbstractLoadBalance implements LoadBalance {\n\n    static int calculateWarmupWeight(int uptime, int warmup, int weight) {\n        int ww = (int) ((float) uptime / ((float) warmup / (float) weight));\n        return ww &lt; 1 ? 1 : (ww &gt; weight ? weight : ww);\n    }\n\n    public &lt;T&gt; Invoker&lt;T&gt; select(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) {\n        if (invokers == null || invokers.isEmpty())\n            return null;\n        if (invokers.size() == 1)\n            return invokers.get(0);\n        return doSelect(invokers, url, invocation);\n    }\n\n    protected abstract &lt;T&gt; Invoker&lt;T&gt; doSelect(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation);\n\n    protected int getWeight(Invoker&lt;?&gt; invoker, Invocation invocation) {\n        int weight = invoker.getUrl().getMethodParameter(invocation.getMethodName(), Constants.WEIGHT_KEY, Constants.DEFAULT_WEIGHT);\n        if (weight &gt; 0) {\n            long timestamp = invoker.getUrl().getParameter(Constants.REMOTE_TIMESTAMP_KEY, 0L);\n            if (timestamp &gt; 0L) {\n                int uptime = (int) (System.currentTimeMillis() - timestamp);\n                int warmup = invoker.getUrl().getParameter(Constants.WARMUP_KEY, Constants.DEFAULT_WARMUP);\n                if (uptime &gt; 0 &amp;&amp; uptime &lt; warmup) {\n                    weight = calculateWarmupWeight(uptime, warmup, weight);\n                }\n            }\n        }\n        return weight;\n    }\n\n}\n</code></pre>\n<h5 id=\"抽象类AbstractLoadBalance实现了接口LoadBalance的select方法。主要是做了一些边界值的判断，正在的操作在抽象方法doSelect中。\"><a href=\"#抽象类AbstractLoadBalance实现了接口LoadBalance的select方法。主要是做了一些边界值的判断，正在的操作在抽象方法doSelect中。\" class=\"headerlink\" title=\"抽象类AbstractLoadBalance实现了接口LoadBalance的select方法。主要是做了一些边界值的判断，正在的操作在抽象方法doSelect中。\"></a>抽象类<strong>AbstractLoadBalance</strong>实现了接口<strong>LoadBalance</strong>的select方法。主要是做了一些边界值的判断，正在的操作在抽象方法doSelect中。</h5><h5 id=\"getWeight方法将从Invoker的url中获取weight参数。默认为100\"><a href=\"#getWeight方法将从Invoker的url中获取weight参数。默认为100\" class=\"headerlink\" title=\"getWeight方法将从Invoker的url中获取weight参数。默认为100\"></a><strong>getWeight</strong>方法将从Invoker的url中获取<strong>weight</strong>参数。默认为100</h5><h2 id=\"random-随机\"><a href=\"#random-随机\" class=\"headerlink\" title=\"random 随机\"></a>random 随机</h2><h5 id=\"dubbo默认的负载方式，看下doSelect方法\"><a href=\"#dubbo默认的负载方式，看下doSelect方法\" class=\"headerlink\" title=\"dubbo默认的负载方式，看下doSelect方法\"></a>dubbo默认的负载方式，看下<strong>doSelect</strong>方法</h5><pre><code class=\"lang-java\">protected &lt;T&gt; Invoker&lt;T&gt; doSelect(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) {\n        int length = invokers.size(); // invokers数量\n        int totalWeight = 0; // 总权重\n        boolean sameWeight = true; // 是不是所有的权重都是一样的\n        for (int i = 0; i &lt; length; i++) {\n            int weight = getWeight(invokers.get(i), invocation);\n            totalWeight += weight; // 相加\n            if (sameWeight &amp;&amp; i &gt; 0\n                    &amp;&amp; weight != getWeight(invokers.get(i - 1), invocation)) {\n                sameWeight = false;\n            }\n        }\n        if (totalWeight &gt; 0 &amp;&amp; !sameWeight) {\n            //如果权重不是都相等，则用随机数生成\n            int offset = random.nextInt(totalWeight);\n            // 返回一个在包含该随机值的invoker\n            for (int i = 0; i &lt; length; i++) {\n                offset -= getWeight(invokers.get(i), invocation);\n                if (offset &lt; 0) {\n                    return invokers.get(i);\n                }\n            }\n        }\n        //如果权重都相等或者总和为0，则随机一个\n        return invokers.get(random.nextInt(length));\n    }\n</code></pre>\n<h5 id=\"可以看到，dubbo的随机负载均衡策略是包含了权重的概念的。所以也不是完全随机。\"><a href=\"#可以看到，dubbo的随机负载均衡策略是包含了权重的概念的。所以也不是完全随机。\" class=\"headerlink\" title=\"可以看到，dubbo的随机负载均衡策略是包含了权重的概念的。所以也不是完全随机。\"></a>可以看到，dubbo的随机负载均衡策略是包含了权重的概念的。所以也不是完全随机。</h5><h2 id=\"roundrobin-轮询\"><a href=\"#roundrobin-轮询\" class=\"headerlink\" title=\"roundrobin 轮询\"></a>roundrobin 轮询</h2><pre><code class=\"lang-java\">protected &lt;T&gt; Invoker&lt;T&gt; doSelect(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) {\n        //通过serviceKey和方法名构建key\n        String key = invokers.get(0).getUrl().getServiceKey() + &quot;.&quot; + invocation.getMethodName();\n        int length = invokers.size(); // invokers数量\n        int maxWeight = 0; // 最大的 权重 值\n        int minWeight = Integer.MAX_VALUE; // 最小的 权重 值\n        final LinkedHashMap&lt;Invoker&lt;T&gt;, IntegerWrapper&gt; invokerToWeightMap = new LinkedHashMap&lt;Invoker&lt;T&gt;, IntegerWrapper&gt;();//有序map\n        int weightSum = 0; //权重 总值\n        for (int i = 0; i &lt; length; i++) {\n            int weight = getWeight(invokers.get(i), invocation); //获取单个invoker的权重\n            maxWeight = Math.max(maxWeight, weight); // 是不是最大的\n            minWeight = Math.min(minWeight, weight); // 是不是最小的\n            if (weight &gt; 0) {\n                invokerToWeightMap.put(invokers.get(i), new IntegerWrapper(weight));\n                weightSum += weight;\n            }\n        }\n        AtomicPositiveInteger sequence = sequences.get(key);\n        if (sequence == null) {\n            sequences.putIfAbsent(key, new AtomicPositiveInteger());\n            sequence = sequences.get(key);\n        }\n        //记录该接口的调用次数\n        int currentSequence = sequence.getAndIncrement();\n        if (maxWeight &gt; 0 &amp;&amp; minWeight &lt; maxWeight) {\n            int mod = currentSequence % weightSum;\n            for (int i = 0; i &lt; maxWeight; i++) {\n                for (Map.Entry&lt;Invoker&lt;T&gt;, IntegerWrapper&gt; each : invokerToWeightMap.entrySet()) {\n                    final Invoker&lt;T&gt; k = each.getKey();\n                    final IntegerWrapper v = each.getValue();\n                    if (mod == 0 &amp;&amp; v.getValue() &gt; 0) {\n                        return k;\n                    }\n                    if (v.getValue() &gt; 0) {\n                        v.decrement();\n                        mod--;\n                    }\n                }\n            }\n        }\n        // 如果权重都一样。或者都小于0。则按照调用次数轮询\n        return invokers.get(currentSequence % length);\n    }\n</code></pre>\n<h5 id=\"可以看到dubbo的轮询不是完全按照次数轮询的。而是按照公约后的权重设置轮询比率，即权重轮询算法-Weighted-Round-Robin-，它是基于轮询算法改进而来的。具体算法原理可以再网上搜索权重轮询调度算法或者见博客dubbo-动态代理实现。\"><a href=\"#可以看到dubbo的轮询不是完全按照次数轮询的。而是按照公约后的权重设置轮询比率，即权重轮询算法-Weighted-Round-Robin-，它是基于轮询算法改进而来的。具体算法原理可以再网上搜索权重轮询调度算法或者见博客dubbo-动态代理实现。\" class=\"headerlink\" title=\"可以看到dubbo的轮询不是完全按照次数轮询的。而是按照公约后的权重设置轮询比率，即权重轮询算法(Weighted Round-Robin) ，它是基于轮询算法改进而来的。具体算法原理可以再网上搜索权重轮询调度算法或者见博客dubbo-动态代理实现。\"></a>可以看到dubbo的轮询不是完全按照次数轮询的。而是按照公约后的权重设置轮询比率，即权重轮询算法(Weighted Round-Robin) ，它是基于轮询算法改进而来的。具体算法原理可以再网上搜索<code>权重轮询调度算法</code>或者见博客<a href=\"http://localhost:4000/arithmetic/roundrobinWeight/\" target=\"_blank\" rel=\"external\">dubbo-动态代理实现</a>。</h5><h2 id=\"leastactive-最小活跃数\"><a href=\"#leastactive-最小活跃数\" class=\"headerlink\" title=\"leastactive 最小活跃数\"></a>leastactive 最小活跃数</h2><pre><code class=\"lang-java\">protected &lt;T&gt; Invoker&lt;T&gt; doSelect(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) {\n        int length = invokers.size(); // invokers数量\n        int leastActive = -1; // 所有invokers中最小的活跃数\n        int leastCount = 0; // invokers当中有多少个invoker的活跃数是leastActive\n        int[] leastIndexs = new int[length]; // 这些活跃数等于leastActive的下标\n        int totalWeight = 0; // 总权重\n        int firstWeight = 0; // Initial value, used for comparision\n        boolean sameWeight = true; // 所有的权重都相等？\n        for (int i = 0; i &lt; length; i++) {\n            Invoker&lt;T&gt; invoker = invokers.get(i);\n            int active = RpcStatus.getStatus(invoker.getUrl(), invocation.getMethodName()).getActive(); // 活跃数\n            int weight = invoker.getUrl().getMethodParameter(invocation.getMethodName(), Constants.WEIGHT_KEY, Constants.DEFAULT_WEIGHT); // 权重\n            if (leastActive == -1 || active &lt; leastActive) { // 如果活跃数比之前的都小\n                leastActive = active; // 记录最小活跃值\n                leastCount = 1; // 重新计算数量\n                leastIndexs[0] = i; // 重置\n                totalWeight = weight; // 重置总权重\n                firstWeight = weight; // 记录为firstWeight\n                sameWeight = true; // 重置，所有的权重相等\n            } else if (active == leastActive) { // 如果和之前的最小活跃值相等\n                leastIndexs[leastCount++] = i; //记录下标\n                totalWeight += weight; // 总权重相加\n                // 在活跃值相等的情况下权重是不是相等\n                if (sameWeight &amp;&amp; i &gt; 0\n                        &amp;&amp; weight != firstWeight) {\n                    sameWeight = false;\n                }\n            }\n        }\n        // assert(leastCount &gt; 0)\n        if (leastCount == 1) {\n            // 如果最小活跃值的Invoker只有一个，则直接返回\n            return invokers.get(leastIndexs[0]);\n        }\n        if (!sameWeight &amp;&amp; totalWeight &gt; 0) {\n            // 如果总权重值大于0并且各个Invoker的权重不相等，则随机取一个，可以看到这里的过程和random的过程是很像的\n            int offsetWeight = random.nextInt(totalWeight);\n            for (int i = 0; i &lt; leastCount; i++) {\n                int leastIndex = leastIndexs[i];\n                offsetWeight -= getWeight(invokers.get(leastIndex), invocation);\n                if (offsetWeight &lt;= 0)\n                    return invokers.get(leastIndex);\n            }\n        }\n        // 如果所有Invoker的权重相等，或者总权重等于0.则随机选取一个\n        return invokers.get(leastIndexs[random.nextInt(leastCount)]);\n    }\n</code></pre>\n<h5 id=\"在最小活跃数的轮询算法中有一个很重要的概念就是活跃数，dubbo的活跃数是如何来的呢。\"><a href=\"#在最小活跃数的轮询算法中有一个很重要的概念就是活跃数，dubbo的活跃数是如何来的呢。\" class=\"headerlink\" title=\"在最小活跃数的轮询算法中有一个很重要的概念就是活跃数，dubbo的活跃数是如何来的呢。\"></a>在<strong>最小活跃数</strong>的轮询算法中有一个很重要的概念就是活跃数，dubbo的活跃数是如何来的呢。</h5><h3 id=\"活跃数的变化\"><a href=\"#活跃数的变化\" class=\"headerlink\" title=\"活跃数的变化\"></a>活跃数的变化</h3><h5 id=\"活跃数的修改发生在com-alibaba-dubbo-rpc-filter-ActiveLimitFilter中。若未配置actives属性，则每进行一次调用前该invoker关联的活跃数加1，调用结束后活跃数减1。\"><a href=\"#活跃数的修改发生在com-alibaba-dubbo-rpc-filter-ActiveLimitFilter中。若未配置actives属性，则每进行一次调用前该invoker关联的活跃数加1，调用结束后活跃数减1。\" class=\"headerlink\" title=\"活跃数的修改发生在com.alibaba.dubbo.rpc.filter.ActiveLimitFilter中。若未配置actives属性，则每进行一次调用前该invoker关联的活跃数加1，调用结束后活跃数减1。\"></a>活跃数的修改发生在com.alibaba.dubbo.rpc.filter.ActiveLimitFilter中。若未配置actives属性，则每进行一次调用前该invoker关联的活跃数加1，调用结束后活跃数减1。</h5><h5 id=\"beginCount对活跃数加1，endCount对活跃数减1。\"><a href=\"#beginCount对活跃数加1，endCount对活跃数减1。\" class=\"headerlink\" title=\"beginCount对活跃数加1，endCount对活跃数减1。\"></a>beginCount对活跃数加1，endCount对活跃数减1。</h5><pre><code class=\"lang-java\">long begin = System.currentTimeMillis();\n            RpcStatus.beginCount(url, methodName);\n            try {\n                Result result = invoker.invoke(invocation);\n                RpcStatus.endCount(url, methodName, System.currentTimeMillis() - begin, true);\n                return result;\n            } catch (RuntimeException t) {\n                RpcStatus.endCount(url, methodName, System.currentTimeMillis() - begin, false);\n                throw t;\n            }\n</code></pre>\n<h5 id=\"如果使用LeastActive负载均衡，则需要启用ActiveLimitFilter，这样活跃数才会变化。\"><a href=\"#如果使用LeastActive负载均衡，则需要启用ActiveLimitFilter，这样活跃数才会变化。\" class=\"headerlink\" title=\"如果使用LeastActive负载均衡，则需要启用ActiveLimitFilter，这样活跃数才会变化。\"></a>如果使用LeastActive负载均衡，则需要启用ActiveLimitFilter，这样活跃数才会变化。</h5><h5 id=\"因此需要配置filter，filter-为-“activelimit”。\"><a href=\"#因此需要配置filter，filter-为-“activelimit”。\" class=\"headerlink\" title=\"因此需要配置filter，filter 为 “activelimit”。\"></a>因此需要配置filter，filter 为 “activelimit”。</h5><pre><code class=\"lang-xml\">&lt;dubbo:service interface=&quot;service.DemoService&quot; ref = &quot;demoService&quot; loadbalance=&quot;leastactive&quot; filter=&quot;activelimit&quot;/&gt;\n</code></pre>\n<h5 id=\"有了活跃数之后，dubbo所做的操作就是找到最小的活跃数的invokers。找到后再按照权重去随机。可以看到代码中的totalWeight指的是相同最小活跃数的权重总和。所以这个一个二维的算法，基于活跃数和权重。\"><a href=\"#有了活跃数之后，dubbo所做的操作就是找到最小的活跃数的invokers。找到后再按照权重去随机。可以看到代码中的totalWeight指的是相同最小活跃数的权重总和。所以这个一个二维的算法，基于活跃数和权重。\" class=\"headerlink\" title=\"有了活跃数之后，dubbo所做的操作就是找到最小的活跃数的invokers。找到后再按照权重去随机。可以看到代码中的totalWeight指的是相同最小活跃数的权重总和。所以这个一个二维的算法，基于活跃数和权重。\"></a>有了活跃数之后，dubbo所做的操作就是找到最小的活跃数的invokers。找到后再按照权重去随机。可以看到代码中的<code>totalWeight</code>指的是相同最小活跃数的权重总和。所以这个一个二维的算法，基于活跃数和权重。</h5><h2 id=\"consistenthash-一致性hash\"><a href=\"#consistenthash-一致性hash\" class=\"headerlink\" title=\"consistenthash 一致性hash\"></a>consistenthash 一致性hash</h2><pre><code class=\"lang-java\">protected &lt;T&gt; Invoker&lt;T&gt; doSelect(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) {\n        //按照ServiceKey和方法名拼成String key\n        String key = invokers.get(0).getUrl().getServiceKey() + &quot;.&quot; + invocation.getMethodName();\n        //获取invokers的hashCode\n        int identityHashCode = System.identityHashCode(invokers);\n        //以调用方法名为key,获取一致性hash选择器\n        ConsistentHashSelector&lt;T&gt; selector = (ConsistentHashSelector&lt;T&gt;) selectors.get(key);\n        // 若不存在则创建新的选择器\n        if (selector == null || selector.identityHashCode != identityHashCode) {\n            selectors.put(key, new ConsistentHashSelector&lt;T&gt;(invokers, invocation.getMethodName(), identityHashCode));\n            selector = (ConsistentHashSelector&lt;T&gt;) selectors.get(key);\n        }\n        // 选择结点\n        return selector.select(invocation);\n    }\n</code></pre>\n<h5 id=\"可以看到doSelect中的方法只是找到或者创建选择器，真正的选择过程在ConsistentHashSelector中\"><a href=\"#可以看到doSelect中的方法只是找到或者创建选择器，真正的选择过程在ConsistentHashSelector中\" class=\"headerlink\" title=\"可以看到doSelect中的方法只是找到或者创建选择器，真正的选择过程在ConsistentHashSelector中\"></a>可以看到doSelect中的方法只是找到或者创建选择器，真正的选择过程在ConsistentHashSelector中</h5><pre><code class=\"lang-java\">private static final class ConsistentHashSelector&lt;T&gt; {\n\n        private final TreeMap&lt;Long, Invoker&lt;T&gt;&gt; virtualInvokers; // 虚拟结点\n\n        private final int                       replicaNumber;   // 副本数\n\n        private final int                       identityHashCode;// hashCode\n\n        private final int[]                     argumentIndex;   // 参数索引数组\n\n        public ConsistentHashSelector(List&lt;Invoker&lt;T&gt;&gt; invokers, String methodName, int identityHashCode) {\n            // 创建TreeMap 来保存结点\n            this.virtualInvokers = new TreeMap&lt;Long, Invoker&lt;T&gt;&gt;();\n            // 生成调用结点HashCode\n            this.identityHashCode = System.identityHashCode(invokers);\n            // 获取Url\n            URL url = invokers.get(0).getUrl();\n            // 获取所配置的结点数，如没有设置则使用默认值160\n            this.replicaNumber = url.getMethodParameter(methodName, &quot;hash.nodes&quot;, 160);\n            // 获取需要进行hash的参数数组索引，默认对第一个参数进行hash\n            String[] index = Constants.COMMA_SPLIT_PATTERN.split(url.getMethodParameter(methodName, &quot;hash.arguments&quot;, &quot;0&quot;));\n            argumentIndex = new int[index.length];\n            for (int i = 0; i &lt; index.length; i ++) {\n                argumentIndex[i] = Integer.parseInt(index[i]);\n            }\n            // 创建虚拟结点\n            // 对每个invoker生成replicaNumber个虚拟结点，并存放于TreeMap中\n            for (Invoker&lt;T&gt; invoker : invokers) {\n\n                for (int i = 0; i &lt; replicaNumber / 4; i++) {\n                    // 根据md5算法为每4个结点生成一个消息摘要，摘要长为16字节128位。\n                    byte[] digest = md5(invoker.getUrl().toFullString() + i);\n                    // 随后将128位分为4部分，0-31,32-63,64-95,95-128，并生成4个32位数，存于long中，long的高32位都为0\n                    // 并作为虚拟结点的key。\n                    for (int h = 0; h &lt; 4; h++) {\n                        long m = hash(digest, h);\n                        virtualInvokers.put(m, invoker);\n                    }\n                }\n            }\n        }\n\n        public int getIdentityHashCode() {\n            return identityHashCode;\n        }\n\n        // 选择结点\n        public Invoker&lt;T&gt; select(Invocation invocation) {\n            // 根据调用参数来生成Key\n            String key = toKey(invocation.getArguments());\n            // 根据这个参数生成消息摘要\n            byte[] digest = md5(key);\n            //调用hash(digest, 0)，将消息摘要转换为hashCode，这里仅取0-31位来生成HashCode\n            //调用sekectForKey方法选择结点。\n            Invoker&lt;T&gt; invoker = sekectForKey(hash(digest, 0));\n            return invoker;\n        }\n\n        private String toKey(Object[] args) {\n            StringBuilder buf = new StringBuilder();\n            // 由于hash.arguments没有进行配置，因为只取方法的第1个参数作为key\n            for (int i : argumentIndex) {\n                if (i &gt;= 0 &amp;&amp; i &lt; args.length) {\n                    buf.append(args[i]);\n                }\n            }\n            return buf.toString();\n        }\n\n        //根据hashCode选择结点\n        private Invoker&lt;T&gt; sekectForKey(long hash) {\n            Invoker&lt;T&gt; invoker;\n            Long key = hash;\n            // 若HashCode直接与某个虚拟结点的key一样，则直接返回该结点\n            if (!virtualInvokers.containsKey(key)) {\n                // 若不一致，找到一个最小上届的key所对应的结点。\n                SortedMap&lt;Long, Invoker&lt;T&gt;&gt; tailMap = virtualInvokers.tailMap(key);\n                // 若存在则返回，例如hashCode落在图中[1]的位置\n                // 若不存在，例如hashCode落在[2]的位置，那么选择treeMap中第一个结点\n                // 使用TreeMap的firstKey方法，来选择最小上界。\n                if (tailMap.isEmpty()) {\n                    key = virtualInvokers.firstKey();\n                } else {\n\n                    key = tailMap.firstKey();\n                }\n            }\n            invoker = virtualInvokers.get(key);\n            return invoker;\n        }\n\n        private long hash(byte[] digest, int number) {\n            return (((long) (digest[3 + number * 4] &amp; 0xFF) &lt;&lt; 24)\n                    | ((long) (digest[2 + number * 4] &amp; 0xFF) &lt;&lt; 16)\n                    | ((long) (digest[1 + number * 4] &amp; 0xFF) &lt;&lt; 8)\n                    | (digest[0 + number * 4] &amp; 0xFF))\n                    &amp; 0xFFFFFFFFL;\n        }\n\n        private byte[] md5(String value) {\n            MessageDigest md5;\n            try {\n                md5 = MessageDigest.getInstance(&quot;MD5&quot;);\n            } catch (NoSuchAlgorithmException e) {\n                throw new IllegalStateException(e.getMessage(), e);\n            }\n            md5.reset();\n            byte[] bytes = null;\n            try {\n                bytes = value.getBytes(&quot;UTF-8&quot;);\n            } catch (UnsupportedEncodingException e) {\n                throw new IllegalStateException(e.getMessage(), e);\n            }\n            md5.update(bytes);\n            return md5.digest();\n        }\n\n    }\n</code></pre>\n<h5 id=\"在进行选择时候若HashCode直接与某个虚拟结点的key一样，则直接返回该结点，例如hashCode落在某个结点上-圆圈所表示-。若不在，找到一个最小上届的key所对应的结点。例如进行选择时的key落在图中1所标注的位置。由于利用TreeMap存储，key所落在的位置可能无法找到最小上界，例如图中2所标注的位置。那么需要返回TreeMap中的最小值（构成逻辑环状结构，找不到，则返回最开头的结点）。\"><a href=\"#在进行选择时候若HashCode直接与某个虚拟结点的key一样，则直接返回该结点，例如hashCode落在某个结点上-圆圈所表示-。若不在，找到一个最小上届的key所对应的结点。例如进行选择时的key落在图中1所标注的位置。由于利用TreeMap存储，key所落在的位置可能无法找到最小上界，例如图中2所标注的位置。那么需要返回TreeMap中的最小值（构成逻辑环状结构，找不到，则返回最开头的结点）。\" class=\"headerlink\" title=\"在进行选择时候若HashCode直接与某个虚拟结点的key一样，则直接返回该结点，例如hashCode落在某个结点上(圆圈所表示)。若不在，找到一个最小上届的key所对应的结点。例如进行选择时的key落在图中1所标注的位置。由于利用TreeMap存储，key所落在的位置可能无法找到最小上界，例如图中2所标注的位置。那么需要返回TreeMap中的最小值（构成逻辑环状结构，找不到，则返回最开头的结点）。\"></a>在进行选择时候若HashCode直接与某个虚拟结点的key一样，则直接返回该结点，例如hashCode落在某个结点上(圆圈所表示)。若不在，找到一个最小上届的key所对应的结点。例如进行选择时的key落在图中1所标注的位置。由于利用TreeMap存储，key所落在的位置可能无法找到最小上界，例如图中2所标注的位置。那么需要返回TreeMap中的最小值（构成逻辑环状结构，找不到，则返回最开头的结点）。</h5><p><img src=\"/img/note/dubbo/dubbo3.png\" alt=\"\"></p>\n<h5 id=\"以上为dubbo的一致性hash算法实现，其中涉及到两个主要的配置参数为hash-arguments-与hash-nodes。\"><a href=\"#以上为dubbo的一致性hash算法实现，其中涉及到两个主要的配置参数为hash-arguments-与hash-nodes。\" class=\"headerlink\" title=\"以上为dubbo的一致性hash算法实现，其中涉及到两个主要的配置参数为hash.arguments 与hash.nodes。\"></a>以上为dubbo的一致性hash算法实现，其中涉及到两个主要的配置参数为hash.arguments 与hash.nodes。</h5><h5 id=\"hash-arguments：-当进行调用时候根据调用方法的哪几个参数生成key，并根据key来通过一致性hash算法来选择调用结点。例如调用方法invoke-String-s1-String-s2-若hash-arguments为1-默认值-，则仅取invoke的参数1（s1）来生成hashCode。\"><a href=\"#hash-arguments：-当进行调用时候根据调用方法的哪几个参数生成key，并根据key来通过一致性hash算法来选择调用结点。例如调用方法invoke-String-s1-String-s2-若hash-arguments为1-默认值-，则仅取invoke的参数1（s1）来生成hashCode。\" class=\"headerlink\" title=\"hash.arguments： 当进行调用时候根据调用方法的哪几个参数生成key，并根据key来通过一致性hash算法来选择调用结点。例如调用方法invoke(String s1,String s2); 若hash.arguments为1(默认值)，则仅取invoke的参数1（s1）来生成hashCode。\"></a><strong>hash.arguments</strong>： 当进行调用时候根据调用方法的哪几个参数生成key，并根据key来通过一致性hash算法来选择调用结点。例如调用方法invoke(String s1,String s2); 若hash.arguments为1(默认值)，则仅取invoke的参数1（s1）来生成hashCode。</h5><h5 id=\"hash-nodes：-为结点的副本数。\"><a href=\"#hash-nodes：-为结点的副本数。\" class=\"headerlink\" title=\"hash.nodes： 为结点的副本数。\"></a><strong>hash.nodes</strong>： 为结点的副本数。</h5><pre><code class=\"lang-xml\">缺省只对第一个参数Hash，如果要修改，请配置\n&lt;dubbo:parameter key=&quot;hash.arguments&quot; value=&quot;0,1&quot; /&gt;\n\n缺省用160份虚拟节点，如果要修改，请配置\n&lt;dubbo:parameter key=&quot;hash.nodes&quot; value=&quot;320&quot; /&gt;\n</code></pre>"},{"layout":"post","title":"dubbo-动态代理实现","date":"2018-03-21T16:00:00.000Z","tag":[["java","java"],["dubbo","dubbo"]],"original":true,"_content":"\n##### 动态代理对于dubbo来说不是必须的，没有代理实现，dubbo一样可以运行。但是dubbo的一个重要的特点就是调用远程服务就像调用本地服务一样的方便。这其中对于其调用过程的隐藏就是通过动态代理来实现的。动态代理本身就就不详细介绍了，可以参考之前的一篇文章：[java动态代理实现](https://winx402.github.io/note/javaDynamicProxy/)\n\n<!--more-->\n\n### 扩展接口：\n##### `com.alibaba.dubbo.rpc.ProxyFactory`\n\n### 使用配置:\n```xml\n<dubbo:consumer proxy=\"\" />\n<dubbo:provider proxy=\"\" />\n```\n\n### 目前已知扩展：\n* stub=com.alibaba.dubbo.rpc.proxy.wrapper.StubProxyFactoryWrapper\n* jdk=com.alibaba.dubbo.rpc.proxy.jdk.JdkProxyFactory\n* javassist=com.alibaba.dubbo.rpc.proxy.javassist.JavassistProxyFactory\n\n### 包结构：\n![](/img/note/dubbo/dubbo1.png)\n\n### ProxyFactory\n```java\n@SPI(\"javassist\") //默认使用javassist\npublic interface ProxyFactory {\n\n    /**\n     * 通过Invoker创建代理\n     *\n     * @param invoker dubbo的可执行单元\n     * @return proxy java代理对象\n     */\n    @Adaptive({Constants.PROXY_KEY})\n    <T> T getProxy(Invoker<T> invoker) throws RpcException;\n\n    /**\n     * 创建 invoker.\n     *\n     * @param <T>\n     * @param proxy\n     * @param type\n     * @param url\n     * @return invoker\n     */\n    @Adaptive({Constants.PROXY_KEY})\n    <T> Invoker<T> getInvoker(T proxy, Class<T> type, URL url) throws RpcException;\n}\n```\n\n### AbstractProxyFactory\n##### **AbstractProxyFactory**实现了之前的**ProxyFactory**接口以及其方法getProxy的通用实现\n```java\npublic abstract class AbstractProxyFactory implements ProxyFactory {\n\n    public <T> T getProxy(Invoker<T> invoker) throws RpcException {\n        Class<?>[] interfaces = null;\n        String config = invoker.getUrl().getParameter(\"interfaces\");\n        if (config != null && config.length() > 0) {\n            String[] types = Constants.COMMA_SPLIT_PATTERN.split(config);\n            if (types != null && types.length > 0) {\n                interfaces = new Class<?>[types.length + 2];\n                interfaces[0] = invoker.getInterface();\n                interfaces[1] = EchoService.class;\n                for (int i = 0; i < types.length; i++) {\n                    interfaces[i + 1] = ReflectUtils.forName(types[i]);\n                }\n            }\n        }\n        if (interfaces == null) {\n            interfaces = new Class<?>[]{invoker.getInterface(), EchoService.class};\n        }\n        return getProxy(invoker, interfaces);\n    }\n\n    public abstract <T> T getProxy(Invoker<T> invoker, Class<?>[] types);\n}\n```\n##### getProxy方法主要是将该代理需要实现的接口给确定好，该接口存储在invoker对象的url的interfaces参数中，是一个字符串，用逗号分隔，我们不需要关心interfaces中存储的到底是哪些接口，只需要知道的是，invoker.getInterface()和EchoService.class会加入到其中，而另一个重载的getProxy方法显然是丢给子类来实现了。\n\n## jdk实现方式\n```java\n/**\n * JdkProxyFactory\n * 继承了AbstractProxyFactory\n */\npublic class JdkProxyFactory extends AbstractProxyFactory {\n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T getProxy(Invoker<T> invoker, Class<?>[] interfaces) {\n        return (T) Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), interfaces, new InvokerInvocationHandler(invoker));\n    }\n\n    public <T> Invoker<T> getInvoker(T proxy, Class<T> type, URL url) {\n        return new AbstractProxyInvoker<T>(proxy, type, url) {\n            @Override\n            protected Object doInvoke(T proxy, String methodName,\n                                      Class<?>[] parameterTypes,\n                                      Object[] arguments) throws Throwable {\n                Method method = proxy.getClass().getMethod(methodName, parameterTypes);\n                return method.invoke(proxy, arguments);\n            }\n        };\n    }\n\n}\n```\n\n##### JdkProxyFactory继承了AbstractProxyFactory，并实现了其抽象方法\n\n### getProxy\n```java\npublic <T> T getProxy(Invoker<T> invoker, Class<?>[] interfaces) {\n        return (T) Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), interfaces, new InvokerInvocationHandler(invoker));\n    }\n```\n##### 对，这里直接使用了jdk的Proxy类来创建代理对象。这里的关键在于InvokerInvocationHandler的实现：\n```java\npublic class InvokerInvocationHandler implements InvocationHandler {\n\n    private final Invoker<?> invoker; //实际执行对象\n\n    //通过Invoker初始化\n    public InvokerInvocationHandler(Invoker<?> handler) {\n        this.invoker = handler;\n    }\n\n    //代理调用的实际过程\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        String methodName = method.getName(); //获取方法名\n        Class<?>[] parameterTypes = method.getParameterTypes(); //方法参数类型\n        if (method.getDeclaringClass() == Object.class) {\n            //判断方法是不是属于Object类的方法。比如getClass、clone、notify等方法。如果是的话直接委托给invoker本身去执行。\n            return method.invoke(invoker, args);\n        }\n        if (\"toString\".equals(methodName) && parameterTypes.length == 0) {\n            //如果重写了toString方法。则调用invoker的toString\n            return invoker.toString();\n        }\n        if (\"hashCode\".equals(methodName) && parameterTypes.length == 0) {\n            //如果重写了hashCode方法。则调用invoker的hashCode\n            return invoker.hashCode();\n        }\n        if (\"equals\".equals(methodName) && parameterTypes.length == 1) {\n            //如果重写了equals方法。则调用invoker的equals\n            return invoker.equals(args[0]);\n        }\n        //否则，通过method和args创建一个RpcInvocation。通过该Invocation去执行invoker调用。并且返回调用结果\n        return invoker.invoke(new RpcInvocation(method, args)).recreate();\n    }\n\n}\n```\n\n##### 可以看到，jdk的实现方式很简单，只是将实际执行对象由我们平时的实际类指向了invoker\n\n### getInvoker\n```java\npublic <T> Invoker<T> getInvoker(T proxy, Class<T> type, URL url) {\n        return new AbstractProxyInvoker<T>(proxy, type, url) {\n            @Override\n            protected Object doInvoke(T proxy, String methodName,\n                                      Class<?>[] parameterTypes,\n                                      Object[] arguments) throws Throwable {\n                Method method = proxy.getClass().getMethod(methodName, parameterTypes);\n                return method.invoke(proxy, arguments);\n            }\n        };\n    }\n```\n\n##### getInvoker方法通过实际执行方法和类去创建一个Invoker。JDK实现方式是创建一个匿名AbstractProxyInvoker类，并实现其doInvoke方法。doInvoke方法中通过反射获取到目标方法。然后再通过反射去执行。\n\n##### 查看AbstractProxyInvoker类，会发现doInvoke是invoke的实际实现。因此对于代理的整个初始化流程：\n1. 拿到实际执行对象，通过该对象去创建Invoker\n2. 通过Invoker再去创建代理对象\n\n## javassist实现方式\n```java\npublic class JavassistProxyFactory extends AbstractProxyFactory {\n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T getProxy(Invoker<T> invoker, Class<?>[] interfaces) {\n        return (T) Proxy.getProxy(interfaces).newInstance(new InvokerInvocationHandler(invoker));\n    }\n\n    public <T> Invoker<T> getInvoker(T proxy, Class<T> type, URL url) {\n        // TODO Wrapper cannot handle this scenario correctly: the classname contains '$'\n        final Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf('$') < 0 ? proxy.getClass() : type);\n        return new AbstractProxyInvoker<T>(proxy, type, url) {\n            @Override\n            protected Object doInvoke(T proxy, String methodName,\n                                      Class<?>[] parameterTypes,\n                                      Object[] arguments) throws Throwable {\n                return wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);\n            }\n        };\n    }\n\n}\n```\n### getProxy\n```java\npublic <T> T getProxy(Invoker<T> invoker, Class<?>[] interfaces) {\n        return (T) Proxy.getProxy(interfaces).newInstance(new InvokerInvocationHandler(invoker));\n    }\n```\n\n##### 和jdk的生成方式差不多，但是这里的Proxy不是jdk自带的类，而是**com.alibaba.dubbo.common.bytecode.Proxy**，该类的主要作用就是通过javassist的字节码技术去动态的创建代理类，下面我们来看下该类的主要实现方法：\n```java\npublic static Proxy getProxy(ClassLoader cl, Class<?>... ics) {\n        if (ics.length > 65535)\n            throw new IllegalArgumentException(\"interface limit exceeded\");\n\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < ics.length; i++) {\n            String itf = ics[i].getName();\n            if (!ics[i].isInterface())\n                throw new RuntimeException(itf + \" is not a interface.\");\n\n            Class<?> tmp = null;\n            try {\n                tmp = Class.forName(itf, false, cl);\n            } catch (ClassNotFoundException e) {\n            }\n\n            if (tmp != ics[i])\n                throw new IllegalArgumentException(ics[i] + \" is not visible from class loader\");\n\n            sb.append(itf).append(';');\n        }\n\n        // use interface class name list as key.\n        String key = sb.toString();\n\n        // get cache by class loader.\n        Map<String, Object> cache;\n        synchronized (ProxyCacheMap) {\n            cache = ProxyCacheMap.get(cl);\n            if (cache == null) {\n                cache = new HashMap<String, Object>();\n                ProxyCacheMap.put(cl, cache);\n            }\n        }\n\n        Proxy proxy = null;\n        synchronized (cache) {\n            do {\n                Object value = cache.get(key);\n                if (value instanceof Reference<?>) {\n                    proxy = (Proxy) ((Reference<?>) value).get();\n                    if (proxy != null)\n                        return proxy;\n                }\n\n                if (value == PendingGenerationMarker) {\n                    try {\n                        cache.wait();\n                    } catch (InterruptedException e) {\n                    }\n                } else {\n                    cache.put(key, PendingGenerationMarker);\n                    break;\n                }\n            }\n            while (true);\n        }\n\n        long id = PROXY_CLASS_COUNTER.getAndIncrement();\n        String pkg = null;\n        ClassGenerator ccp = null, ccm = null;\n        try {\n            ccp = ClassGenerator.newInstance(cl);\n\n            Set<String> worked = new HashSet<String>();\n            List<Method> methods = new ArrayList<Method>();\n\n            for (int i = 0; i < ics.length; i++) {\n                if (!Modifier.isPublic(ics[i].getModifiers())) {\n                    String npkg = ics[i].getPackage().getName();\n                    if (pkg == null) {\n                        pkg = npkg;\n                    } else {\n                        if (!pkg.equals(npkg))\n                            throw new IllegalArgumentException(\"non-public interfaces from different packages\");\n                    }\n                }\n                ccp.addInterface(ics[i]);\n\n                for (Method method : ics[i].getMethods()) {\n                    String desc = ReflectUtils.getDesc(method);\n                    if (worked.contains(desc))\n                        continue;\n                    worked.add(desc);\n\n                    int ix = methods.size();\n                    Class<?> rt = method.getReturnType();\n                    Class<?>[] pts = method.getParameterTypes();\n\n                    StringBuilder code = new StringBuilder(\"Object[] args = new Object[\").append(pts.length).append(\"];\");\n                    for (int j = 0; j < pts.length; j++)\n                        code.append(\" args[\").append(j).append(\"] = ($w)$\").append(j + 1).append(\";\");\n                    code.append(\" Object ret = handler.invoke(this, methods[\" + ix + \"], args);\");\n                    if (!Void.TYPE.equals(rt))\n                        code.append(\" return \").append(asArgument(rt, \"ret\")).append(\";\");\n\n                    methods.add(method);\n                    ccp.addMethod(method.getName(), method.getModifiers(), rt, pts, method.getExceptionTypes(), code.toString());\n                }\n            }\n\n            if (pkg == null)\n                pkg = PACKAGE_NAME;\n\n            // create ProxyInstance class.\n            String pcn = pkg + \".proxy\" + id;\n            ccp.setClassName(pcn);\n            ccp.addField(\"public static java.lang.reflect.Method[] methods;\");\n            ccp.addField(\"private \" + InvocationHandler.class.getName() + \" handler;\");\n            ccp.addConstructor(Modifier.PUBLIC, new Class<?>[]{InvocationHandler.class}, new Class<?>[0], \"handler=$1;\");\n            ccp.addDefaultConstructor();\n            Class<?> clazz = ccp.toClass();\n            clazz.getField(\"methods\").set(null, methods.toArray(new Method[0]));\n\n            // create Proxy class.\n            String fcn = Proxy.class.getName() + id;\n            ccm = ClassGenerator.newInstance(cl);\n            ccm.setClassName(fcn);\n            ccm.addDefaultConstructor();\n            ccm.setSuperClass(Proxy.class);\n            ccm.addMethod(\"public Object newInstance(\" + InvocationHandler.class.getName() + \" h){ return new \" + pcn + \"($1); }\");\n            Class<?> pc = ccm.toClass();\n            proxy = (Proxy) pc.newInstance();\n        } catch (RuntimeException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new RuntimeException(e.getMessage(), e);\n        } finally {\n            // release ClassGenerator\n            if (ccp != null)\n                ccp.release();\n            if (ccm != null)\n                ccm.release();\n            synchronized (cache) {\n                if (proxy == null)\n                    cache.remove(key);\n                else\n                    cache.put(key, new WeakReference<Proxy>(proxy));\n                cache.notifyAll();\n            }\n        }\n        return proxy;\n    }\n```\n\n##### 该方法通过ClassLoader和Class接口生成一个Proxy类（注意是Proxy类，而不是之前的getProxy的泛型T类，实际上该Proxy就是该方法所处的类） 代码比较长，以下它的实现过程：\n1. 遍历所有入参接口，以;分割连接起来，以它为key以map为缓存查找如果有，说明代理对象已创建返回\n2. 利用AtomicLong对象自增获取一个long数组来作为生产类的后缀，防止冲突\n3. 遍历接口获取所有定义的方法\n    1. 将方法签名解析成字符串，加入到一个集合Set<String> worked中 ，用来判重\n    2. 获取方法应该在methods数组中的索引下标ix\n    3. 获取方法的参数类型以及返回类型\n    4. 构建方法体return ret= handler.invoke(this, methods[ix], args);这里的方法调用其实是委托给InvokerInvocationHandler实例对象的，去调用真正的实例\n    5. 方法加入到methods数组中；将字符串构建的方法加入到代理类中\n4. 创建代理实例对象ProxyInstance\n    1. 类名为  pkg + “.poxy”+id = 包名 + “.poxy” +自增数值\n    2. 添加静态字段Method[] methods; 保存了该代理类代理的所有方法。在代理方法体中直接通过数组下表ix来获取方法\n    3. 添加实例对象InvocationHandler handler；代理实际上就是将方法的的执行给了handler。该handler的实现和jdk中的handler是同一个。\n    4. 创建构造函数，构造函数的参数就是上面的InvocationHandler\n    5. 添加默认构造函数\n    6. 利用工具类ClassGenerator生成对应的字节码\n5. 创建代理对象，它的newInstance(handler)方法用来创建基于我们接口的代理\n    1. 代理对象名Proxy + id\n    2. 添加默认构造器\n    3. 实现方法newInstance代码，return new pcn(hadler) 这里pcn就是前面生成的代理对象类名\n    4. 利用工具类ClassGenerator生成字节码并实例化对象返回\n\n##### 通过**Proxy.getProxy(interfaces)**创建了代理类之后，再调用newInstance方法，通过InvokerInvocationHandler和Invoker创建了代理实例；\n\n### getInvoker\n```java\npublic <T> Invoker<T> getInvoker(T proxy, Class<T> type, URL url) {\n        final Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf('$') < 0 ? proxy.getClass() : type);\n        return new AbstractProxyInvoker<T>(proxy, type, url) {\n            @Override\n            protected Object doInvoke(T proxy, String methodName,\n                                      Class<?>[] parameterTypes,\n                                      Object[] arguments) throws Throwable {\n                return wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);\n            }\n        };\n    }\n```\n\n##### 实现过程如下：\n1. 根据传入的 proxy对象的类信息创建对它的包装对象Wrapper,这里同样是通过javassist生成字节码创建的。详细的过程就不介绍了，和上面的过程很类似\n2. 返回AbstractProxyInvoker对象实例，这个invoker对象invoke方法可以根据传入的invocation对象中包含的方法名，方法参数来调用wrapper对象返回调用结果\n\n## StubProxyFactoryWrapper\n```java\npublic class StubProxyFactoryWrapper implements ProxyFactory {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(StubProxyFactoryWrapper.class);\n\n    private final ProxyFactory proxyFactory;\n\n    private Protocol protocol;\n\n    public StubProxyFactoryWrapper(ProxyFactory proxyFactory) {\n        this.proxyFactory = proxyFactory;\n    }\n\n    public void setProtocol(Protocol protocol) {\n        this.protocol = protocol;\n    }\n\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    public <T> T getProxy(Invoker<T> invoker) throws RpcException {\n        T proxy = proxyFactory.getProxy(invoker);\n        if (GenericService.class != invoker.getInterface()) {\n            String stub = invoker.getUrl().getParameter(Constants.STUB_KEY, invoker.getUrl().getParameter(Constants.LOCAL_KEY));\n            if (ConfigUtils.isNotEmpty(stub)) {\n                Class<?> serviceType = invoker.getInterface();\n                if (ConfigUtils.isDefault(stub)) {\n                    if (invoker.getUrl().hasParameter(Constants.STUB_KEY)) {\n                        stub = serviceType.getName() + \"Stub\";\n                    } else {\n                        stub = serviceType.getName() + \"Local\";\n                    }\n                }\n                try {\n                    Class<?> stubClass = ReflectUtils.forName(stub);\n                    if (!serviceType.isAssignableFrom(stubClass)) {\n                        throw new IllegalStateException(\"The stub implementation class \" + stubClass.getName() + \" not implement interface \" + serviceType.getName());\n                    }\n                    try {\n                        Constructor<?> constructor = ReflectUtils.findConstructor(stubClass, serviceType);\n                        proxy = (T) constructor.newInstance(new Object[]{proxy});\n                        //export stub service\n                        URL url = invoker.getUrl();\n                        if (url.getParameter(Constants.STUB_EVENT_KEY, Constants.DEFAULT_STUB_EVENT)) {\n                            url = url.addParameter(Constants.STUB_EVENT_METHODS_KEY, StringUtils.join(Wrapper.getWrapper(proxy.getClass()).getDeclaredMethodNames(), \",\"));\n                            url = url.addParameter(Constants.IS_SERVER_KEY, Boolean.FALSE.toString());\n                            try {\n                                export(proxy, (Class) invoker.getInterface(), url);\n                            } catch (Exception e) {\n                                LOGGER.error(\"export a stub service error.\", e);\n                            }\n                        }\n                    } catch (NoSuchMethodException e) {\n                        throw new IllegalStateException(\"No such constructor \\\"public \" + stubClass.getSimpleName() + \"(\" + serviceType.getName() + \")\\\" in stub implementation class \" + stubClass.getName(), e);\n                    }\n                } catch (Throwable t) {\n                    LOGGER.error(\"Failed to create stub implementation class \" + stub + \" in consumer \" + NetUtils.getLocalHost() + \" use dubbo version \" + Version.getVersion() + \", cause: \" + t.getMessage(), t);\n                    // ignore\n                }\n            }\n        }\n        return proxy;\n    }\n\n    public <T> Invoker<T> getInvoker(T proxy, Class<T> type, URL url) throws RpcException {\n        return proxyFactory.getInvoker(proxy, type, url);\n    }\n\n    private <T> Exporter<T> export(T instance, Class<T> type, URL url) {\n        return protocol.export(proxyFactory.getInvoker(instance, type, url));\n    }\n\n}\n```\n##### StubProxyFactoryWrapper实现了对代理工厂进行装饰的功能，主要用于暴露服务提供者的本地服务给远端消费者来调用\n\n## 总结\n##### jdk和javassist的实现的区别就在于是jdk提供的字节码功能还是通过javassist来自定义类。本质上来说原理是一样的。整个的流程就像前面提到的\n1. 拿到**实际执行对象**，通过该对象去创建Invoker\n2. 通过Invoker再去创建代理对象\n\n##### 但是其中有一些问题需要去思考：\n1. 这个代理的流程是从哪里发起的\n2. 如果是消费端，只有服务的接口，没有实际执行的对象。那么这个代理是如何产生的；\n3. 为什么javassist的getInvoker中，还需要实现wrapper类","source":"_posts/note/dubbo/proxy.md","raw":"---\nlayout: post\ntitle: dubbo-动态代理实现\ndate: 2018/03/22\ntags: [tech, index, dubbo]\ntag: [[java, java], [dubbo, dubbo]]\noriginal: true\n---\n\n##### 动态代理对于dubbo来说不是必须的，没有代理实现，dubbo一样可以运行。但是dubbo的一个重要的特点就是调用远程服务就像调用本地服务一样的方便。这其中对于其调用过程的隐藏就是通过动态代理来实现的。动态代理本身就就不详细介绍了，可以参考之前的一篇文章：[java动态代理实现](https://winx402.github.io/note/javaDynamicProxy/)\n\n<!--more-->\n\n### 扩展接口：\n##### `com.alibaba.dubbo.rpc.ProxyFactory`\n\n### 使用配置:\n```xml\n<dubbo:consumer proxy=\"\" />\n<dubbo:provider proxy=\"\" />\n```\n\n### 目前已知扩展：\n* stub=com.alibaba.dubbo.rpc.proxy.wrapper.StubProxyFactoryWrapper\n* jdk=com.alibaba.dubbo.rpc.proxy.jdk.JdkProxyFactory\n* javassist=com.alibaba.dubbo.rpc.proxy.javassist.JavassistProxyFactory\n\n### 包结构：\n![](/img/note/dubbo/dubbo1.png)\n\n### ProxyFactory\n```java\n@SPI(\"javassist\") //默认使用javassist\npublic interface ProxyFactory {\n\n    /**\n     * 通过Invoker创建代理\n     *\n     * @param invoker dubbo的可执行单元\n     * @return proxy java代理对象\n     */\n    @Adaptive({Constants.PROXY_KEY})\n    <T> T getProxy(Invoker<T> invoker) throws RpcException;\n\n    /**\n     * 创建 invoker.\n     *\n     * @param <T>\n     * @param proxy\n     * @param type\n     * @param url\n     * @return invoker\n     */\n    @Adaptive({Constants.PROXY_KEY})\n    <T> Invoker<T> getInvoker(T proxy, Class<T> type, URL url) throws RpcException;\n}\n```\n\n### AbstractProxyFactory\n##### **AbstractProxyFactory**实现了之前的**ProxyFactory**接口以及其方法getProxy的通用实现\n```java\npublic abstract class AbstractProxyFactory implements ProxyFactory {\n\n    public <T> T getProxy(Invoker<T> invoker) throws RpcException {\n        Class<?>[] interfaces = null;\n        String config = invoker.getUrl().getParameter(\"interfaces\");\n        if (config != null && config.length() > 0) {\n            String[] types = Constants.COMMA_SPLIT_PATTERN.split(config);\n            if (types != null && types.length > 0) {\n                interfaces = new Class<?>[types.length + 2];\n                interfaces[0] = invoker.getInterface();\n                interfaces[1] = EchoService.class;\n                for (int i = 0; i < types.length; i++) {\n                    interfaces[i + 1] = ReflectUtils.forName(types[i]);\n                }\n            }\n        }\n        if (interfaces == null) {\n            interfaces = new Class<?>[]{invoker.getInterface(), EchoService.class};\n        }\n        return getProxy(invoker, interfaces);\n    }\n\n    public abstract <T> T getProxy(Invoker<T> invoker, Class<?>[] types);\n}\n```\n##### getProxy方法主要是将该代理需要实现的接口给确定好，该接口存储在invoker对象的url的interfaces参数中，是一个字符串，用逗号分隔，我们不需要关心interfaces中存储的到底是哪些接口，只需要知道的是，invoker.getInterface()和EchoService.class会加入到其中，而另一个重载的getProxy方法显然是丢给子类来实现了。\n\n## jdk实现方式\n```java\n/**\n * JdkProxyFactory\n * 继承了AbstractProxyFactory\n */\npublic class JdkProxyFactory extends AbstractProxyFactory {\n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T getProxy(Invoker<T> invoker, Class<?>[] interfaces) {\n        return (T) Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), interfaces, new InvokerInvocationHandler(invoker));\n    }\n\n    public <T> Invoker<T> getInvoker(T proxy, Class<T> type, URL url) {\n        return new AbstractProxyInvoker<T>(proxy, type, url) {\n            @Override\n            protected Object doInvoke(T proxy, String methodName,\n                                      Class<?>[] parameterTypes,\n                                      Object[] arguments) throws Throwable {\n                Method method = proxy.getClass().getMethod(methodName, parameterTypes);\n                return method.invoke(proxy, arguments);\n            }\n        };\n    }\n\n}\n```\n\n##### JdkProxyFactory继承了AbstractProxyFactory，并实现了其抽象方法\n\n### getProxy\n```java\npublic <T> T getProxy(Invoker<T> invoker, Class<?>[] interfaces) {\n        return (T) Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), interfaces, new InvokerInvocationHandler(invoker));\n    }\n```\n##### 对，这里直接使用了jdk的Proxy类来创建代理对象。这里的关键在于InvokerInvocationHandler的实现：\n```java\npublic class InvokerInvocationHandler implements InvocationHandler {\n\n    private final Invoker<?> invoker; //实际执行对象\n\n    //通过Invoker初始化\n    public InvokerInvocationHandler(Invoker<?> handler) {\n        this.invoker = handler;\n    }\n\n    //代理调用的实际过程\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        String methodName = method.getName(); //获取方法名\n        Class<?>[] parameterTypes = method.getParameterTypes(); //方法参数类型\n        if (method.getDeclaringClass() == Object.class) {\n            //判断方法是不是属于Object类的方法。比如getClass、clone、notify等方法。如果是的话直接委托给invoker本身去执行。\n            return method.invoke(invoker, args);\n        }\n        if (\"toString\".equals(methodName) && parameterTypes.length == 0) {\n            //如果重写了toString方法。则调用invoker的toString\n            return invoker.toString();\n        }\n        if (\"hashCode\".equals(methodName) && parameterTypes.length == 0) {\n            //如果重写了hashCode方法。则调用invoker的hashCode\n            return invoker.hashCode();\n        }\n        if (\"equals\".equals(methodName) && parameterTypes.length == 1) {\n            //如果重写了equals方法。则调用invoker的equals\n            return invoker.equals(args[0]);\n        }\n        //否则，通过method和args创建一个RpcInvocation。通过该Invocation去执行invoker调用。并且返回调用结果\n        return invoker.invoke(new RpcInvocation(method, args)).recreate();\n    }\n\n}\n```\n\n##### 可以看到，jdk的实现方式很简单，只是将实际执行对象由我们平时的实际类指向了invoker\n\n### getInvoker\n```java\npublic <T> Invoker<T> getInvoker(T proxy, Class<T> type, URL url) {\n        return new AbstractProxyInvoker<T>(proxy, type, url) {\n            @Override\n            protected Object doInvoke(T proxy, String methodName,\n                                      Class<?>[] parameterTypes,\n                                      Object[] arguments) throws Throwable {\n                Method method = proxy.getClass().getMethod(methodName, parameterTypes);\n                return method.invoke(proxy, arguments);\n            }\n        };\n    }\n```\n\n##### getInvoker方法通过实际执行方法和类去创建一个Invoker。JDK实现方式是创建一个匿名AbstractProxyInvoker类，并实现其doInvoke方法。doInvoke方法中通过反射获取到目标方法。然后再通过反射去执行。\n\n##### 查看AbstractProxyInvoker类，会发现doInvoke是invoke的实际实现。因此对于代理的整个初始化流程：\n1. 拿到实际执行对象，通过该对象去创建Invoker\n2. 通过Invoker再去创建代理对象\n\n## javassist实现方式\n```java\npublic class JavassistProxyFactory extends AbstractProxyFactory {\n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T getProxy(Invoker<T> invoker, Class<?>[] interfaces) {\n        return (T) Proxy.getProxy(interfaces).newInstance(new InvokerInvocationHandler(invoker));\n    }\n\n    public <T> Invoker<T> getInvoker(T proxy, Class<T> type, URL url) {\n        // TODO Wrapper cannot handle this scenario correctly: the classname contains '$'\n        final Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf('$') < 0 ? proxy.getClass() : type);\n        return new AbstractProxyInvoker<T>(proxy, type, url) {\n            @Override\n            protected Object doInvoke(T proxy, String methodName,\n                                      Class<?>[] parameterTypes,\n                                      Object[] arguments) throws Throwable {\n                return wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);\n            }\n        };\n    }\n\n}\n```\n### getProxy\n```java\npublic <T> T getProxy(Invoker<T> invoker, Class<?>[] interfaces) {\n        return (T) Proxy.getProxy(interfaces).newInstance(new InvokerInvocationHandler(invoker));\n    }\n```\n\n##### 和jdk的生成方式差不多，但是这里的Proxy不是jdk自带的类，而是**com.alibaba.dubbo.common.bytecode.Proxy**，该类的主要作用就是通过javassist的字节码技术去动态的创建代理类，下面我们来看下该类的主要实现方法：\n```java\npublic static Proxy getProxy(ClassLoader cl, Class<?>... ics) {\n        if (ics.length > 65535)\n            throw new IllegalArgumentException(\"interface limit exceeded\");\n\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < ics.length; i++) {\n            String itf = ics[i].getName();\n            if (!ics[i].isInterface())\n                throw new RuntimeException(itf + \" is not a interface.\");\n\n            Class<?> tmp = null;\n            try {\n                tmp = Class.forName(itf, false, cl);\n            } catch (ClassNotFoundException e) {\n            }\n\n            if (tmp != ics[i])\n                throw new IllegalArgumentException(ics[i] + \" is not visible from class loader\");\n\n            sb.append(itf).append(';');\n        }\n\n        // use interface class name list as key.\n        String key = sb.toString();\n\n        // get cache by class loader.\n        Map<String, Object> cache;\n        synchronized (ProxyCacheMap) {\n            cache = ProxyCacheMap.get(cl);\n            if (cache == null) {\n                cache = new HashMap<String, Object>();\n                ProxyCacheMap.put(cl, cache);\n            }\n        }\n\n        Proxy proxy = null;\n        synchronized (cache) {\n            do {\n                Object value = cache.get(key);\n                if (value instanceof Reference<?>) {\n                    proxy = (Proxy) ((Reference<?>) value).get();\n                    if (proxy != null)\n                        return proxy;\n                }\n\n                if (value == PendingGenerationMarker) {\n                    try {\n                        cache.wait();\n                    } catch (InterruptedException e) {\n                    }\n                } else {\n                    cache.put(key, PendingGenerationMarker);\n                    break;\n                }\n            }\n            while (true);\n        }\n\n        long id = PROXY_CLASS_COUNTER.getAndIncrement();\n        String pkg = null;\n        ClassGenerator ccp = null, ccm = null;\n        try {\n            ccp = ClassGenerator.newInstance(cl);\n\n            Set<String> worked = new HashSet<String>();\n            List<Method> methods = new ArrayList<Method>();\n\n            for (int i = 0; i < ics.length; i++) {\n                if (!Modifier.isPublic(ics[i].getModifiers())) {\n                    String npkg = ics[i].getPackage().getName();\n                    if (pkg == null) {\n                        pkg = npkg;\n                    } else {\n                        if (!pkg.equals(npkg))\n                            throw new IllegalArgumentException(\"non-public interfaces from different packages\");\n                    }\n                }\n                ccp.addInterface(ics[i]);\n\n                for (Method method : ics[i].getMethods()) {\n                    String desc = ReflectUtils.getDesc(method);\n                    if (worked.contains(desc))\n                        continue;\n                    worked.add(desc);\n\n                    int ix = methods.size();\n                    Class<?> rt = method.getReturnType();\n                    Class<?>[] pts = method.getParameterTypes();\n\n                    StringBuilder code = new StringBuilder(\"Object[] args = new Object[\").append(pts.length).append(\"];\");\n                    for (int j = 0; j < pts.length; j++)\n                        code.append(\" args[\").append(j).append(\"] = ($w)$\").append(j + 1).append(\";\");\n                    code.append(\" Object ret = handler.invoke(this, methods[\" + ix + \"], args);\");\n                    if (!Void.TYPE.equals(rt))\n                        code.append(\" return \").append(asArgument(rt, \"ret\")).append(\";\");\n\n                    methods.add(method);\n                    ccp.addMethod(method.getName(), method.getModifiers(), rt, pts, method.getExceptionTypes(), code.toString());\n                }\n            }\n\n            if (pkg == null)\n                pkg = PACKAGE_NAME;\n\n            // create ProxyInstance class.\n            String pcn = pkg + \".proxy\" + id;\n            ccp.setClassName(pcn);\n            ccp.addField(\"public static java.lang.reflect.Method[] methods;\");\n            ccp.addField(\"private \" + InvocationHandler.class.getName() + \" handler;\");\n            ccp.addConstructor(Modifier.PUBLIC, new Class<?>[]{InvocationHandler.class}, new Class<?>[0], \"handler=$1;\");\n            ccp.addDefaultConstructor();\n            Class<?> clazz = ccp.toClass();\n            clazz.getField(\"methods\").set(null, methods.toArray(new Method[0]));\n\n            // create Proxy class.\n            String fcn = Proxy.class.getName() + id;\n            ccm = ClassGenerator.newInstance(cl);\n            ccm.setClassName(fcn);\n            ccm.addDefaultConstructor();\n            ccm.setSuperClass(Proxy.class);\n            ccm.addMethod(\"public Object newInstance(\" + InvocationHandler.class.getName() + \" h){ return new \" + pcn + \"($1); }\");\n            Class<?> pc = ccm.toClass();\n            proxy = (Proxy) pc.newInstance();\n        } catch (RuntimeException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new RuntimeException(e.getMessage(), e);\n        } finally {\n            // release ClassGenerator\n            if (ccp != null)\n                ccp.release();\n            if (ccm != null)\n                ccm.release();\n            synchronized (cache) {\n                if (proxy == null)\n                    cache.remove(key);\n                else\n                    cache.put(key, new WeakReference<Proxy>(proxy));\n                cache.notifyAll();\n            }\n        }\n        return proxy;\n    }\n```\n\n##### 该方法通过ClassLoader和Class接口生成一个Proxy类（注意是Proxy类，而不是之前的getProxy的泛型T类，实际上该Proxy就是该方法所处的类） 代码比较长，以下它的实现过程：\n1. 遍历所有入参接口，以;分割连接起来，以它为key以map为缓存查找如果有，说明代理对象已创建返回\n2. 利用AtomicLong对象自增获取一个long数组来作为生产类的后缀，防止冲突\n3. 遍历接口获取所有定义的方法\n    1. 将方法签名解析成字符串，加入到一个集合Set<String> worked中 ，用来判重\n    2. 获取方法应该在methods数组中的索引下标ix\n    3. 获取方法的参数类型以及返回类型\n    4. 构建方法体return ret= handler.invoke(this, methods[ix], args);这里的方法调用其实是委托给InvokerInvocationHandler实例对象的，去调用真正的实例\n    5. 方法加入到methods数组中；将字符串构建的方法加入到代理类中\n4. 创建代理实例对象ProxyInstance\n    1. 类名为  pkg + “.poxy”+id = 包名 + “.poxy” +自增数值\n    2. 添加静态字段Method[] methods; 保存了该代理类代理的所有方法。在代理方法体中直接通过数组下表ix来获取方法\n    3. 添加实例对象InvocationHandler handler；代理实际上就是将方法的的执行给了handler。该handler的实现和jdk中的handler是同一个。\n    4. 创建构造函数，构造函数的参数就是上面的InvocationHandler\n    5. 添加默认构造函数\n    6. 利用工具类ClassGenerator生成对应的字节码\n5. 创建代理对象，它的newInstance(handler)方法用来创建基于我们接口的代理\n    1. 代理对象名Proxy + id\n    2. 添加默认构造器\n    3. 实现方法newInstance代码，return new pcn(hadler) 这里pcn就是前面生成的代理对象类名\n    4. 利用工具类ClassGenerator生成字节码并实例化对象返回\n\n##### 通过**Proxy.getProxy(interfaces)**创建了代理类之后，再调用newInstance方法，通过InvokerInvocationHandler和Invoker创建了代理实例；\n\n### getInvoker\n```java\npublic <T> Invoker<T> getInvoker(T proxy, Class<T> type, URL url) {\n        final Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf('$') < 0 ? proxy.getClass() : type);\n        return new AbstractProxyInvoker<T>(proxy, type, url) {\n            @Override\n            protected Object doInvoke(T proxy, String methodName,\n                                      Class<?>[] parameterTypes,\n                                      Object[] arguments) throws Throwable {\n                return wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);\n            }\n        };\n    }\n```\n\n##### 实现过程如下：\n1. 根据传入的 proxy对象的类信息创建对它的包装对象Wrapper,这里同样是通过javassist生成字节码创建的。详细的过程就不介绍了，和上面的过程很类似\n2. 返回AbstractProxyInvoker对象实例，这个invoker对象invoke方法可以根据传入的invocation对象中包含的方法名，方法参数来调用wrapper对象返回调用结果\n\n## StubProxyFactoryWrapper\n```java\npublic class StubProxyFactoryWrapper implements ProxyFactory {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(StubProxyFactoryWrapper.class);\n\n    private final ProxyFactory proxyFactory;\n\n    private Protocol protocol;\n\n    public StubProxyFactoryWrapper(ProxyFactory proxyFactory) {\n        this.proxyFactory = proxyFactory;\n    }\n\n    public void setProtocol(Protocol protocol) {\n        this.protocol = protocol;\n    }\n\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    public <T> T getProxy(Invoker<T> invoker) throws RpcException {\n        T proxy = proxyFactory.getProxy(invoker);\n        if (GenericService.class != invoker.getInterface()) {\n            String stub = invoker.getUrl().getParameter(Constants.STUB_KEY, invoker.getUrl().getParameter(Constants.LOCAL_KEY));\n            if (ConfigUtils.isNotEmpty(stub)) {\n                Class<?> serviceType = invoker.getInterface();\n                if (ConfigUtils.isDefault(stub)) {\n                    if (invoker.getUrl().hasParameter(Constants.STUB_KEY)) {\n                        stub = serviceType.getName() + \"Stub\";\n                    } else {\n                        stub = serviceType.getName() + \"Local\";\n                    }\n                }\n                try {\n                    Class<?> stubClass = ReflectUtils.forName(stub);\n                    if (!serviceType.isAssignableFrom(stubClass)) {\n                        throw new IllegalStateException(\"The stub implementation class \" + stubClass.getName() + \" not implement interface \" + serviceType.getName());\n                    }\n                    try {\n                        Constructor<?> constructor = ReflectUtils.findConstructor(stubClass, serviceType);\n                        proxy = (T) constructor.newInstance(new Object[]{proxy});\n                        //export stub service\n                        URL url = invoker.getUrl();\n                        if (url.getParameter(Constants.STUB_EVENT_KEY, Constants.DEFAULT_STUB_EVENT)) {\n                            url = url.addParameter(Constants.STUB_EVENT_METHODS_KEY, StringUtils.join(Wrapper.getWrapper(proxy.getClass()).getDeclaredMethodNames(), \",\"));\n                            url = url.addParameter(Constants.IS_SERVER_KEY, Boolean.FALSE.toString());\n                            try {\n                                export(proxy, (Class) invoker.getInterface(), url);\n                            } catch (Exception e) {\n                                LOGGER.error(\"export a stub service error.\", e);\n                            }\n                        }\n                    } catch (NoSuchMethodException e) {\n                        throw new IllegalStateException(\"No such constructor \\\"public \" + stubClass.getSimpleName() + \"(\" + serviceType.getName() + \")\\\" in stub implementation class \" + stubClass.getName(), e);\n                    }\n                } catch (Throwable t) {\n                    LOGGER.error(\"Failed to create stub implementation class \" + stub + \" in consumer \" + NetUtils.getLocalHost() + \" use dubbo version \" + Version.getVersion() + \", cause: \" + t.getMessage(), t);\n                    // ignore\n                }\n            }\n        }\n        return proxy;\n    }\n\n    public <T> Invoker<T> getInvoker(T proxy, Class<T> type, URL url) throws RpcException {\n        return proxyFactory.getInvoker(proxy, type, url);\n    }\n\n    private <T> Exporter<T> export(T instance, Class<T> type, URL url) {\n        return protocol.export(proxyFactory.getInvoker(instance, type, url));\n    }\n\n}\n```\n##### StubProxyFactoryWrapper实现了对代理工厂进行装饰的功能，主要用于暴露服务提供者的本地服务给远端消费者来调用\n\n## 总结\n##### jdk和javassist的实现的区别就在于是jdk提供的字节码功能还是通过javassist来自定义类。本质上来说原理是一样的。整个的流程就像前面提到的\n1. 拿到**实际执行对象**，通过该对象去创建Invoker\n2. 通过Invoker再去创建代理对象\n\n##### 但是其中有一些问题需要去思考：\n1. 这个代理的流程是从哪里发起的\n2. 如果是消费端，只有服务的接口，没有实际执行的对象。那么这个代理是如何产生的；\n3. 为什么javassist的getInvoker中，还需要实现wrapper类","slug":"note/dubbo/proxy","published":1,"updated":"2018-05-08T14:51:18.325Z","_id":"cjgxop3ne0038jah1num3ym1l","comments":1,"photos":[],"link":"","content":"<h5 id=\"动态代理对于dubbo来说不是必须的，没有代理实现，dubbo一样可以运行。但是dubbo的一个重要的特点就是调用远程服务就像调用本地服务一样的方便。这其中对于其调用过程的隐藏就是通过动态代理来实现的。动态代理本身就就不详细介绍了，可以参考之前的一篇文章：java动态代理实现\"><a href=\"#动态代理对于dubbo来说不是必须的，没有代理实现，dubbo一样可以运行。但是dubbo的一个重要的特点就是调用远程服务就像调用本地服务一样的方便。这其中对于其调用过程的隐藏就是通过动态代理来实现的。动态代理本身就就不详细介绍了，可以参考之前的一篇文章：java动态代理实现\" class=\"headerlink\" title=\"动态代理对于dubbo来说不是必须的，没有代理实现，dubbo一样可以运行。但是dubbo的一个重要的特点就是调用远程服务就像调用本地服务一样的方便。这其中对于其调用过程的隐藏就是通过动态代理来实现的。动态代理本身就就不详细介绍了，可以参考之前的一篇文章：java动态代理实现\"></a>动态代理对于dubbo来说不是必须的，没有代理实现，dubbo一样可以运行。但是dubbo的一个重要的特点就是调用远程服务就像调用本地服务一样的方便。这其中对于其调用过程的隐藏就是通过动态代理来实现的。动态代理本身就就不详细介绍了，可以参考之前的一篇文章：<a href=\"https://winx402.github.io/note/javaDynamicProxy/\" target=\"_blank\" rel=\"external\">java动态代理实现</a></h5><a id=\"more\"></a>\n<h3 id=\"扩展接口：\"><a href=\"#扩展接口：\" class=\"headerlink\" title=\"扩展接口：\"></a>扩展接口：</h3><h5 id=\"com-alibaba-dubbo-rpc-ProxyFactory\"><a href=\"#com-alibaba-dubbo-rpc-ProxyFactory\" class=\"headerlink\" title=\"com.alibaba.dubbo.rpc.ProxyFactory\"></a><code>com.alibaba.dubbo.rpc.ProxyFactory</code></h5><h3 id=\"使用配置\"><a href=\"#使用配置\" class=\"headerlink\" title=\"使用配置:\"></a>使用配置:</h3><pre><code class=\"lang-xml\">&lt;dubbo:consumer proxy=&quot;&quot; /&gt;\n&lt;dubbo:provider proxy=&quot;&quot; /&gt;\n</code></pre>\n<h3 id=\"目前已知扩展：\"><a href=\"#目前已知扩展：\" class=\"headerlink\" title=\"目前已知扩展：\"></a>目前已知扩展：</h3><ul>\n<li>stub=com.alibaba.dubbo.rpc.proxy.wrapper.StubProxyFactoryWrapper</li>\n<li>jdk=com.alibaba.dubbo.rpc.proxy.jdk.JdkProxyFactory</li>\n<li>javassist=com.alibaba.dubbo.rpc.proxy.javassist.JavassistProxyFactory</li>\n</ul>\n<h3 id=\"包结构：\"><a href=\"#包结构：\" class=\"headerlink\" title=\"包结构：\"></a>包结构：</h3><p><img src=\"/img/note/dubbo/dubbo1.png\" alt=\"\"></p>\n<h3 id=\"ProxyFactory\"><a href=\"#ProxyFactory\" class=\"headerlink\" title=\"ProxyFactory\"></a>ProxyFactory</h3><pre><code class=\"lang-java\">@SPI(&quot;javassist&quot;) //默认使用javassist\npublic interface ProxyFactory {\n\n    /**\n     * 通过Invoker创建代理\n     *\n     * @param invoker dubbo的可执行单元\n     * @return proxy java代理对象\n     */\n    @Adaptive({Constants.PROXY_KEY})\n    &lt;T&gt; T getProxy(Invoker&lt;T&gt; invoker) throws RpcException;\n\n    /**\n     * 创建 invoker.\n     *\n     * @param &lt;T&gt;\n     * @param proxy\n     * @param type\n     * @param url\n     * @return invoker\n     */\n    @Adaptive({Constants.PROXY_KEY})\n    &lt;T&gt; Invoker&lt;T&gt; getInvoker(T proxy, Class&lt;T&gt; type, URL url) throws RpcException;\n}\n</code></pre>\n<h3 id=\"AbstractProxyFactory\"><a href=\"#AbstractProxyFactory\" class=\"headerlink\" title=\"AbstractProxyFactory\"></a>AbstractProxyFactory</h3><h5 id=\"AbstractProxyFactory实现了之前的ProxyFactory接口以及其方法getProxy的通用实现\"><a href=\"#AbstractProxyFactory实现了之前的ProxyFactory接口以及其方法getProxy的通用实现\" class=\"headerlink\" title=\"AbstractProxyFactory实现了之前的ProxyFactory接口以及其方法getProxy的通用实现\"></a><strong>AbstractProxyFactory</strong>实现了之前的<strong>ProxyFactory</strong>接口以及其方法getProxy的通用实现</h5><pre><code class=\"lang-java\">public abstract class AbstractProxyFactory implements ProxyFactory {\n\n    public &lt;T&gt; T getProxy(Invoker&lt;T&gt; invoker) throws RpcException {\n        Class&lt;?&gt;[] interfaces = null;\n        String config = invoker.getUrl().getParameter(&quot;interfaces&quot;);\n        if (config != null &amp;&amp; config.length() &gt; 0) {\n            String[] types = Constants.COMMA_SPLIT_PATTERN.split(config);\n            if (types != null &amp;&amp; types.length &gt; 0) {\n                interfaces = new Class&lt;?&gt;[types.length + 2];\n                interfaces[0] = invoker.getInterface();\n                interfaces[1] = EchoService.class;\n                for (int i = 0; i &lt; types.length; i++) {\n                    interfaces[i + 1] = ReflectUtils.forName(types[i]);\n                }\n            }\n        }\n        if (interfaces == null) {\n            interfaces = new Class&lt;?&gt;[]{invoker.getInterface(), EchoService.class};\n        }\n        return getProxy(invoker, interfaces);\n    }\n\n    public abstract &lt;T&gt; T getProxy(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] types);\n}\n</code></pre>\n<h5 id=\"getProxy方法主要是将该代理需要实现的接口给确定好，该接口存储在invoker对象的url的interfaces参数中，是一个字符串，用逗号分隔，我们不需要关心interfaces中存储的到底是哪些接口，只需要知道的是，invoker-getInterface-和EchoService-class会加入到其中，而另一个重载的getProxy方法显然是丢给子类来实现了。\"><a href=\"#getProxy方法主要是将该代理需要实现的接口给确定好，该接口存储在invoker对象的url的interfaces参数中，是一个字符串，用逗号分隔，我们不需要关心interfaces中存储的到底是哪些接口，只需要知道的是，invoker-getInterface-和EchoService-class会加入到其中，而另一个重载的getProxy方法显然是丢给子类来实现了。\" class=\"headerlink\" title=\"getProxy方法主要是将该代理需要实现的接口给确定好，该接口存储在invoker对象的url的interfaces参数中，是一个字符串，用逗号分隔，我们不需要关心interfaces中存储的到底是哪些接口，只需要知道的是，invoker.getInterface()和EchoService.class会加入到其中，而另一个重载的getProxy方法显然是丢给子类来实现了。\"></a>getProxy方法主要是将该代理需要实现的接口给确定好，该接口存储在invoker对象的url的interfaces参数中，是一个字符串，用逗号分隔，我们不需要关心interfaces中存储的到底是哪些接口，只需要知道的是，invoker.getInterface()和EchoService.class会加入到其中，而另一个重载的getProxy方法显然是丢给子类来实现了。</h5><h2 id=\"jdk实现方式\"><a href=\"#jdk实现方式\" class=\"headerlink\" title=\"jdk实现方式\"></a>jdk实现方式</h2><pre><code class=\"lang-java\">/**\n * JdkProxyFactory\n * 继承了AbstractProxyFactory\n */\npublic class JdkProxyFactory extends AbstractProxyFactory {\n\n    @SuppressWarnings(&quot;unchecked&quot;)\n    public &lt;T&gt; T getProxy(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] interfaces) {\n        return (T) Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), interfaces, new InvokerInvocationHandler(invoker));\n    }\n\n    public &lt;T&gt; Invoker&lt;T&gt; getInvoker(T proxy, Class&lt;T&gt; type, URL url) {\n        return new AbstractProxyInvoker&lt;T&gt;(proxy, type, url) {\n            @Override\n            protected Object doInvoke(T proxy, String methodName,\n                                      Class&lt;?&gt;[] parameterTypes,\n                                      Object[] arguments) throws Throwable {\n                Method method = proxy.getClass().getMethod(methodName, parameterTypes);\n                return method.invoke(proxy, arguments);\n            }\n        };\n    }\n\n}\n</code></pre>\n<h5 id=\"JdkProxyFactory继承了AbstractProxyFactory，并实现了其抽象方法\"><a href=\"#JdkProxyFactory继承了AbstractProxyFactory，并实现了其抽象方法\" class=\"headerlink\" title=\"JdkProxyFactory继承了AbstractProxyFactory，并实现了其抽象方法\"></a>JdkProxyFactory继承了AbstractProxyFactory，并实现了其抽象方法</h5><h3 id=\"getProxy\"><a href=\"#getProxy\" class=\"headerlink\" title=\"getProxy\"></a>getProxy</h3><pre><code class=\"lang-java\">public &lt;T&gt; T getProxy(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] interfaces) {\n        return (T) Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), interfaces, new InvokerInvocationHandler(invoker));\n    }\n</code></pre>\n<h5 id=\"对，这里直接使用了jdk的Proxy类来创建代理对象。这里的关键在于InvokerInvocationHandler的实现：\"><a href=\"#对，这里直接使用了jdk的Proxy类来创建代理对象。这里的关键在于InvokerInvocationHandler的实现：\" class=\"headerlink\" title=\"对，这里直接使用了jdk的Proxy类来创建代理对象。这里的关键在于InvokerInvocationHandler的实现：\"></a>对，这里直接使用了jdk的Proxy类来创建代理对象。这里的关键在于InvokerInvocationHandler的实现：</h5><pre><code class=\"lang-java\">public class InvokerInvocationHandler implements InvocationHandler {\n\n    private final Invoker&lt;?&gt; invoker; //实际执行对象\n\n    //通过Invoker初始化\n    public InvokerInvocationHandler(Invoker&lt;?&gt; handler) {\n        this.invoker = handler;\n    }\n\n    //代理调用的实际过程\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        String methodName = method.getName(); //获取方法名\n        Class&lt;?&gt;[] parameterTypes = method.getParameterTypes(); //方法参数类型\n        if (method.getDeclaringClass() == Object.class) {\n            //判断方法是不是属于Object类的方法。比如getClass、clone、notify等方法。如果是的话直接委托给invoker本身去执行。\n            return method.invoke(invoker, args);\n        }\n        if (&quot;toString&quot;.equals(methodName) &amp;&amp; parameterTypes.length == 0) {\n            //如果重写了toString方法。则调用invoker的toString\n            return invoker.toString();\n        }\n        if (&quot;hashCode&quot;.equals(methodName) &amp;&amp; parameterTypes.length == 0) {\n            //如果重写了hashCode方法。则调用invoker的hashCode\n            return invoker.hashCode();\n        }\n        if (&quot;equals&quot;.equals(methodName) &amp;&amp; parameterTypes.length == 1) {\n            //如果重写了equals方法。则调用invoker的equals\n            return invoker.equals(args[0]);\n        }\n        //否则，通过method和args创建一个RpcInvocation。通过该Invocation去执行invoker调用。并且返回调用结果\n        return invoker.invoke(new RpcInvocation(method, args)).recreate();\n    }\n\n}\n</code></pre>\n<h5 id=\"可以看到，jdk的实现方式很简单，只是将实际执行对象由我们平时的实际类指向了invoker\"><a href=\"#可以看到，jdk的实现方式很简单，只是将实际执行对象由我们平时的实际类指向了invoker\" class=\"headerlink\" title=\"可以看到，jdk的实现方式很简单，只是将实际执行对象由我们平时的实际类指向了invoker\"></a>可以看到，jdk的实现方式很简单，只是将实际执行对象由我们平时的实际类指向了invoker</h5><h3 id=\"getInvoker\"><a href=\"#getInvoker\" class=\"headerlink\" title=\"getInvoker\"></a>getInvoker</h3><pre><code class=\"lang-java\">public &lt;T&gt; Invoker&lt;T&gt; getInvoker(T proxy, Class&lt;T&gt; type, URL url) {\n        return new AbstractProxyInvoker&lt;T&gt;(proxy, type, url) {\n            @Override\n            protected Object doInvoke(T proxy, String methodName,\n                                      Class&lt;?&gt;[] parameterTypes,\n                                      Object[] arguments) throws Throwable {\n                Method method = proxy.getClass().getMethod(methodName, parameterTypes);\n                return method.invoke(proxy, arguments);\n            }\n        };\n    }\n</code></pre>\n<h5 id=\"getInvoker方法通过实际执行方法和类去创建一个Invoker。JDK实现方式是创建一个匿名AbstractProxyInvoker类，并实现其doInvoke方法。doInvoke方法中通过反射获取到目标方法。然后再通过反射去执行。\"><a href=\"#getInvoker方法通过实际执行方法和类去创建一个Invoker。JDK实现方式是创建一个匿名AbstractProxyInvoker类，并实现其doInvoke方法。doInvoke方法中通过反射获取到目标方法。然后再通过反射去执行。\" class=\"headerlink\" title=\"getInvoker方法通过实际执行方法和类去创建一个Invoker。JDK实现方式是创建一个匿名AbstractProxyInvoker类，并实现其doInvoke方法。doInvoke方法中通过反射获取到目标方法。然后再通过反射去执行。\"></a>getInvoker方法通过实际执行方法和类去创建一个Invoker。JDK实现方式是创建一个匿名AbstractProxyInvoker类，并实现其doInvoke方法。doInvoke方法中通过反射获取到目标方法。然后再通过反射去执行。</h5><h5 id=\"查看AbstractProxyInvoker类，会发现doInvoke是invoke的实际实现。因此对于代理的整个初始化流程：\"><a href=\"#查看AbstractProxyInvoker类，会发现doInvoke是invoke的实际实现。因此对于代理的整个初始化流程：\" class=\"headerlink\" title=\"查看AbstractProxyInvoker类，会发现doInvoke是invoke的实际实现。因此对于代理的整个初始化流程：\"></a>查看AbstractProxyInvoker类，会发现doInvoke是invoke的实际实现。因此对于代理的整个初始化流程：</h5><ol>\n<li>拿到实际执行对象，通过该对象去创建Invoker</li>\n<li>通过Invoker再去创建代理对象</li>\n</ol>\n<h2 id=\"javassist实现方式\"><a href=\"#javassist实现方式\" class=\"headerlink\" title=\"javassist实现方式\"></a>javassist实现方式</h2><pre><code class=\"lang-java\">public class JavassistProxyFactory extends AbstractProxyFactory {\n\n    @SuppressWarnings(&quot;unchecked&quot;)\n    public &lt;T&gt; T getProxy(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] interfaces) {\n        return (T) Proxy.getProxy(interfaces).newInstance(new InvokerInvocationHandler(invoker));\n    }\n\n    public &lt;T&gt; Invoker&lt;T&gt; getInvoker(T proxy, Class&lt;T&gt; type, URL url) {\n        // TODO Wrapper cannot handle this scenario correctly: the classname contains &#39;$&#39;\n        final Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf(&#39;$&#39;) &lt; 0 ? proxy.getClass() : type);\n        return new AbstractProxyInvoker&lt;T&gt;(proxy, type, url) {\n            @Override\n            protected Object doInvoke(T proxy, String methodName,\n                                      Class&lt;?&gt;[] parameterTypes,\n                                      Object[] arguments) throws Throwable {\n                return wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);\n            }\n        };\n    }\n\n}\n</code></pre>\n<h3 id=\"getProxy-1\"><a href=\"#getProxy-1\" class=\"headerlink\" title=\"getProxy\"></a>getProxy</h3><pre><code class=\"lang-java\">public &lt;T&gt; T getProxy(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] interfaces) {\n        return (T) Proxy.getProxy(interfaces).newInstance(new InvokerInvocationHandler(invoker));\n    }\n</code></pre>\n<h5 id=\"和jdk的生成方式差不多，但是这里的Proxy不是jdk自带的类，而是com-alibaba-dubbo-common-bytecode-Proxy，该类的主要作用就是通过javassist的字节码技术去动态的创建代理类，下面我们来看下该类的主要实现方法：\"><a href=\"#和jdk的生成方式差不多，但是这里的Proxy不是jdk自带的类，而是com-alibaba-dubbo-common-bytecode-Proxy，该类的主要作用就是通过javassist的字节码技术去动态的创建代理类，下面我们来看下该类的主要实现方法：\" class=\"headerlink\" title=\"和jdk的生成方式差不多，但是这里的Proxy不是jdk自带的类，而是com.alibaba.dubbo.common.bytecode.Proxy，该类的主要作用就是通过javassist的字节码技术去动态的创建代理类，下面我们来看下该类的主要实现方法：\"></a>和jdk的生成方式差不多，但是这里的Proxy不是jdk自带的类，而是<strong>com.alibaba.dubbo.common.bytecode.Proxy</strong>，该类的主要作用就是通过javassist的字节码技术去动态的创建代理类，下面我们来看下该类的主要实现方法：</h5><pre><code class=\"lang-java\">public static Proxy getProxy(ClassLoader cl, Class&lt;?&gt;... ics) {\n        if (ics.length &gt; 65535)\n            throw new IllegalArgumentException(&quot;interface limit exceeded&quot;);\n\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i &lt; ics.length; i++) {\n            String itf = ics[i].getName();\n            if (!ics[i].isInterface())\n                throw new RuntimeException(itf + &quot; is not a interface.&quot;);\n\n            Class&lt;?&gt; tmp = null;\n            try {\n                tmp = Class.forName(itf, false, cl);\n            } catch (ClassNotFoundException e) {\n            }\n\n            if (tmp != ics[i])\n                throw new IllegalArgumentException(ics[i] + &quot; is not visible from class loader&quot;);\n\n            sb.append(itf).append(&#39;;&#39;);\n        }\n\n        // use interface class name list as key.\n        String key = sb.toString();\n\n        // get cache by class loader.\n        Map&lt;String, Object&gt; cache;\n        synchronized (ProxyCacheMap) {\n            cache = ProxyCacheMap.get(cl);\n            if (cache == null) {\n                cache = new HashMap&lt;String, Object&gt;();\n                ProxyCacheMap.put(cl, cache);\n            }\n        }\n\n        Proxy proxy = null;\n        synchronized (cache) {\n            do {\n                Object value = cache.get(key);\n                if (value instanceof Reference&lt;?&gt;) {\n                    proxy = (Proxy) ((Reference&lt;?&gt;) value).get();\n                    if (proxy != null)\n                        return proxy;\n                }\n\n                if (value == PendingGenerationMarker) {\n                    try {\n                        cache.wait();\n                    } catch (InterruptedException e) {\n                    }\n                } else {\n                    cache.put(key, PendingGenerationMarker);\n                    break;\n                }\n            }\n            while (true);\n        }\n\n        long id = PROXY_CLASS_COUNTER.getAndIncrement();\n        String pkg = null;\n        ClassGenerator ccp = null, ccm = null;\n        try {\n            ccp = ClassGenerator.newInstance(cl);\n\n            Set&lt;String&gt; worked = new HashSet&lt;String&gt;();\n            List&lt;Method&gt; methods = new ArrayList&lt;Method&gt;();\n\n            for (int i = 0; i &lt; ics.length; i++) {\n                if (!Modifier.isPublic(ics[i].getModifiers())) {\n                    String npkg = ics[i].getPackage().getName();\n                    if (pkg == null) {\n                        pkg = npkg;\n                    } else {\n                        if (!pkg.equals(npkg))\n                            throw new IllegalArgumentException(&quot;non-public interfaces from different packages&quot;);\n                    }\n                }\n                ccp.addInterface(ics[i]);\n\n                for (Method method : ics[i].getMethods()) {\n                    String desc = ReflectUtils.getDesc(method);\n                    if (worked.contains(desc))\n                        continue;\n                    worked.add(desc);\n\n                    int ix = methods.size();\n                    Class&lt;?&gt; rt = method.getReturnType();\n                    Class&lt;?&gt;[] pts = method.getParameterTypes();\n\n                    StringBuilder code = new StringBuilder(&quot;Object[] args = new Object[&quot;).append(pts.length).append(&quot;];&quot;);\n                    for (int j = 0; j &lt; pts.length; j++)\n                        code.append(&quot; args[&quot;).append(j).append(&quot;] = ($w)$&quot;).append(j + 1).append(&quot;;&quot;);\n                    code.append(&quot; Object ret = handler.invoke(this, methods[&quot; + ix + &quot;], args);&quot;);\n                    if (!Void.TYPE.equals(rt))\n                        code.append(&quot; return &quot;).append(asArgument(rt, &quot;ret&quot;)).append(&quot;;&quot;);\n\n                    methods.add(method);\n                    ccp.addMethod(method.getName(), method.getModifiers(), rt, pts, method.getExceptionTypes(), code.toString());\n                }\n            }\n\n            if (pkg == null)\n                pkg = PACKAGE_NAME;\n\n            // create ProxyInstance class.\n            String pcn = pkg + &quot;.proxy&quot; + id;\n            ccp.setClassName(pcn);\n            ccp.addField(&quot;public static java.lang.reflect.Method[] methods;&quot;);\n            ccp.addField(&quot;private &quot; + InvocationHandler.class.getName() + &quot; handler;&quot;);\n            ccp.addConstructor(Modifier.PUBLIC, new Class&lt;?&gt;[]{InvocationHandler.class}, new Class&lt;?&gt;[0], &quot;handler=$1;&quot;);\n            ccp.addDefaultConstructor();\n            Class&lt;?&gt; clazz = ccp.toClass();\n            clazz.getField(&quot;methods&quot;).set(null, methods.toArray(new Method[0]));\n\n            // create Proxy class.\n            String fcn = Proxy.class.getName() + id;\n            ccm = ClassGenerator.newInstance(cl);\n            ccm.setClassName(fcn);\n            ccm.addDefaultConstructor();\n            ccm.setSuperClass(Proxy.class);\n            ccm.addMethod(&quot;public Object newInstance(&quot; + InvocationHandler.class.getName() + &quot; h){ return new &quot; + pcn + &quot;($1); }&quot;);\n            Class&lt;?&gt; pc = ccm.toClass();\n            proxy = (Proxy) pc.newInstance();\n        } catch (RuntimeException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new RuntimeException(e.getMessage(), e);\n        } finally {\n            // release ClassGenerator\n            if (ccp != null)\n                ccp.release();\n            if (ccm != null)\n                ccm.release();\n            synchronized (cache) {\n                if (proxy == null)\n                    cache.remove(key);\n                else\n                    cache.put(key, new WeakReference&lt;Proxy&gt;(proxy));\n                cache.notifyAll();\n            }\n        }\n        return proxy;\n    }\n</code></pre>\n<h5 id=\"该方法通过ClassLoader和Class接口生成一个Proxy类（注意是Proxy类，而不是之前的getProxy的泛型T类，实际上该Proxy就是该方法所处的类）-代码比较长，以下它的实现过程：\"><a href=\"#该方法通过ClassLoader和Class接口生成一个Proxy类（注意是Proxy类，而不是之前的getProxy的泛型T类，实际上该Proxy就是该方法所处的类）-代码比较长，以下它的实现过程：\" class=\"headerlink\" title=\"该方法通过ClassLoader和Class接口生成一个Proxy类（注意是Proxy类，而不是之前的getProxy的泛型T类，实际上该Proxy就是该方法所处的类） 代码比较长，以下它的实现过程：\"></a>该方法通过ClassLoader和Class接口生成一个Proxy类（注意是Proxy类，而不是之前的getProxy的泛型T类，实际上该Proxy就是该方法所处的类） 代码比较长，以下它的实现过程：</h5><ol>\n<li>遍历所有入参接口，以;分割连接起来，以它为key以map为缓存查找如果有，说明代理对象已创建返回</li>\n<li>利用AtomicLong对象自增获取一个long数组来作为生产类的后缀，防止冲突</li>\n<li>遍历接口获取所有定义的方法<ol>\n<li>将方法签名解析成字符串，加入到一个集合Set<string> worked中 ，用来判重</string></li>\n<li>获取方法应该在methods数组中的索引下标ix</li>\n<li>获取方法的参数类型以及返回类型</li>\n<li>构建方法体return ret= handler.invoke(this, methods[ix], args);这里的方法调用其实是委托给InvokerInvocationHandler实例对象的，去调用真正的实例</li>\n<li>方法加入到methods数组中；将字符串构建的方法加入到代理类中</li>\n</ol>\n</li>\n<li>创建代理实例对象ProxyInstance<ol>\n<li>类名为  pkg + “.poxy”+id = 包名 + “.poxy” +自增数值</li>\n<li>添加静态字段Method[] methods; 保存了该代理类代理的所有方法。在代理方法体中直接通过数组下表ix来获取方法</li>\n<li>添加实例对象InvocationHandler handler；代理实际上就是将方法的的执行给了handler。该handler的实现和jdk中的handler是同一个。</li>\n<li>创建构造函数，构造函数的参数就是上面的InvocationHandler</li>\n<li>添加默认构造函数</li>\n<li>利用工具类ClassGenerator生成对应的字节码</li>\n</ol>\n</li>\n<li>创建代理对象，它的newInstance(handler)方法用来创建基于我们接口的代理<ol>\n<li>代理对象名Proxy + id</li>\n<li>添加默认构造器</li>\n<li>实现方法newInstance代码，return new pcn(hadler) 这里pcn就是前面生成的代理对象类名</li>\n<li>利用工具类ClassGenerator生成字节码并实例化对象返回</li>\n</ol>\n</li>\n</ol>\n<h5 id=\"通过Proxy-getProxy-interfaces-创建了代理类之后，再调用newInstance方法，通过InvokerInvocationHandler和Invoker创建了代理实例；\"><a href=\"#通过Proxy-getProxy-interfaces-创建了代理类之后，再调用newInstance方法，通过InvokerInvocationHandler和Invoker创建了代理实例；\" class=\"headerlink\" title=\"通过Proxy.getProxy(interfaces)创建了代理类之后，再调用newInstance方法，通过InvokerInvocationHandler和Invoker创建了代理实例；\"></a>通过<strong>Proxy.getProxy(interfaces)</strong>创建了代理类之后，再调用newInstance方法，通过InvokerInvocationHandler和Invoker创建了代理实例；</h5><h3 id=\"getInvoker-1\"><a href=\"#getInvoker-1\" class=\"headerlink\" title=\"getInvoker\"></a>getInvoker</h3><pre><code class=\"lang-java\">public &lt;T&gt; Invoker&lt;T&gt; getInvoker(T proxy, Class&lt;T&gt; type, URL url) {\n        final Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf(&#39;$&#39;) &lt; 0 ? proxy.getClass() : type);\n        return new AbstractProxyInvoker&lt;T&gt;(proxy, type, url) {\n            @Override\n            protected Object doInvoke(T proxy, String methodName,\n                                      Class&lt;?&gt;[] parameterTypes,\n                                      Object[] arguments) throws Throwable {\n                return wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);\n            }\n        };\n    }\n</code></pre>\n<h5 id=\"实现过程如下：\"><a href=\"#实现过程如下：\" class=\"headerlink\" title=\"实现过程如下：\"></a>实现过程如下：</h5><ol>\n<li>根据传入的 proxy对象的类信息创建对它的包装对象Wrapper,这里同样是通过javassist生成字节码创建的。详细的过程就不介绍了，和上面的过程很类似</li>\n<li>返回AbstractProxyInvoker对象实例，这个invoker对象invoke方法可以根据传入的invocation对象中包含的方法名，方法参数来调用wrapper对象返回调用结果</li>\n</ol>\n<h2 id=\"StubProxyFactoryWrapper\"><a href=\"#StubProxyFactoryWrapper\" class=\"headerlink\" title=\"StubProxyFactoryWrapper\"></a>StubProxyFactoryWrapper</h2><pre><code class=\"lang-java\">public class StubProxyFactoryWrapper implements ProxyFactory {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(StubProxyFactoryWrapper.class);\n\n    private final ProxyFactory proxyFactory;\n\n    private Protocol protocol;\n\n    public StubProxyFactoryWrapper(ProxyFactory proxyFactory) {\n        this.proxyFactory = proxyFactory;\n    }\n\n    public void setProtocol(Protocol protocol) {\n        this.protocol = protocol;\n    }\n\n    @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})\n    public &lt;T&gt; T getProxy(Invoker&lt;T&gt; invoker) throws RpcException {\n        T proxy = proxyFactory.getProxy(invoker);\n        if (GenericService.class != invoker.getInterface()) {\n            String stub = invoker.getUrl().getParameter(Constants.STUB_KEY, invoker.getUrl().getParameter(Constants.LOCAL_KEY));\n            if (ConfigUtils.isNotEmpty(stub)) {\n                Class&lt;?&gt; serviceType = invoker.getInterface();\n                if (ConfigUtils.isDefault(stub)) {\n                    if (invoker.getUrl().hasParameter(Constants.STUB_KEY)) {\n                        stub = serviceType.getName() + &quot;Stub&quot;;\n                    } else {\n                        stub = serviceType.getName() + &quot;Local&quot;;\n                    }\n                }\n                try {\n                    Class&lt;?&gt; stubClass = ReflectUtils.forName(stub);\n                    if (!serviceType.isAssignableFrom(stubClass)) {\n                        throw new IllegalStateException(&quot;The stub implementation class &quot; + stubClass.getName() + &quot; not implement interface &quot; + serviceType.getName());\n                    }\n                    try {\n                        Constructor&lt;?&gt; constructor = ReflectUtils.findConstructor(stubClass, serviceType);\n                        proxy = (T) constructor.newInstance(new Object[]{proxy});\n                        //export stub service\n                        URL url = invoker.getUrl();\n                        if (url.getParameter(Constants.STUB_EVENT_KEY, Constants.DEFAULT_STUB_EVENT)) {\n                            url = url.addParameter(Constants.STUB_EVENT_METHODS_KEY, StringUtils.join(Wrapper.getWrapper(proxy.getClass()).getDeclaredMethodNames(), &quot;,&quot;));\n                            url = url.addParameter(Constants.IS_SERVER_KEY, Boolean.FALSE.toString());\n                            try {\n                                export(proxy, (Class) invoker.getInterface(), url);\n                            } catch (Exception e) {\n                                LOGGER.error(&quot;export a stub service error.&quot;, e);\n                            }\n                        }\n                    } catch (NoSuchMethodException e) {\n                        throw new IllegalStateException(&quot;No such constructor \\&quot;public &quot; + stubClass.getSimpleName() + &quot;(&quot; + serviceType.getName() + &quot;)\\&quot; in stub implementation class &quot; + stubClass.getName(), e);\n                    }\n                } catch (Throwable t) {\n                    LOGGER.error(&quot;Failed to create stub implementation class &quot; + stub + &quot; in consumer &quot; + NetUtils.getLocalHost() + &quot; use dubbo version &quot; + Version.getVersion() + &quot;, cause: &quot; + t.getMessage(), t);\n                    // ignore\n                }\n            }\n        }\n        return proxy;\n    }\n\n    public &lt;T&gt; Invoker&lt;T&gt; getInvoker(T proxy, Class&lt;T&gt; type, URL url) throws RpcException {\n        return proxyFactory.getInvoker(proxy, type, url);\n    }\n\n    private &lt;T&gt; Exporter&lt;T&gt; export(T instance, Class&lt;T&gt; type, URL url) {\n        return protocol.export(proxyFactory.getInvoker(instance, type, url));\n    }\n\n}\n</code></pre>\n<h5 id=\"StubProxyFactoryWrapper实现了对代理工厂进行装饰的功能，主要用于暴露服务提供者的本地服务给远端消费者来调用\"><a href=\"#StubProxyFactoryWrapper实现了对代理工厂进行装饰的功能，主要用于暴露服务提供者的本地服务给远端消费者来调用\" class=\"headerlink\" title=\"StubProxyFactoryWrapper实现了对代理工厂进行装饰的功能，主要用于暴露服务提供者的本地服务给远端消费者来调用\"></a>StubProxyFactoryWrapper实现了对代理工厂进行装饰的功能，主要用于暴露服务提供者的本地服务给远端消费者来调用</h5><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><h5 id=\"jdk和javassist的实现的区别就在于是jdk提供的字节码功能还是通过javassist来自定义类。本质上来说原理是一样的。整个的流程就像前面提到的\"><a href=\"#jdk和javassist的实现的区别就在于是jdk提供的字节码功能还是通过javassist来自定义类。本质上来说原理是一样的。整个的流程就像前面提到的\" class=\"headerlink\" title=\"jdk和javassist的实现的区别就在于是jdk提供的字节码功能还是通过javassist来自定义类。本质上来说原理是一样的。整个的流程就像前面提到的\"></a>jdk和javassist的实现的区别就在于是jdk提供的字节码功能还是通过javassist来自定义类。本质上来说原理是一样的。整个的流程就像前面提到的</h5><ol>\n<li>拿到<strong>实际执行对象</strong>，通过该对象去创建Invoker</li>\n<li>通过Invoker再去创建代理对象</li>\n</ol>\n<h5 id=\"但是其中有一些问题需要去思考：\"><a href=\"#但是其中有一些问题需要去思考：\" class=\"headerlink\" title=\"但是其中有一些问题需要去思考：\"></a>但是其中有一些问题需要去思考：</h5><ol>\n<li>这个代理的流程是从哪里发起的</li>\n<li>如果是消费端，只有服务的接口，没有实际执行的对象。那么这个代理是如何产生的；</li>\n<li>为什么javassist的getInvoker中，还需要实现wrapper类</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h5 id=\"动态代理对于dubbo来说不是必须的，没有代理实现，dubbo一样可以运行。但是dubbo的一个重要的特点就是调用远程服务就像调用本地服务一样的方便。这其中对于其调用过程的隐藏就是通过动态代理来实现的。动态代理本身就就不详细介绍了，可以参考之前的一篇文章：java动态代理实现\"><a href=\"#动态代理对于dubbo来说不是必须的，没有代理实现，dubbo一样可以运行。但是dubbo的一个重要的特点就是调用远程服务就像调用本地服务一样的方便。这其中对于其调用过程的隐藏就是通过动态代理来实现的。动态代理本身就就不详细介绍了，可以参考之前的一篇文章：java动态代理实现\" class=\"headerlink\" title=\"动态代理对于dubbo来说不是必须的，没有代理实现，dubbo一样可以运行。但是dubbo的一个重要的特点就是调用远程服务就像调用本地服务一样的方便。这其中对于其调用过程的隐藏就是通过动态代理来实现的。动态代理本身就就不详细介绍了，可以参考之前的一篇文章：java动态代理实现\"></a>动态代理对于dubbo来说不是必须的，没有代理实现，dubbo一样可以运行。但是dubbo的一个重要的特点就是调用远程服务就像调用本地服务一样的方便。这其中对于其调用过程的隐藏就是通过动态代理来实现的。动态代理本身就就不详细介绍了，可以参考之前的一篇文章：<a href=\"https://winx402.github.io/note/javaDynamicProxy/\" target=\"_blank\" rel=\"external\">java动态代理实现</a></h5>","more":"<h3 id=\"扩展接口：\"><a href=\"#扩展接口：\" class=\"headerlink\" title=\"扩展接口：\"></a>扩展接口：</h3><h5 id=\"com-alibaba-dubbo-rpc-ProxyFactory\"><a href=\"#com-alibaba-dubbo-rpc-ProxyFactory\" class=\"headerlink\" title=\"com.alibaba.dubbo.rpc.ProxyFactory\"></a><code>com.alibaba.dubbo.rpc.ProxyFactory</code></h5><h3 id=\"使用配置\"><a href=\"#使用配置\" class=\"headerlink\" title=\"使用配置:\"></a>使用配置:</h3><pre><code class=\"lang-xml\">&lt;dubbo:consumer proxy=&quot;&quot; /&gt;\n&lt;dubbo:provider proxy=&quot;&quot; /&gt;\n</code></pre>\n<h3 id=\"目前已知扩展：\"><a href=\"#目前已知扩展：\" class=\"headerlink\" title=\"目前已知扩展：\"></a>目前已知扩展：</h3><ul>\n<li>stub=com.alibaba.dubbo.rpc.proxy.wrapper.StubProxyFactoryWrapper</li>\n<li>jdk=com.alibaba.dubbo.rpc.proxy.jdk.JdkProxyFactory</li>\n<li>javassist=com.alibaba.dubbo.rpc.proxy.javassist.JavassistProxyFactory</li>\n</ul>\n<h3 id=\"包结构：\"><a href=\"#包结构：\" class=\"headerlink\" title=\"包结构：\"></a>包结构：</h3><p><img src=\"/img/note/dubbo/dubbo1.png\" alt=\"\"></p>\n<h3 id=\"ProxyFactory\"><a href=\"#ProxyFactory\" class=\"headerlink\" title=\"ProxyFactory\"></a>ProxyFactory</h3><pre><code class=\"lang-java\">@SPI(&quot;javassist&quot;) //默认使用javassist\npublic interface ProxyFactory {\n\n    /**\n     * 通过Invoker创建代理\n     *\n     * @param invoker dubbo的可执行单元\n     * @return proxy java代理对象\n     */\n    @Adaptive({Constants.PROXY_KEY})\n    &lt;T&gt; T getProxy(Invoker&lt;T&gt; invoker) throws RpcException;\n\n    /**\n     * 创建 invoker.\n     *\n     * @param &lt;T&gt;\n     * @param proxy\n     * @param type\n     * @param url\n     * @return invoker\n     */\n    @Adaptive({Constants.PROXY_KEY})\n    &lt;T&gt; Invoker&lt;T&gt; getInvoker(T proxy, Class&lt;T&gt; type, URL url) throws RpcException;\n}\n</code></pre>\n<h3 id=\"AbstractProxyFactory\"><a href=\"#AbstractProxyFactory\" class=\"headerlink\" title=\"AbstractProxyFactory\"></a>AbstractProxyFactory</h3><h5 id=\"AbstractProxyFactory实现了之前的ProxyFactory接口以及其方法getProxy的通用实现\"><a href=\"#AbstractProxyFactory实现了之前的ProxyFactory接口以及其方法getProxy的通用实现\" class=\"headerlink\" title=\"AbstractProxyFactory实现了之前的ProxyFactory接口以及其方法getProxy的通用实现\"></a><strong>AbstractProxyFactory</strong>实现了之前的<strong>ProxyFactory</strong>接口以及其方法getProxy的通用实现</h5><pre><code class=\"lang-java\">public abstract class AbstractProxyFactory implements ProxyFactory {\n\n    public &lt;T&gt; T getProxy(Invoker&lt;T&gt; invoker) throws RpcException {\n        Class&lt;?&gt;[] interfaces = null;\n        String config = invoker.getUrl().getParameter(&quot;interfaces&quot;);\n        if (config != null &amp;&amp; config.length() &gt; 0) {\n            String[] types = Constants.COMMA_SPLIT_PATTERN.split(config);\n            if (types != null &amp;&amp; types.length &gt; 0) {\n                interfaces = new Class&lt;?&gt;[types.length + 2];\n                interfaces[0] = invoker.getInterface();\n                interfaces[1] = EchoService.class;\n                for (int i = 0; i &lt; types.length; i++) {\n                    interfaces[i + 1] = ReflectUtils.forName(types[i]);\n                }\n            }\n        }\n        if (interfaces == null) {\n            interfaces = new Class&lt;?&gt;[]{invoker.getInterface(), EchoService.class};\n        }\n        return getProxy(invoker, interfaces);\n    }\n\n    public abstract &lt;T&gt; T getProxy(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] types);\n}\n</code></pre>\n<h5 id=\"getProxy方法主要是将该代理需要实现的接口给确定好，该接口存储在invoker对象的url的interfaces参数中，是一个字符串，用逗号分隔，我们不需要关心interfaces中存储的到底是哪些接口，只需要知道的是，invoker-getInterface-和EchoService-class会加入到其中，而另一个重载的getProxy方法显然是丢给子类来实现了。\"><a href=\"#getProxy方法主要是将该代理需要实现的接口给确定好，该接口存储在invoker对象的url的interfaces参数中，是一个字符串，用逗号分隔，我们不需要关心interfaces中存储的到底是哪些接口，只需要知道的是，invoker-getInterface-和EchoService-class会加入到其中，而另一个重载的getProxy方法显然是丢给子类来实现了。\" class=\"headerlink\" title=\"getProxy方法主要是将该代理需要实现的接口给确定好，该接口存储在invoker对象的url的interfaces参数中，是一个字符串，用逗号分隔，我们不需要关心interfaces中存储的到底是哪些接口，只需要知道的是，invoker.getInterface()和EchoService.class会加入到其中，而另一个重载的getProxy方法显然是丢给子类来实现了。\"></a>getProxy方法主要是将该代理需要实现的接口给确定好，该接口存储在invoker对象的url的interfaces参数中，是一个字符串，用逗号分隔，我们不需要关心interfaces中存储的到底是哪些接口，只需要知道的是，invoker.getInterface()和EchoService.class会加入到其中，而另一个重载的getProxy方法显然是丢给子类来实现了。</h5><h2 id=\"jdk实现方式\"><a href=\"#jdk实现方式\" class=\"headerlink\" title=\"jdk实现方式\"></a>jdk实现方式</h2><pre><code class=\"lang-java\">/**\n * JdkProxyFactory\n * 继承了AbstractProxyFactory\n */\npublic class JdkProxyFactory extends AbstractProxyFactory {\n\n    @SuppressWarnings(&quot;unchecked&quot;)\n    public &lt;T&gt; T getProxy(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] interfaces) {\n        return (T) Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), interfaces, new InvokerInvocationHandler(invoker));\n    }\n\n    public &lt;T&gt; Invoker&lt;T&gt; getInvoker(T proxy, Class&lt;T&gt; type, URL url) {\n        return new AbstractProxyInvoker&lt;T&gt;(proxy, type, url) {\n            @Override\n            protected Object doInvoke(T proxy, String methodName,\n                                      Class&lt;?&gt;[] parameterTypes,\n                                      Object[] arguments) throws Throwable {\n                Method method = proxy.getClass().getMethod(methodName, parameterTypes);\n                return method.invoke(proxy, arguments);\n            }\n        };\n    }\n\n}\n</code></pre>\n<h5 id=\"JdkProxyFactory继承了AbstractProxyFactory，并实现了其抽象方法\"><a href=\"#JdkProxyFactory继承了AbstractProxyFactory，并实现了其抽象方法\" class=\"headerlink\" title=\"JdkProxyFactory继承了AbstractProxyFactory，并实现了其抽象方法\"></a>JdkProxyFactory继承了AbstractProxyFactory，并实现了其抽象方法</h5><h3 id=\"getProxy\"><a href=\"#getProxy\" class=\"headerlink\" title=\"getProxy\"></a>getProxy</h3><pre><code class=\"lang-java\">public &lt;T&gt; T getProxy(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] interfaces) {\n        return (T) Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), interfaces, new InvokerInvocationHandler(invoker));\n    }\n</code></pre>\n<h5 id=\"对，这里直接使用了jdk的Proxy类来创建代理对象。这里的关键在于InvokerInvocationHandler的实现：\"><a href=\"#对，这里直接使用了jdk的Proxy类来创建代理对象。这里的关键在于InvokerInvocationHandler的实现：\" class=\"headerlink\" title=\"对，这里直接使用了jdk的Proxy类来创建代理对象。这里的关键在于InvokerInvocationHandler的实现：\"></a>对，这里直接使用了jdk的Proxy类来创建代理对象。这里的关键在于InvokerInvocationHandler的实现：</h5><pre><code class=\"lang-java\">public class InvokerInvocationHandler implements InvocationHandler {\n\n    private final Invoker&lt;?&gt; invoker; //实际执行对象\n\n    //通过Invoker初始化\n    public InvokerInvocationHandler(Invoker&lt;?&gt; handler) {\n        this.invoker = handler;\n    }\n\n    //代理调用的实际过程\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        String methodName = method.getName(); //获取方法名\n        Class&lt;?&gt;[] parameterTypes = method.getParameterTypes(); //方法参数类型\n        if (method.getDeclaringClass() == Object.class) {\n            //判断方法是不是属于Object类的方法。比如getClass、clone、notify等方法。如果是的话直接委托给invoker本身去执行。\n            return method.invoke(invoker, args);\n        }\n        if (&quot;toString&quot;.equals(methodName) &amp;&amp; parameterTypes.length == 0) {\n            //如果重写了toString方法。则调用invoker的toString\n            return invoker.toString();\n        }\n        if (&quot;hashCode&quot;.equals(methodName) &amp;&amp; parameterTypes.length == 0) {\n            //如果重写了hashCode方法。则调用invoker的hashCode\n            return invoker.hashCode();\n        }\n        if (&quot;equals&quot;.equals(methodName) &amp;&amp; parameterTypes.length == 1) {\n            //如果重写了equals方法。则调用invoker的equals\n            return invoker.equals(args[0]);\n        }\n        //否则，通过method和args创建一个RpcInvocation。通过该Invocation去执行invoker调用。并且返回调用结果\n        return invoker.invoke(new RpcInvocation(method, args)).recreate();\n    }\n\n}\n</code></pre>\n<h5 id=\"可以看到，jdk的实现方式很简单，只是将实际执行对象由我们平时的实际类指向了invoker\"><a href=\"#可以看到，jdk的实现方式很简单，只是将实际执行对象由我们平时的实际类指向了invoker\" class=\"headerlink\" title=\"可以看到，jdk的实现方式很简单，只是将实际执行对象由我们平时的实际类指向了invoker\"></a>可以看到，jdk的实现方式很简单，只是将实际执行对象由我们平时的实际类指向了invoker</h5><h3 id=\"getInvoker\"><a href=\"#getInvoker\" class=\"headerlink\" title=\"getInvoker\"></a>getInvoker</h3><pre><code class=\"lang-java\">public &lt;T&gt; Invoker&lt;T&gt; getInvoker(T proxy, Class&lt;T&gt; type, URL url) {\n        return new AbstractProxyInvoker&lt;T&gt;(proxy, type, url) {\n            @Override\n            protected Object doInvoke(T proxy, String methodName,\n                                      Class&lt;?&gt;[] parameterTypes,\n                                      Object[] arguments) throws Throwable {\n                Method method = proxy.getClass().getMethod(methodName, parameterTypes);\n                return method.invoke(proxy, arguments);\n            }\n        };\n    }\n</code></pre>\n<h5 id=\"getInvoker方法通过实际执行方法和类去创建一个Invoker。JDK实现方式是创建一个匿名AbstractProxyInvoker类，并实现其doInvoke方法。doInvoke方法中通过反射获取到目标方法。然后再通过反射去执行。\"><a href=\"#getInvoker方法通过实际执行方法和类去创建一个Invoker。JDK实现方式是创建一个匿名AbstractProxyInvoker类，并实现其doInvoke方法。doInvoke方法中通过反射获取到目标方法。然后再通过反射去执行。\" class=\"headerlink\" title=\"getInvoker方法通过实际执行方法和类去创建一个Invoker。JDK实现方式是创建一个匿名AbstractProxyInvoker类，并实现其doInvoke方法。doInvoke方法中通过反射获取到目标方法。然后再通过反射去执行。\"></a>getInvoker方法通过实际执行方法和类去创建一个Invoker。JDK实现方式是创建一个匿名AbstractProxyInvoker类，并实现其doInvoke方法。doInvoke方法中通过反射获取到目标方法。然后再通过反射去执行。</h5><h5 id=\"查看AbstractProxyInvoker类，会发现doInvoke是invoke的实际实现。因此对于代理的整个初始化流程：\"><a href=\"#查看AbstractProxyInvoker类，会发现doInvoke是invoke的实际实现。因此对于代理的整个初始化流程：\" class=\"headerlink\" title=\"查看AbstractProxyInvoker类，会发现doInvoke是invoke的实际实现。因此对于代理的整个初始化流程：\"></a>查看AbstractProxyInvoker类，会发现doInvoke是invoke的实际实现。因此对于代理的整个初始化流程：</h5><ol>\n<li>拿到实际执行对象，通过该对象去创建Invoker</li>\n<li>通过Invoker再去创建代理对象</li>\n</ol>\n<h2 id=\"javassist实现方式\"><a href=\"#javassist实现方式\" class=\"headerlink\" title=\"javassist实现方式\"></a>javassist实现方式</h2><pre><code class=\"lang-java\">public class JavassistProxyFactory extends AbstractProxyFactory {\n\n    @SuppressWarnings(&quot;unchecked&quot;)\n    public &lt;T&gt; T getProxy(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] interfaces) {\n        return (T) Proxy.getProxy(interfaces).newInstance(new InvokerInvocationHandler(invoker));\n    }\n\n    public &lt;T&gt; Invoker&lt;T&gt; getInvoker(T proxy, Class&lt;T&gt; type, URL url) {\n        // TODO Wrapper cannot handle this scenario correctly: the classname contains &#39;$&#39;\n        final Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf(&#39;$&#39;) &lt; 0 ? proxy.getClass() : type);\n        return new AbstractProxyInvoker&lt;T&gt;(proxy, type, url) {\n            @Override\n            protected Object doInvoke(T proxy, String methodName,\n                                      Class&lt;?&gt;[] parameterTypes,\n                                      Object[] arguments) throws Throwable {\n                return wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);\n            }\n        };\n    }\n\n}\n</code></pre>\n<h3 id=\"getProxy-1\"><a href=\"#getProxy-1\" class=\"headerlink\" title=\"getProxy\"></a>getProxy</h3><pre><code class=\"lang-java\">public &lt;T&gt; T getProxy(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] interfaces) {\n        return (T) Proxy.getProxy(interfaces).newInstance(new InvokerInvocationHandler(invoker));\n    }\n</code></pre>\n<h5 id=\"和jdk的生成方式差不多，但是这里的Proxy不是jdk自带的类，而是com-alibaba-dubbo-common-bytecode-Proxy，该类的主要作用就是通过javassist的字节码技术去动态的创建代理类，下面我们来看下该类的主要实现方法：\"><a href=\"#和jdk的生成方式差不多，但是这里的Proxy不是jdk自带的类，而是com-alibaba-dubbo-common-bytecode-Proxy，该类的主要作用就是通过javassist的字节码技术去动态的创建代理类，下面我们来看下该类的主要实现方法：\" class=\"headerlink\" title=\"和jdk的生成方式差不多，但是这里的Proxy不是jdk自带的类，而是com.alibaba.dubbo.common.bytecode.Proxy，该类的主要作用就是通过javassist的字节码技术去动态的创建代理类，下面我们来看下该类的主要实现方法：\"></a>和jdk的生成方式差不多，但是这里的Proxy不是jdk自带的类，而是<strong>com.alibaba.dubbo.common.bytecode.Proxy</strong>，该类的主要作用就是通过javassist的字节码技术去动态的创建代理类，下面我们来看下该类的主要实现方法：</h5><pre><code class=\"lang-java\">public static Proxy getProxy(ClassLoader cl, Class&lt;?&gt;... ics) {\n        if (ics.length &gt; 65535)\n            throw new IllegalArgumentException(&quot;interface limit exceeded&quot;);\n\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i &lt; ics.length; i++) {\n            String itf = ics[i].getName();\n            if (!ics[i].isInterface())\n                throw new RuntimeException(itf + &quot; is not a interface.&quot;);\n\n            Class&lt;?&gt; tmp = null;\n            try {\n                tmp = Class.forName(itf, false, cl);\n            } catch (ClassNotFoundException e) {\n            }\n\n            if (tmp != ics[i])\n                throw new IllegalArgumentException(ics[i] + &quot; is not visible from class loader&quot;);\n\n            sb.append(itf).append(&#39;;&#39;);\n        }\n\n        // use interface class name list as key.\n        String key = sb.toString();\n\n        // get cache by class loader.\n        Map&lt;String, Object&gt; cache;\n        synchronized (ProxyCacheMap) {\n            cache = ProxyCacheMap.get(cl);\n            if (cache == null) {\n                cache = new HashMap&lt;String, Object&gt;();\n                ProxyCacheMap.put(cl, cache);\n            }\n        }\n\n        Proxy proxy = null;\n        synchronized (cache) {\n            do {\n                Object value = cache.get(key);\n                if (value instanceof Reference&lt;?&gt;) {\n                    proxy = (Proxy) ((Reference&lt;?&gt;) value).get();\n                    if (proxy != null)\n                        return proxy;\n                }\n\n                if (value == PendingGenerationMarker) {\n                    try {\n                        cache.wait();\n                    } catch (InterruptedException e) {\n                    }\n                } else {\n                    cache.put(key, PendingGenerationMarker);\n                    break;\n                }\n            }\n            while (true);\n        }\n\n        long id = PROXY_CLASS_COUNTER.getAndIncrement();\n        String pkg = null;\n        ClassGenerator ccp = null, ccm = null;\n        try {\n            ccp = ClassGenerator.newInstance(cl);\n\n            Set&lt;String&gt; worked = new HashSet&lt;String&gt;();\n            List&lt;Method&gt; methods = new ArrayList&lt;Method&gt;();\n\n            for (int i = 0; i &lt; ics.length; i++) {\n                if (!Modifier.isPublic(ics[i].getModifiers())) {\n                    String npkg = ics[i].getPackage().getName();\n                    if (pkg == null) {\n                        pkg = npkg;\n                    } else {\n                        if (!pkg.equals(npkg))\n                            throw new IllegalArgumentException(&quot;non-public interfaces from different packages&quot;);\n                    }\n                }\n                ccp.addInterface(ics[i]);\n\n                for (Method method : ics[i].getMethods()) {\n                    String desc = ReflectUtils.getDesc(method);\n                    if (worked.contains(desc))\n                        continue;\n                    worked.add(desc);\n\n                    int ix = methods.size();\n                    Class&lt;?&gt; rt = method.getReturnType();\n                    Class&lt;?&gt;[] pts = method.getParameterTypes();\n\n                    StringBuilder code = new StringBuilder(&quot;Object[] args = new Object[&quot;).append(pts.length).append(&quot;];&quot;);\n                    for (int j = 0; j &lt; pts.length; j++)\n                        code.append(&quot; args[&quot;).append(j).append(&quot;] = ($w)$&quot;).append(j + 1).append(&quot;;&quot;);\n                    code.append(&quot; Object ret = handler.invoke(this, methods[&quot; + ix + &quot;], args);&quot;);\n                    if (!Void.TYPE.equals(rt))\n                        code.append(&quot; return &quot;).append(asArgument(rt, &quot;ret&quot;)).append(&quot;;&quot;);\n\n                    methods.add(method);\n                    ccp.addMethod(method.getName(), method.getModifiers(), rt, pts, method.getExceptionTypes(), code.toString());\n                }\n            }\n\n            if (pkg == null)\n                pkg = PACKAGE_NAME;\n\n            // create ProxyInstance class.\n            String pcn = pkg + &quot;.proxy&quot; + id;\n            ccp.setClassName(pcn);\n            ccp.addField(&quot;public static java.lang.reflect.Method[] methods;&quot;);\n            ccp.addField(&quot;private &quot; + InvocationHandler.class.getName() + &quot; handler;&quot;);\n            ccp.addConstructor(Modifier.PUBLIC, new Class&lt;?&gt;[]{InvocationHandler.class}, new Class&lt;?&gt;[0], &quot;handler=$1;&quot;);\n            ccp.addDefaultConstructor();\n            Class&lt;?&gt; clazz = ccp.toClass();\n            clazz.getField(&quot;methods&quot;).set(null, methods.toArray(new Method[0]));\n\n            // create Proxy class.\n            String fcn = Proxy.class.getName() + id;\n            ccm = ClassGenerator.newInstance(cl);\n            ccm.setClassName(fcn);\n            ccm.addDefaultConstructor();\n            ccm.setSuperClass(Proxy.class);\n            ccm.addMethod(&quot;public Object newInstance(&quot; + InvocationHandler.class.getName() + &quot; h){ return new &quot; + pcn + &quot;($1); }&quot;);\n            Class&lt;?&gt; pc = ccm.toClass();\n            proxy = (Proxy) pc.newInstance();\n        } catch (RuntimeException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new RuntimeException(e.getMessage(), e);\n        } finally {\n            // release ClassGenerator\n            if (ccp != null)\n                ccp.release();\n            if (ccm != null)\n                ccm.release();\n            synchronized (cache) {\n                if (proxy == null)\n                    cache.remove(key);\n                else\n                    cache.put(key, new WeakReference&lt;Proxy&gt;(proxy));\n                cache.notifyAll();\n            }\n        }\n        return proxy;\n    }\n</code></pre>\n<h5 id=\"该方法通过ClassLoader和Class接口生成一个Proxy类（注意是Proxy类，而不是之前的getProxy的泛型T类，实际上该Proxy就是该方法所处的类）-代码比较长，以下它的实现过程：\"><a href=\"#该方法通过ClassLoader和Class接口生成一个Proxy类（注意是Proxy类，而不是之前的getProxy的泛型T类，实际上该Proxy就是该方法所处的类）-代码比较长，以下它的实现过程：\" class=\"headerlink\" title=\"该方法通过ClassLoader和Class接口生成一个Proxy类（注意是Proxy类，而不是之前的getProxy的泛型T类，实际上该Proxy就是该方法所处的类） 代码比较长，以下它的实现过程：\"></a>该方法通过ClassLoader和Class接口生成一个Proxy类（注意是Proxy类，而不是之前的getProxy的泛型T类，实际上该Proxy就是该方法所处的类） 代码比较长，以下它的实现过程：</h5><ol>\n<li>遍历所有入参接口，以;分割连接起来，以它为key以map为缓存查找如果有，说明代理对象已创建返回</li>\n<li>利用AtomicLong对象自增获取一个long数组来作为生产类的后缀，防止冲突</li>\n<li>遍历接口获取所有定义的方法<ol>\n<li>将方法签名解析成字符串，加入到一个集合Set<string> worked中 ，用来判重</string></li>\n<li>获取方法应该在methods数组中的索引下标ix</li>\n<li>获取方法的参数类型以及返回类型</li>\n<li>构建方法体return ret= handler.invoke(this, methods[ix], args);这里的方法调用其实是委托给InvokerInvocationHandler实例对象的，去调用真正的实例</li>\n<li>方法加入到methods数组中；将字符串构建的方法加入到代理类中</li>\n</ol>\n</li>\n<li>创建代理实例对象ProxyInstance<ol>\n<li>类名为  pkg + “.poxy”+id = 包名 + “.poxy” +自增数值</li>\n<li>添加静态字段Method[] methods; 保存了该代理类代理的所有方法。在代理方法体中直接通过数组下表ix来获取方法</li>\n<li>添加实例对象InvocationHandler handler；代理实际上就是将方法的的执行给了handler。该handler的实现和jdk中的handler是同一个。</li>\n<li>创建构造函数，构造函数的参数就是上面的InvocationHandler</li>\n<li>添加默认构造函数</li>\n<li>利用工具类ClassGenerator生成对应的字节码</li>\n</ol>\n</li>\n<li>创建代理对象，它的newInstance(handler)方法用来创建基于我们接口的代理<ol>\n<li>代理对象名Proxy + id</li>\n<li>添加默认构造器</li>\n<li>实现方法newInstance代码，return new pcn(hadler) 这里pcn就是前面生成的代理对象类名</li>\n<li>利用工具类ClassGenerator生成字节码并实例化对象返回</li>\n</ol>\n</li>\n</ol>\n<h5 id=\"通过Proxy-getProxy-interfaces-创建了代理类之后，再调用newInstance方法，通过InvokerInvocationHandler和Invoker创建了代理实例；\"><a href=\"#通过Proxy-getProxy-interfaces-创建了代理类之后，再调用newInstance方法，通过InvokerInvocationHandler和Invoker创建了代理实例；\" class=\"headerlink\" title=\"通过Proxy.getProxy(interfaces)创建了代理类之后，再调用newInstance方法，通过InvokerInvocationHandler和Invoker创建了代理实例；\"></a>通过<strong>Proxy.getProxy(interfaces)</strong>创建了代理类之后，再调用newInstance方法，通过InvokerInvocationHandler和Invoker创建了代理实例；</h5><h3 id=\"getInvoker-1\"><a href=\"#getInvoker-1\" class=\"headerlink\" title=\"getInvoker\"></a>getInvoker</h3><pre><code class=\"lang-java\">public &lt;T&gt; Invoker&lt;T&gt; getInvoker(T proxy, Class&lt;T&gt; type, URL url) {\n        final Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf(&#39;$&#39;) &lt; 0 ? proxy.getClass() : type);\n        return new AbstractProxyInvoker&lt;T&gt;(proxy, type, url) {\n            @Override\n            protected Object doInvoke(T proxy, String methodName,\n                                      Class&lt;?&gt;[] parameterTypes,\n                                      Object[] arguments) throws Throwable {\n                return wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);\n            }\n        };\n    }\n</code></pre>\n<h5 id=\"实现过程如下：\"><a href=\"#实现过程如下：\" class=\"headerlink\" title=\"实现过程如下：\"></a>实现过程如下：</h5><ol>\n<li>根据传入的 proxy对象的类信息创建对它的包装对象Wrapper,这里同样是通过javassist生成字节码创建的。详细的过程就不介绍了，和上面的过程很类似</li>\n<li>返回AbstractProxyInvoker对象实例，这个invoker对象invoke方法可以根据传入的invocation对象中包含的方法名，方法参数来调用wrapper对象返回调用结果</li>\n</ol>\n<h2 id=\"StubProxyFactoryWrapper\"><a href=\"#StubProxyFactoryWrapper\" class=\"headerlink\" title=\"StubProxyFactoryWrapper\"></a>StubProxyFactoryWrapper</h2><pre><code class=\"lang-java\">public class StubProxyFactoryWrapper implements ProxyFactory {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(StubProxyFactoryWrapper.class);\n\n    private final ProxyFactory proxyFactory;\n\n    private Protocol protocol;\n\n    public StubProxyFactoryWrapper(ProxyFactory proxyFactory) {\n        this.proxyFactory = proxyFactory;\n    }\n\n    public void setProtocol(Protocol protocol) {\n        this.protocol = protocol;\n    }\n\n    @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})\n    public &lt;T&gt; T getProxy(Invoker&lt;T&gt; invoker) throws RpcException {\n        T proxy = proxyFactory.getProxy(invoker);\n        if (GenericService.class != invoker.getInterface()) {\n            String stub = invoker.getUrl().getParameter(Constants.STUB_KEY, invoker.getUrl().getParameter(Constants.LOCAL_KEY));\n            if (ConfigUtils.isNotEmpty(stub)) {\n                Class&lt;?&gt; serviceType = invoker.getInterface();\n                if (ConfigUtils.isDefault(stub)) {\n                    if (invoker.getUrl().hasParameter(Constants.STUB_KEY)) {\n                        stub = serviceType.getName() + &quot;Stub&quot;;\n                    } else {\n                        stub = serviceType.getName() + &quot;Local&quot;;\n                    }\n                }\n                try {\n                    Class&lt;?&gt; stubClass = ReflectUtils.forName(stub);\n                    if (!serviceType.isAssignableFrom(stubClass)) {\n                        throw new IllegalStateException(&quot;The stub implementation class &quot; + stubClass.getName() + &quot; not implement interface &quot; + serviceType.getName());\n                    }\n                    try {\n                        Constructor&lt;?&gt; constructor = ReflectUtils.findConstructor(stubClass, serviceType);\n                        proxy = (T) constructor.newInstance(new Object[]{proxy});\n                        //export stub service\n                        URL url = invoker.getUrl();\n                        if (url.getParameter(Constants.STUB_EVENT_KEY, Constants.DEFAULT_STUB_EVENT)) {\n                            url = url.addParameter(Constants.STUB_EVENT_METHODS_KEY, StringUtils.join(Wrapper.getWrapper(proxy.getClass()).getDeclaredMethodNames(), &quot;,&quot;));\n                            url = url.addParameter(Constants.IS_SERVER_KEY, Boolean.FALSE.toString());\n                            try {\n                                export(proxy, (Class) invoker.getInterface(), url);\n                            } catch (Exception e) {\n                                LOGGER.error(&quot;export a stub service error.&quot;, e);\n                            }\n                        }\n                    } catch (NoSuchMethodException e) {\n                        throw new IllegalStateException(&quot;No such constructor \\&quot;public &quot; + stubClass.getSimpleName() + &quot;(&quot; + serviceType.getName() + &quot;)\\&quot; in stub implementation class &quot; + stubClass.getName(), e);\n                    }\n                } catch (Throwable t) {\n                    LOGGER.error(&quot;Failed to create stub implementation class &quot; + stub + &quot; in consumer &quot; + NetUtils.getLocalHost() + &quot; use dubbo version &quot; + Version.getVersion() + &quot;, cause: &quot; + t.getMessage(), t);\n                    // ignore\n                }\n            }\n        }\n        return proxy;\n    }\n\n    public &lt;T&gt; Invoker&lt;T&gt; getInvoker(T proxy, Class&lt;T&gt; type, URL url) throws RpcException {\n        return proxyFactory.getInvoker(proxy, type, url);\n    }\n\n    private &lt;T&gt; Exporter&lt;T&gt; export(T instance, Class&lt;T&gt; type, URL url) {\n        return protocol.export(proxyFactory.getInvoker(instance, type, url));\n    }\n\n}\n</code></pre>\n<h5 id=\"StubProxyFactoryWrapper实现了对代理工厂进行装饰的功能，主要用于暴露服务提供者的本地服务给远端消费者来调用\"><a href=\"#StubProxyFactoryWrapper实现了对代理工厂进行装饰的功能，主要用于暴露服务提供者的本地服务给远端消费者来调用\" class=\"headerlink\" title=\"StubProxyFactoryWrapper实现了对代理工厂进行装饰的功能，主要用于暴露服务提供者的本地服务给远端消费者来调用\"></a>StubProxyFactoryWrapper实现了对代理工厂进行装饰的功能，主要用于暴露服务提供者的本地服务给远端消费者来调用</h5><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><h5 id=\"jdk和javassist的实现的区别就在于是jdk提供的字节码功能还是通过javassist来自定义类。本质上来说原理是一样的。整个的流程就像前面提到的\"><a href=\"#jdk和javassist的实现的区别就在于是jdk提供的字节码功能还是通过javassist来自定义类。本质上来说原理是一样的。整个的流程就像前面提到的\" class=\"headerlink\" title=\"jdk和javassist的实现的区别就在于是jdk提供的字节码功能还是通过javassist来自定义类。本质上来说原理是一样的。整个的流程就像前面提到的\"></a>jdk和javassist的实现的区别就在于是jdk提供的字节码功能还是通过javassist来自定义类。本质上来说原理是一样的。整个的流程就像前面提到的</h5><ol>\n<li>拿到<strong>实际执行对象</strong>，通过该对象去创建Invoker</li>\n<li>通过Invoker再去创建代理对象</li>\n</ol>\n<h5 id=\"但是其中有一些问题需要去思考：\"><a href=\"#但是其中有一些问题需要去思考：\" class=\"headerlink\" title=\"但是其中有一些问题需要去思考：\"></a>但是其中有一些问题需要去思考：</h5><ol>\n<li>这个代理的流程是从哪里发起的</li>\n<li>如果是消费端，只有服务的接口，没有实际执行的对象。那么这个代理是如何产生的；</li>\n<li>为什么javassist的getInvoker中，还需要实现wrapper类</li>\n</ol>"},{"layout":"post","title":"dubbo-各种序列方式的比较","date":"2018-03-25T16:00:00.000Z","original":true,"_content":"\n### 扩展说明\n##### 将对象转成字节流，用于网络传输，以及将字节流转为对象，用于在收到字节流数据后还原成对象。\n\n### 扩展接口\n* `com.alibaba.dubbo.common.serialize.Serialization`\n* com.alibaba.dubbo.common.serialize.ObjectInput\n\n### 使用配置\n```xml\n<dubbo:provider serialization=\"\" />\n```\n<!--more-->\n\n### 目前已知扩展：\n* fastjson=com.alibaba.dubbo.common.serialize.fastjson.FastJsonSerialization\n* fst=com.alibaba.dubbo.common.serialize.fst.FstSerialization\n* hessian2=com.alibaba.dubbo.common.serialize.hessian2.Hessian2Serialization\n* java=com.alibaba.dubbo.common.serialize.java.JavaSerialization\n* compactedjava=com.alibaba.dubbo.common.serialize.java.CompactedJavaSerialization\n* nativejava=com.alibaba.dubbo.common.serialize.nativejava.NativeJavaSerialization\n* kryo=com.alibaba.dubbo.common.serialize.kryo.KryoSerialization\n\n### Serialization\n```java\n@SPI(\"hessian2\") //默认实现方式为hessian2\npublic interface Serialization {\n\n    /**\n     * 返回序列化方式id，该id每种实现都是写死的\n     */\n    byte getContentTypeId();\n\n    /**\n     * 返回字符串形式的序列化类型\n     */\n    String getContentType();\n\n    /**\n     * 创建序列化工具ObjectOutput\n     * com.alibaba.dubbo.common.serialize.ObjectOutput\n     */\n    @Adaptive\n    ObjectOutput serialize(URL url, OutputStream output) throws IOException;\n\n    /**\n     * 创建反序列化工具ObjectOutput\n     * com.alibaba.dubbo.common.serialize.ObjectInput\n     */\n    @Adaptive\n    ObjectInput deserialize(URL url, InputStream input) throws IOException;\n\n}\n```\n\n##### 可以看到上面的序列化过程主要是交给了ObjectOutput和ObjectInput。我们来看下他们分别是什么样的\n\n### ObjectOutput、DataOutput\n```java\npublic interface ObjectOutput extends DataOutput {\n\n    /**\n     * write object.\n     */\n    void writeObject(Object obj) throws IOException;\n}\n```\n\n#### 继承了DataOutput：\n```java\npublic interface DataOutput {\n\n    /**\n     * Write boolean.\n     *\n     * @param v value.\n     * @throws IOException\n     */\n    void writeBool(boolean v) throws IOException;\n\n    /**\n     * Write byte.\n     *\n     * @param v value.\n     * @throws IOException\n     */\n    void writeByte(byte v) throws IOException;\n\n    /**\n     * Write short.\n     *\n     * @param v value.\n     * @throws IOException\n     */\n    void writeShort(short v) throws IOException;\n\n    /**\n     * Write integer.\n     *\n     * @param v value.\n     * @throws IOException\n     */\n    void writeInt(int v) throws IOException;\n\n    /**\n     * Write long.\n     *\n     * @param v value.\n     * @throws IOException\n     */\n    void writeLong(long v) throws IOException;\n\n    /**\n     * Write float.\n     *\n     * @param v value.\n     * @throws IOException\n     */\n    void writeFloat(float v) throws IOException;\n\n    /**\n     * Write double.\n     *\n     * @param v value.\n     * @throws IOException\n     */\n    void writeDouble(double v) throws IOException;\n\n    /**\n     * Write string.\n     *\n     * @param v value.\n     * @throws IOException\n     */\n    void writeUTF(String v) throws IOException;\n\n    /**\n     * Write byte array.\n     *\n     * @param v value.\n     * @throws IOException\n     */\n    void writeBytes(byte[] v) throws IOException;\n\n    /**\n     * Write byte array.\n     *\n     * @param v   value.\n     * @param off offset.\n     * @param len length.\n     * @throws IOException\n     */\n    void writeBytes(byte[] v, int off, int len) throws IOException;\n\n    /**\n     * Flush buffer.\n     *\n     * @throws IOException\n     */\n    void flushBuffer() throws IOException;\n}\n```\n\n##### 可看到如果继承ObjectOutput，则需要实现Object的序列化，以及基础类型的序列化和String类型的序列化的实现过程\n\n### ObjectInput、DataInput\n```java\npublic interface ObjectInput extends DataInput {\n\n    /**\n     * read object.\n     */\n    Object readObject() throws IOException, ClassNotFoundException;\n\n    /**\n     * read object.\n     */\n    <T> T readObject(Class<T> cls) throws IOException, ClassNotFoundException;\n\n    /**\n     * read object.\n     */\n    <T> T readObject(Class<T> cls, Type type) throws IOException, ClassNotFoundException;\n\n}\n```\n\n```java\npublic interface DataInput {\n\n    /**\n     * Read boolean.\n     *\n     * @return boolean.\n     * @throws IOException\n     */\n    boolean readBool() throws IOException;\n\n    /**\n     * Read byte.\n     *\n     * @return byte value.\n     * @throws IOException\n     */\n    byte readByte() throws IOException;\n\n    /**\n     * Read short integer.\n     *\n     * @return short.\n     * @throws IOException\n     */\n    short readShort() throws IOException;\n\n    /**\n     * Read integer.\n     *\n     * @return integer.\n     * @throws IOException\n     */\n    int readInt() throws IOException;\n\n    /**\n     * Read long.\n     *\n     * @return long.\n     * @throws IOException\n     */\n    long readLong() throws IOException;\n\n    /**\n     * Read float.\n     *\n     * @return float.\n     * @throws IOException\n     */\n    float readFloat() throws IOException;\n\n    /**\n     * Read double.\n     *\n     * @return double.\n     * @throws IOException\n     */\n    double readDouble() throws IOException;\n\n    /**\n     * Read UTF-8 string.\n     *\n     * @return string.\n     * @throws IOException\n     */\n    String readUTF() throws IOException;\n\n    /**\n     * Read byte array.\n     *\n     * @return byte array.\n     * @throws IOException\n     */\n    byte[] readBytes() throws IOException;\n}\n```\n##### ObjectInput和ObjectOutput相反。做反序列化操作\n\n##### 各种序列化的过程都是通过实现的这两个接口来实现的。这两个接口又是通过各种流的嵌套封装来完成操作的。因此后面将就这几种序列化方式做一个特点分析和各方面的比较。\n\n## fastjson\n","source":"_posts/note/dubbo/serializable.md","raw":"---\nlayout: post\ntitle: dubbo-各种序列方式的比较\ndate: 2018/03/26\ntag: [[java, java], [dubbo, dubbo]]\noriginal: true\n---\n\n### 扩展说明\n##### 将对象转成字节流，用于网络传输，以及将字节流转为对象，用于在收到字节流数据后还原成对象。\n\n### 扩展接口\n* `com.alibaba.dubbo.common.serialize.Serialization`\n* com.alibaba.dubbo.common.serialize.ObjectInput\n\n### 使用配置\n```xml\n<dubbo:provider serialization=\"\" />\n```\n<!--more-->\n\n### 目前已知扩展：\n* fastjson=com.alibaba.dubbo.common.serialize.fastjson.FastJsonSerialization\n* fst=com.alibaba.dubbo.common.serialize.fst.FstSerialization\n* hessian2=com.alibaba.dubbo.common.serialize.hessian2.Hessian2Serialization\n* java=com.alibaba.dubbo.common.serialize.java.JavaSerialization\n* compactedjava=com.alibaba.dubbo.common.serialize.java.CompactedJavaSerialization\n* nativejava=com.alibaba.dubbo.common.serialize.nativejava.NativeJavaSerialization\n* kryo=com.alibaba.dubbo.common.serialize.kryo.KryoSerialization\n\n### Serialization\n```java\n@SPI(\"hessian2\") //默认实现方式为hessian2\npublic interface Serialization {\n\n    /**\n     * 返回序列化方式id，该id每种实现都是写死的\n     */\n    byte getContentTypeId();\n\n    /**\n     * 返回字符串形式的序列化类型\n     */\n    String getContentType();\n\n    /**\n     * 创建序列化工具ObjectOutput\n     * com.alibaba.dubbo.common.serialize.ObjectOutput\n     */\n    @Adaptive\n    ObjectOutput serialize(URL url, OutputStream output) throws IOException;\n\n    /**\n     * 创建反序列化工具ObjectOutput\n     * com.alibaba.dubbo.common.serialize.ObjectInput\n     */\n    @Adaptive\n    ObjectInput deserialize(URL url, InputStream input) throws IOException;\n\n}\n```\n\n##### 可以看到上面的序列化过程主要是交给了ObjectOutput和ObjectInput。我们来看下他们分别是什么样的\n\n### ObjectOutput、DataOutput\n```java\npublic interface ObjectOutput extends DataOutput {\n\n    /**\n     * write object.\n     */\n    void writeObject(Object obj) throws IOException;\n}\n```\n\n#### 继承了DataOutput：\n```java\npublic interface DataOutput {\n\n    /**\n     * Write boolean.\n     *\n     * @param v value.\n     * @throws IOException\n     */\n    void writeBool(boolean v) throws IOException;\n\n    /**\n     * Write byte.\n     *\n     * @param v value.\n     * @throws IOException\n     */\n    void writeByte(byte v) throws IOException;\n\n    /**\n     * Write short.\n     *\n     * @param v value.\n     * @throws IOException\n     */\n    void writeShort(short v) throws IOException;\n\n    /**\n     * Write integer.\n     *\n     * @param v value.\n     * @throws IOException\n     */\n    void writeInt(int v) throws IOException;\n\n    /**\n     * Write long.\n     *\n     * @param v value.\n     * @throws IOException\n     */\n    void writeLong(long v) throws IOException;\n\n    /**\n     * Write float.\n     *\n     * @param v value.\n     * @throws IOException\n     */\n    void writeFloat(float v) throws IOException;\n\n    /**\n     * Write double.\n     *\n     * @param v value.\n     * @throws IOException\n     */\n    void writeDouble(double v) throws IOException;\n\n    /**\n     * Write string.\n     *\n     * @param v value.\n     * @throws IOException\n     */\n    void writeUTF(String v) throws IOException;\n\n    /**\n     * Write byte array.\n     *\n     * @param v value.\n     * @throws IOException\n     */\n    void writeBytes(byte[] v) throws IOException;\n\n    /**\n     * Write byte array.\n     *\n     * @param v   value.\n     * @param off offset.\n     * @param len length.\n     * @throws IOException\n     */\n    void writeBytes(byte[] v, int off, int len) throws IOException;\n\n    /**\n     * Flush buffer.\n     *\n     * @throws IOException\n     */\n    void flushBuffer() throws IOException;\n}\n```\n\n##### 可看到如果继承ObjectOutput，则需要实现Object的序列化，以及基础类型的序列化和String类型的序列化的实现过程\n\n### ObjectInput、DataInput\n```java\npublic interface ObjectInput extends DataInput {\n\n    /**\n     * read object.\n     */\n    Object readObject() throws IOException, ClassNotFoundException;\n\n    /**\n     * read object.\n     */\n    <T> T readObject(Class<T> cls) throws IOException, ClassNotFoundException;\n\n    /**\n     * read object.\n     */\n    <T> T readObject(Class<T> cls, Type type) throws IOException, ClassNotFoundException;\n\n}\n```\n\n```java\npublic interface DataInput {\n\n    /**\n     * Read boolean.\n     *\n     * @return boolean.\n     * @throws IOException\n     */\n    boolean readBool() throws IOException;\n\n    /**\n     * Read byte.\n     *\n     * @return byte value.\n     * @throws IOException\n     */\n    byte readByte() throws IOException;\n\n    /**\n     * Read short integer.\n     *\n     * @return short.\n     * @throws IOException\n     */\n    short readShort() throws IOException;\n\n    /**\n     * Read integer.\n     *\n     * @return integer.\n     * @throws IOException\n     */\n    int readInt() throws IOException;\n\n    /**\n     * Read long.\n     *\n     * @return long.\n     * @throws IOException\n     */\n    long readLong() throws IOException;\n\n    /**\n     * Read float.\n     *\n     * @return float.\n     * @throws IOException\n     */\n    float readFloat() throws IOException;\n\n    /**\n     * Read double.\n     *\n     * @return double.\n     * @throws IOException\n     */\n    double readDouble() throws IOException;\n\n    /**\n     * Read UTF-8 string.\n     *\n     * @return string.\n     * @throws IOException\n     */\n    String readUTF() throws IOException;\n\n    /**\n     * Read byte array.\n     *\n     * @return byte array.\n     * @throws IOException\n     */\n    byte[] readBytes() throws IOException;\n}\n```\n##### ObjectInput和ObjectOutput相反。做反序列化操作\n\n##### 各种序列化的过程都是通过实现的这两个接口来实现的。这两个接口又是通过各种流的嵌套封装来完成操作的。因此后面将就这几种序列化方式做一个特点分析和各方面的比较。\n\n## fastjson\n","slug":"note/dubbo/serializable","published":1,"updated":"2018-05-08T13:00:14.277Z","comments":1,"photos":[],"link":"","_id":"cjgxop3nf003bjah14ms4xf2v","content":"<h3 id=\"扩展说明\"><a href=\"#扩展说明\" class=\"headerlink\" title=\"扩展说明\"></a>扩展说明</h3><h5 id=\"将对象转成字节流，用于网络传输，以及将字节流转为对象，用于在收到字节流数据后还原成对象。\"><a href=\"#将对象转成字节流，用于网络传输，以及将字节流转为对象，用于在收到字节流数据后还原成对象。\" class=\"headerlink\" title=\"将对象转成字节流，用于网络传输，以及将字节流转为对象，用于在收到字节流数据后还原成对象。\"></a>将对象转成字节流，用于网络传输，以及将字节流转为对象，用于在收到字节流数据后还原成对象。</h5><h3 id=\"扩展接口\"><a href=\"#扩展接口\" class=\"headerlink\" title=\"扩展接口\"></a>扩展接口</h3><ul>\n<li><code>com.alibaba.dubbo.common.serialize.Serialization</code></li>\n<li>com.alibaba.dubbo.common.serialize.ObjectInput</li>\n</ul>\n<h3 id=\"使用配置\"><a href=\"#使用配置\" class=\"headerlink\" title=\"使用配置\"></a>使用配置</h3><pre><code class=\"lang-xml\">&lt;dubbo:provider serialization=&quot;&quot; /&gt;\n</code></pre>\n<a id=\"more\"></a>\n<h3 id=\"目前已知扩展：\"><a href=\"#目前已知扩展：\" class=\"headerlink\" title=\"目前已知扩展：\"></a>目前已知扩展：</h3><ul>\n<li>fastjson=com.alibaba.dubbo.common.serialize.fastjson.FastJsonSerialization</li>\n<li>fst=com.alibaba.dubbo.common.serialize.fst.FstSerialization</li>\n<li>hessian2=com.alibaba.dubbo.common.serialize.hessian2.Hessian2Serialization</li>\n<li>java=com.alibaba.dubbo.common.serialize.java.JavaSerialization</li>\n<li>compactedjava=com.alibaba.dubbo.common.serialize.java.CompactedJavaSerialization</li>\n<li>nativejava=com.alibaba.dubbo.common.serialize.nativejava.NativeJavaSerialization</li>\n<li>kryo=com.alibaba.dubbo.common.serialize.kryo.KryoSerialization</li>\n</ul>\n<h3 id=\"Serialization\"><a href=\"#Serialization\" class=\"headerlink\" title=\"Serialization\"></a>Serialization</h3><pre><code class=\"lang-java\">@SPI(&quot;hessian2&quot;) //默认实现方式为hessian2\npublic interface Serialization {\n\n    /**\n     * 返回序列化方式id，该id每种实现都是写死的\n     */\n    byte getContentTypeId();\n\n    /**\n     * 返回字符串形式的序列化类型\n     */\n    String getContentType();\n\n    /**\n     * 创建序列化工具ObjectOutput\n     * com.alibaba.dubbo.common.serialize.ObjectOutput\n     */\n    @Adaptive\n    ObjectOutput serialize(URL url, OutputStream output) throws IOException;\n\n    /**\n     * 创建反序列化工具ObjectOutput\n     * com.alibaba.dubbo.common.serialize.ObjectInput\n     */\n    @Adaptive\n    ObjectInput deserialize(URL url, InputStream input) throws IOException;\n\n}\n</code></pre>\n<h5 id=\"可以看到上面的序列化过程主要是交给了ObjectOutput和ObjectInput。我们来看下他们分别是什么样的\"><a href=\"#可以看到上面的序列化过程主要是交给了ObjectOutput和ObjectInput。我们来看下他们分别是什么样的\" class=\"headerlink\" title=\"可以看到上面的序列化过程主要是交给了ObjectOutput和ObjectInput。我们来看下他们分别是什么样的\"></a>可以看到上面的序列化过程主要是交给了ObjectOutput和ObjectInput。我们来看下他们分别是什么样的</h5><h3 id=\"ObjectOutput、DataOutput\"><a href=\"#ObjectOutput、DataOutput\" class=\"headerlink\" title=\"ObjectOutput、DataOutput\"></a>ObjectOutput、DataOutput</h3><pre><code class=\"lang-java\">public interface ObjectOutput extends DataOutput {\n\n    /**\n     * write object.\n     */\n    void writeObject(Object obj) throws IOException;\n}\n</code></pre>\n<h4 id=\"继承了DataOutput：\"><a href=\"#继承了DataOutput：\" class=\"headerlink\" title=\"继承了DataOutput：\"></a>继承了DataOutput：</h4><pre><code class=\"lang-java\">public interface DataOutput {\n\n    /**\n     * Write boolean.\n     *\n     * @param v value.\n     * @throws IOException\n     */\n    void writeBool(boolean v) throws IOException;\n\n    /**\n     * Write byte.\n     *\n     * @param v value.\n     * @throws IOException\n     */\n    void writeByte(byte v) throws IOException;\n\n    /**\n     * Write short.\n     *\n     * @param v value.\n     * @throws IOException\n     */\n    void writeShort(short v) throws IOException;\n\n    /**\n     * Write integer.\n     *\n     * @param v value.\n     * @throws IOException\n     */\n    void writeInt(int v) throws IOException;\n\n    /**\n     * Write long.\n     *\n     * @param v value.\n     * @throws IOException\n     */\n    void writeLong(long v) throws IOException;\n\n    /**\n     * Write float.\n     *\n     * @param v value.\n     * @throws IOException\n     */\n    void writeFloat(float v) throws IOException;\n\n    /**\n     * Write double.\n     *\n     * @param v value.\n     * @throws IOException\n     */\n    void writeDouble(double v) throws IOException;\n\n    /**\n     * Write string.\n     *\n     * @param v value.\n     * @throws IOException\n     */\n    void writeUTF(String v) throws IOException;\n\n    /**\n     * Write byte array.\n     *\n     * @param v value.\n     * @throws IOException\n     */\n    void writeBytes(byte[] v) throws IOException;\n\n    /**\n     * Write byte array.\n     *\n     * @param v   value.\n     * @param off offset.\n     * @param len length.\n     * @throws IOException\n     */\n    void writeBytes(byte[] v, int off, int len) throws IOException;\n\n    /**\n     * Flush buffer.\n     *\n     * @throws IOException\n     */\n    void flushBuffer() throws IOException;\n}\n</code></pre>\n<h5 id=\"可看到如果继承ObjectOutput，则需要实现Object的序列化，以及基础类型的序列化和String类型的序列化的实现过程\"><a href=\"#可看到如果继承ObjectOutput，则需要实现Object的序列化，以及基础类型的序列化和String类型的序列化的实现过程\" class=\"headerlink\" title=\"可看到如果继承ObjectOutput，则需要实现Object的序列化，以及基础类型的序列化和String类型的序列化的实现过程\"></a>可看到如果继承ObjectOutput，则需要实现Object的序列化，以及基础类型的序列化和String类型的序列化的实现过程</h5><h3 id=\"ObjectInput、DataInput\"><a href=\"#ObjectInput、DataInput\" class=\"headerlink\" title=\"ObjectInput、DataInput\"></a>ObjectInput、DataInput</h3><pre><code class=\"lang-java\">public interface ObjectInput extends DataInput {\n\n    /**\n     * read object.\n     */\n    Object readObject() throws IOException, ClassNotFoundException;\n\n    /**\n     * read object.\n     */\n    &lt;T&gt; T readObject(Class&lt;T&gt; cls) throws IOException, ClassNotFoundException;\n\n    /**\n     * read object.\n     */\n    &lt;T&gt; T readObject(Class&lt;T&gt; cls, Type type) throws IOException, ClassNotFoundException;\n\n}\n</code></pre>\n<pre><code class=\"lang-java\">public interface DataInput {\n\n    /**\n     * Read boolean.\n     *\n     * @return boolean.\n     * @throws IOException\n     */\n    boolean readBool() throws IOException;\n\n    /**\n     * Read byte.\n     *\n     * @return byte value.\n     * @throws IOException\n     */\n    byte readByte() throws IOException;\n\n    /**\n     * Read short integer.\n     *\n     * @return short.\n     * @throws IOException\n     */\n    short readShort() throws IOException;\n\n    /**\n     * Read integer.\n     *\n     * @return integer.\n     * @throws IOException\n     */\n    int readInt() throws IOException;\n\n    /**\n     * Read long.\n     *\n     * @return long.\n     * @throws IOException\n     */\n    long readLong() throws IOException;\n\n    /**\n     * Read float.\n     *\n     * @return float.\n     * @throws IOException\n     */\n    float readFloat() throws IOException;\n\n    /**\n     * Read double.\n     *\n     * @return double.\n     * @throws IOException\n     */\n    double readDouble() throws IOException;\n\n    /**\n     * Read UTF-8 string.\n     *\n     * @return string.\n     * @throws IOException\n     */\n    String readUTF() throws IOException;\n\n    /**\n     * Read byte array.\n     *\n     * @return byte array.\n     * @throws IOException\n     */\n    byte[] readBytes() throws IOException;\n}\n</code></pre>\n<h5 id=\"ObjectInput和ObjectOutput相反。做反序列化操作\"><a href=\"#ObjectInput和ObjectOutput相反。做反序列化操作\" class=\"headerlink\" title=\"ObjectInput和ObjectOutput相反。做反序列化操作\"></a>ObjectInput和ObjectOutput相反。做反序列化操作</h5><h5 id=\"各种序列化的过程都是通过实现的这两个接口来实现的。这两个接口又是通过各种流的嵌套封装来完成操作的。因此后面将就这几种序列化方式做一个特点分析和各方面的比较。\"><a href=\"#各种序列化的过程都是通过实现的这两个接口来实现的。这两个接口又是通过各种流的嵌套封装来完成操作的。因此后面将就这几种序列化方式做一个特点分析和各方面的比较。\" class=\"headerlink\" title=\"各种序列化的过程都是通过实现的这两个接口来实现的。这两个接口又是通过各种流的嵌套封装来完成操作的。因此后面将就这几种序列化方式做一个特点分析和各方面的比较。\"></a>各种序列化的过程都是通过实现的这两个接口来实现的。这两个接口又是通过各种流的嵌套封装来完成操作的。因此后面将就这几种序列化方式做一个特点分析和各方面的比较。</h5><h2 id=\"fastjson\"><a href=\"#fastjson\" class=\"headerlink\" title=\"fastjson\"></a>fastjson</h2>","site":{"data":{}},"excerpt":"<h3 id=\"扩展说明\"><a href=\"#扩展说明\" class=\"headerlink\" title=\"扩展说明\"></a>扩展说明</h3><h5 id=\"将对象转成字节流，用于网络传输，以及将字节流转为对象，用于在收到字节流数据后还原成对象。\"><a href=\"#将对象转成字节流，用于网络传输，以及将字节流转为对象，用于在收到字节流数据后还原成对象。\" class=\"headerlink\" title=\"将对象转成字节流，用于网络传输，以及将字节流转为对象，用于在收到字节流数据后还原成对象。\"></a>将对象转成字节流，用于网络传输，以及将字节流转为对象，用于在收到字节流数据后还原成对象。</h5><h3 id=\"扩展接口\"><a href=\"#扩展接口\" class=\"headerlink\" title=\"扩展接口\"></a>扩展接口</h3><ul>\n<li><code>com.alibaba.dubbo.common.serialize.Serialization</code></li>\n<li>com.alibaba.dubbo.common.serialize.ObjectInput</li>\n</ul>\n<h3 id=\"使用配置\"><a href=\"#使用配置\" class=\"headerlink\" title=\"使用配置\"></a>使用配置</h3><pre><code class=\"lang-xml\">&lt;dubbo:provider serialization=&quot;&quot; /&gt;\n</code></pre>","more":"<h3 id=\"目前已知扩展：\"><a href=\"#目前已知扩展：\" class=\"headerlink\" title=\"目前已知扩展：\"></a>目前已知扩展：</h3><ul>\n<li>fastjson=com.alibaba.dubbo.common.serialize.fastjson.FastJsonSerialization</li>\n<li>fst=com.alibaba.dubbo.common.serialize.fst.FstSerialization</li>\n<li>hessian2=com.alibaba.dubbo.common.serialize.hessian2.Hessian2Serialization</li>\n<li>java=com.alibaba.dubbo.common.serialize.java.JavaSerialization</li>\n<li>compactedjava=com.alibaba.dubbo.common.serialize.java.CompactedJavaSerialization</li>\n<li>nativejava=com.alibaba.dubbo.common.serialize.nativejava.NativeJavaSerialization</li>\n<li>kryo=com.alibaba.dubbo.common.serialize.kryo.KryoSerialization</li>\n</ul>\n<h3 id=\"Serialization\"><a href=\"#Serialization\" class=\"headerlink\" title=\"Serialization\"></a>Serialization</h3><pre><code class=\"lang-java\">@SPI(&quot;hessian2&quot;) //默认实现方式为hessian2\npublic interface Serialization {\n\n    /**\n     * 返回序列化方式id，该id每种实现都是写死的\n     */\n    byte getContentTypeId();\n\n    /**\n     * 返回字符串形式的序列化类型\n     */\n    String getContentType();\n\n    /**\n     * 创建序列化工具ObjectOutput\n     * com.alibaba.dubbo.common.serialize.ObjectOutput\n     */\n    @Adaptive\n    ObjectOutput serialize(URL url, OutputStream output) throws IOException;\n\n    /**\n     * 创建反序列化工具ObjectOutput\n     * com.alibaba.dubbo.common.serialize.ObjectInput\n     */\n    @Adaptive\n    ObjectInput deserialize(URL url, InputStream input) throws IOException;\n\n}\n</code></pre>\n<h5 id=\"可以看到上面的序列化过程主要是交给了ObjectOutput和ObjectInput。我们来看下他们分别是什么样的\"><a href=\"#可以看到上面的序列化过程主要是交给了ObjectOutput和ObjectInput。我们来看下他们分别是什么样的\" class=\"headerlink\" title=\"可以看到上面的序列化过程主要是交给了ObjectOutput和ObjectInput。我们来看下他们分别是什么样的\"></a>可以看到上面的序列化过程主要是交给了ObjectOutput和ObjectInput。我们来看下他们分别是什么样的</h5><h3 id=\"ObjectOutput、DataOutput\"><a href=\"#ObjectOutput、DataOutput\" class=\"headerlink\" title=\"ObjectOutput、DataOutput\"></a>ObjectOutput、DataOutput</h3><pre><code class=\"lang-java\">public interface ObjectOutput extends DataOutput {\n\n    /**\n     * write object.\n     */\n    void writeObject(Object obj) throws IOException;\n}\n</code></pre>\n<h4 id=\"继承了DataOutput：\"><a href=\"#继承了DataOutput：\" class=\"headerlink\" title=\"继承了DataOutput：\"></a>继承了DataOutput：</h4><pre><code class=\"lang-java\">public interface DataOutput {\n\n    /**\n     * Write boolean.\n     *\n     * @param v value.\n     * @throws IOException\n     */\n    void writeBool(boolean v) throws IOException;\n\n    /**\n     * Write byte.\n     *\n     * @param v value.\n     * @throws IOException\n     */\n    void writeByte(byte v) throws IOException;\n\n    /**\n     * Write short.\n     *\n     * @param v value.\n     * @throws IOException\n     */\n    void writeShort(short v) throws IOException;\n\n    /**\n     * Write integer.\n     *\n     * @param v value.\n     * @throws IOException\n     */\n    void writeInt(int v) throws IOException;\n\n    /**\n     * Write long.\n     *\n     * @param v value.\n     * @throws IOException\n     */\n    void writeLong(long v) throws IOException;\n\n    /**\n     * Write float.\n     *\n     * @param v value.\n     * @throws IOException\n     */\n    void writeFloat(float v) throws IOException;\n\n    /**\n     * Write double.\n     *\n     * @param v value.\n     * @throws IOException\n     */\n    void writeDouble(double v) throws IOException;\n\n    /**\n     * Write string.\n     *\n     * @param v value.\n     * @throws IOException\n     */\n    void writeUTF(String v) throws IOException;\n\n    /**\n     * Write byte array.\n     *\n     * @param v value.\n     * @throws IOException\n     */\n    void writeBytes(byte[] v) throws IOException;\n\n    /**\n     * Write byte array.\n     *\n     * @param v   value.\n     * @param off offset.\n     * @param len length.\n     * @throws IOException\n     */\n    void writeBytes(byte[] v, int off, int len) throws IOException;\n\n    /**\n     * Flush buffer.\n     *\n     * @throws IOException\n     */\n    void flushBuffer() throws IOException;\n}\n</code></pre>\n<h5 id=\"可看到如果继承ObjectOutput，则需要实现Object的序列化，以及基础类型的序列化和String类型的序列化的实现过程\"><a href=\"#可看到如果继承ObjectOutput，则需要实现Object的序列化，以及基础类型的序列化和String类型的序列化的实现过程\" class=\"headerlink\" title=\"可看到如果继承ObjectOutput，则需要实现Object的序列化，以及基础类型的序列化和String类型的序列化的实现过程\"></a>可看到如果继承ObjectOutput，则需要实现Object的序列化，以及基础类型的序列化和String类型的序列化的实现过程</h5><h3 id=\"ObjectInput、DataInput\"><a href=\"#ObjectInput、DataInput\" class=\"headerlink\" title=\"ObjectInput、DataInput\"></a>ObjectInput、DataInput</h3><pre><code class=\"lang-java\">public interface ObjectInput extends DataInput {\n\n    /**\n     * read object.\n     */\n    Object readObject() throws IOException, ClassNotFoundException;\n\n    /**\n     * read object.\n     */\n    &lt;T&gt; T readObject(Class&lt;T&gt; cls) throws IOException, ClassNotFoundException;\n\n    /**\n     * read object.\n     */\n    &lt;T&gt; T readObject(Class&lt;T&gt; cls, Type type) throws IOException, ClassNotFoundException;\n\n}\n</code></pre>\n<pre><code class=\"lang-java\">public interface DataInput {\n\n    /**\n     * Read boolean.\n     *\n     * @return boolean.\n     * @throws IOException\n     */\n    boolean readBool() throws IOException;\n\n    /**\n     * Read byte.\n     *\n     * @return byte value.\n     * @throws IOException\n     */\n    byte readByte() throws IOException;\n\n    /**\n     * Read short integer.\n     *\n     * @return short.\n     * @throws IOException\n     */\n    short readShort() throws IOException;\n\n    /**\n     * Read integer.\n     *\n     * @return integer.\n     * @throws IOException\n     */\n    int readInt() throws IOException;\n\n    /**\n     * Read long.\n     *\n     * @return long.\n     * @throws IOException\n     */\n    long readLong() throws IOException;\n\n    /**\n     * Read float.\n     *\n     * @return float.\n     * @throws IOException\n     */\n    float readFloat() throws IOException;\n\n    /**\n     * Read double.\n     *\n     * @return double.\n     * @throws IOException\n     */\n    double readDouble() throws IOException;\n\n    /**\n     * Read UTF-8 string.\n     *\n     * @return string.\n     * @throws IOException\n     */\n    String readUTF() throws IOException;\n\n    /**\n     * Read byte array.\n     *\n     * @return byte array.\n     * @throws IOException\n     */\n    byte[] readBytes() throws IOException;\n}\n</code></pre>\n<h5 id=\"ObjectInput和ObjectOutput相反。做反序列化操作\"><a href=\"#ObjectInput和ObjectOutput相反。做反序列化操作\" class=\"headerlink\" title=\"ObjectInput和ObjectOutput相反。做反序列化操作\"></a>ObjectInput和ObjectOutput相反。做反序列化操作</h5><h5 id=\"各种序列化的过程都是通过实现的这两个接口来实现的。这两个接口又是通过各种流的嵌套封装来完成操作的。因此后面将就这几种序列化方式做一个特点分析和各方面的比较。\"><a href=\"#各种序列化的过程都是通过实现的这两个接口来实现的。这两个接口又是通过各种流的嵌套封装来完成操作的。因此后面将就这几种序列化方式做一个特点分析和各方面的比较。\" class=\"headerlink\" title=\"各种序列化的过程都是通过实现的这两个接口来实现的。这两个接口又是通过各种流的嵌套封装来完成操作的。因此后面将就这几种序列化方式做一个特点分析和各方面的比较。\"></a>各种序列化的过程都是通过实现的这两个接口来实现的。这两个接口又是通过各种流的嵌套封装来完成操作的。因此后面将就这几种序列化方式做一个特点分析和各方面的比较。</h5><h2 id=\"fastjson\"><a href=\"#fastjson\" class=\"headerlink\" title=\"fastjson\"></a>fastjson</h2>"},{"layout":"post","title":"dubbo概述","date":"2018-03-21T16:00:00.000Z","tag":[["java","java"],["dubbo","dubbo"]],"original":true,"_content":"\n##### 从这篇文章开始，我将对dubbo的源码进行阅读与分析。网络上对于dubbo的架构已经整体的设计原理已经有非常多的文章了，这里推荐一下[dubbo官方技术文档](http://dubbo.io/books/dubbo-dev-book/)。这些文档已经对dubbo的整体架构和扩展机制做了详细的说明。这在我后面的系列文章中将不会再有这部分介绍。但是该文档只是指出了dubbo的众多扩展点的接口以及简单说明，并没有对接口做详细的代码实现分析。所以我将尝试阅读并分享基于这些扩展点的代码实现过程。\n\n<!--more-->\n\n#### 在这之前，我们还是简单介绍一下dubbo的框架设计\n\n## 框架设计\n### 整体设计\n![](/img/note/dubbo/dubbo-framework.jpg)\n\n##### 图例说明：\n* 图中左边淡蓝背景的为服务消费方使用的接口，右边淡绿色背景的为服务提供方使用的接口，位于中轴线上的为双方都用到的接口。\n* 图中从下至上分为十层，各层均为单向依赖，右边的黑色箭头代表层之间的依赖关系，每一层都可以剥离上层被复用，其中，Service 和 Config 层为 API，其它各层均为 SPI。\n* 图中绿色小块的为扩展接口，蓝色小块为实现类，图中只显示用于关联各层的实现类。\n* 图中蓝色虚线为初始化过程，即启动时组装链，红色实线为方法调用过程，即运行时调时链，紫色三角箭头为继承，可以把子类看作父类的同一个节点，线上的文字为调用的方法。\n\n### 各层说明\n* **config 配置层**：对外配置接口，以 ServiceConfig, ReferenceConfig 为中心，可以直接初始化配置类，也可以通过 spring 解析配置生成配置类\n* **proxy 服务代理层**：服务接口透明代理，生成服务的客户端 Stub 和服务器端 Skeleton, 以 ServiceProxy 为中心，扩展接口为 ProxyFactory\n* **registry 注册中心层**：封装服务地址的注册与发现，以服务 URL 为中心，扩展接口为 RegistryFactory, Registry, RegistryService\n* **cluster 路由层**：封装多个提供者的路由及负载均衡，并桥接注册中心，以 Invoker 为中心，扩展接口为 Cluster, Directory, Router, LoadBalance\n* **monitor 监控层**：RPC 调用次数和调用时间监控，以 Statistics 为中心，扩展接口为 MonitorFactory, Monitor, MonitorService\n* **protocol 远程调用层**：封装 RPC 调用，以 Invocation, Result 为中心，扩展接口为 Protocol, Invoker, Exporter\n* **exchange 信息交换层**：封装请求响应模式，同步转异步，以 Request, Response 为中心，扩展接口为 Exchanger, ExchangeChannel, ExchangeClient, ExchangeServer\n* **transport 网络传输层**：抽象 mina 和 netty 为统一接口，以 Message 为中心，扩展接口为 Channel, Transporter, Client, Server, Codec\n* **serialize 数据序列化层**：可复用的一些工具，扩展接口为 Serialization, ObjectInput, ObjectOutput, ThreadPool\n\n### 关系说明\n* 在 RPC 中，Protocol 是核心层，也就是只要有 Protocol + Invoker + Exporter 就可以完成非透明的 RPC 调用，然后在 Invoker 的主过程上 Filter 拦截点。\n* 图中的 Consumer 和 Provider 是抽象概念，只是想让看图者更直观的了解哪些类分属于客户端与服务器端，不用 Client 和 Server 的原因是 Dubbo 在很多场景下都使用 Provider, Consumer, Registry, Monitor 划分逻辑拓普节点，保持统一概念。\n* 而 Cluster 是外围概念，所以 Cluster 的目的是将多个 Invoker 伪装成一个 Invoker，这样其它人只要关注 Protocol 层 Invoker 即可，加上 Cluster 或者去掉 Cluster 对其它层都不会造成影响，因为只有一个提供者时，是不需要 Cluster 的。\n* Proxy 层封装了所有接口的透明化代理，而在其它层都以 Invoker 为中心，只有到了暴露给用户使用时，才用 Proxy 将 Invoker 转成接口，或将接口实现转成 Invoker，也就是去掉 Proxy 层 RPC 是可以 Run 的，只是不那么透明，不那么看起来像调本地服务一样调远程服务。\n* 而 Remoting 实现是 Dubbo 协议的实现，如果你选择 RMI 协议，整个 Remoting 都不会用上，Remoting 内部再划为 Transport 传输层和 Exchange 信息交换层，Transport 层只负责单向消息传输，是对 Mina, Netty, Grizzly 的抽象，它也可以扩展 UDP 传输，而 Exchange 层是在传输层之上封装了 Request-Response 语义。\n* Registry 和 Monitor 实际上不算一层，而是一个独立的节点，只是为了全局概览，用层的方式画在一起。\n\n### 其他\n##### 以上摘抄了一部分个人觉得对理解dubbo结构比较重要的部分，当然只看这一部分肯定还是很糊涂的，需要结合各种实际项目以及源码去慢慢理解。除此之外，还有一些比较重要的架构信息：\n* dubbo的扩展点机制，dubbo是如何实现模块化的：[dubbo扩展点加载](http://dubbo.io/books/dubbo-dev-book/SPI.html)\n* dubbo的整体实现细节，加载入口，服务以及通讯细节：[dubbo实现细节](http://dubbo.io/books/dubbo-dev-book/implementation.html)\n\n##### 其实作为rpc远程调用本身来说，实现是很简单的，只是dubbo在这之上构建了一套完整的基于服务的整体架构，这也是dubbo的魅力所在，那么我后面也将对这些服务做一些详细实现分析：\n##### [dubbo-动态代理实现](https://winx402.github.io/note/dubbo/proxy/)\n##### [dubbo-负载均衡实现](https://winx402.github.io/note/dubbo/loadBalance/)\n##### [本系列dubbo源码分析](https://winx402.github.io/tags/dubbo/)","source":"_posts/note/dubbo/summarize.md","raw":"---\nlayout: post\ntitle: dubbo概述\ndate: 2018/03/22\ntags: [tech, index, dubbo]\ntag: [[java, java], [dubbo, dubbo]]\noriginal: true\n---\n\n##### 从这篇文章开始，我将对dubbo的源码进行阅读与分析。网络上对于dubbo的架构已经整体的设计原理已经有非常多的文章了，这里推荐一下[dubbo官方技术文档](http://dubbo.io/books/dubbo-dev-book/)。这些文档已经对dubbo的整体架构和扩展机制做了详细的说明。这在我后面的系列文章中将不会再有这部分介绍。但是该文档只是指出了dubbo的众多扩展点的接口以及简单说明，并没有对接口做详细的代码实现分析。所以我将尝试阅读并分享基于这些扩展点的代码实现过程。\n\n<!--more-->\n\n#### 在这之前，我们还是简单介绍一下dubbo的框架设计\n\n## 框架设计\n### 整体设计\n![](/img/note/dubbo/dubbo-framework.jpg)\n\n##### 图例说明：\n* 图中左边淡蓝背景的为服务消费方使用的接口，右边淡绿色背景的为服务提供方使用的接口，位于中轴线上的为双方都用到的接口。\n* 图中从下至上分为十层，各层均为单向依赖，右边的黑色箭头代表层之间的依赖关系，每一层都可以剥离上层被复用，其中，Service 和 Config 层为 API，其它各层均为 SPI。\n* 图中绿色小块的为扩展接口，蓝色小块为实现类，图中只显示用于关联各层的实现类。\n* 图中蓝色虚线为初始化过程，即启动时组装链，红色实线为方法调用过程，即运行时调时链，紫色三角箭头为继承，可以把子类看作父类的同一个节点，线上的文字为调用的方法。\n\n### 各层说明\n* **config 配置层**：对外配置接口，以 ServiceConfig, ReferenceConfig 为中心，可以直接初始化配置类，也可以通过 spring 解析配置生成配置类\n* **proxy 服务代理层**：服务接口透明代理，生成服务的客户端 Stub 和服务器端 Skeleton, 以 ServiceProxy 为中心，扩展接口为 ProxyFactory\n* **registry 注册中心层**：封装服务地址的注册与发现，以服务 URL 为中心，扩展接口为 RegistryFactory, Registry, RegistryService\n* **cluster 路由层**：封装多个提供者的路由及负载均衡，并桥接注册中心，以 Invoker 为中心，扩展接口为 Cluster, Directory, Router, LoadBalance\n* **monitor 监控层**：RPC 调用次数和调用时间监控，以 Statistics 为中心，扩展接口为 MonitorFactory, Monitor, MonitorService\n* **protocol 远程调用层**：封装 RPC 调用，以 Invocation, Result 为中心，扩展接口为 Protocol, Invoker, Exporter\n* **exchange 信息交换层**：封装请求响应模式，同步转异步，以 Request, Response 为中心，扩展接口为 Exchanger, ExchangeChannel, ExchangeClient, ExchangeServer\n* **transport 网络传输层**：抽象 mina 和 netty 为统一接口，以 Message 为中心，扩展接口为 Channel, Transporter, Client, Server, Codec\n* **serialize 数据序列化层**：可复用的一些工具，扩展接口为 Serialization, ObjectInput, ObjectOutput, ThreadPool\n\n### 关系说明\n* 在 RPC 中，Protocol 是核心层，也就是只要有 Protocol + Invoker + Exporter 就可以完成非透明的 RPC 调用，然后在 Invoker 的主过程上 Filter 拦截点。\n* 图中的 Consumer 和 Provider 是抽象概念，只是想让看图者更直观的了解哪些类分属于客户端与服务器端，不用 Client 和 Server 的原因是 Dubbo 在很多场景下都使用 Provider, Consumer, Registry, Monitor 划分逻辑拓普节点，保持统一概念。\n* 而 Cluster 是外围概念，所以 Cluster 的目的是将多个 Invoker 伪装成一个 Invoker，这样其它人只要关注 Protocol 层 Invoker 即可，加上 Cluster 或者去掉 Cluster 对其它层都不会造成影响，因为只有一个提供者时，是不需要 Cluster 的。\n* Proxy 层封装了所有接口的透明化代理，而在其它层都以 Invoker 为中心，只有到了暴露给用户使用时，才用 Proxy 将 Invoker 转成接口，或将接口实现转成 Invoker，也就是去掉 Proxy 层 RPC 是可以 Run 的，只是不那么透明，不那么看起来像调本地服务一样调远程服务。\n* 而 Remoting 实现是 Dubbo 协议的实现，如果你选择 RMI 协议，整个 Remoting 都不会用上，Remoting 内部再划为 Transport 传输层和 Exchange 信息交换层，Transport 层只负责单向消息传输，是对 Mina, Netty, Grizzly 的抽象，它也可以扩展 UDP 传输，而 Exchange 层是在传输层之上封装了 Request-Response 语义。\n* Registry 和 Monitor 实际上不算一层，而是一个独立的节点，只是为了全局概览，用层的方式画在一起。\n\n### 其他\n##### 以上摘抄了一部分个人觉得对理解dubbo结构比较重要的部分，当然只看这一部分肯定还是很糊涂的，需要结合各种实际项目以及源码去慢慢理解。除此之外，还有一些比较重要的架构信息：\n* dubbo的扩展点机制，dubbo是如何实现模块化的：[dubbo扩展点加载](http://dubbo.io/books/dubbo-dev-book/SPI.html)\n* dubbo的整体实现细节，加载入口，服务以及通讯细节：[dubbo实现细节](http://dubbo.io/books/dubbo-dev-book/implementation.html)\n\n##### 其实作为rpc远程调用本身来说，实现是很简单的，只是dubbo在这之上构建了一套完整的基于服务的整体架构，这也是dubbo的魅力所在，那么我后面也将对这些服务做一些详细实现分析：\n##### [dubbo-动态代理实现](https://winx402.github.io/note/dubbo/proxy/)\n##### [dubbo-负载均衡实现](https://winx402.github.io/note/dubbo/loadBalance/)\n##### [本系列dubbo源码分析](https://winx402.github.io/tags/dubbo/)","slug":"note/dubbo/summarize","published":1,"updated":"2018-05-08T14:51:18.366Z","_id":"cjgxop3ng003djah1ad07f2em","comments":1,"photos":[],"link":"","content":"<h5 id=\"从这篇文章开始，我将对dubbo的源码进行阅读与分析。网络上对于dubbo的架构已经整体的设计原理已经有非常多的文章了，这里推荐一下dubbo官方技术文档。这些文档已经对dubbo的整体架构和扩展机制做了详细的说明。这在我后面的系列文章中将不会再有这部分介绍。但是该文档只是指出了dubbo的众多扩展点的接口以及简单说明，并没有对接口做详细的代码实现分析。所以我将尝试阅读并分享基于这些扩展点的代码实现过程。\"><a href=\"#从这篇文章开始，我将对dubbo的源码进行阅读与分析。网络上对于dubbo的架构已经整体的设计原理已经有非常多的文章了，这里推荐一下dubbo官方技术文档。这些文档已经对dubbo的整体架构和扩展机制做了详细的说明。这在我后面的系列文章中将不会再有这部分介绍。但是该文档只是指出了dubbo的众多扩展点的接口以及简单说明，并没有对接口做详细的代码实现分析。所以我将尝试阅读并分享基于这些扩展点的代码实现过程。\" class=\"headerlink\" title=\"从这篇文章开始，我将对dubbo的源码进行阅读与分析。网络上对于dubbo的架构已经整体的设计原理已经有非常多的文章了，这里推荐一下dubbo官方技术文档。这些文档已经对dubbo的整体架构和扩展机制做了详细的说明。这在我后面的系列文章中将不会再有这部分介绍。但是该文档只是指出了dubbo的众多扩展点的接口以及简单说明，并没有对接口做详细的代码实现分析。所以我将尝试阅读并分享基于这些扩展点的代码实现过程。\"></a>从这篇文章开始，我将对dubbo的源码进行阅读与分析。网络上对于dubbo的架构已经整体的设计原理已经有非常多的文章了，这里推荐一下<a href=\"http://dubbo.io/books/dubbo-dev-book/\" target=\"_blank\" rel=\"external\">dubbo官方技术文档</a>。这些文档已经对dubbo的整体架构和扩展机制做了详细的说明。这在我后面的系列文章中将不会再有这部分介绍。但是该文档只是指出了dubbo的众多扩展点的接口以及简单说明，并没有对接口做详细的代码实现分析。所以我将尝试阅读并分享基于这些扩展点的代码实现过程。</h5><a id=\"more\"></a>\n<h4 id=\"在这之前，我们还是简单介绍一下dubbo的框架设计\"><a href=\"#在这之前，我们还是简单介绍一下dubbo的框架设计\" class=\"headerlink\" title=\"在这之前，我们还是简单介绍一下dubbo的框架设计\"></a>在这之前，我们还是简单介绍一下dubbo的框架设计</h4><h2 id=\"框架设计\"><a href=\"#框架设计\" class=\"headerlink\" title=\"框架设计\"></a>框架设计</h2><h3 id=\"整体设计\"><a href=\"#整体设计\" class=\"headerlink\" title=\"整体设计\"></a>整体设计</h3><p><img src=\"/img/note/dubbo/dubbo-framework.jpg\" alt=\"\"></p>\n<h5 id=\"图例说明：\"><a href=\"#图例说明：\" class=\"headerlink\" title=\"图例说明：\"></a>图例说明：</h5><ul>\n<li>图中左边淡蓝背景的为服务消费方使用的接口，右边淡绿色背景的为服务提供方使用的接口，位于中轴线上的为双方都用到的接口。</li>\n<li>图中从下至上分为十层，各层均为单向依赖，右边的黑色箭头代表层之间的依赖关系，每一层都可以剥离上层被复用，其中，Service 和 Config 层为 API，其它各层均为 SPI。</li>\n<li>图中绿色小块的为扩展接口，蓝色小块为实现类，图中只显示用于关联各层的实现类。</li>\n<li>图中蓝色虚线为初始化过程，即启动时组装链，红色实线为方法调用过程，即运行时调时链，紫色三角箭头为继承，可以把子类看作父类的同一个节点，线上的文字为调用的方法。</li>\n</ul>\n<h3 id=\"各层说明\"><a href=\"#各层说明\" class=\"headerlink\" title=\"各层说明\"></a>各层说明</h3><ul>\n<li><strong>config 配置层</strong>：对外配置接口，以 ServiceConfig, ReferenceConfig 为中心，可以直接初始化配置类，也可以通过 spring 解析配置生成配置类</li>\n<li><strong>proxy 服务代理层</strong>：服务接口透明代理，生成服务的客户端 Stub 和服务器端 Skeleton, 以 ServiceProxy 为中心，扩展接口为 ProxyFactory</li>\n<li><strong>registry 注册中心层</strong>：封装服务地址的注册与发现，以服务 URL 为中心，扩展接口为 RegistryFactory, Registry, RegistryService</li>\n<li><strong>cluster 路由层</strong>：封装多个提供者的路由及负载均衡，并桥接注册中心，以 Invoker 为中心，扩展接口为 Cluster, Directory, Router, LoadBalance</li>\n<li><strong>monitor 监控层</strong>：RPC 调用次数和调用时间监控，以 Statistics 为中心，扩展接口为 MonitorFactory, Monitor, MonitorService</li>\n<li><strong>protocol 远程调用层</strong>：封装 RPC 调用，以 Invocation, Result 为中心，扩展接口为 Protocol, Invoker, Exporter</li>\n<li><strong>exchange 信息交换层</strong>：封装请求响应模式，同步转异步，以 Request, Response 为中心，扩展接口为 Exchanger, ExchangeChannel, ExchangeClient, ExchangeServer</li>\n<li><strong>transport 网络传输层</strong>：抽象 mina 和 netty 为统一接口，以 Message 为中心，扩展接口为 Channel, Transporter, Client, Server, Codec</li>\n<li><strong>serialize 数据序列化层</strong>：可复用的一些工具，扩展接口为 Serialization, ObjectInput, ObjectOutput, ThreadPool</li>\n</ul>\n<h3 id=\"关系说明\"><a href=\"#关系说明\" class=\"headerlink\" title=\"关系说明\"></a>关系说明</h3><ul>\n<li>在 RPC 中，Protocol 是核心层，也就是只要有 Protocol + Invoker + Exporter 就可以完成非透明的 RPC 调用，然后在 Invoker 的主过程上 Filter 拦截点。</li>\n<li>图中的 Consumer 和 Provider 是抽象概念，只是想让看图者更直观的了解哪些类分属于客户端与服务器端，不用 Client 和 Server 的原因是 Dubbo 在很多场景下都使用 Provider, Consumer, Registry, Monitor 划分逻辑拓普节点，保持统一概念。</li>\n<li>而 Cluster 是外围概念，所以 Cluster 的目的是将多个 Invoker 伪装成一个 Invoker，这样其它人只要关注 Protocol 层 Invoker 即可，加上 Cluster 或者去掉 Cluster 对其它层都不会造成影响，因为只有一个提供者时，是不需要 Cluster 的。</li>\n<li>Proxy 层封装了所有接口的透明化代理，而在其它层都以 Invoker 为中心，只有到了暴露给用户使用时，才用 Proxy 将 Invoker 转成接口，或将接口实现转成 Invoker，也就是去掉 Proxy 层 RPC 是可以 Run 的，只是不那么透明，不那么看起来像调本地服务一样调远程服务。</li>\n<li>而 Remoting 实现是 Dubbo 协议的实现，如果你选择 RMI 协议，整个 Remoting 都不会用上，Remoting 内部再划为 Transport 传输层和 Exchange 信息交换层，Transport 层只负责单向消息传输，是对 Mina, Netty, Grizzly 的抽象，它也可以扩展 UDP 传输，而 Exchange 层是在传输层之上封装了 Request-Response 语义。</li>\n<li>Registry 和 Monitor 实际上不算一层，而是一个独立的节点，只是为了全局概览，用层的方式画在一起。</li>\n</ul>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><h5 id=\"以上摘抄了一部分个人觉得对理解dubbo结构比较重要的部分，当然只看这一部分肯定还是很糊涂的，需要结合各种实际项目以及源码去慢慢理解。除此之外，还有一些比较重要的架构信息：\"><a href=\"#以上摘抄了一部分个人觉得对理解dubbo结构比较重要的部分，当然只看这一部分肯定还是很糊涂的，需要结合各种实际项目以及源码去慢慢理解。除此之外，还有一些比较重要的架构信息：\" class=\"headerlink\" title=\"以上摘抄了一部分个人觉得对理解dubbo结构比较重要的部分，当然只看这一部分肯定还是很糊涂的，需要结合各种实际项目以及源码去慢慢理解。除此之外，还有一些比较重要的架构信息：\"></a>以上摘抄了一部分个人觉得对理解dubbo结构比较重要的部分，当然只看这一部分肯定还是很糊涂的，需要结合各种实际项目以及源码去慢慢理解。除此之外，还有一些比较重要的架构信息：</h5><ul>\n<li>dubbo的扩展点机制，dubbo是如何实现模块化的：<a href=\"http://dubbo.io/books/dubbo-dev-book/SPI.html\" target=\"_blank\" rel=\"external\">dubbo扩展点加载</a></li>\n<li>dubbo的整体实现细节，加载入口，服务以及通讯细节：<a href=\"http://dubbo.io/books/dubbo-dev-book/implementation.html\" target=\"_blank\" rel=\"external\">dubbo实现细节</a></li>\n</ul>\n<h5 id=\"其实作为rpc远程调用本身来说，实现是很简单的，只是dubbo在这之上构建了一套完整的基于服务的整体架构，这也是dubbo的魅力所在，那么我后面也将对这些服务做一些详细实现分析：\"><a href=\"#其实作为rpc远程调用本身来说，实现是很简单的，只是dubbo在这之上构建了一套完整的基于服务的整体架构，这也是dubbo的魅力所在，那么我后面也将对这些服务做一些详细实现分析：\" class=\"headerlink\" title=\"其实作为rpc远程调用本身来说，实现是很简单的，只是dubbo在这之上构建了一套完整的基于服务的整体架构，这也是dubbo的魅力所在，那么我后面也将对这些服务做一些详细实现分析：\"></a>其实作为rpc远程调用本身来说，实现是很简单的，只是dubbo在这之上构建了一套完整的基于服务的整体架构，这也是dubbo的魅力所在，那么我后面也将对这些服务做一些详细实现分析：</h5><h5 id=\"dubbo-动态代理实现\"><a href=\"#dubbo-动态代理实现\" class=\"headerlink\" title=\"dubbo-动态代理实现\"></a><a href=\"https://winx402.github.io/note/dubbo/proxy/\" target=\"_blank\" rel=\"external\">dubbo-动态代理实现</a></h5><h5 id=\"dubbo-负载均衡实现\"><a href=\"#dubbo-负载均衡实现\" class=\"headerlink\" title=\"dubbo-负载均衡实现\"></a><a href=\"https://winx402.github.io/note/dubbo/loadBalance/\" target=\"_blank\" rel=\"external\">dubbo-负载均衡实现</a></h5><h5 id=\"本系列dubbo源码分析\"><a href=\"#本系列dubbo源码分析\" class=\"headerlink\" title=\"本系列dubbo源码分析\"></a><a href=\"https://winx402.github.io/tags/dubbo/\" target=\"_blank\" rel=\"external\">本系列dubbo源码分析</a></h5>","site":{"data":{}},"excerpt":"<h5 id=\"从这篇文章开始，我将对dubbo的源码进行阅读与分析。网络上对于dubbo的架构已经整体的设计原理已经有非常多的文章了，这里推荐一下dubbo官方技术文档。这些文档已经对dubbo的整体架构和扩展机制做了详细的说明。这在我后面的系列文章中将不会再有这部分介绍。但是该文档只是指出了dubbo的众多扩展点的接口以及简单说明，并没有对接口做详细的代码实现分析。所以我将尝试阅读并分享基于这些扩展点的代码实现过程。\"><a href=\"#从这篇文章开始，我将对dubbo的源码进行阅读与分析。网络上对于dubbo的架构已经整体的设计原理已经有非常多的文章了，这里推荐一下dubbo官方技术文档。这些文档已经对dubbo的整体架构和扩展机制做了详细的说明。这在我后面的系列文章中将不会再有这部分介绍。但是该文档只是指出了dubbo的众多扩展点的接口以及简单说明，并没有对接口做详细的代码实现分析。所以我将尝试阅读并分享基于这些扩展点的代码实现过程。\" class=\"headerlink\" title=\"从这篇文章开始，我将对dubbo的源码进行阅读与分析。网络上对于dubbo的架构已经整体的设计原理已经有非常多的文章了，这里推荐一下dubbo官方技术文档。这些文档已经对dubbo的整体架构和扩展机制做了详细的说明。这在我后面的系列文章中将不会再有这部分介绍。但是该文档只是指出了dubbo的众多扩展点的接口以及简单说明，并没有对接口做详细的代码实现分析。所以我将尝试阅读并分享基于这些扩展点的代码实现过程。\"></a>从这篇文章开始，我将对dubbo的源码进行阅读与分析。网络上对于dubbo的架构已经整体的设计原理已经有非常多的文章了，这里推荐一下<a href=\"http://dubbo.io/books/dubbo-dev-book/\" target=\"_blank\" rel=\"external\">dubbo官方技术文档</a>。这些文档已经对dubbo的整体架构和扩展机制做了详细的说明。这在我后面的系列文章中将不会再有这部分介绍。但是该文档只是指出了dubbo的众多扩展点的接口以及简单说明，并没有对接口做详细的代码实现分析。所以我将尝试阅读并分享基于这些扩展点的代码实现过程。</h5>","more":"<h4 id=\"在这之前，我们还是简单介绍一下dubbo的框架设计\"><a href=\"#在这之前，我们还是简单介绍一下dubbo的框架设计\" class=\"headerlink\" title=\"在这之前，我们还是简单介绍一下dubbo的框架设计\"></a>在这之前，我们还是简单介绍一下dubbo的框架设计</h4><h2 id=\"框架设计\"><a href=\"#框架设计\" class=\"headerlink\" title=\"框架设计\"></a>框架设计</h2><h3 id=\"整体设计\"><a href=\"#整体设计\" class=\"headerlink\" title=\"整体设计\"></a>整体设计</h3><p><img src=\"/img/note/dubbo/dubbo-framework.jpg\" alt=\"\"></p>\n<h5 id=\"图例说明：\"><a href=\"#图例说明：\" class=\"headerlink\" title=\"图例说明：\"></a>图例说明：</h5><ul>\n<li>图中左边淡蓝背景的为服务消费方使用的接口，右边淡绿色背景的为服务提供方使用的接口，位于中轴线上的为双方都用到的接口。</li>\n<li>图中从下至上分为十层，各层均为单向依赖，右边的黑色箭头代表层之间的依赖关系，每一层都可以剥离上层被复用，其中，Service 和 Config 层为 API，其它各层均为 SPI。</li>\n<li>图中绿色小块的为扩展接口，蓝色小块为实现类，图中只显示用于关联各层的实现类。</li>\n<li>图中蓝色虚线为初始化过程，即启动时组装链，红色实线为方法调用过程，即运行时调时链，紫色三角箭头为继承，可以把子类看作父类的同一个节点，线上的文字为调用的方法。</li>\n</ul>\n<h3 id=\"各层说明\"><a href=\"#各层说明\" class=\"headerlink\" title=\"各层说明\"></a>各层说明</h3><ul>\n<li><strong>config 配置层</strong>：对外配置接口，以 ServiceConfig, ReferenceConfig 为中心，可以直接初始化配置类，也可以通过 spring 解析配置生成配置类</li>\n<li><strong>proxy 服务代理层</strong>：服务接口透明代理，生成服务的客户端 Stub 和服务器端 Skeleton, 以 ServiceProxy 为中心，扩展接口为 ProxyFactory</li>\n<li><strong>registry 注册中心层</strong>：封装服务地址的注册与发现，以服务 URL 为中心，扩展接口为 RegistryFactory, Registry, RegistryService</li>\n<li><strong>cluster 路由层</strong>：封装多个提供者的路由及负载均衡，并桥接注册中心，以 Invoker 为中心，扩展接口为 Cluster, Directory, Router, LoadBalance</li>\n<li><strong>monitor 监控层</strong>：RPC 调用次数和调用时间监控，以 Statistics 为中心，扩展接口为 MonitorFactory, Monitor, MonitorService</li>\n<li><strong>protocol 远程调用层</strong>：封装 RPC 调用，以 Invocation, Result 为中心，扩展接口为 Protocol, Invoker, Exporter</li>\n<li><strong>exchange 信息交换层</strong>：封装请求响应模式，同步转异步，以 Request, Response 为中心，扩展接口为 Exchanger, ExchangeChannel, ExchangeClient, ExchangeServer</li>\n<li><strong>transport 网络传输层</strong>：抽象 mina 和 netty 为统一接口，以 Message 为中心，扩展接口为 Channel, Transporter, Client, Server, Codec</li>\n<li><strong>serialize 数据序列化层</strong>：可复用的一些工具，扩展接口为 Serialization, ObjectInput, ObjectOutput, ThreadPool</li>\n</ul>\n<h3 id=\"关系说明\"><a href=\"#关系说明\" class=\"headerlink\" title=\"关系说明\"></a>关系说明</h3><ul>\n<li>在 RPC 中，Protocol 是核心层，也就是只要有 Protocol + Invoker + Exporter 就可以完成非透明的 RPC 调用，然后在 Invoker 的主过程上 Filter 拦截点。</li>\n<li>图中的 Consumer 和 Provider 是抽象概念，只是想让看图者更直观的了解哪些类分属于客户端与服务器端，不用 Client 和 Server 的原因是 Dubbo 在很多场景下都使用 Provider, Consumer, Registry, Monitor 划分逻辑拓普节点，保持统一概念。</li>\n<li>而 Cluster 是外围概念，所以 Cluster 的目的是将多个 Invoker 伪装成一个 Invoker，这样其它人只要关注 Protocol 层 Invoker 即可，加上 Cluster 或者去掉 Cluster 对其它层都不会造成影响，因为只有一个提供者时，是不需要 Cluster 的。</li>\n<li>Proxy 层封装了所有接口的透明化代理，而在其它层都以 Invoker 为中心，只有到了暴露给用户使用时，才用 Proxy 将 Invoker 转成接口，或将接口实现转成 Invoker，也就是去掉 Proxy 层 RPC 是可以 Run 的，只是不那么透明，不那么看起来像调本地服务一样调远程服务。</li>\n<li>而 Remoting 实现是 Dubbo 协议的实现，如果你选择 RMI 协议，整个 Remoting 都不会用上，Remoting 内部再划为 Transport 传输层和 Exchange 信息交换层，Transport 层只负责单向消息传输，是对 Mina, Netty, Grizzly 的抽象，它也可以扩展 UDP 传输，而 Exchange 层是在传输层之上封装了 Request-Response 语义。</li>\n<li>Registry 和 Monitor 实际上不算一层，而是一个独立的节点，只是为了全局概览，用层的方式画在一起。</li>\n</ul>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><h5 id=\"以上摘抄了一部分个人觉得对理解dubbo结构比较重要的部分，当然只看这一部分肯定还是很糊涂的，需要结合各种实际项目以及源码去慢慢理解。除此之外，还有一些比较重要的架构信息：\"><a href=\"#以上摘抄了一部分个人觉得对理解dubbo结构比较重要的部分，当然只看这一部分肯定还是很糊涂的，需要结合各种实际项目以及源码去慢慢理解。除此之外，还有一些比较重要的架构信息：\" class=\"headerlink\" title=\"以上摘抄了一部分个人觉得对理解dubbo结构比较重要的部分，当然只看这一部分肯定还是很糊涂的，需要结合各种实际项目以及源码去慢慢理解。除此之外，还有一些比较重要的架构信息：\"></a>以上摘抄了一部分个人觉得对理解dubbo结构比较重要的部分，当然只看这一部分肯定还是很糊涂的，需要结合各种实际项目以及源码去慢慢理解。除此之外，还有一些比较重要的架构信息：</h5><ul>\n<li>dubbo的扩展点机制，dubbo是如何实现模块化的：<a href=\"http://dubbo.io/books/dubbo-dev-book/SPI.html\" target=\"_blank\" rel=\"external\">dubbo扩展点加载</a></li>\n<li>dubbo的整体实现细节，加载入口，服务以及通讯细节：<a href=\"http://dubbo.io/books/dubbo-dev-book/implementation.html\" target=\"_blank\" rel=\"external\">dubbo实现细节</a></li>\n</ul>\n<h5 id=\"其实作为rpc远程调用本身来说，实现是很简单的，只是dubbo在这之上构建了一套完整的基于服务的整体架构，这也是dubbo的魅力所在，那么我后面也将对这些服务做一些详细实现分析：\"><a href=\"#其实作为rpc远程调用本身来说，实现是很简单的，只是dubbo在这之上构建了一套完整的基于服务的整体架构，这也是dubbo的魅力所在，那么我后面也将对这些服务做一些详细实现分析：\" class=\"headerlink\" title=\"其实作为rpc远程调用本身来说，实现是很简单的，只是dubbo在这之上构建了一套完整的基于服务的整体架构，这也是dubbo的魅力所在，那么我后面也将对这些服务做一些详细实现分析：\"></a>其实作为rpc远程调用本身来说，实现是很简单的，只是dubbo在这之上构建了一套完整的基于服务的整体架构，这也是dubbo的魅力所在，那么我后面也将对这些服务做一些详细实现分析：</h5><h5 id=\"dubbo-动态代理实现\"><a href=\"#dubbo-动态代理实现\" class=\"headerlink\" title=\"dubbo-动态代理实现\"></a><a href=\"https://winx402.github.io/note/dubbo/proxy/\" target=\"_blank\" rel=\"external\">dubbo-动态代理实现</a></h5><h5 id=\"dubbo-负载均衡实现\"><a href=\"#dubbo-负载均衡实现\" class=\"headerlink\" title=\"dubbo-负载均衡实现\"></a><a href=\"https://winx402.github.io/note/dubbo/loadBalance/\" target=\"_blank\" rel=\"external\">dubbo-负载均衡实现</a></h5><h5 id=\"本系列dubbo源码分析\"><a href=\"#本系列dubbo源码分析\" class=\"headerlink\" title=\"本系列dubbo源码分析\"></a><a href=\"https://winx402.github.io/tags/dubbo/\" target=\"_blank\" rel=\"external\">本系列dubbo源码分析</a></h5>"},{"layout":"post","title":"java阻塞队列详解","date":"2018-03-26T16:00:00.000Z","tag":[["java","java"]],"_content":"\n##### `java.util.concurrent`包里的**BlockingQueue**接口表示一个线程安放入和提取实例的队列。这里我们将分析和演示如何使用这个**BlockingQueue**，以及对BlockingQueue的各种实现的源码解析。\n\n<!--more-->\n\n## BlockingQueue的使用\n\n##### **BlockingQueue**的数据结构为队列，通常将操作线程区分为生成者和消费者。下图是对这个原理的阐述：\n\n![blockingQueue](/img/note/jdk/blockingqueue.png)\n\n##### 生产者线程往里边放，消费者线程从里边取的一个BlockingQueue。\n##### 生产者线程将会持续生产新对象并将其插入到队列之中，直到队列达到它所能容纳的临界点。也就是说，它是有限的。如果该阻塞队列到达了其临界点，负责生产的线程将会在往里边插入新对象时发生阻塞。它会一直处于阻塞之中，直到负责消费的线程从队列中拿走一个对象。\n\n##### 负责消费的线程将会一直从该阻塞队列中拿出对象。如果消费线程尝试去从一个空的队列中提取对象的话，这个消费线程将会处于阻塞之中，直到生产线程把一个对象丢进队列。\n\n## BlockingQueue\n```java\npublic interface BlockingQueue<E> extends Queue<E> {\n\n    boolean add(E e);\n\n    boolean offer(E e);\n\n    void put(E e) throws InterruptedException;\n\n    boolean offer(E e, long timeout, TimeUnit unit)\n        throws InterruptedException;\n\n    E take() throws InterruptedException;\n\n    E poll(long timeout, TimeUnit unit)\n        throws InterruptedException;\n\n    int remainingCapacity();\n\n    boolean remove(Object o);\n\n    public boolean contains(Object o);\n\n    int drainTo(Collection<? super E> c);\n\n    int drainTo(Collection<? super E> c, int maxElements);\n}\n```\n\n##### 接口**BlockingQueue**的方法就是上面几个，分析一下几个主要方法的用途：\n1. **offer** & **poll**：往队列中插入、取出数据，如果成功则返回true，如果失败则返回false，这个过程不阻塞，看下ArrayBlockingQueue中的实现：\n```java\npublic boolean offer(E e) {\n        checkNotNull(e);\n        //通过锁来保证线程安全\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n        try {\n            if (count == items.length)\n                //如果队列已满\n                return false;\n            else {\n                //如果队列未满，真正的插入操作在enqueue中进行\n                enqueue(e);\n                return true;\n            }\n        } finally {\n            lock.unlock();\n        }\n    }\n```\n```java\npublic E poll() {\n        //通过锁来保证线程安全\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n        try {\n            //如果队列为空则返回null，否则通过dequeue拿到队首数据\n            return (count == 0) ? null : dequeue();\n        } finally {\n            lock.unlock();\n        }\n    }\n```\n2. **add** & **remove** ：往队列中插入、删除数据，如果成功则返回true，不阻塞，如果失败则抛出异常，看下AbstractQueue中的实现：\n```java\npublic boolean add(E e) {\n        if (offer(e))\n            return true;\n        else\n            throw new IllegalStateException(\"Queue full\");\n    }\n```\n```java\npublic E remove() {\n        E x = poll();\n        if (x != null)\n            return x;\n        else\n            throw new NoSuchElementException();\n    }\n```\n##### 可以看到add和remove的操作很简单，把具体队列操作都依赖给了offer和pull\n\n3. **put** & **take**：put操作时阻塞队列的核心，将数据插入队列，如果队列满，则阻塞直到插入成功。take和put相对应，从队列中取数据，看下ArrayBlockingQueue中的实现：\n```java\npublic void put(E e) throws InterruptedException {\n        checkNotNull(e);\n        final ReentrantLock lock = this.lock;\n        lock.lockInterruptibly();\n        try {\n            while (count == items.length)\n                notFull.await(); //利用条件对象notFull阻塞\n            enqueue(e);\n        } finally {\n            lock.unlock();\n        }\n    }\n```\n```java\npublic E take() throws InterruptedException {\n        final ReentrantLock lock = this.lock;\n        lock.lockInterruptibly();\n        try {\n            while (count == 0)\n                notEmpty.await(); //利用条件对象notEmpty阻塞\n            return dequeue();\n        } finally {\n            lock.unlock();\n        }\n    }\n```\n\n##### 知道了**BlockingQueue**的基本用法和简单的实现，那么java中常见的**BlockingQueue**有哪些呢：\n* ArrayBlockingQueue\n* DelayQueue\n* LinkedBlockingQueue\n* SynchronousQueue\n\n##### 他们有什么区别呢。下面我们将通过源码来具体分析他们的实现过程。\n\n## ArrayBlockingQueue\n##### **ArrayBlockingQueue**类继承了AbstractQueue并实现了**BlockingQueue**接口，来看下**ArrayBlockingQueue**中一些主要的属性。\n\n```java\npublic class ArrayBlockingQueue<E> extends AbstractQueue<E>\n        implements BlockingQueue<E>, java.io.Serializable {\n    //使用final 数组保存队列中的数据。数组需要初始化长度。因此数组的长度就是ArrayBlockingQueue的最大容量\n    final Object[] items;\n\n    //数组的下标指针，标识着下一步的take, poll, peek or remove操作。相当于头部指针\n    int takeIndex;\n\n    ////数组的下标指针，标识着下一步的put, offer, or add操作，相当于尾部指针\n    int putIndex;\n\n    //当前队列中已有数据的个数\n    int count;\n\n    //锁，保证基本的数据操作的线程安全\n    final ReentrantLock lock;\n\n    //条件对象，用于takes操作的等待\n    private final Condition notEmpty;\n\n    //条件对象，用于puts操作的等待\n    private final Condition notFull;\n\n    //迭代器\n    transient Itrs itrs = null;\n}\n```\n\n##### 可以看到**ArrayBlockingQueue**的底层数据结构是通过有界数组来实现的，因此你必须在创建的时候就应该确定好容量：\n```java\npublic ArrayBlockingQueue(int capacity) {\n        this(capacity, false);\n    }\n```\n\n```java\npublic ArrayBlockingQueue(int capacity, boolean fair) {\n        if (capacity <= 0)\n            throw new IllegalArgumentException();\n        this.items = new Object[capacity];\n        lock = new ReentrantLock(fair);\n        notEmpty = lock.newCondition();\n        notFull =  lock.newCondition();\n    }\n```\n\n```java\npublic ArrayBlockingQueue(int capacity, boolean fair,\n                              Collection<? extends E> c) {\n        this(capacity, fair);\n\n        final ReentrantLock lock = this.lock;\n        lock.lock(); // Lock only for visibility, not mutual exclusion\n        try {\n            int i = 0;\n            try {\n                for (E e : c) {\n                    checkNotNull(e);\n                    items[i++] = e;\n                }\n            } catch (ArrayIndexOutOfBoundsException ex) {\n                throw new IllegalArgumentException();\n            }\n            count = i;\n            putIndex = (i == capacity) ? 0 : i;\n        } finally {\n            lock.unlock();\n        }\n    }\n```\n\n##### 可以看到ArrayBlockingQueue的初始化可以有三个参数：\n1. **capacity（容量）**：三个构造函数都需要的变量，也就是ArrayBlockingQueue的初始容量。\n2. **fair（是否公平）**：缺省默认为非公平，这里的公平与非公平主要体现在锁的获取上，ArrayBlockingQueue会根据这个参数来创建公平锁或者非公平锁\n3. **c（集合）**：初始集合数据，即使有这个参数，ArrayBlockingQueue依然会按照capacity的大小来初始化数组大小，即使c的容量可能会超过capacity。如果c的容量大于capacity大小。构造函数中会捕获该异常**ArrayIndexOutOfBoundsException**，并抛出一个新的**IllegalArgumentException**异常。\n\n##### 这是**ArrayBlockingQueue**的主要特点，那么我们来看看ArrayBlockingQueue是如何来操作数据添加和删除数据的\n#### enqueue（入队）\n```java\nprivate void enqueue(E x) {\n        final Object[] items = this.items;\n        //通过putIndex下标直接插入数据\n        items[putIndex] = x;\n        //自增putIndex后，如果已经是数组尾部，则重新开始计算，循环指针\n        if (++putIndex == items.length)\n            putIndex = 0;\n        count++;//数据大小加1\n        notEmpty.signal(); //释放因为take操作而阻塞的线程\n    }\n```\n##### 该操作为私有操作，只有方法内部可以调用，通过上面的代码我们知道put, offer, add操作都是通过该方法插入的数据，所以在enqueue方法中并没有锁的操作，因为在外部已经获取过锁\n\n#### dequeue（出队）\n```java\nprivate E dequeue() {\n        final Object[] items = this.items;\n        //通过takeIndex获取数组数据\n        E x = (E) items[takeIndex];\n        //制空\n        items[takeIndex] = null;\n        //自增takeIndex后，如果已经是数组尾部，则重新开始计算，循环指针\n        if (++takeIndex == items.length)\n            takeIndex = 0;\n        count--;//数据大小减1\n        if (itrs != null)\n            itrs.elementDequeued();\n        notFull.signal();//释放因为put操作而阻塞的线程\n        return x; //返回数据\n    }\n```\n\n## DelayQueue\n##### **DelayQueue**是一个无界的**BlockingQueue**，用于放置实现了**Delayed**接口的对象，其中的对象只能在其到期时才能从队列中取走。这种队列是有序的，即队头对象的延迟到期时间最长。注意：不能将null元素放置到这种队列中。\n\n### 先来看下使用过程：\n##### 创建一个Delayed，用于保存任务数据以及延迟执行的时间\n```java\npublic class B implements Delayed{\n\n        private long endTime; //执行时间\n\n        public B(long endTime) {\n            this.endTime = endTime;\n        }\n\n        public long getDelay(TimeUnit unit) {\n            return unit.convert(endTime - System.currentTimeMillis(), TimeUnit.MILLISECONDS);\n        }\n\n        public int compareTo(Delayed o) {\n            if(o == null) return 1;\n            if(o == this) return 0;\n            if (this.getDelay(TimeUnit.NANOSECONDS) > o.getDelay(TimeUnit.NANOSECONDS)) {\n                return 1;\n            }else if (this.getDelay(TimeUnit.NANOSECONDS) == o.getDelay(TimeUnit.NANOSECONDS)) {\n                return 0;\n            }else {\n                return -1;\n            }\n        }\n    }\n```\n\n##### main方法\n```java\npublic static void main(String[] args) throws InterruptedException {\n        DelayQueue<B> delayed = new DelayQueue<B>();\n        B b = new B(new Date().getTime() + 10000); //第一个任务在10秒后执行\n        B b1 = new B(new Date().getTime() + 5000); //第二个任务在5秒后执行\n        delayed.put(b);\n        delayed.put(b1);\n        System.out.println(delayed.take().getEndTime());\n        System.out.println(delayed.take().getEndTime());\n    }\n```\n\n##### 输出结果：\n```\n1522220892807\n1522220897807\n```\n\n### DelayQueue实现细节\n#### 看下DelayQueue的属性变量\n```java\npublic class DelayQueue<E extends Delayed> extends AbstractQueue<E>\n    implements BlockingQueue<E> {\n\n    //锁，控制队列操作的线程安全\n    private final transient ReentrantLock lock = new ReentrantLock();\n\n    //优先队列，实际存储节点的数据结构，优先队列将按照我们提供的compareTo方法进行排序\n    //队列中使用数组进行存储数据，但是在容量不够的时候可以动态扩容。在这里初始大小为11\n    private final PriorityQueue<E> q = new PriorityQueue<E>();\n\n    //当前头部节点的等待线程，防止多个线程等待同一个节点\n    private Thread leader = null;\n\n    //线程阻塞使用Condition实现\n    private final Condition available = lock.newCondition();\n}\n```\n\n#### 我们来看下构造函数：\n\n##### 无参构造函数\n```java\npublic DelayQueue() {}\n```\n\n##### 通过集合初始化**DelayQueue**\n```java\npublic DelayQueue(Collection<? extends E> c) {\n        this.addAll(c);\n}\n```\n\n##### 可以看到**DelayQueue**的构造函数非常简单，这是因为**DelayQueue**是无界的，而且真正存储数据的**PriorityQueue**默认就已经初始化完成。所以**DelayQueue**实际并不关心数据的存储，它的核心还是在于take操作的阻塞过程：\n```java\npublic E take() throws InterruptedException {\n        final ReentrantLock lock = this.lock; //通过锁来保证线程安全\n        lock.lockInterruptibly(); //可中断锁\n        try {\n            for (;;) {\n                E first = q.peek(); //查看队列头部的节点\n                if (first == null)\n                    available.await(); //如果队列为空，阻塞\n                else {\n                    long delay = first.getDelay(NANOSECONDS); //获取等待时间\n                    if (delay <= 0) //等待时间小于等于0 则直接返回，这是该方法唯一的出口。除非锁中断\n                        return q.poll();\n                    first = null; // 等待时间大于0，需要阻塞等待\n                    if (leader != null)\n                        available.await(); //如果有其他线程在等待该节点，则阻塞\n                    else {\n                        Thread thisThread = Thread.currentThread();\n                        leader = thisThread; //设置等待头部节点的线程\n                        try {\n                            available.awaitNanos(delay); //等待固定时间\n                        } finally {\n                            if (leader == thisThread)\n                                leader = null; //等待结束后释放等待线程，重新获取节点\n                        }\n                    }\n                }\n            }\n        } finally {\n            if (leader == null && q.peek() != null)\n                available.signal(); //如果没有线程在等待头部节点，并且队列不为空。则唤醒其他等待线程\n            lock.unlock(); //锁释放\n        }\n    }\n```\n\n##### 整理一下操作流程：\n1. 获取锁\n2. 获取队列头部的节点（不出队）\n3. 如果头部节点为空，则判断队列为空，线程阻塞等待并释放锁，唤醒时回到步骤2\n4. 如果节点不为空，获取头部节点的等待时间（这里参照之前的例子，需要自行计算等待时间，略坑）\n5. 如果等待时间小于等于0。则认为该节点可以返回，调用poll操作返回。这是该方法的唯一一个正常出口\n6. 等待时间大于0\n    1. 判断是否还有其他线程在等待该节点，如果有，则阻塞并释放锁。（理论上来说等该线程唤醒并执行时获取到的应该是后续的节点了），唤醒时回到步骤2\n    2. 如果没有其他线程等待，则通过awaitNanos方法等待固定时间。唤醒时释放头部节点的等待线程。重新回到步骤2\n7. 通常情况下，awaitNanos方法过后重新获取节点能够正常返回了。然后调用finally块，在finally中会释放步骤3和步骤6中的第1部分的阻塞线程中的一个。\n\n##### 在上面的操作过程中有一个小坑就是步骤4，这里的等待时间需要自行计算。这里会带来什么坑呢，看个例子：\n```java\npublic static void main(String[] args) throws InterruptedException {\n        DelayQueue<B> delayed = new DelayQueue<B>();\n        B b = new B(new Date().getTime() + 10000);\n        B b1 = new B(new Date().getTime() + 5000);\n        delayed.put(b);\n        delayed.put(b1);\n        b1.setEndTime(b1.getEndTime() + 10000);\n        System.out.println(delayed.take().getEndTime());\n        System.out.println(delayed.take().getEndTime());\n    }\n\n    private static class B implements Delayed{\n\n        private long endTime;\n\n        public B(long endTime) {\n            this.endTime = endTime;\n        }\n\n        public long getDelay(TimeUnit unit) {\n            return unit.convert(endTime - System.currentTimeMillis(), TimeUnit.MILLISECONDS);\n        }\n\n        public long getEndTime() {\n            return endTime;\n        }\n\n        public void setEndTime(long endTime) {\n            this.endTime = endTime;\n        }\n\n        public int compareTo(Delayed o) {\n            if(o == null) return 1;\n            if(o == this) return 0;\n            if (this.getDelay(TimeUnit.NANOSECONDS) > o.getDelay(TimeUnit.NANOSECONDS)) {\n                return 1;\n            }else if (this.getDelay(TimeUnit.NANOSECONDS) == o.getDelay(TimeUnit.NANOSECONDS)) {\n                return 0;\n            }else {\n                return -1;\n            }\n        }\n    }\n```\n\n##### 输出结果\n```\n1522230732548\n1522230727548\n```\n\n##### 解释一下上面的例子，这个例子和之前的例子是一样的。设置了两个任务并且入队。一个任务5秒后执行，一个任务10秒后执行。入队后将5秒执行的任务再往后推迟10秒（变成了15秒）。结果执行结果显示15秒延迟的任务先执行。再立刻执行了10秒延迟任务。\n\n##### 这个坑就在于需要开发者自己去计算到期时间，而且这个时间必须是实时计算出来。如果固定返回一个大于0的数字，这个队列将永远循环阻塞在该节点。后面的任务将不会被执行。就算不是固定时间，但是修改了任务执行时间，任务不会重新排序。导致队列部分后续任务执行时间错误。\n\n##### 当然这样也有一点好处，就是使得**DelayQueue**本身足够简单。**DelayQueue**不用去关心或者计算任务的过期时间，而是把这部分操场依赖给了任务本身。但是没有做到动态的调整队列顺序已保证过期时间计算的复杂性。所以这个操作还是有点坑。\n\n### offer、poll\n```java\npublic boolean offer(E e) {\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n        try {\n            q.offer(e); //调用优先队列的offer操作，有排序\n            if (q.peek() == e) {\n                leader = null; //如果插入的节点是头部节点，则唤醒等待线程\n                available.signal();\n            }\n            return true;\n        } finally {\n            lock.unlock();\n        }\n    }\n```\n\n```java\npublic E poll() {\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n        try {\n            E first = q.peek();\n            if (first == null || first.getDelay(NANOSECONDS) > 0) //如果头部节点为空或者没到执行时间\n                return null; //返回空\n            else\n                return q.poll();\n        } finally {\n            lock.unlock();\n        }\n    }\n```\n\n## LinkedBlockingQueue\n##### LinkedBlockingQueue是一个由链表实现的有界队列阻塞队列。让我们来看下代码：\n```java\npublic class LinkedBlockingQueue<E> extends AbstractQueue<E>\n        implements BlockingQueue<E>, java.io.Serializable {\n\n    //链表节点，存储节点数据和下一个节点\n    static class Node<E> {\n        E item;\n\n        Node<E> next;\n\n        Node(E x) { item = x; }\n    }\n\n    //最大容量。默认为Integer.MAX_VALUE\n    private final int capacity;\n\n    //线程安全类AtomicInteger，记录链表队列长度\n    private final AtomicInteger count = new AtomicInteger();\n\n    //头部节点\n    transient Node<E> head;\n\n    //尾部节点\n    private transient Node<E> last;\n\n    /** 获取节点操作 的锁 */\n    private final ReentrantLock takeLock = new ReentrantLock();\n\n    /** 获取节点操作 的条件对象 */\n    private final Condition notEmpty = takeLock.newCondition();\n\n    /** 添加节点操作 的锁 */\n    private final ReentrantLock putLock = new ReentrantLock();\n\n    /** 添加节点操作 的条件对象 */\n    private final Condition notFull = putLock.newCondition();\n}\n```\n\n### 看下构造函数\n```java\npublic LinkedBlockingQueue() {\n        this(Integer.MAX_VALUE);\n    }\n```\n##### 默认构造函数的初始化大小为Integer.MAX_VALUE\n\n```java\npublic LinkedBlockingQueue(int capacity) {\n        if (capacity <= 0) throw new IllegalArgumentException();\n        this.capacity = capacity;\n        last = head = new Node<E>(null);\n    }\n```\n##### 头部节点和尾部节点都指向同一个空节点\n\n```java\npublic LinkedBlockingQueue(Collection<? extends E> c) {\n        this(Integer.MAX_VALUE);\n        final ReentrantLock putLock = this.putLock;\n        putLock.lock(); // Never contended, but necessary for visibility\n        try {\n            int n = 0;\n            for (E e : c) {\n                if (e == null)\n                    throw new NullPointerException();\n                if (n == capacity)\n                    throw new IllegalStateException(\"Queue full\");\n                enqueue(new Node<E>(e));\n                ++n;\n            }\n            count.set(n);\n        } finally {\n            putLock.unlock();\n        }\n    }\n```\n##### 利用集合初始化队列，设置为Integer.MAX_VALUE容量，然后循环入队enqueue操作\n\n### put\n```java\npublic void put(E e) throws InterruptedException {\n        if (e == null) throw new NullPointerException(); //不允许插入空值\n        int c = -1;\n        Node<E> node = new Node<E>(e); //构建新的节点\n        final ReentrantLock putLock = this.putLock;\n        final AtomicInteger count = this.count;\n        putLock.lockInterruptibly(); //可中断锁\n        try {\n            while (count.get() == capacity) {\n                notFull.await(); //如果队列满，则一直阻塞\n            }\n            enqueue(node); //如果操作\n            c = count.getAndIncrement();\n            if (c + 1 < capacity)\n                notFull.signal(); //判断这次操作后队列没有满，则唤醒其他入队请求线程\n        } finally {\n            putLock.unlock(); //解锁\n        }\n        if (c == 0)\n            signalNotEmpty(); //如果本次操作之前队列为空，则在本次操作之后队列不为空了，所以这里需要唤醒获取节点的线程\n    }\n```\n\n##### 通过**put**方法看到**LinkedBlockingQueue**的操作和**ArrayBlockingQueue**的操作都大同小异，主要是通过**ReentrantLock**来控制线程安全，以及通过**Condition**实现条件阻塞。他们之间主要的不同点就在于他们存储数据的数据结构。\n","source":"_posts/note/jdk/blockingQueue.md","raw":"---\nlayout: post\ntitle: java阻塞队列详解\ndate: 2018/03/27\ntags: [tech, index]\ntag: [[java, java]]\n---\n\n##### `java.util.concurrent`包里的**BlockingQueue**接口表示一个线程安放入和提取实例的队列。这里我们将分析和演示如何使用这个**BlockingQueue**，以及对BlockingQueue的各种实现的源码解析。\n\n<!--more-->\n\n## BlockingQueue的使用\n\n##### **BlockingQueue**的数据结构为队列，通常将操作线程区分为生成者和消费者。下图是对这个原理的阐述：\n\n![blockingQueue](/img/note/jdk/blockingqueue.png)\n\n##### 生产者线程往里边放，消费者线程从里边取的一个BlockingQueue。\n##### 生产者线程将会持续生产新对象并将其插入到队列之中，直到队列达到它所能容纳的临界点。也就是说，它是有限的。如果该阻塞队列到达了其临界点，负责生产的线程将会在往里边插入新对象时发生阻塞。它会一直处于阻塞之中，直到负责消费的线程从队列中拿走一个对象。\n\n##### 负责消费的线程将会一直从该阻塞队列中拿出对象。如果消费线程尝试去从一个空的队列中提取对象的话，这个消费线程将会处于阻塞之中，直到生产线程把一个对象丢进队列。\n\n## BlockingQueue\n```java\npublic interface BlockingQueue<E> extends Queue<E> {\n\n    boolean add(E e);\n\n    boolean offer(E e);\n\n    void put(E e) throws InterruptedException;\n\n    boolean offer(E e, long timeout, TimeUnit unit)\n        throws InterruptedException;\n\n    E take() throws InterruptedException;\n\n    E poll(long timeout, TimeUnit unit)\n        throws InterruptedException;\n\n    int remainingCapacity();\n\n    boolean remove(Object o);\n\n    public boolean contains(Object o);\n\n    int drainTo(Collection<? super E> c);\n\n    int drainTo(Collection<? super E> c, int maxElements);\n}\n```\n\n##### 接口**BlockingQueue**的方法就是上面几个，分析一下几个主要方法的用途：\n1. **offer** & **poll**：往队列中插入、取出数据，如果成功则返回true，如果失败则返回false，这个过程不阻塞，看下ArrayBlockingQueue中的实现：\n```java\npublic boolean offer(E e) {\n        checkNotNull(e);\n        //通过锁来保证线程安全\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n        try {\n            if (count == items.length)\n                //如果队列已满\n                return false;\n            else {\n                //如果队列未满，真正的插入操作在enqueue中进行\n                enqueue(e);\n                return true;\n            }\n        } finally {\n            lock.unlock();\n        }\n    }\n```\n```java\npublic E poll() {\n        //通过锁来保证线程安全\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n        try {\n            //如果队列为空则返回null，否则通过dequeue拿到队首数据\n            return (count == 0) ? null : dequeue();\n        } finally {\n            lock.unlock();\n        }\n    }\n```\n2. **add** & **remove** ：往队列中插入、删除数据，如果成功则返回true，不阻塞，如果失败则抛出异常，看下AbstractQueue中的实现：\n```java\npublic boolean add(E e) {\n        if (offer(e))\n            return true;\n        else\n            throw new IllegalStateException(\"Queue full\");\n    }\n```\n```java\npublic E remove() {\n        E x = poll();\n        if (x != null)\n            return x;\n        else\n            throw new NoSuchElementException();\n    }\n```\n##### 可以看到add和remove的操作很简单，把具体队列操作都依赖给了offer和pull\n\n3. **put** & **take**：put操作时阻塞队列的核心，将数据插入队列，如果队列满，则阻塞直到插入成功。take和put相对应，从队列中取数据，看下ArrayBlockingQueue中的实现：\n```java\npublic void put(E e) throws InterruptedException {\n        checkNotNull(e);\n        final ReentrantLock lock = this.lock;\n        lock.lockInterruptibly();\n        try {\n            while (count == items.length)\n                notFull.await(); //利用条件对象notFull阻塞\n            enqueue(e);\n        } finally {\n            lock.unlock();\n        }\n    }\n```\n```java\npublic E take() throws InterruptedException {\n        final ReentrantLock lock = this.lock;\n        lock.lockInterruptibly();\n        try {\n            while (count == 0)\n                notEmpty.await(); //利用条件对象notEmpty阻塞\n            return dequeue();\n        } finally {\n            lock.unlock();\n        }\n    }\n```\n\n##### 知道了**BlockingQueue**的基本用法和简单的实现，那么java中常见的**BlockingQueue**有哪些呢：\n* ArrayBlockingQueue\n* DelayQueue\n* LinkedBlockingQueue\n* SynchronousQueue\n\n##### 他们有什么区别呢。下面我们将通过源码来具体分析他们的实现过程。\n\n## ArrayBlockingQueue\n##### **ArrayBlockingQueue**类继承了AbstractQueue并实现了**BlockingQueue**接口，来看下**ArrayBlockingQueue**中一些主要的属性。\n\n```java\npublic class ArrayBlockingQueue<E> extends AbstractQueue<E>\n        implements BlockingQueue<E>, java.io.Serializable {\n    //使用final 数组保存队列中的数据。数组需要初始化长度。因此数组的长度就是ArrayBlockingQueue的最大容量\n    final Object[] items;\n\n    //数组的下标指针，标识着下一步的take, poll, peek or remove操作。相当于头部指针\n    int takeIndex;\n\n    ////数组的下标指针，标识着下一步的put, offer, or add操作，相当于尾部指针\n    int putIndex;\n\n    //当前队列中已有数据的个数\n    int count;\n\n    //锁，保证基本的数据操作的线程安全\n    final ReentrantLock lock;\n\n    //条件对象，用于takes操作的等待\n    private final Condition notEmpty;\n\n    //条件对象，用于puts操作的等待\n    private final Condition notFull;\n\n    //迭代器\n    transient Itrs itrs = null;\n}\n```\n\n##### 可以看到**ArrayBlockingQueue**的底层数据结构是通过有界数组来实现的，因此你必须在创建的时候就应该确定好容量：\n```java\npublic ArrayBlockingQueue(int capacity) {\n        this(capacity, false);\n    }\n```\n\n```java\npublic ArrayBlockingQueue(int capacity, boolean fair) {\n        if (capacity <= 0)\n            throw new IllegalArgumentException();\n        this.items = new Object[capacity];\n        lock = new ReentrantLock(fair);\n        notEmpty = lock.newCondition();\n        notFull =  lock.newCondition();\n    }\n```\n\n```java\npublic ArrayBlockingQueue(int capacity, boolean fair,\n                              Collection<? extends E> c) {\n        this(capacity, fair);\n\n        final ReentrantLock lock = this.lock;\n        lock.lock(); // Lock only for visibility, not mutual exclusion\n        try {\n            int i = 0;\n            try {\n                for (E e : c) {\n                    checkNotNull(e);\n                    items[i++] = e;\n                }\n            } catch (ArrayIndexOutOfBoundsException ex) {\n                throw new IllegalArgumentException();\n            }\n            count = i;\n            putIndex = (i == capacity) ? 0 : i;\n        } finally {\n            lock.unlock();\n        }\n    }\n```\n\n##### 可以看到ArrayBlockingQueue的初始化可以有三个参数：\n1. **capacity（容量）**：三个构造函数都需要的变量，也就是ArrayBlockingQueue的初始容量。\n2. **fair（是否公平）**：缺省默认为非公平，这里的公平与非公平主要体现在锁的获取上，ArrayBlockingQueue会根据这个参数来创建公平锁或者非公平锁\n3. **c（集合）**：初始集合数据，即使有这个参数，ArrayBlockingQueue依然会按照capacity的大小来初始化数组大小，即使c的容量可能会超过capacity。如果c的容量大于capacity大小。构造函数中会捕获该异常**ArrayIndexOutOfBoundsException**，并抛出一个新的**IllegalArgumentException**异常。\n\n##### 这是**ArrayBlockingQueue**的主要特点，那么我们来看看ArrayBlockingQueue是如何来操作数据添加和删除数据的\n#### enqueue（入队）\n```java\nprivate void enqueue(E x) {\n        final Object[] items = this.items;\n        //通过putIndex下标直接插入数据\n        items[putIndex] = x;\n        //自增putIndex后，如果已经是数组尾部，则重新开始计算，循环指针\n        if (++putIndex == items.length)\n            putIndex = 0;\n        count++;//数据大小加1\n        notEmpty.signal(); //释放因为take操作而阻塞的线程\n    }\n```\n##### 该操作为私有操作，只有方法内部可以调用，通过上面的代码我们知道put, offer, add操作都是通过该方法插入的数据，所以在enqueue方法中并没有锁的操作，因为在外部已经获取过锁\n\n#### dequeue（出队）\n```java\nprivate E dequeue() {\n        final Object[] items = this.items;\n        //通过takeIndex获取数组数据\n        E x = (E) items[takeIndex];\n        //制空\n        items[takeIndex] = null;\n        //自增takeIndex后，如果已经是数组尾部，则重新开始计算，循环指针\n        if (++takeIndex == items.length)\n            takeIndex = 0;\n        count--;//数据大小减1\n        if (itrs != null)\n            itrs.elementDequeued();\n        notFull.signal();//释放因为put操作而阻塞的线程\n        return x; //返回数据\n    }\n```\n\n## DelayQueue\n##### **DelayQueue**是一个无界的**BlockingQueue**，用于放置实现了**Delayed**接口的对象，其中的对象只能在其到期时才能从队列中取走。这种队列是有序的，即队头对象的延迟到期时间最长。注意：不能将null元素放置到这种队列中。\n\n### 先来看下使用过程：\n##### 创建一个Delayed，用于保存任务数据以及延迟执行的时间\n```java\npublic class B implements Delayed{\n\n        private long endTime; //执行时间\n\n        public B(long endTime) {\n            this.endTime = endTime;\n        }\n\n        public long getDelay(TimeUnit unit) {\n            return unit.convert(endTime - System.currentTimeMillis(), TimeUnit.MILLISECONDS);\n        }\n\n        public int compareTo(Delayed o) {\n            if(o == null) return 1;\n            if(o == this) return 0;\n            if (this.getDelay(TimeUnit.NANOSECONDS) > o.getDelay(TimeUnit.NANOSECONDS)) {\n                return 1;\n            }else if (this.getDelay(TimeUnit.NANOSECONDS) == o.getDelay(TimeUnit.NANOSECONDS)) {\n                return 0;\n            }else {\n                return -1;\n            }\n        }\n    }\n```\n\n##### main方法\n```java\npublic static void main(String[] args) throws InterruptedException {\n        DelayQueue<B> delayed = new DelayQueue<B>();\n        B b = new B(new Date().getTime() + 10000); //第一个任务在10秒后执行\n        B b1 = new B(new Date().getTime() + 5000); //第二个任务在5秒后执行\n        delayed.put(b);\n        delayed.put(b1);\n        System.out.println(delayed.take().getEndTime());\n        System.out.println(delayed.take().getEndTime());\n    }\n```\n\n##### 输出结果：\n```\n1522220892807\n1522220897807\n```\n\n### DelayQueue实现细节\n#### 看下DelayQueue的属性变量\n```java\npublic class DelayQueue<E extends Delayed> extends AbstractQueue<E>\n    implements BlockingQueue<E> {\n\n    //锁，控制队列操作的线程安全\n    private final transient ReentrantLock lock = new ReentrantLock();\n\n    //优先队列，实际存储节点的数据结构，优先队列将按照我们提供的compareTo方法进行排序\n    //队列中使用数组进行存储数据，但是在容量不够的时候可以动态扩容。在这里初始大小为11\n    private final PriorityQueue<E> q = new PriorityQueue<E>();\n\n    //当前头部节点的等待线程，防止多个线程等待同一个节点\n    private Thread leader = null;\n\n    //线程阻塞使用Condition实现\n    private final Condition available = lock.newCondition();\n}\n```\n\n#### 我们来看下构造函数：\n\n##### 无参构造函数\n```java\npublic DelayQueue() {}\n```\n\n##### 通过集合初始化**DelayQueue**\n```java\npublic DelayQueue(Collection<? extends E> c) {\n        this.addAll(c);\n}\n```\n\n##### 可以看到**DelayQueue**的构造函数非常简单，这是因为**DelayQueue**是无界的，而且真正存储数据的**PriorityQueue**默认就已经初始化完成。所以**DelayQueue**实际并不关心数据的存储，它的核心还是在于take操作的阻塞过程：\n```java\npublic E take() throws InterruptedException {\n        final ReentrantLock lock = this.lock; //通过锁来保证线程安全\n        lock.lockInterruptibly(); //可中断锁\n        try {\n            for (;;) {\n                E first = q.peek(); //查看队列头部的节点\n                if (first == null)\n                    available.await(); //如果队列为空，阻塞\n                else {\n                    long delay = first.getDelay(NANOSECONDS); //获取等待时间\n                    if (delay <= 0) //等待时间小于等于0 则直接返回，这是该方法唯一的出口。除非锁中断\n                        return q.poll();\n                    first = null; // 等待时间大于0，需要阻塞等待\n                    if (leader != null)\n                        available.await(); //如果有其他线程在等待该节点，则阻塞\n                    else {\n                        Thread thisThread = Thread.currentThread();\n                        leader = thisThread; //设置等待头部节点的线程\n                        try {\n                            available.awaitNanos(delay); //等待固定时间\n                        } finally {\n                            if (leader == thisThread)\n                                leader = null; //等待结束后释放等待线程，重新获取节点\n                        }\n                    }\n                }\n            }\n        } finally {\n            if (leader == null && q.peek() != null)\n                available.signal(); //如果没有线程在等待头部节点，并且队列不为空。则唤醒其他等待线程\n            lock.unlock(); //锁释放\n        }\n    }\n```\n\n##### 整理一下操作流程：\n1. 获取锁\n2. 获取队列头部的节点（不出队）\n3. 如果头部节点为空，则判断队列为空，线程阻塞等待并释放锁，唤醒时回到步骤2\n4. 如果节点不为空，获取头部节点的等待时间（这里参照之前的例子，需要自行计算等待时间，略坑）\n5. 如果等待时间小于等于0。则认为该节点可以返回，调用poll操作返回。这是该方法的唯一一个正常出口\n6. 等待时间大于0\n    1. 判断是否还有其他线程在等待该节点，如果有，则阻塞并释放锁。（理论上来说等该线程唤醒并执行时获取到的应该是后续的节点了），唤醒时回到步骤2\n    2. 如果没有其他线程等待，则通过awaitNanos方法等待固定时间。唤醒时释放头部节点的等待线程。重新回到步骤2\n7. 通常情况下，awaitNanos方法过后重新获取节点能够正常返回了。然后调用finally块，在finally中会释放步骤3和步骤6中的第1部分的阻塞线程中的一个。\n\n##### 在上面的操作过程中有一个小坑就是步骤4，这里的等待时间需要自行计算。这里会带来什么坑呢，看个例子：\n```java\npublic static void main(String[] args) throws InterruptedException {\n        DelayQueue<B> delayed = new DelayQueue<B>();\n        B b = new B(new Date().getTime() + 10000);\n        B b1 = new B(new Date().getTime() + 5000);\n        delayed.put(b);\n        delayed.put(b1);\n        b1.setEndTime(b1.getEndTime() + 10000);\n        System.out.println(delayed.take().getEndTime());\n        System.out.println(delayed.take().getEndTime());\n    }\n\n    private static class B implements Delayed{\n\n        private long endTime;\n\n        public B(long endTime) {\n            this.endTime = endTime;\n        }\n\n        public long getDelay(TimeUnit unit) {\n            return unit.convert(endTime - System.currentTimeMillis(), TimeUnit.MILLISECONDS);\n        }\n\n        public long getEndTime() {\n            return endTime;\n        }\n\n        public void setEndTime(long endTime) {\n            this.endTime = endTime;\n        }\n\n        public int compareTo(Delayed o) {\n            if(o == null) return 1;\n            if(o == this) return 0;\n            if (this.getDelay(TimeUnit.NANOSECONDS) > o.getDelay(TimeUnit.NANOSECONDS)) {\n                return 1;\n            }else if (this.getDelay(TimeUnit.NANOSECONDS) == o.getDelay(TimeUnit.NANOSECONDS)) {\n                return 0;\n            }else {\n                return -1;\n            }\n        }\n    }\n```\n\n##### 输出结果\n```\n1522230732548\n1522230727548\n```\n\n##### 解释一下上面的例子，这个例子和之前的例子是一样的。设置了两个任务并且入队。一个任务5秒后执行，一个任务10秒后执行。入队后将5秒执行的任务再往后推迟10秒（变成了15秒）。结果执行结果显示15秒延迟的任务先执行。再立刻执行了10秒延迟任务。\n\n##### 这个坑就在于需要开发者自己去计算到期时间，而且这个时间必须是实时计算出来。如果固定返回一个大于0的数字，这个队列将永远循环阻塞在该节点。后面的任务将不会被执行。就算不是固定时间，但是修改了任务执行时间，任务不会重新排序。导致队列部分后续任务执行时间错误。\n\n##### 当然这样也有一点好处，就是使得**DelayQueue**本身足够简单。**DelayQueue**不用去关心或者计算任务的过期时间，而是把这部分操场依赖给了任务本身。但是没有做到动态的调整队列顺序已保证过期时间计算的复杂性。所以这个操作还是有点坑。\n\n### offer、poll\n```java\npublic boolean offer(E e) {\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n        try {\n            q.offer(e); //调用优先队列的offer操作，有排序\n            if (q.peek() == e) {\n                leader = null; //如果插入的节点是头部节点，则唤醒等待线程\n                available.signal();\n            }\n            return true;\n        } finally {\n            lock.unlock();\n        }\n    }\n```\n\n```java\npublic E poll() {\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n        try {\n            E first = q.peek();\n            if (first == null || first.getDelay(NANOSECONDS) > 0) //如果头部节点为空或者没到执行时间\n                return null; //返回空\n            else\n                return q.poll();\n        } finally {\n            lock.unlock();\n        }\n    }\n```\n\n## LinkedBlockingQueue\n##### LinkedBlockingQueue是一个由链表实现的有界队列阻塞队列。让我们来看下代码：\n```java\npublic class LinkedBlockingQueue<E> extends AbstractQueue<E>\n        implements BlockingQueue<E>, java.io.Serializable {\n\n    //链表节点，存储节点数据和下一个节点\n    static class Node<E> {\n        E item;\n\n        Node<E> next;\n\n        Node(E x) { item = x; }\n    }\n\n    //最大容量。默认为Integer.MAX_VALUE\n    private final int capacity;\n\n    //线程安全类AtomicInteger，记录链表队列长度\n    private final AtomicInteger count = new AtomicInteger();\n\n    //头部节点\n    transient Node<E> head;\n\n    //尾部节点\n    private transient Node<E> last;\n\n    /** 获取节点操作 的锁 */\n    private final ReentrantLock takeLock = new ReentrantLock();\n\n    /** 获取节点操作 的条件对象 */\n    private final Condition notEmpty = takeLock.newCondition();\n\n    /** 添加节点操作 的锁 */\n    private final ReentrantLock putLock = new ReentrantLock();\n\n    /** 添加节点操作 的条件对象 */\n    private final Condition notFull = putLock.newCondition();\n}\n```\n\n### 看下构造函数\n```java\npublic LinkedBlockingQueue() {\n        this(Integer.MAX_VALUE);\n    }\n```\n##### 默认构造函数的初始化大小为Integer.MAX_VALUE\n\n```java\npublic LinkedBlockingQueue(int capacity) {\n        if (capacity <= 0) throw new IllegalArgumentException();\n        this.capacity = capacity;\n        last = head = new Node<E>(null);\n    }\n```\n##### 头部节点和尾部节点都指向同一个空节点\n\n```java\npublic LinkedBlockingQueue(Collection<? extends E> c) {\n        this(Integer.MAX_VALUE);\n        final ReentrantLock putLock = this.putLock;\n        putLock.lock(); // Never contended, but necessary for visibility\n        try {\n            int n = 0;\n            for (E e : c) {\n                if (e == null)\n                    throw new NullPointerException();\n                if (n == capacity)\n                    throw new IllegalStateException(\"Queue full\");\n                enqueue(new Node<E>(e));\n                ++n;\n            }\n            count.set(n);\n        } finally {\n            putLock.unlock();\n        }\n    }\n```\n##### 利用集合初始化队列，设置为Integer.MAX_VALUE容量，然后循环入队enqueue操作\n\n### put\n```java\npublic void put(E e) throws InterruptedException {\n        if (e == null) throw new NullPointerException(); //不允许插入空值\n        int c = -1;\n        Node<E> node = new Node<E>(e); //构建新的节点\n        final ReentrantLock putLock = this.putLock;\n        final AtomicInteger count = this.count;\n        putLock.lockInterruptibly(); //可中断锁\n        try {\n            while (count.get() == capacity) {\n                notFull.await(); //如果队列满，则一直阻塞\n            }\n            enqueue(node); //如果操作\n            c = count.getAndIncrement();\n            if (c + 1 < capacity)\n                notFull.signal(); //判断这次操作后队列没有满，则唤醒其他入队请求线程\n        } finally {\n            putLock.unlock(); //解锁\n        }\n        if (c == 0)\n            signalNotEmpty(); //如果本次操作之前队列为空，则在本次操作之后队列不为空了，所以这里需要唤醒获取节点的线程\n    }\n```\n\n##### 通过**put**方法看到**LinkedBlockingQueue**的操作和**ArrayBlockingQueue**的操作都大同小异，主要是通过**ReentrantLock**来控制线程安全，以及通过**Condition**实现条件阻塞。他们之间主要的不同点就在于他们存储数据的数据结构。\n","slug":"note/jdk/blockingQueue","published":1,"updated":"2018-05-08T13:00:14.278Z","comments":1,"photos":[],"link":"","_id":"cjgxop3nh003fjah1egeivn20","content":"<h5 id=\"java-util-concurrent包里的BlockingQueue接口表示一个线程安放入和提取实例的队列。这里我们将分析和演示如何使用这个BlockingQueue，以及对BlockingQueue的各种实现的源码解析。\"><a href=\"#java-util-concurrent包里的BlockingQueue接口表示一个线程安放入和提取实例的队列。这里我们将分析和演示如何使用这个BlockingQueue，以及对BlockingQueue的各种实现的源码解析。\" class=\"headerlink\" title=\"java.util.concurrent包里的BlockingQueue接口表示一个线程安放入和提取实例的队列。这里我们将分析和演示如何使用这个BlockingQueue，以及对BlockingQueue的各种实现的源码解析。\"></a><code>java.util.concurrent</code>包里的<strong>BlockingQueue</strong>接口表示一个线程安放入和提取实例的队列。这里我们将分析和演示如何使用这个<strong>BlockingQueue</strong>，以及对BlockingQueue的各种实现的源码解析。</h5><a id=\"more\"></a>\n<h2 id=\"BlockingQueue的使用\"><a href=\"#BlockingQueue的使用\" class=\"headerlink\" title=\"BlockingQueue的使用\"></a>BlockingQueue的使用</h2><h5 id=\"BlockingQueue的数据结构为队列，通常将操作线程区分为生成者和消费者。下图是对这个原理的阐述：\"><a href=\"#BlockingQueue的数据结构为队列，通常将操作线程区分为生成者和消费者。下图是对这个原理的阐述：\" class=\"headerlink\" title=\"BlockingQueue的数据结构为队列，通常将操作线程区分为生成者和消费者。下图是对这个原理的阐述：\"></a><strong>BlockingQueue</strong>的数据结构为队列，通常将操作线程区分为生成者和消费者。下图是对这个原理的阐述：</h5><p><img src=\"/img/note/jdk/blockingqueue.png\" alt=\"blockingQueue\"></p>\n<h5 id=\"生产者线程往里边放，消费者线程从里边取的一个BlockingQueue。\"><a href=\"#生产者线程往里边放，消费者线程从里边取的一个BlockingQueue。\" class=\"headerlink\" title=\"生产者线程往里边放，消费者线程从里边取的一个BlockingQueue。\"></a>生产者线程往里边放，消费者线程从里边取的一个BlockingQueue。</h5><h5 id=\"生产者线程将会持续生产新对象并将其插入到队列之中，直到队列达到它所能容纳的临界点。也就是说，它是有限的。如果该阻塞队列到达了其临界点，负责生产的线程将会在往里边插入新对象时发生阻塞。它会一直处于阻塞之中，直到负责消费的线程从队列中拿走一个对象。\"><a href=\"#生产者线程将会持续生产新对象并将其插入到队列之中，直到队列达到它所能容纳的临界点。也就是说，它是有限的。如果该阻塞队列到达了其临界点，负责生产的线程将会在往里边插入新对象时发生阻塞。它会一直处于阻塞之中，直到负责消费的线程从队列中拿走一个对象。\" class=\"headerlink\" title=\"生产者线程将会持续生产新对象并将其插入到队列之中，直到队列达到它所能容纳的临界点。也就是说，它是有限的。如果该阻塞队列到达了其临界点，负责生产的线程将会在往里边插入新对象时发生阻塞。它会一直处于阻塞之中，直到负责消费的线程从队列中拿走一个对象。\"></a>生产者线程将会持续生产新对象并将其插入到队列之中，直到队列达到它所能容纳的临界点。也就是说，它是有限的。如果该阻塞队列到达了其临界点，负责生产的线程将会在往里边插入新对象时发生阻塞。它会一直处于阻塞之中，直到负责消费的线程从队列中拿走一个对象。</h5><h5 id=\"负责消费的线程将会一直从该阻塞队列中拿出对象。如果消费线程尝试去从一个空的队列中提取对象的话，这个消费线程将会处于阻塞之中，直到生产线程把一个对象丢进队列。\"><a href=\"#负责消费的线程将会一直从该阻塞队列中拿出对象。如果消费线程尝试去从一个空的队列中提取对象的话，这个消费线程将会处于阻塞之中，直到生产线程把一个对象丢进队列。\" class=\"headerlink\" title=\"负责消费的线程将会一直从该阻塞队列中拿出对象。如果消费线程尝试去从一个空的队列中提取对象的话，这个消费线程将会处于阻塞之中，直到生产线程把一个对象丢进队列。\"></a>负责消费的线程将会一直从该阻塞队列中拿出对象。如果消费线程尝试去从一个空的队列中提取对象的话，这个消费线程将会处于阻塞之中，直到生产线程把一个对象丢进队列。</h5><h2 id=\"BlockingQueue\"><a href=\"#BlockingQueue\" class=\"headerlink\" title=\"BlockingQueue\"></a>BlockingQueue</h2><pre><code class=\"lang-java\">public interface BlockingQueue&lt;E&gt; extends Queue&lt;E&gt; {\n\n    boolean add(E e);\n\n    boolean offer(E e);\n\n    void put(E e) throws InterruptedException;\n\n    boolean offer(E e, long timeout, TimeUnit unit)\n        throws InterruptedException;\n\n    E take() throws InterruptedException;\n\n    E poll(long timeout, TimeUnit unit)\n        throws InterruptedException;\n\n    int remainingCapacity();\n\n    boolean remove(Object o);\n\n    public boolean contains(Object o);\n\n    int drainTo(Collection&lt;? super E&gt; c);\n\n    int drainTo(Collection&lt;? super E&gt; c, int maxElements);\n}\n</code></pre>\n<h5 id=\"接口BlockingQueue的方法就是上面几个，分析一下几个主要方法的用途：\"><a href=\"#接口BlockingQueue的方法就是上面几个，分析一下几个主要方法的用途：\" class=\"headerlink\" title=\"接口BlockingQueue的方法就是上面几个，分析一下几个主要方法的用途：\"></a>接口<strong>BlockingQueue</strong>的方法就是上面几个，分析一下几个主要方法的用途：</h5><ol>\n<li><strong>offer</strong> &amp; <strong>poll</strong>：往队列中插入、取出数据，如果成功则返回true，如果失败则返回false，这个过程不阻塞，看下ArrayBlockingQueue中的实现：<pre><code class=\"lang-java\">public boolean offer(E e) {\n     checkNotNull(e);\n     //通过锁来保证线程安全\n     final ReentrantLock lock = this.lock;\n     lock.lock();\n     try {\n         if (count == items.length)\n             //如果队列已满\n             return false;\n         else {\n             //如果队列未满，真正的插入操作在enqueue中进行\n             enqueue(e);\n             return true;\n         }\n     } finally {\n         lock.unlock();\n     }\n }\n</code></pre>\n<pre><code class=\"lang-java\">public E poll() {\n     //通过锁来保证线程安全\n     final ReentrantLock lock = this.lock;\n     lock.lock();\n     try {\n         //如果队列为空则返回null，否则通过dequeue拿到队首数据\n         return (count == 0) ? null : dequeue();\n     } finally {\n         lock.unlock();\n     }\n }\n</code></pre>\n</li>\n<li><p><strong>add</strong> &amp; <strong>remove</strong> ：往队列中插入、删除数据，如果成功则返回true，不阻塞，如果失败则抛出异常，看下AbstractQueue中的实现：</p>\n<pre><code class=\"lang-java\">public boolean add(E e) {\n     if (offer(e))\n         return true;\n     else\n         throw new IllegalStateException(&quot;Queue full&quot;);\n }\n</code></pre>\n<pre><code class=\"lang-java\">public E remove() {\n     E x = poll();\n     if (x != null)\n         return x;\n     else\n         throw new NoSuchElementException();\n }\n</code></pre>\n<h5 id=\"可以看到add和remove的操作很简单，把具体队列操作都依赖给了offer和pull\"><a href=\"#可以看到add和remove的操作很简单，把具体队列操作都依赖给了offer和pull\" class=\"headerlink\" title=\"可以看到add和remove的操作很简单，把具体队列操作都依赖给了offer和pull\"></a>可以看到add和remove的操作很简单，把具体队列操作都依赖给了offer和pull</h5></li>\n<li><p><strong>put</strong> &amp; <strong>take</strong>：put操作时阻塞队列的核心，将数据插入队列，如果队列满，则阻塞直到插入成功。take和put相对应，从队列中取数据，看下ArrayBlockingQueue中的实现：</p>\n<pre><code class=\"lang-java\">public void put(E e) throws InterruptedException {\n     checkNotNull(e);\n     final ReentrantLock lock = this.lock;\n     lock.lockInterruptibly();\n     try {\n         while (count == items.length)\n             notFull.await(); //利用条件对象notFull阻塞\n         enqueue(e);\n     } finally {\n         lock.unlock();\n     }\n }\n</code></pre>\n<pre><code class=\"lang-java\">public E take() throws InterruptedException {\n     final ReentrantLock lock = this.lock;\n     lock.lockInterruptibly();\n     try {\n         while (count == 0)\n             notEmpty.await(); //利用条件对象notEmpty阻塞\n         return dequeue();\n     } finally {\n         lock.unlock();\n     }\n }\n</code></pre>\n</li>\n</ol>\n<h5 id=\"知道了BlockingQueue的基本用法和简单的实现，那么java中常见的BlockingQueue有哪些呢：\"><a href=\"#知道了BlockingQueue的基本用法和简单的实现，那么java中常见的BlockingQueue有哪些呢：\" class=\"headerlink\" title=\"知道了BlockingQueue的基本用法和简单的实现，那么java中常见的BlockingQueue有哪些呢：\"></a>知道了<strong>BlockingQueue</strong>的基本用法和简单的实现，那么java中常见的<strong>BlockingQueue</strong>有哪些呢：</h5><ul>\n<li>ArrayBlockingQueue</li>\n<li>DelayQueue</li>\n<li>LinkedBlockingQueue</li>\n<li>SynchronousQueue</li>\n</ul>\n<h5 id=\"他们有什么区别呢。下面我们将通过源码来具体分析他们的实现过程。\"><a href=\"#他们有什么区别呢。下面我们将通过源码来具体分析他们的实现过程。\" class=\"headerlink\" title=\"他们有什么区别呢。下面我们将通过源码来具体分析他们的实现过程。\"></a>他们有什么区别呢。下面我们将通过源码来具体分析他们的实现过程。</h5><h2 id=\"ArrayBlockingQueue\"><a href=\"#ArrayBlockingQueue\" class=\"headerlink\" title=\"ArrayBlockingQueue\"></a>ArrayBlockingQueue</h2><h5 id=\"ArrayBlockingQueue类继承了AbstractQueue并实现了BlockingQueue接口，来看下ArrayBlockingQueue中一些主要的属性。\"><a href=\"#ArrayBlockingQueue类继承了AbstractQueue并实现了BlockingQueue接口，来看下ArrayBlockingQueue中一些主要的属性。\" class=\"headerlink\" title=\"ArrayBlockingQueue类继承了AbstractQueue并实现了BlockingQueue接口，来看下ArrayBlockingQueue中一些主要的属性。\"></a><strong>ArrayBlockingQueue</strong>类继承了AbstractQueue并实现了<strong>BlockingQueue</strong>接口，来看下<strong>ArrayBlockingQueue</strong>中一些主要的属性。</h5><pre><code class=\"lang-java\">public class ArrayBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;\n        implements BlockingQueue&lt;E&gt;, java.io.Serializable {\n    //使用final 数组保存队列中的数据。数组需要初始化长度。因此数组的长度就是ArrayBlockingQueue的最大容量\n    final Object[] items;\n\n    //数组的下标指针，标识着下一步的take, poll, peek or remove操作。相当于头部指针\n    int takeIndex;\n\n    ////数组的下标指针，标识着下一步的put, offer, or add操作，相当于尾部指针\n    int putIndex;\n\n    //当前队列中已有数据的个数\n    int count;\n\n    //锁，保证基本的数据操作的线程安全\n    final ReentrantLock lock;\n\n    //条件对象，用于takes操作的等待\n    private final Condition notEmpty;\n\n    //条件对象，用于puts操作的等待\n    private final Condition notFull;\n\n    //迭代器\n    transient Itrs itrs = null;\n}\n</code></pre>\n<h5 id=\"可以看到ArrayBlockingQueue的底层数据结构是通过有界数组来实现的，因此你必须在创建的时候就应该确定好容量：\"><a href=\"#可以看到ArrayBlockingQueue的底层数据结构是通过有界数组来实现的，因此你必须在创建的时候就应该确定好容量：\" class=\"headerlink\" title=\"可以看到ArrayBlockingQueue的底层数据结构是通过有界数组来实现的，因此你必须在创建的时候就应该确定好容量：\"></a>可以看到<strong>ArrayBlockingQueue</strong>的底层数据结构是通过有界数组来实现的，因此你必须在创建的时候就应该确定好容量：</h5><pre><code class=\"lang-java\">public ArrayBlockingQueue(int capacity) {\n        this(capacity, false);\n    }\n</code></pre>\n<pre><code class=\"lang-java\">public ArrayBlockingQueue(int capacity, boolean fair) {\n        if (capacity &lt;= 0)\n            throw new IllegalArgumentException();\n        this.items = new Object[capacity];\n        lock = new ReentrantLock(fair);\n        notEmpty = lock.newCondition();\n        notFull =  lock.newCondition();\n    }\n</code></pre>\n<pre><code class=\"lang-java\">public ArrayBlockingQueue(int capacity, boolean fair,\n                              Collection&lt;? extends E&gt; c) {\n        this(capacity, fair);\n\n        final ReentrantLock lock = this.lock;\n        lock.lock(); // Lock only for visibility, not mutual exclusion\n        try {\n            int i = 0;\n            try {\n                for (E e : c) {\n                    checkNotNull(e);\n                    items[i++] = e;\n                }\n            } catch (ArrayIndexOutOfBoundsException ex) {\n                throw new IllegalArgumentException();\n            }\n            count = i;\n            putIndex = (i == capacity) ? 0 : i;\n        } finally {\n            lock.unlock();\n        }\n    }\n</code></pre>\n<h5 id=\"可以看到ArrayBlockingQueue的初始化可以有三个参数：\"><a href=\"#可以看到ArrayBlockingQueue的初始化可以有三个参数：\" class=\"headerlink\" title=\"可以看到ArrayBlockingQueue的初始化可以有三个参数：\"></a>可以看到ArrayBlockingQueue的初始化可以有三个参数：</h5><ol>\n<li><strong>capacity（容量）</strong>：三个构造函数都需要的变量，也就是ArrayBlockingQueue的初始容量。</li>\n<li><strong>fair（是否公平）</strong>：缺省默认为非公平，这里的公平与非公平主要体现在锁的获取上，ArrayBlockingQueue会根据这个参数来创建公平锁或者非公平锁</li>\n<li><strong>c（集合）</strong>：初始集合数据，即使有这个参数，ArrayBlockingQueue依然会按照capacity的大小来初始化数组大小，即使c的容量可能会超过capacity。如果c的容量大于capacity大小。构造函数中会捕获该异常<strong>ArrayIndexOutOfBoundsException</strong>，并抛出一个新的<strong>IllegalArgumentException</strong>异常。</li>\n</ol>\n<h5 id=\"这是ArrayBlockingQueue的主要特点，那么我们来看看ArrayBlockingQueue是如何来操作数据添加和删除数据的\"><a href=\"#这是ArrayBlockingQueue的主要特点，那么我们来看看ArrayBlockingQueue是如何来操作数据添加和删除数据的\" class=\"headerlink\" title=\"这是ArrayBlockingQueue的主要特点，那么我们来看看ArrayBlockingQueue是如何来操作数据添加和删除数据的\"></a>这是<strong>ArrayBlockingQueue</strong>的主要特点，那么我们来看看ArrayBlockingQueue是如何来操作数据添加和删除数据的</h5><h4 id=\"enqueue（入队）\"><a href=\"#enqueue（入队）\" class=\"headerlink\" title=\"enqueue（入队）\"></a>enqueue（入队）</h4><pre><code class=\"lang-java\">private void enqueue(E x) {\n        final Object[] items = this.items;\n        //通过putIndex下标直接插入数据\n        items[putIndex] = x;\n        //自增putIndex后，如果已经是数组尾部，则重新开始计算，循环指针\n        if (++putIndex == items.length)\n            putIndex = 0;\n        count++;//数据大小加1\n        notEmpty.signal(); //释放因为take操作而阻塞的线程\n    }\n</code></pre>\n<h5 id=\"该操作为私有操作，只有方法内部可以调用，通过上面的代码我们知道put-offer-add操作都是通过该方法插入的数据，所以在enqueue方法中并没有锁的操作，因为在外部已经获取过锁\"><a href=\"#该操作为私有操作，只有方法内部可以调用，通过上面的代码我们知道put-offer-add操作都是通过该方法插入的数据，所以在enqueue方法中并没有锁的操作，因为在外部已经获取过锁\" class=\"headerlink\" title=\"该操作为私有操作，只有方法内部可以调用，通过上面的代码我们知道put, offer, add操作都是通过该方法插入的数据，所以在enqueue方法中并没有锁的操作，因为在外部已经获取过锁\"></a>该操作为私有操作，只有方法内部可以调用，通过上面的代码我们知道put, offer, add操作都是通过该方法插入的数据，所以在enqueue方法中并没有锁的操作，因为在外部已经获取过锁</h5><h4 id=\"dequeue（出队）\"><a href=\"#dequeue（出队）\" class=\"headerlink\" title=\"dequeue（出队）\"></a>dequeue（出队）</h4><pre><code class=\"lang-java\">private E dequeue() {\n        final Object[] items = this.items;\n        //通过takeIndex获取数组数据\n        E x = (E) items[takeIndex];\n        //制空\n        items[takeIndex] = null;\n        //自增takeIndex后，如果已经是数组尾部，则重新开始计算，循环指针\n        if (++takeIndex == items.length)\n            takeIndex = 0;\n        count--;//数据大小减1\n        if (itrs != null)\n            itrs.elementDequeued();\n        notFull.signal();//释放因为put操作而阻塞的线程\n        return x; //返回数据\n    }\n</code></pre>\n<h2 id=\"DelayQueue\"><a href=\"#DelayQueue\" class=\"headerlink\" title=\"DelayQueue\"></a>DelayQueue</h2><h5 id=\"DelayQueue是一个无界的BlockingQueue，用于放置实现了Delayed接口的对象，其中的对象只能在其到期时才能从队列中取走。这种队列是有序的，即队头对象的延迟到期时间最长。注意：不能将null元素放置到这种队列中。\"><a href=\"#DelayQueue是一个无界的BlockingQueue，用于放置实现了Delayed接口的对象，其中的对象只能在其到期时才能从队列中取走。这种队列是有序的，即队头对象的延迟到期时间最长。注意：不能将null元素放置到这种队列中。\" class=\"headerlink\" title=\"DelayQueue是一个无界的BlockingQueue，用于放置实现了Delayed接口的对象，其中的对象只能在其到期时才能从队列中取走。这种队列是有序的，即队头对象的延迟到期时间最长。注意：不能将null元素放置到这种队列中。\"></a><strong>DelayQueue</strong>是一个无界的<strong>BlockingQueue</strong>，用于放置实现了<strong>Delayed</strong>接口的对象，其中的对象只能在其到期时才能从队列中取走。这种队列是有序的，即队头对象的延迟到期时间最长。注意：不能将null元素放置到这种队列中。</h5><h3 id=\"先来看下使用过程：\"><a href=\"#先来看下使用过程：\" class=\"headerlink\" title=\"先来看下使用过程：\"></a>先来看下使用过程：</h3><h5 id=\"创建一个Delayed，用于保存任务数据以及延迟执行的时间\"><a href=\"#创建一个Delayed，用于保存任务数据以及延迟执行的时间\" class=\"headerlink\" title=\"创建一个Delayed，用于保存任务数据以及延迟执行的时间\"></a>创建一个Delayed，用于保存任务数据以及延迟执行的时间</h5><pre><code class=\"lang-java\">public class B implements Delayed{\n\n        private long endTime; //执行时间\n\n        public B(long endTime) {\n            this.endTime = endTime;\n        }\n\n        public long getDelay(TimeUnit unit) {\n            return unit.convert(endTime - System.currentTimeMillis(), TimeUnit.MILLISECONDS);\n        }\n\n        public int compareTo(Delayed o) {\n            if(o == null) return 1;\n            if(o == this) return 0;\n            if (this.getDelay(TimeUnit.NANOSECONDS) &gt; o.getDelay(TimeUnit.NANOSECONDS)) {\n                return 1;\n            }else if (this.getDelay(TimeUnit.NANOSECONDS) == o.getDelay(TimeUnit.NANOSECONDS)) {\n                return 0;\n            }else {\n                return -1;\n            }\n        }\n    }\n</code></pre>\n<h5 id=\"main方法\"><a href=\"#main方法\" class=\"headerlink\" title=\"main方法\"></a>main方法</h5><pre><code class=\"lang-java\">public static void main(String[] args) throws InterruptedException {\n        DelayQueue&lt;B&gt; delayed = new DelayQueue&lt;B&gt;();\n        B b = new B(new Date().getTime() + 10000); //第一个任务在10秒后执行\n        B b1 = new B(new Date().getTime() + 5000); //第二个任务在5秒后执行\n        delayed.put(b);\n        delayed.put(b1);\n        System.out.println(delayed.take().getEndTime());\n        System.out.println(delayed.take().getEndTime());\n    }\n</code></pre>\n<h5 id=\"输出结果：\"><a href=\"#输出结果：\" class=\"headerlink\" title=\"输出结果：\"></a>输出结果：</h5><pre><code>1522220892807\n1522220897807\n</code></pre><h3 id=\"DelayQueue实现细节\"><a href=\"#DelayQueue实现细节\" class=\"headerlink\" title=\"DelayQueue实现细节\"></a>DelayQueue实现细节</h3><h4 id=\"看下DelayQueue的属性变量\"><a href=\"#看下DelayQueue的属性变量\" class=\"headerlink\" title=\"看下DelayQueue的属性变量\"></a>看下DelayQueue的属性变量</h4><pre><code class=\"lang-java\">public class DelayQueue&lt;E extends Delayed&gt; extends AbstractQueue&lt;E&gt;\n    implements BlockingQueue&lt;E&gt; {\n\n    //锁，控制队列操作的线程安全\n    private final transient ReentrantLock lock = new ReentrantLock();\n\n    //优先队列，实际存储节点的数据结构，优先队列将按照我们提供的compareTo方法进行排序\n    //队列中使用数组进行存储数据，但是在容量不够的时候可以动态扩容。在这里初始大小为11\n    private final PriorityQueue&lt;E&gt; q = new PriorityQueue&lt;E&gt;();\n\n    //当前头部节点的等待线程，防止多个线程等待同一个节点\n    private Thread leader = null;\n\n    //线程阻塞使用Condition实现\n    private final Condition available = lock.newCondition();\n}\n</code></pre>\n<h4 id=\"我们来看下构造函数：\"><a href=\"#我们来看下构造函数：\" class=\"headerlink\" title=\"我们来看下构造函数：\"></a>我们来看下构造函数：</h4><h5 id=\"无参构造函数\"><a href=\"#无参构造函数\" class=\"headerlink\" title=\"无参构造函数\"></a>无参构造函数</h5><pre><code class=\"lang-java\">public DelayQueue() {}\n</code></pre>\n<h5 id=\"通过集合初始化DelayQueue\"><a href=\"#通过集合初始化DelayQueue\" class=\"headerlink\" title=\"通过集合初始化DelayQueue\"></a>通过集合初始化<strong>DelayQueue</strong></h5><pre><code class=\"lang-java\">public DelayQueue(Collection&lt;? extends E&gt; c) {\n        this.addAll(c);\n}\n</code></pre>\n<h5 id=\"可以看到DelayQueue的构造函数非常简单，这是因为DelayQueue是无界的，而且真正存储数据的PriorityQueue默认就已经初始化完成。所以DelayQueue实际并不关心数据的存储，它的核心还是在于take操作的阻塞过程：\"><a href=\"#可以看到DelayQueue的构造函数非常简单，这是因为DelayQueue是无界的，而且真正存储数据的PriorityQueue默认就已经初始化完成。所以DelayQueue实际并不关心数据的存储，它的核心还是在于take操作的阻塞过程：\" class=\"headerlink\" title=\"可以看到DelayQueue的构造函数非常简单，这是因为DelayQueue是无界的，而且真正存储数据的PriorityQueue默认就已经初始化完成。所以DelayQueue实际并不关心数据的存储，它的核心还是在于take操作的阻塞过程：\"></a>可以看到<strong>DelayQueue</strong>的构造函数非常简单，这是因为<strong>DelayQueue</strong>是无界的，而且真正存储数据的<strong>PriorityQueue</strong>默认就已经初始化完成。所以<strong>DelayQueue</strong>实际并不关心数据的存储，它的核心还是在于take操作的阻塞过程：</h5><pre><code class=\"lang-java\">public E take() throws InterruptedException {\n        final ReentrantLock lock = this.lock; //通过锁来保证线程安全\n        lock.lockInterruptibly(); //可中断锁\n        try {\n            for (;;) {\n                E first = q.peek(); //查看队列头部的节点\n                if (first == null)\n                    available.await(); //如果队列为空，阻塞\n                else {\n                    long delay = first.getDelay(NANOSECONDS); //获取等待时间\n                    if (delay &lt;= 0) //等待时间小于等于0 则直接返回，这是该方法唯一的出口。除非锁中断\n                        return q.poll();\n                    first = null; // 等待时间大于0，需要阻塞等待\n                    if (leader != null)\n                        available.await(); //如果有其他线程在等待该节点，则阻塞\n                    else {\n                        Thread thisThread = Thread.currentThread();\n                        leader = thisThread; //设置等待头部节点的线程\n                        try {\n                            available.awaitNanos(delay); //等待固定时间\n                        } finally {\n                            if (leader == thisThread)\n                                leader = null; //等待结束后释放等待线程，重新获取节点\n                        }\n                    }\n                }\n            }\n        } finally {\n            if (leader == null &amp;&amp; q.peek() != null)\n                available.signal(); //如果没有线程在等待头部节点，并且队列不为空。则唤醒其他等待线程\n            lock.unlock(); //锁释放\n        }\n    }\n</code></pre>\n<h5 id=\"整理一下操作流程：\"><a href=\"#整理一下操作流程：\" class=\"headerlink\" title=\"整理一下操作流程：\"></a>整理一下操作流程：</h5><ol>\n<li>获取锁</li>\n<li>获取队列头部的节点（不出队）</li>\n<li>如果头部节点为空，则判断队列为空，线程阻塞等待并释放锁，唤醒时回到步骤2</li>\n<li>如果节点不为空，获取头部节点的等待时间（这里参照之前的例子，需要自行计算等待时间，略坑）</li>\n<li>如果等待时间小于等于0。则认为该节点可以返回，调用poll操作返回。这是该方法的唯一一个正常出口</li>\n<li>等待时间大于0<ol>\n<li>判断是否还有其他线程在等待该节点，如果有，则阻塞并释放锁。（理论上来说等该线程唤醒并执行时获取到的应该是后续的节点了），唤醒时回到步骤2</li>\n<li>如果没有其他线程等待，则通过awaitNanos方法等待固定时间。唤醒时释放头部节点的等待线程。重新回到步骤2</li>\n</ol>\n</li>\n<li>通常情况下，awaitNanos方法过后重新获取节点能够正常返回了。然后调用finally块，在finally中会释放步骤3和步骤6中的第1部分的阻塞线程中的一个。</li>\n</ol>\n<h5 id=\"在上面的操作过程中有一个小坑就是步骤4，这里的等待时间需要自行计算。这里会带来什么坑呢，看个例子：\"><a href=\"#在上面的操作过程中有一个小坑就是步骤4，这里的等待时间需要自行计算。这里会带来什么坑呢，看个例子：\" class=\"headerlink\" title=\"在上面的操作过程中有一个小坑就是步骤4，这里的等待时间需要自行计算。这里会带来什么坑呢，看个例子：\"></a>在上面的操作过程中有一个小坑就是步骤4，这里的等待时间需要自行计算。这里会带来什么坑呢，看个例子：</h5><pre><code class=\"lang-java\">public static void main(String[] args) throws InterruptedException {\n        DelayQueue&lt;B&gt; delayed = new DelayQueue&lt;B&gt;();\n        B b = new B(new Date().getTime() + 10000);\n        B b1 = new B(new Date().getTime() + 5000);\n        delayed.put(b);\n        delayed.put(b1);\n        b1.setEndTime(b1.getEndTime() + 10000);\n        System.out.println(delayed.take().getEndTime());\n        System.out.println(delayed.take().getEndTime());\n    }\n\n    private static class B implements Delayed{\n\n        private long endTime;\n\n        public B(long endTime) {\n            this.endTime = endTime;\n        }\n\n        public long getDelay(TimeUnit unit) {\n            return unit.convert(endTime - System.currentTimeMillis(), TimeUnit.MILLISECONDS);\n        }\n\n        public long getEndTime() {\n            return endTime;\n        }\n\n        public void setEndTime(long endTime) {\n            this.endTime = endTime;\n        }\n\n        public int compareTo(Delayed o) {\n            if(o == null) return 1;\n            if(o == this) return 0;\n            if (this.getDelay(TimeUnit.NANOSECONDS) &gt; o.getDelay(TimeUnit.NANOSECONDS)) {\n                return 1;\n            }else if (this.getDelay(TimeUnit.NANOSECONDS) == o.getDelay(TimeUnit.NANOSECONDS)) {\n                return 0;\n            }else {\n                return -1;\n            }\n        }\n    }\n</code></pre>\n<h5 id=\"输出结果\"><a href=\"#输出结果\" class=\"headerlink\" title=\"输出结果\"></a>输出结果</h5><pre><code>1522230732548\n1522230727548\n</code></pre><h5 id=\"解释一下上面的例子，这个例子和之前的例子是一样的。设置了两个任务并且入队。一个任务5秒后执行，一个任务10秒后执行。入队后将5秒执行的任务再往后推迟10秒（变成了15秒）。结果执行结果显示15秒延迟的任务先执行。再立刻执行了10秒延迟任务。\"><a href=\"#解释一下上面的例子，这个例子和之前的例子是一样的。设置了两个任务并且入队。一个任务5秒后执行，一个任务10秒后执行。入队后将5秒执行的任务再往后推迟10秒（变成了15秒）。结果执行结果显示15秒延迟的任务先执行。再立刻执行了10秒延迟任务。\" class=\"headerlink\" title=\"解释一下上面的例子，这个例子和之前的例子是一样的。设置了两个任务并且入队。一个任务5秒后执行，一个任务10秒后执行。入队后将5秒执行的任务再往后推迟10秒（变成了15秒）。结果执行结果显示15秒延迟的任务先执行。再立刻执行了10秒延迟任务。\"></a>解释一下上面的例子，这个例子和之前的例子是一样的。设置了两个任务并且入队。一个任务5秒后执行，一个任务10秒后执行。入队后将5秒执行的任务再往后推迟10秒（变成了15秒）。结果执行结果显示15秒延迟的任务先执行。再立刻执行了10秒延迟任务。</h5><h5 id=\"这个坑就在于需要开发者自己去计算到期时间，而且这个时间必须是实时计算出来。如果固定返回一个大于0的数字，这个队列将永远循环阻塞在该节点。后面的任务将不会被执行。就算不是固定时间，但是修改了任务执行时间，任务不会重新排序。导致队列部分后续任务执行时间错误。\"><a href=\"#这个坑就在于需要开发者自己去计算到期时间，而且这个时间必须是实时计算出来。如果固定返回一个大于0的数字，这个队列将永远循环阻塞在该节点。后面的任务将不会被执行。就算不是固定时间，但是修改了任务执行时间，任务不会重新排序。导致队列部分后续任务执行时间错误。\" class=\"headerlink\" title=\"这个坑就在于需要开发者自己去计算到期时间，而且这个时间必须是实时计算出来。如果固定返回一个大于0的数字，这个队列将永远循环阻塞在该节点。后面的任务将不会被执行。就算不是固定时间，但是修改了任务执行时间，任务不会重新排序。导致队列部分后续任务执行时间错误。\"></a>这个坑就在于需要开发者自己去计算到期时间，而且这个时间必须是实时计算出来。如果固定返回一个大于0的数字，这个队列将永远循环阻塞在该节点。后面的任务将不会被执行。就算不是固定时间，但是修改了任务执行时间，任务不会重新排序。导致队列部分后续任务执行时间错误。</h5><h5 id=\"当然这样也有一点好处，就是使得DelayQueue本身足够简单。DelayQueue不用去关心或者计算任务的过期时间，而是把这部分操场依赖给了任务本身。但是没有做到动态的调整队列顺序已保证过期时间计算的复杂性。所以这个操作还是有点坑。\"><a href=\"#当然这样也有一点好处，就是使得DelayQueue本身足够简单。DelayQueue不用去关心或者计算任务的过期时间，而是把这部分操场依赖给了任务本身。但是没有做到动态的调整队列顺序已保证过期时间计算的复杂性。所以这个操作还是有点坑。\" class=\"headerlink\" title=\"当然这样也有一点好处，就是使得DelayQueue本身足够简单。DelayQueue不用去关心或者计算任务的过期时间，而是把这部分操场依赖给了任务本身。但是没有做到动态的调整队列顺序已保证过期时间计算的复杂性。所以这个操作还是有点坑。\"></a>当然这样也有一点好处，就是使得<strong>DelayQueue</strong>本身足够简单。<strong>DelayQueue</strong>不用去关心或者计算任务的过期时间，而是把这部分操场依赖给了任务本身。但是没有做到动态的调整队列顺序已保证过期时间计算的复杂性。所以这个操作还是有点坑。</h5><h3 id=\"offer、poll\"><a href=\"#offer、poll\" class=\"headerlink\" title=\"offer、poll\"></a>offer、poll</h3><pre><code class=\"lang-java\">public boolean offer(E e) {\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n        try {\n            q.offer(e); //调用优先队列的offer操作，有排序\n            if (q.peek() == e) {\n                leader = null; //如果插入的节点是头部节点，则唤醒等待线程\n                available.signal();\n            }\n            return true;\n        } finally {\n            lock.unlock();\n        }\n    }\n</code></pre>\n<pre><code class=\"lang-java\">public E poll() {\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n        try {\n            E first = q.peek();\n            if (first == null || first.getDelay(NANOSECONDS) &gt; 0) //如果头部节点为空或者没到执行时间\n                return null; //返回空\n            else\n                return q.poll();\n        } finally {\n            lock.unlock();\n        }\n    }\n</code></pre>\n<h2 id=\"LinkedBlockingQueue\"><a href=\"#LinkedBlockingQueue\" class=\"headerlink\" title=\"LinkedBlockingQueue\"></a>LinkedBlockingQueue</h2><h5 id=\"LinkedBlockingQueue是一个由链表实现的有界队列阻塞队列。让我们来看下代码：\"><a href=\"#LinkedBlockingQueue是一个由链表实现的有界队列阻塞队列。让我们来看下代码：\" class=\"headerlink\" title=\"LinkedBlockingQueue是一个由链表实现的有界队列阻塞队列。让我们来看下代码：\"></a>LinkedBlockingQueue是一个由链表实现的有界队列阻塞队列。让我们来看下代码：</h5><pre><code class=\"lang-java\">public class LinkedBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;\n        implements BlockingQueue&lt;E&gt;, java.io.Serializable {\n\n    //链表节点，存储节点数据和下一个节点\n    static class Node&lt;E&gt; {\n        E item;\n\n        Node&lt;E&gt; next;\n\n        Node(E x) { item = x; }\n    }\n\n    //最大容量。默认为Integer.MAX_VALUE\n    private final int capacity;\n\n    //线程安全类AtomicInteger，记录链表队列长度\n    private final AtomicInteger count = new AtomicInteger();\n\n    //头部节点\n    transient Node&lt;E&gt; head;\n\n    //尾部节点\n    private transient Node&lt;E&gt; last;\n\n    /** 获取节点操作 的锁 */\n    private final ReentrantLock takeLock = new ReentrantLock();\n\n    /** 获取节点操作 的条件对象 */\n    private final Condition notEmpty = takeLock.newCondition();\n\n    /** 添加节点操作 的锁 */\n    private final ReentrantLock putLock = new ReentrantLock();\n\n    /** 添加节点操作 的条件对象 */\n    private final Condition notFull = putLock.newCondition();\n}\n</code></pre>\n<h3 id=\"看下构造函数\"><a href=\"#看下构造函数\" class=\"headerlink\" title=\"看下构造函数\"></a>看下构造函数</h3><pre><code class=\"lang-java\">public LinkedBlockingQueue() {\n        this(Integer.MAX_VALUE);\n    }\n</code></pre>\n<h5 id=\"默认构造函数的初始化大小为Integer-MAX-VALUE\"><a href=\"#默认构造函数的初始化大小为Integer-MAX-VALUE\" class=\"headerlink\" title=\"默认构造函数的初始化大小为Integer.MAX_VALUE\"></a>默认构造函数的初始化大小为Integer.MAX_VALUE</h5><pre><code class=\"lang-java\">public LinkedBlockingQueue(int capacity) {\n        if (capacity &lt;= 0) throw new IllegalArgumentException();\n        this.capacity = capacity;\n        last = head = new Node&lt;E&gt;(null);\n    }\n</code></pre>\n<h5 id=\"头部节点和尾部节点都指向同一个空节点\"><a href=\"#头部节点和尾部节点都指向同一个空节点\" class=\"headerlink\" title=\"头部节点和尾部节点都指向同一个空节点\"></a>头部节点和尾部节点都指向同一个空节点</h5><pre><code class=\"lang-java\">public LinkedBlockingQueue(Collection&lt;? extends E&gt; c) {\n        this(Integer.MAX_VALUE);\n        final ReentrantLock putLock = this.putLock;\n        putLock.lock(); // Never contended, but necessary for visibility\n        try {\n            int n = 0;\n            for (E e : c) {\n                if (e == null)\n                    throw new NullPointerException();\n                if (n == capacity)\n                    throw new IllegalStateException(&quot;Queue full&quot;);\n                enqueue(new Node&lt;E&gt;(e));\n                ++n;\n            }\n            count.set(n);\n        } finally {\n            putLock.unlock();\n        }\n    }\n</code></pre>\n<h5 id=\"利用集合初始化队列，设置为Integer-MAX-VALUE容量，然后循环入队enqueue操作\"><a href=\"#利用集合初始化队列，设置为Integer-MAX-VALUE容量，然后循环入队enqueue操作\" class=\"headerlink\" title=\"利用集合初始化队列，设置为Integer.MAX_VALUE容量，然后循环入队enqueue操作\"></a>利用集合初始化队列，设置为Integer.MAX_VALUE容量，然后循环入队enqueue操作</h5><h3 id=\"put\"><a href=\"#put\" class=\"headerlink\" title=\"put\"></a>put</h3><pre><code class=\"lang-java\">public void put(E e) throws InterruptedException {\n        if (e == null) throw new NullPointerException(); //不允许插入空值\n        int c = -1;\n        Node&lt;E&gt; node = new Node&lt;E&gt;(e); //构建新的节点\n        final ReentrantLock putLock = this.putLock;\n        final AtomicInteger count = this.count;\n        putLock.lockInterruptibly(); //可中断锁\n        try {\n            while (count.get() == capacity) {\n                notFull.await(); //如果队列满，则一直阻塞\n            }\n            enqueue(node); //如果操作\n            c = count.getAndIncrement();\n            if (c + 1 &lt; capacity)\n                notFull.signal(); //判断这次操作后队列没有满，则唤醒其他入队请求线程\n        } finally {\n            putLock.unlock(); //解锁\n        }\n        if (c == 0)\n            signalNotEmpty(); //如果本次操作之前队列为空，则在本次操作之后队列不为空了，所以这里需要唤醒获取节点的线程\n    }\n</code></pre>\n<h5 id=\"通过put方法看到LinkedBlockingQueue的操作和ArrayBlockingQueue的操作都大同小异，主要是通过ReentrantLock来控制线程安全，以及通过Condition实现条件阻塞。他们之间主要的不同点就在于他们存储数据的数据结构。\"><a href=\"#通过put方法看到LinkedBlockingQueue的操作和ArrayBlockingQueue的操作都大同小异，主要是通过ReentrantLock来控制线程安全，以及通过Condition实现条件阻塞。他们之间主要的不同点就在于他们存储数据的数据结构。\" class=\"headerlink\" title=\"通过put方法看到LinkedBlockingQueue的操作和ArrayBlockingQueue的操作都大同小异，主要是通过ReentrantLock来控制线程安全，以及通过Condition实现条件阻塞。他们之间主要的不同点就在于他们存储数据的数据结构。\"></a>通过<strong>put</strong>方法看到<strong>LinkedBlockingQueue</strong>的操作和<strong>ArrayBlockingQueue</strong>的操作都大同小异，主要是通过<strong>ReentrantLock</strong>来控制线程安全，以及通过<strong>Condition</strong>实现条件阻塞。他们之间主要的不同点就在于他们存储数据的数据结构。</h5>","site":{"data":{}},"excerpt":"<h5 id=\"java-util-concurrent包里的BlockingQueue接口表示一个线程安放入和提取实例的队列。这里我们将分析和演示如何使用这个BlockingQueue，以及对BlockingQueue的各种实现的源码解析。\"><a href=\"#java-util-concurrent包里的BlockingQueue接口表示一个线程安放入和提取实例的队列。这里我们将分析和演示如何使用这个BlockingQueue，以及对BlockingQueue的各种实现的源码解析。\" class=\"headerlink\" title=\"java.util.concurrent包里的BlockingQueue接口表示一个线程安放入和提取实例的队列。这里我们将分析和演示如何使用这个BlockingQueue，以及对BlockingQueue的各种实现的源码解析。\"></a><code>java.util.concurrent</code>包里的<strong>BlockingQueue</strong>接口表示一个线程安放入和提取实例的队列。这里我们将分析和演示如何使用这个<strong>BlockingQueue</strong>，以及对BlockingQueue的各种实现的源码解析。</h5>","more":"<h2 id=\"BlockingQueue的使用\"><a href=\"#BlockingQueue的使用\" class=\"headerlink\" title=\"BlockingQueue的使用\"></a>BlockingQueue的使用</h2><h5 id=\"BlockingQueue的数据结构为队列，通常将操作线程区分为生成者和消费者。下图是对这个原理的阐述：\"><a href=\"#BlockingQueue的数据结构为队列，通常将操作线程区分为生成者和消费者。下图是对这个原理的阐述：\" class=\"headerlink\" title=\"BlockingQueue的数据结构为队列，通常将操作线程区分为生成者和消费者。下图是对这个原理的阐述：\"></a><strong>BlockingQueue</strong>的数据结构为队列，通常将操作线程区分为生成者和消费者。下图是对这个原理的阐述：</h5><p><img src=\"/img/note/jdk/blockingqueue.png\" alt=\"blockingQueue\"></p>\n<h5 id=\"生产者线程往里边放，消费者线程从里边取的一个BlockingQueue。\"><a href=\"#生产者线程往里边放，消费者线程从里边取的一个BlockingQueue。\" class=\"headerlink\" title=\"生产者线程往里边放，消费者线程从里边取的一个BlockingQueue。\"></a>生产者线程往里边放，消费者线程从里边取的一个BlockingQueue。</h5><h5 id=\"生产者线程将会持续生产新对象并将其插入到队列之中，直到队列达到它所能容纳的临界点。也就是说，它是有限的。如果该阻塞队列到达了其临界点，负责生产的线程将会在往里边插入新对象时发生阻塞。它会一直处于阻塞之中，直到负责消费的线程从队列中拿走一个对象。\"><a href=\"#生产者线程将会持续生产新对象并将其插入到队列之中，直到队列达到它所能容纳的临界点。也就是说，它是有限的。如果该阻塞队列到达了其临界点，负责生产的线程将会在往里边插入新对象时发生阻塞。它会一直处于阻塞之中，直到负责消费的线程从队列中拿走一个对象。\" class=\"headerlink\" title=\"生产者线程将会持续生产新对象并将其插入到队列之中，直到队列达到它所能容纳的临界点。也就是说，它是有限的。如果该阻塞队列到达了其临界点，负责生产的线程将会在往里边插入新对象时发生阻塞。它会一直处于阻塞之中，直到负责消费的线程从队列中拿走一个对象。\"></a>生产者线程将会持续生产新对象并将其插入到队列之中，直到队列达到它所能容纳的临界点。也就是说，它是有限的。如果该阻塞队列到达了其临界点，负责生产的线程将会在往里边插入新对象时发生阻塞。它会一直处于阻塞之中，直到负责消费的线程从队列中拿走一个对象。</h5><h5 id=\"负责消费的线程将会一直从该阻塞队列中拿出对象。如果消费线程尝试去从一个空的队列中提取对象的话，这个消费线程将会处于阻塞之中，直到生产线程把一个对象丢进队列。\"><a href=\"#负责消费的线程将会一直从该阻塞队列中拿出对象。如果消费线程尝试去从一个空的队列中提取对象的话，这个消费线程将会处于阻塞之中，直到生产线程把一个对象丢进队列。\" class=\"headerlink\" title=\"负责消费的线程将会一直从该阻塞队列中拿出对象。如果消费线程尝试去从一个空的队列中提取对象的话，这个消费线程将会处于阻塞之中，直到生产线程把一个对象丢进队列。\"></a>负责消费的线程将会一直从该阻塞队列中拿出对象。如果消费线程尝试去从一个空的队列中提取对象的话，这个消费线程将会处于阻塞之中，直到生产线程把一个对象丢进队列。</h5><h2 id=\"BlockingQueue\"><a href=\"#BlockingQueue\" class=\"headerlink\" title=\"BlockingQueue\"></a>BlockingQueue</h2><pre><code class=\"lang-java\">public interface BlockingQueue&lt;E&gt; extends Queue&lt;E&gt; {\n\n    boolean add(E e);\n\n    boolean offer(E e);\n\n    void put(E e) throws InterruptedException;\n\n    boolean offer(E e, long timeout, TimeUnit unit)\n        throws InterruptedException;\n\n    E take() throws InterruptedException;\n\n    E poll(long timeout, TimeUnit unit)\n        throws InterruptedException;\n\n    int remainingCapacity();\n\n    boolean remove(Object o);\n\n    public boolean contains(Object o);\n\n    int drainTo(Collection&lt;? super E&gt; c);\n\n    int drainTo(Collection&lt;? super E&gt; c, int maxElements);\n}\n</code></pre>\n<h5 id=\"接口BlockingQueue的方法就是上面几个，分析一下几个主要方法的用途：\"><a href=\"#接口BlockingQueue的方法就是上面几个，分析一下几个主要方法的用途：\" class=\"headerlink\" title=\"接口BlockingQueue的方法就是上面几个，分析一下几个主要方法的用途：\"></a>接口<strong>BlockingQueue</strong>的方法就是上面几个，分析一下几个主要方法的用途：</h5><ol>\n<li><strong>offer</strong> &amp; <strong>poll</strong>：往队列中插入、取出数据，如果成功则返回true，如果失败则返回false，这个过程不阻塞，看下ArrayBlockingQueue中的实现：<pre><code class=\"lang-java\">public boolean offer(E e) {\n     checkNotNull(e);\n     //通过锁来保证线程安全\n     final ReentrantLock lock = this.lock;\n     lock.lock();\n     try {\n         if (count == items.length)\n             //如果队列已满\n             return false;\n         else {\n             //如果队列未满，真正的插入操作在enqueue中进行\n             enqueue(e);\n             return true;\n         }\n     } finally {\n         lock.unlock();\n     }\n }\n</code></pre>\n<pre><code class=\"lang-java\">public E poll() {\n     //通过锁来保证线程安全\n     final ReentrantLock lock = this.lock;\n     lock.lock();\n     try {\n         //如果队列为空则返回null，否则通过dequeue拿到队首数据\n         return (count == 0) ? null : dequeue();\n     } finally {\n         lock.unlock();\n     }\n }\n</code></pre>\n</li>\n<li><p><strong>add</strong> &amp; <strong>remove</strong> ：往队列中插入、删除数据，如果成功则返回true，不阻塞，如果失败则抛出异常，看下AbstractQueue中的实现：</p>\n<pre><code class=\"lang-java\">public boolean add(E e) {\n     if (offer(e))\n         return true;\n     else\n         throw new IllegalStateException(&quot;Queue full&quot;);\n }\n</code></pre>\n<pre><code class=\"lang-java\">public E remove() {\n     E x = poll();\n     if (x != null)\n         return x;\n     else\n         throw new NoSuchElementException();\n }\n</code></pre>\n<h5 id=\"可以看到add和remove的操作很简单，把具体队列操作都依赖给了offer和pull\"><a href=\"#可以看到add和remove的操作很简单，把具体队列操作都依赖给了offer和pull\" class=\"headerlink\" title=\"可以看到add和remove的操作很简单，把具体队列操作都依赖给了offer和pull\"></a>可以看到add和remove的操作很简单，把具体队列操作都依赖给了offer和pull</h5></li>\n<li><p><strong>put</strong> &amp; <strong>take</strong>：put操作时阻塞队列的核心，将数据插入队列，如果队列满，则阻塞直到插入成功。take和put相对应，从队列中取数据，看下ArrayBlockingQueue中的实现：</p>\n<pre><code class=\"lang-java\">public void put(E e) throws InterruptedException {\n     checkNotNull(e);\n     final ReentrantLock lock = this.lock;\n     lock.lockInterruptibly();\n     try {\n         while (count == items.length)\n             notFull.await(); //利用条件对象notFull阻塞\n         enqueue(e);\n     } finally {\n         lock.unlock();\n     }\n }\n</code></pre>\n<pre><code class=\"lang-java\">public E take() throws InterruptedException {\n     final ReentrantLock lock = this.lock;\n     lock.lockInterruptibly();\n     try {\n         while (count == 0)\n             notEmpty.await(); //利用条件对象notEmpty阻塞\n         return dequeue();\n     } finally {\n         lock.unlock();\n     }\n }\n</code></pre>\n</li>\n</ol>\n<h5 id=\"知道了BlockingQueue的基本用法和简单的实现，那么java中常见的BlockingQueue有哪些呢：\"><a href=\"#知道了BlockingQueue的基本用法和简单的实现，那么java中常见的BlockingQueue有哪些呢：\" class=\"headerlink\" title=\"知道了BlockingQueue的基本用法和简单的实现，那么java中常见的BlockingQueue有哪些呢：\"></a>知道了<strong>BlockingQueue</strong>的基本用法和简单的实现，那么java中常见的<strong>BlockingQueue</strong>有哪些呢：</h5><ul>\n<li>ArrayBlockingQueue</li>\n<li>DelayQueue</li>\n<li>LinkedBlockingQueue</li>\n<li>SynchronousQueue</li>\n</ul>\n<h5 id=\"他们有什么区别呢。下面我们将通过源码来具体分析他们的实现过程。\"><a href=\"#他们有什么区别呢。下面我们将通过源码来具体分析他们的实现过程。\" class=\"headerlink\" title=\"他们有什么区别呢。下面我们将通过源码来具体分析他们的实现过程。\"></a>他们有什么区别呢。下面我们将通过源码来具体分析他们的实现过程。</h5><h2 id=\"ArrayBlockingQueue\"><a href=\"#ArrayBlockingQueue\" class=\"headerlink\" title=\"ArrayBlockingQueue\"></a>ArrayBlockingQueue</h2><h5 id=\"ArrayBlockingQueue类继承了AbstractQueue并实现了BlockingQueue接口，来看下ArrayBlockingQueue中一些主要的属性。\"><a href=\"#ArrayBlockingQueue类继承了AbstractQueue并实现了BlockingQueue接口，来看下ArrayBlockingQueue中一些主要的属性。\" class=\"headerlink\" title=\"ArrayBlockingQueue类继承了AbstractQueue并实现了BlockingQueue接口，来看下ArrayBlockingQueue中一些主要的属性。\"></a><strong>ArrayBlockingQueue</strong>类继承了AbstractQueue并实现了<strong>BlockingQueue</strong>接口，来看下<strong>ArrayBlockingQueue</strong>中一些主要的属性。</h5><pre><code class=\"lang-java\">public class ArrayBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;\n        implements BlockingQueue&lt;E&gt;, java.io.Serializable {\n    //使用final 数组保存队列中的数据。数组需要初始化长度。因此数组的长度就是ArrayBlockingQueue的最大容量\n    final Object[] items;\n\n    //数组的下标指针，标识着下一步的take, poll, peek or remove操作。相当于头部指针\n    int takeIndex;\n\n    ////数组的下标指针，标识着下一步的put, offer, or add操作，相当于尾部指针\n    int putIndex;\n\n    //当前队列中已有数据的个数\n    int count;\n\n    //锁，保证基本的数据操作的线程安全\n    final ReentrantLock lock;\n\n    //条件对象，用于takes操作的等待\n    private final Condition notEmpty;\n\n    //条件对象，用于puts操作的等待\n    private final Condition notFull;\n\n    //迭代器\n    transient Itrs itrs = null;\n}\n</code></pre>\n<h5 id=\"可以看到ArrayBlockingQueue的底层数据结构是通过有界数组来实现的，因此你必须在创建的时候就应该确定好容量：\"><a href=\"#可以看到ArrayBlockingQueue的底层数据结构是通过有界数组来实现的，因此你必须在创建的时候就应该确定好容量：\" class=\"headerlink\" title=\"可以看到ArrayBlockingQueue的底层数据结构是通过有界数组来实现的，因此你必须在创建的时候就应该确定好容量：\"></a>可以看到<strong>ArrayBlockingQueue</strong>的底层数据结构是通过有界数组来实现的，因此你必须在创建的时候就应该确定好容量：</h5><pre><code class=\"lang-java\">public ArrayBlockingQueue(int capacity) {\n        this(capacity, false);\n    }\n</code></pre>\n<pre><code class=\"lang-java\">public ArrayBlockingQueue(int capacity, boolean fair) {\n        if (capacity &lt;= 0)\n            throw new IllegalArgumentException();\n        this.items = new Object[capacity];\n        lock = new ReentrantLock(fair);\n        notEmpty = lock.newCondition();\n        notFull =  lock.newCondition();\n    }\n</code></pre>\n<pre><code class=\"lang-java\">public ArrayBlockingQueue(int capacity, boolean fair,\n                              Collection&lt;? extends E&gt; c) {\n        this(capacity, fair);\n\n        final ReentrantLock lock = this.lock;\n        lock.lock(); // Lock only for visibility, not mutual exclusion\n        try {\n            int i = 0;\n            try {\n                for (E e : c) {\n                    checkNotNull(e);\n                    items[i++] = e;\n                }\n            } catch (ArrayIndexOutOfBoundsException ex) {\n                throw new IllegalArgumentException();\n            }\n            count = i;\n            putIndex = (i == capacity) ? 0 : i;\n        } finally {\n            lock.unlock();\n        }\n    }\n</code></pre>\n<h5 id=\"可以看到ArrayBlockingQueue的初始化可以有三个参数：\"><a href=\"#可以看到ArrayBlockingQueue的初始化可以有三个参数：\" class=\"headerlink\" title=\"可以看到ArrayBlockingQueue的初始化可以有三个参数：\"></a>可以看到ArrayBlockingQueue的初始化可以有三个参数：</h5><ol>\n<li><strong>capacity（容量）</strong>：三个构造函数都需要的变量，也就是ArrayBlockingQueue的初始容量。</li>\n<li><strong>fair（是否公平）</strong>：缺省默认为非公平，这里的公平与非公平主要体现在锁的获取上，ArrayBlockingQueue会根据这个参数来创建公平锁或者非公平锁</li>\n<li><strong>c（集合）</strong>：初始集合数据，即使有这个参数，ArrayBlockingQueue依然会按照capacity的大小来初始化数组大小，即使c的容量可能会超过capacity。如果c的容量大于capacity大小。构造函数中会捕获该异常<strong>ArrayIndexOutOfBoundsException</strong>，并抛出一个新的<strong>IllegalArgumentException</strong>异常。</li>\n</ol>\n<h5 id=\"这是ArrayBlockingQueue的主要特点，那么我们来看看ArrayBlockingQueue是如何来操作数据添加和删除数据的\"><a href=\"#这是ArrayBlockingQueue的主要特点，那么我们来看看ArrayBlockingQueue是如何来操作数据添加和删除数据的\" class=\"headerlink\" title=\"这是ArrayBlockingQueue的主要特点，那么我们来看看ArrayBlockingQueue是如何来操作数据添加和删除数据的\"></a>这是<strong>ArrayBlockingQueue</strong>的主要特点，那么我们来看看ArrayBlockingQueue是如何来操作数据添加和删除数据的</h5><h4 id=\"enqueue（入队）\"><a href=\"#enqueue（入队）\" class=\"headerlink\" title=\"enqueue（入队）\"></a>enqueue（入队）</h4><pre><code class=\"lang-java\">private void enqueue(E x) {\n        final Object[] items = this.items;\n        //通过putIndex下标直接插入数据\n        items[putIndex] = x;\n        //自增putIndex后，如果已经是数组尾部，则重新开始计算，循环指针\n        if (++putIndex == items.length)\n            putIndex = 0;\n        count++;//数据大小加1\n        notEmpty.signal(); //释放因为take操作而阻塞的线程\n    }\n</code></pre>\n<h5 id=\"该操作为私有操作，只有方法内部可以调用，通过上面的代码我们知道put-offer-add操作都是通过该方法插入的数据，所以在enqueue方法中并没有锁的操作，因为在外部已经获取过锁\"><a href=\"#该操作为私有操作，只有方法内部可以调用，通过上面的代码我们知道put-offer-add操作都是通过该方法插入的数据，所以在enqueue方法中并没有锁的操作，因为在外部已经获取过锁\" class=\"headerlink\" title=\"该操作为私有操作，只有方法内部可以调用，通过上面的代码我们知道put, offer, add操作都是通过该方法插入的数据，所以在enqueue方法中并没有锁的操作，因为在外部已经获取过锁\"></a>该操作为私有操作，只有方法内部可以调用，通过上面的代码我们知道put, offer, add操作都是通过该方法插入的数据，所以在enqueue方法中并没有锁的操作，因为在外部已经获取过锁</h5><h4 id=\"dequeue（出队）\"><a href=\"#dequeue（出队）\" class=\"headerlink\" title=\"dequeue（出队）\"></a>dequeue（出队）</h4><pre><code class=\"lang-java\">private E dequeue() {\n        final Object[] items = this.items;\n        //通过takeIndex获取数组数据\n        E x = (E) items[takeIndex];\n        //制空\n        items[takeIndex] = null;\n        //自增takeIndex后，如果已经是数组尾部，则重新开始计算，循环指针\n        if (++takeIndex == items.length)\n            takeIndex = 0;\n        count--;//数据大小减1\n        if (itrs != null)\n            itrs.elementDequeued();\n        notFull.signal();//释放因为put操作而阻塞的线程\n        return x; //返回数据\n    }\n</code></pre>\n<h2 id=\"DelayQueue\"><a href=\"#DelayQueue\" class=\"headerlink\" title=\"DelayQueue\"></a>DelayQueue</h2><h5 id=\"DelayQueue是一个无界的BlockingQueue，用于放置实现了Delayed接口的对象，其中的对象只能在其到期时才能从队列中取走。这种队列是有序的，即队头对象的延迟到期时间最长。注意：不能将null元素放置到这种队列中。\"><a href=\"#DelayQueue是一个无界的BlockingQueue，用于放置实现了Delayed接口的对象，其中的对象只能在其到期时才能从队列中取走。这种队列是有序的，即队头对象的延迟到期时间最长。注意：不能将null元素放置到这种队列中。\" class=\"headerlink\" title=\"DelayQueue是一个无界的BlockingQueue，用于放置实现了Delayed接口的对象，其中的对象只能在其到期时才能从队列中取走。这种队列是有序的，即队头对象的延迟到期时间最长。注意：不能将null元素放置到这种队列中。\"></a><strong>DelayQueue</strong>是一个无界的<strong>BlockingQueue</strong>，用于放置实现了<strong>Delayed</strong>接口的对象，其中的对象只能在其到期时才能从队列中取走。这种队列是有序的，即队头对象的延迟到期时间最长。注意：不能将null元素放置到这种队列中。</h5><h3 id=\"先来看下使用过程：\"><a href=\"#先来看下使用过程：\" class=\"headerlink\" title=\"先来看下使用过程：\"></a>先来看下使用过程：</h3><h5 id=\"创建一个Delayed，用于保存任务数据以及延迟执行的时间\"><a href=\"#创建一个Delayed，用于保存任务数据以及延迟执行的时间\" class=\"headerlink\" title=\"创建一个Delayed，用于保存任务数据以及延迟执行的时间\"></a>创建一个Delayed，用于保存任务数据以及延迟执行的时间</h5><pre><code class=\"lang-java\">public class B implements Delayed{\n\n        private long endTime; //执行时间\n\n        public B(long endTime) {\n            this.endTime = endTime;\n        }\n\n        public long getDelay(TimeUnit unit) {\n            return unit.convert(endTime - System.currentTimeMillis(), TimeUnit.MILLISECONDS);\n        }\n\n        public int compareTo(Delayed o) {\n            if(o == null) return 1;\n            if(o == this) return 0;\n            if (this.getDelay(TimeUnit.NANOSECONDS) &gt; o.getDelay(TimeUnit.NANOSECONDS)) {\n                return 1;\n            }else if (this.getDelay(TimeUnit.NANOSECONDS) == o.getDelay(TimeUnit.NANOSECONDS)) {\n                return 0;\n            }else {\n                return -1;\n            }\n        }\n    }\n</code></pre>\n<h5 id=\"main方法\"><a href=\"#main方法\" class=\"headerlink\" title=\"main方法\"></a>main方法</h5><pre><code class=\"lang-java\">public static void main(String[] args) throws InterruptedException {\n        DelayQueue&lt;B&gt; delayed = new DelayQueue&lt;B&gt;();\n        B b = new B(new Date().getTime() + 10000); //第一个任务在10秒后执行\n        B b1 = new B(new Date().getTime() + 5000); //第二个任务在5秒后执行\n        delayed.put(b);\n        delayed.put(b1);\n        System.out.println(delayed.take().getEndTime());\n        System.out.println(delayed.take().getEndTime());\n    }\n</code></pre>\n<h5 id=\"输出结果：\"><a href=\"#输出结果：\" class=\"headerlink\" title=\"输出结果：\"></a>输出结果：</h5><pre><code>1522220892807\n1522220897807\n</code></pre><h3 id=\"DelayQueue实现细节\"><a href=\"#DelayQueue实现细节\" class=\"headerlink\" title=\"DelayQueue实现细节\"></a>DelayQueue实现细节</h3><h4 id=\"看下DelayQueue的属性变量\"><a href=\"#看下DelayQueue的属性变量\" class=\"headerlink\" title=\"看下DelayQueue的属性变量\"></a>看下DelayQueue的属性变量</h4><pre><code class=\"lang-java\">public class DelayQueue&lt;E extends Delayed&gt; extends AbstractQueue&lt;E&gt;\n    implements BlockingQueue&lt;E&gt; {\n\n    //锁，控制队列操作的线程安全\n    private final transient ReentrantLock lock = new ReentrantLock();\n\n    //优先队列，实际存储节点的数据结构，优先队列将按照我们提供的compareTo方法进行排序\n    //队列中使用数组进行存储数据，但是在容量不够的时候可以动态扩容。在这里初始大小为11\n    private final PriorityQueue&lt;E&gt; q = new PriorityQueue&lt;E&gt;();\n\n    //当前头部节点的等待线程，防止多个线程等待同一个节点\n    private Thread leader = null;\n\n    //线程阻塞使用Condition实现\n    private final Condition available = lock.newCondition();\n}\n</code></pre>\n<h4 id=\"我们来看下构造函数：\"><a href=\"#我们来看下构造函数：\" class=\"headerlink\" title=\"我们来看下构造函数：\"></a>我们来看下构造函数：</h4><h5 id=\"无参构造函数\"><a href=\"#无参构造函数\" class=\"headerlink\" title=\"无参构造函数\"></a>无参构造函数</h5><pre><code class=\"lang-java\">public DelayQueue() {}\n</code></pre>\n<h5 id=\"通过集合初始化DelayQueue\"><a href=\"#通过集合初始化DelayQueue\" class=\"headerlink\" title=\"通过集合初始化DelayQueue\"></a>通过集合初始化<strong>DelayQueue</strong></h5><pre><code class=\"lang-java\">public DelayQueue(Collection&lt;? extends E&gt; c) {\n        this.addAll(c);\n}\n</code></pre>\n<h5 id=\"可以看到DelayQueue的构造函数非常简单，这是因为DelayQueue是无界的，而且真正存储数据的PriorityQueue默认就已经初始化完成。所以DelayQueue实际并不关心数据的存储，它的核心还是在于take操作的阻塞过程：\"><a href=\"#可以看到DelayQueue的构造函数非常简单，这是因为DelayQueue是无界的，而且真正存储数据的PriorityQueue默认就已经初始化完成。所以DelayQueue实际并不关心数据的存储，它的核心还是在于take操作的阻塞过程：\" class=\"headerlink\" title=\"可以看到DelayQueue的构造函数非常简单，这是因为DelayQueue是无界的，而且真正存储数据的PriorityQueue默认就已经初始化完成。所以DelayQueue实际并不关心数据的存储，它的核心还是在于take操作的阻塞过程：\"></a>可以看到<strong>DelayQueue</strong>的构造函数非常简单，这是因为<strong>DelayQueue</strong>是无界的，而且真正存储数据的<strong>PriorityQueue</strong>默认就已经初始化完成。所以<strong>DelayQueue</strong>实际并不关心数据的存储，它的核心还是在于take操作的阻塞过程：</h5><pre><code class=\"lang-java\">public E take() throws InterruptedException {\n        final ReentrantLock lock = this.lock; //通过锁来保证线程安全\n        lock.lockInterruptibly(); //可中断锁\n        try {\n            for (;;) {\n                E first = q.peek(); //查看队列头部的节点\n                if (first == null)\n                    available.await(); //如果队列为空，阻塞\n                else {\n                    long delay = first.getDelay(NANOSECONDS); //获取等待时间\n                    if (delay &lt;= 0) //等待时间小于等于0 则直接返回，这是该方法唯一的出口。除非锁中断\n                        return q.poll();\n                    first = null; // 等待时间大于0，需要阻塞等待\n                    if (leader != null)\n                        available.await(); //如果有其他线程在等待该节点，则阻塞\n                    else {\n                        Thread thisThread = Thread.currentThread();\n                        leader = thisThread; //设置等待头部节点的线程\n                        try {\n                            available.awaitNanos(delay); //等待固定时间\n                        } finally {\n                            if (leader == thisThread)\n                                leader = null; //等待结束后释放等待线程，重新获取节点\n                        }\n                    }\n                }\n            }\n        } finally {\n            if (leader == null &amp;&amp; q.peek() != null)\n                available.signal(); //如果没有线程在等待头部节点，并且队列不为空。则唤醒其他等待线程\n            lock.unlock(); //锁释放\n        }\n    }\n</code></pre>\n<h5 id=\"整理一下操作流程：\"><a href=\"#整理一下操作流程：\" class=\"headerlink\" title=\"整理一下操作流程：\"></a>整理一下操作流程：</h5><ol>\n<li>获取锁</li>\n<li>获取队列头部的节点（不出队）</li>\n<li>如果头部节点为空，则判断队列为空，线程阻塞等待并释放锁，唤醒时回到步骤2</li>\n<li>如果节点不为空，获取头部节点的等待时间（这里参照之前的例子，需要自行计算等待时间，略坑）</li>\n<li>如果等待时间小于等于0。则认为该节点可以返回，调用poll操作返回。这是该方法的唯一一个正常出口</li>\n<li>等待时间大于0<ol>\n<li>判断是否还有其他线程在等待该节点，如果有，则阻塞并释放锁。（理论上来说等该线程唤醒并执行时获取到的应该是后续的节点了），唤醒时回到步骤2</li>\n<li>如果没有其他线程等待，则通过awaitNanos方法等待固定时间。唤醒时释放头部节点的等待线程。重新回到步骤2</li>\n</ol>\n</li>\n<li>通常情况下，awaitNanos方法过后重新获取节点能够正常返回了。然后调用finally块，在finally中会释放步骤3和步骤6中的第1部分的阻塞线程中的一个。</li>\n</ol>\n<h5 id=\"在上面的操作过程中有一个小坑就是步骤4，这里的等待时间需要自行计算。这里会带来什么坑呢，看个例子：\"><a href=\"#在上面的操作过程中有一个小坑就是步骤4，这里的等待时间需要自行计算。这里会带来什么坑呢，看个例子：\" class=\"headerlink\" title=\"在上面的操作过程中有一个小坑就是步骤4，这里的等待时间需要自行计算。这里会带来什么坑呢，看个例子：\"></a>在上面的操作过程中有一个小坑就是步骤4，这里的等待时间需要自行计算。这里会带来什么坑呢，看个例子：</h5><pre><code class=\"lang-java\">public static void main(String[] args) throws InterruptedException {\n        DelayQueue&lt;B&gt; delayed = new DelayQueue&lt;B&gt;();\n        B b = new B(new Date().getTime() + 10000);\n        B b1 = new B(new Date().getTime() + 5000);\n        delayed.put(b);\n        delayed.put(b1);\n        b1.setEndTime(b1.getEndTime() + 10000);\n        System.out.println(delayed.take().getEndTime());\n        System.out.println(delayed.take().getEndTime());\n    }\n\n    private static class B implements Delayed{\n\n        private long endTime;\n\n        public B(long endTime) {\n            this.endTime = endTime;\n        }\n\n        public long getDelay(TimeUnit unit) {\n            return unit.convert(endTime - System.currentTimeMillis(), TimeUnit.MILLISECONDS);\n        }\n\n        public long getEndTime() {\n            return endTime;\n        }\n\n        public void setEndTime(long endTime) {\n            this.endTime = endTime;\n        }\n\n        public int compareTo(Delayed o) {\n            if(o == null) return 1;\n            if(o == this) return 0;\n            if (this.getDelay(TimeUnit.NANOSECONDS) &gt; o.getDelay(TimeUnit.NANOSECONDS)) {\n                return 1;\n            }else if (this.getDelay(TimeUnit.NANOSECONDS) == o.getDelay(TimeUnit.NANOSECONDS)) {\n                return 0;\n            }else {\n                return -1;\n            }\n        }\n    }\n</code></pre>\n<h5 id=\"输出结果\"><a href=\"#输出结果\" class=\"headerlink\" title=\"输出结果\"></a>输出结果</h5><pre><code>1522230732548\n1522230727548\n</code></pre><h5 id=\"解释一下上面的例子，这个例子和之前的例子是一样的。设置了两个任务并且入队。一个任务5秒后执行，一个任务10秒后执行。入队后将5秒执行的任务再往后推迟10秒（变成了15秒）。结果执行结果显示15秒延迟的任务先执行。再立刻执行了10秒延迟任务。\"><a href=\"#解释一下上面的例子，这个例子和之前的例子是一样的。设置了两个任务并且入队。一个任务5秒后执行，一个任务10秒后执行。入队后将5秒执行的任务再往后推迟10秒（变成了15秒）。结果执行结果显示15秒延迟的任务先执行。再立刻执行了10秒延迟任务。\" class=\"headerlink\" title=\"解释一下上面的例子，这个例子和之前的例子是一样的。设置了两个任务并且入队。一个任务5秒后执行，一个任务10秒后执行。入队后将5秒执行的任务再往后推迟10秒（变成了15秒）。结果执行结果显示15秒延迟的任务先执行。再立刻执行了10秒延迟任务。\"></a>解释一下上面的例子，这个例子和之前的例子是一样的。设置了两个任务并且入队。一个任务5秒后执行，一个任务10秒后执行。入队后将5秒执行的任务再往后推迟10秒（变成了15秒）。结果执行结果显示15秒延迟的任务先执行。再立刻执行了10秒延迟任务。</h5><h5 id=\"这个坑就在于需要开发者自己去计算到期时间，而且这个时间必须是实时计算出来。如果固定返回一个大于0的数字，这个队列将永远循环阻塞在该节点。后面的任务将不会被执行。就算不是固定时间，但是修改了任务执行时间，任务不会重新排序。导致队列部分后续任务执行时间错误。\"><a href=\"#这个坑就在于需要开发者自己去计算到期时间，而且这个时间必须是实时计算出来。如果固定返回一个大于0的数字，这个队列将永远循环阻塞在该节点。后面的任务将不会被执行。就算不是固定时间，但是修改了任务执行时间，任务不会重新排序。导致队列部分后续任务执行时间错误。\" class=\"headerlink\" title=\"这个坑就在于需要开发者自己去计算到期时间，而且这个时间必须是实时计算出来。如果固定返回一个大于0的数字，这个队列将永远循环阻塞在该节点。后面的任务将不会被执行。就算不是固定时间，但是修改了任务执行时间，任务不会重新排序。导致队列部分后续任务执行时间错误。\"></a>这个坑就在于需要开发者自己去计算到期时间，而且这个时间必须是实时计算出来。如果固定返回一个大于0的数字，这个队列将永远循环阻塞在该节点。后面的任务将不会被执行。就算不是固定时间，但是修改了任务执行时间，任务不会重新排序。导致队列部分后续任务执行时间错误。</h5><h5 id=\"当然这样也有一点好处，就是使得DelayQueue本身足够简单。DelayQueue不用去关心或者计算任务的过期时间，而是把这部分操场依赖给了任务本身。但是没有做到动态的调整队列顺序已保证过期时间计算的复杂性。所以这个操作还是有点坑。\"><a href=\"#当然这样也有一点好处，就是使得DelayQueue本身足够简单。DelayQueue不用去关心或者计算任务的过期时间，而是把这部分操场依赖给了任务本身。但是没有做到动态的调整队列顺序已保证过期时间计算的复杂性。所以这个操作还是有点坑。\" class=\"headerlink\" title=\"当然这样也有一点好处，就是使得DelayQueue本身足够简单。DelayQueue不用去关心或者计算任务的过期时间，而是把这部分操场依赖给了任务本身。但是没有做到动态的调整队列顺序已保证过期时间计算的复杂性。所以这个操作还是有点坑。\"></a>当然这样也有一点好处，就是使得<strong>DelayQueue</strong>本身足够简单。<strong>DelayQueue</strong>不用去关心或者计算任务的过期时间，而是把这部分操场依赖给了任务本身。但是没有做到动态的调整队列顺序已保证过期时间计算的复杂性。所以这个操作还是有点坑。</h5><h3 id=\"offer、poll\"><a href=\"#offer、poll\" class=\"headerlink\" title=\"offer、poll\"></a>offer、poll</h3><pre><code class=\"lang-java\">public boolean offer(E e) {\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n        try {\n            q.offer(e); //调用优先队列的offer操作，有排序\n            if (q.peek() == e) {\n                leader = null; //如果插入的节点是头部节点，则唤醒等待线程\n                available.signal();\n            }\n            return true;\n        } finally {\n            lock.unlock();\n        }\n    }\n</code></pre>\n<pre><code class=\"lang-java\">public E poll() {\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n        try {\n            E first = q.peek();\n            if (first == null || first.getDelay(NANOSECONDS) &gt; 0) //如果头部节点为空或者没到执行时间\n                return null; //返回空\n            else\n                return q.poll();\n        } finally {\n            lock.unlock();\n        }\n    }\n</code></pre>\n<h2 id=\"LinkedBlockingQueue\"><a href=\"#LinkedBlockingQueue\" class=\"headerlink\" title=\"LinkedBlockingQueue\"></a>LinkedBlockingQueue</h2><h5 id=\"LinkedBlockingQueue是一个由链表实现的有界队列阻塞队列。让我们来看下代码：\"><a href=\"#LinkedBlockingQueue是一个由链表实现的有界队列阻塞队列。让我们来看下代码：\" class=\"headerlink\" title=\"LinkedBlockingQueue是一个由链表实现的有界队列阻塞队列。让我们来看下代码：\"></a>LinkedBlockingQueue是一个由链表实现的有界队列阻塞队列。让我们来看下代码：</h5><pre><code class=\"lang-java\">public class LinkedBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;\n        implements BlockingQueue&lt;E&gt;, java.io.Serializable {\n\n    //链表节点，存储节点数据和下一个节点\n    static class Node&lt;E&gt; {\n        E item;\n\n        Node&lt;E&gt; next;\n\n        Node(E x) { item = x; }\n    }\n\n    //最大容量。默认为Integer.MAX_VALUE\n    private final int capacity;\n\n    //线程安全类AtomicInteger，记录链表队列长度\n    private final AtomicInteger count = new AtomicInteger();\n\n    //头部节点\n    transient Node&lt;E&gt; head;\n\n    //尾部节点\n    private transient Node&lt;E&gt; last;\n\n    /** 获取节点操作 的锁 */\n    private final ReentrantLock takeLock = new ReentrantLock();\n\n    /** 获取节点操作 的条件对象 */\n    private final Condition notEmpty = takeLock.newCondition();\n\n    /** 添加节点操作 的锁 */\n    private final ReentrantLock putLock = new ReentrantLock();\n\n    /** 添加节点操作 的条件对象 */\n    private final Condition notFull = putLock.newCondition();\n}\n</code></pre>\n<h3 id=\"看下构造函数\"><a href=\"#看下构造函数\" class=\"headerlink\" title=\"看下构造函数\"></a>看下构造函数</h3><pre><code class=\"lang-java\">public LinkedBlockingQueue() {\n        this(Integer.MAX_VALUE);\n    }\n</code></pre>\n<h5 id=\"默认构造函数的初始化大小为Integer-MAX-VALUE\"><a href=\"#默认构造函数的初始化大小为Integer-MAX-VALUE\" class=\"headerlink\" title=\"默认构造函数的初始化大小为Integer.MAX_VALUE\"></a>默认构造函数的初始化大小为Integer.MAX_VALUE</h5><pre><code class=\"lang-java\">public LinkedBlockingQueue(int capacity) {\n        if (capacity &lt;= 0) throw new IllegalArgumentException();\n        this.capacity = capacity;\n        last = head = new Node&lt;E&gt;(null);\n    }\n</code></pre>\n<h5 id=\"头部节点和尾部节点都指向同一个空节点\"><a href=\"#头部节点和尾部节点都指向同一个空节点\" class=\"headerlink\" title=\"头部节点和尾部节点都指向同一个空节点\"></a>头部节点和尾部节点都指向同一个空节点</h5><pre><code class=\"lang-java\">public LinkedBlockingQueue(Collection&lt;? extends E&gt; c) {\n        this(Integer.MAX_VALUE);\n        final ReentrantLock putLock = this.putLock;\n        putLock.lock(); // Never contended, but necessary for visibility\n        try {\n            int n = 0;\n            for (E e : c) {\n                if (e == null)\n                    throw new NullPointerException();\n                if (n == capacity)\n                    throw new IllegalStateException(&quot;Queue full&quot;);\n                enqueue(new Node&lt;E&gt;(e));\n                ++n;\n            }\n            count.set(n);\n        } finally {\n            putLock.unlock();\n        }\n    }\n</code></pre>\n<h5 id=\"利用集合初始化队列，设置为Integer-MAX-VALUE容量，然后循环入队enqueue操作\"><a href=\"#利用集合初始化队列，设置为Integer-MAX-VALUE容量，然后循环入队enqueue操作\" class=\"headerlink\" title=\"利用集合初始化队列，设置为Integer.MAX_VALUE容量，然后循环入队enqueue操作\"></a>利用集合初始化队列，设置为Integer.MAX_VALUE容量，然后循环入队enqueue操作</h5><h3 id=\"put\"><a href=\"#put\" class=\"headerlink\" title=\"put\"></a>put</h3><pre><code class=\"lang-java\">public void put(E e) throws InterruptedException {\n        if (e == null) throw new NullPointerException(); //不允许插入空值\n        int c = -1;\n        Node&lt;E&gt; node = new Node&lt;E&gt;(e); //构建新的节点\n        final ReentrantLock putLock = this.putLock;\n        final AtomicInteger count = this.count;\n        putLock.lockInterruptibly(); //可中断锁\n        try {\n            while (count.get() == capacity) {\n                notFull.await(); //如果队列满，则一直阻塞\n            }\n            enqueue(node); //如果操作\n            c = count.getAndIncrement();\n            if (c + 1 &lt; capacity)\n                notFull.signal(); //判断这次操作后队列没有满，则唤醒其他入队请求线程\n        } finally {\n            putLock.unlock(); //解锁\n        }\n        if (c == 0)\n            signalNotEmpty(); //如果本次操作之前队列为空，则在本次操作之后队列不为空了，所以这里需要唤醒获取节点的线程\n    }\n</code></pre>\n<h5 id=\"通过put方法看到LinkedBlockingQueue的操作和ArrayBlockingQueue的操作都大同小异，主要是通过ReentrantLock来控制线程安全，以及通过Condition实现条件阻塞。他们之间主要的不同点就在于他们存储数据的数据结构。\"><a href=\"#通过put方法看到LinkedBlockingQueue的操作和ArrayBlockingQueue的操作都大同小异，主要是通过ReentrantLock来控制线程安全，以及通过Condition实现条件阻塞。他们之间主要的不同点就在于他们存储数据的数据结构。\" class=\"headerlink\" title=\"通过put方法看到LinkedBlockingQueue的操作和ArrayBlockingQueue的操作都大同小异，主要是通过ReentrantLock来控制线程安全，以及通过Condition实现条件阻塞。他们之间主要的不同点就在于他们存储数据的数据结构。\"></a>通过<strong>put</strong>方法看到<strong>LinkedBlockingQueue</strong>的操作和<strong>ArrayBlockingQueue</strong>的操作都大同小异，主要是通过<strong>ReentrantLock</strong>来控制线程安全，以及通过<strong>Condition</strong>实现条件阻塞。他们之间主要的不同点就在于他们存储数据的数据结构。</h5>"},{"layout":"post","title":"java类加载过程","date":"2017-12-25T16:00:00.000Z","tag":[["java","java"]],"_content":"\n# java类加载过程\n##### 类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载，验证，准备，解析，初始化，使用和卸载七个阶段。其中验证，准备和解析三个部分统称为连接，这七个阶段的发生顺序如图所示：\n<!--more-->\n\n![java类加载搓成](/img/note/javaClassLoading.png) <div class='img-note'>JAVA类加载过程</div>\n\n### 加载\n##### 加载既是将class文件字节码加载到内存中，并将这些静态数据转换为jvm方法区运行时数据结构。在堆中生成一个代表这个类的java.lang.Class对象，作为方法区访问对象的入口。\n### 链接\n##### 将已读入内存的二进制数据合并到JVM运行状态中去的过程。包含验证、准备、解析等过程。\n#### 验证:\n1. 类文件结构检查：确保加载的类信息符合JVM规范，遵从类文件结构的固定格式。\n2. 元数据验证：确保类本身符合Java语言的语法规定，比如验证final类型的类没有子类，以及final类型的方法没有被覆盖。注意，语义检查的错误在编译器编译阶段就会通不过，但是如果有程序员通过非编译的手段生成了类文件，其中有可能会含有语义错误，此时的语义检查主要是防止这种没有编译而生成的class文件引入的错误。\n3. 字节码验证：确保字节码流可以被Java虚拟机安全地执行。字节码流代表Java方法(包括静态方法和实例方法)，它是由被称作操作码的单字节指令组成的序列，每一个操作码后都跟着一个或多个操作数。字节码验证步骤会检查每个操作码是否合法，即是否有着合法的操作数。\n4. 二进制兼容性验证：确保相互引用的类之间的协调一致。例如，在Worker类的gotoWork()方法中会调用Car类的run()方法，Java虚拟机在验证Worker类时，会检查在方法区内是否存在Car类的run()方法，假如不存在(当Worker类和Car类的版本不兼容就会出现这种问题)，就会抛出NoSuchMethodError错误。\n\n#### 准备:\n1. 正式为类变量分配内存，并设置类变量初始值的阶段。这些内存都将在方法区分配。这个时候进行内存分配的仅包括类变量（static变量），而不包括实例变量。实例变量将会在对象实例化时随着对象一起分配在java堆中\n2. 这里所说的初始值\"通常情况下\"是数据类型的零值，假设一个类型变量定义为：`public static int value = 123;`，那么变量value在准备过后的初始值为0而不是123。而把value赋值为123的动作存放于类构造器&lt;clinit&gt;中，该方法将在初始化阶段才会执行。\n3. 上面所说的是通常情况，会有一些\"特殊情况下\"：如果类字段的字段属性表中存在ConstantValues属性，那么准备阶段value就会被初始化为ConstantValues。例如：`public static final int value = 123;`\n\n#### 解析：\n1. 虚拟机常量池内的符号引用替换为直接引用的过程。\n2. 例如在Worker类的gotoWork()方法中会引用Car类的run()方法。\n```java\npublic void gotoWork() {\n    car.run();// 这段代码在Worker类的二进制数据中表示为符号引用\n}\n```\n3. 在Worker类的二进制数据中，包含了一个对Car类的run()方法的符号引用，它由run()方法的全名和相关描述符组成。\n4. 在解析阶段，Java虚拟机会把这个符号引用替换为一个指针，该指针指向Car类的run()方法在方法区内的内存位置，这个指针就是直接引用。\n\n### 初始化\n##### 类初始化是类加载过程的最后一步，前面的类加载过程，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码。初始化是执行类的构造器&lt;clinit&gt;()方法的过程。\n##### 类构造器&lt;clinit&gt;()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static块）中的语句合并产生的。\n##### 当初始化一个类的时候，如果发现其父类还没有进行过初始化、则需要先触发其父类的初始化。\n##### 虚拟机会保证一个类的&lt;clinit&gt;()方法在多线程环境中被正确加锁和同步。\n##### 当访问一个java类的静态域时，只有真正声明这个域的类才会被初始化。\n\n#### 说明 &lt;clinit&gt; 与&lt;init&gt;方法\n##### 可能出现在class文件中的两种编译器产生的方法是：实例初始化方法(名为&lt;init&gt;)和类与接口初始化方法(名为&lt;clinit&gt;)。\n##### 这两个方法一个是虚拟机在装载一个类初始化的时候调用的（clinit）。另一个是在类实例化时调用的（init）\n##### &lt;clinit&gt;方法：所有的类变量初始化语句和类型的静态初始化语句都被Java编译器收集到了一起，放在一个特殊的方法中。这个方法就是&lt;clinit&gt;\n##### &lt;init&gt;方法：是在一个类进行对象实例化时调用的。实例化一个类有四种途径：调用new操作符；调用Class或java.lang.reflect.Constructor对象的newInstance()方法；调用任何现有对象的clone()方法；通过java.io.ObjectInputStream类的getObject()方法反序列化。Java编译器会为它的每一个类都至少生成一个实例初始化方法。在Class文件中,被称为\"&lt;init&gt;\"\n##### 区别：一个是用于初始化静态的类变量， 一个是初始化实例变量!\n\n### 使用\n##### 使用既是所需要的对象开始被调用。\n\n### 卸载\n##### 对象被jvm回收。\n\n#### 示例\n\n```java\npublic class InitDemo {\n\n    static {\n        System.out.println(\"InitDemo static init ...\");\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"InitDemo main begin\");\n        InitA a = new InitA();\n        System.out.println(InitA.width);\n        InitA b = new InitA();\n\n    }\n}\n```\n\n```java\nclass InitBase{\n\n    static {\n        System.out.println(\"InitBase static init ...\");\n    }\n}\n```\n\n```java\nclass InitA extends InitBase {\n\n    public static int width = 60;\n\n    static {\n        System.out.println(\"InitA static init ...\");\n        width = 30;\n    }\n\n    public InitA() {\n        System.out.println(\" InitA init ... \");\n    }\n}\n```\n\n##### 运行结果：\n\n```\nInitDemo static init ...\nInitDemo main begin\nInitBase static init ...\nInitA static init ...\n InitA init ...\n30\n InitA init ...\n```\n\n##### 可以看到，在执行结果中，先运行main方法所在类的初始化方法，之后运行main函数。然后运行父类InitBase的初始化方法。之后运行InitA的静态初始化。以及InitA的构造函数。此后虽然new了多个InitA，但是其静态的初始化方法&lt;clinit&gt;只运行了一次。\n\n# 被动引用和主动引用\n##### 在java虚拟机规范中，严格规定了，只有对类进行主动引用，才会触发其初始化方法。而除此之外的引用方式称之为被动引用，不会触发类的初始化方法。\n### 主动引用\n##### 虚拟机规范规定只有如下四种情况才能触发主动引用：\n#### 遇到new、getstatic、setstatic、invokestatic 4条指令时，如果类没有初始化，则需要触发其初始化（final修饰的常量除外）。\n#### (1).使用new关键字实例化对象\n\n```java\npublic class NewClass {\n\n    static {\n        System.out.println(\"NewClass init ...\");\n    }\n\n}\n```\n\n```java\nclass Init1{\n    public static void main(String[] args) {\n        new NewClass();\n    }\n}\n```\n\n##### 运行结果：\n```\nNewClass init ...\n```\n\n#### (2).读取类的静态成员变量\n\n```java\npublic class StaticAttributeClass {\n\n    public static int value = 10;\n\n    public static void staticMethod() {\n\n    }\n\n    static {\n        System.out.println(\"StaticAttributeClass init ...\");\n    }\n}\n```\n\n```java\nclass Init2{\n    public static void main(String[] args) {\n        //1.读取静态变量\n        int value = StaticAttributeClass.value;\n    }\n}\n```\n##### 运行结果：\n```\nStaticAttributeClass init ...\n```\n\n#### (3).设置类的静态成员变量\n```java\nclass Init2{\n    public static void main(String[] args) {\n        StaticAttributeClass.value = 5\n    }\n}\n```\n##### 运行结果：\n```\nStaticAttributeClass init ...\n```\n\n#### (4).调用静态方法\n```java\nclass Init2{\n    public static void main(String[] args) {\n        StaticAttributeClass.staticMethod();\n    }\n}\n\n```\n##### 运行结果：\n```\nStaticAttributeClass init ...\n```\n\n#### 使用java.lang.reflenct包的方法对类进行放射调用，如果没有进行初始化，则需要触发其初始化。\n```java\npublic class ReflectClass {\n\n    static {\n        System.out.println(\"ReflectClass init ...\");\n    }\n}\n```\n\n```java\nclass Init3{\n    public static void main(String[] args) {\n        try {\n            Class clazz = Class.forName(\"com.dhb.classload.ReflectClass\");\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n##### 运行结果：\n```\nReflectClass init ..\n```\n\n#### 当一个类初始化的时候，如果其父类还没有初始化，则需要先对其父类进行初始化。\n```java\npublic class SuperClass {\n    static {\n        System.out.println(\"SuperClass init ...\");\n    }\n    public static int value = 10;\n}\n```\n\n```java\nclass SubClass extends SuperClass {\n    static {\n        System.out.println(\"SubClass init ...\");\n    }\n}\n```\n\n```java\nclass Init4 {\n    public static void main(String[] args) {\n        new SubClass();\n    }\n}\n```\n##### 运行结果：\n```\nSuperClass init ...\nSubClass init ...\n```\n\n#### 当虚拟机启动时，用户需要指定一个执行的主类，虚拟机会首先初始化这个主类\n```java\npublic class MainClass {\n\n    static {\n        System.out.println(\"MainClass init ...\");\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"main begin ...\");\n    }\n}\n```\n##### 运行结果：\n```\nMainClass init ...\nmain begin ...\n```\n\n### 被动引用\n##### 主动引用之外的引用情况都称之为被动引用，这些引用不会进行初始化。\n#### 通过子类引用父类的静态字段，不会导致子类初始化\n```java\npublic class SuperClass {\n    static {\n        System.out.println(\"SuperClass init ...\");\n    }\n    public static int value = 10;\n}\n```\n\n```java\nclass SubClass extends SuperClass {\n    static {\n        System.out.println(\"SubClass init ...\");\n    }\n\n}\n```\n\n```java\nclass Init4 {\n    public static void main(String[] args) {\n        int value = SubClass.value;\n    }\n}\n```\n##### 运行结果：\n```\nSuperClass init ...\n```\n\n#### 通过数组定义来引用，不会触发此类的初始化\n```java\npublic class ArrayClass {\n\n    static {\n        System.out.println(\"ArrayClass init ...\");\n    }\n}\n```\n\n```java\nclass Init5{\n    public static void main(String[] args) {\n        ArrayClass[] arrays = new  ArrayClass[10];\n    }\n}\n```\n##### 运行结果为空\n\n#### 常量在编译阶段会存入调用类的常量池中，本质没有直接引用到定义的常量类中，因此不会触发定义的常量类初始化\n```java\npublic class ConstClass {\n    static {\n        System.out.println(\"ConstClass init ...\");\n    }\n\n    public static final int value = 10;\n}\n```\n\n```java\nclass Init6{\n    public static void main(String[] args) {\n        int value = ConstClass.value;\n    }\n}\n```\n##### 运行结果为空\n\n### 2.3练习题\n如下类的输出：\n```java\npublic class Singleton {\n\n    private static Singleton instance = new Singleton();\n\n    public static int x = 0;\n    public static int y;\n\n    private Singleton () {\n        x ++;\n        y ++;\n    }\n\n    public static Singleton getInstance() {\n        return instance;\n    }\n\n    public static void main(String[] args) {\n        Singleton singleton = getInstance();\n        System.out.println(x);\n        System.out.println(y);\n    }\n }\n```\n##### 运行结果:\n```\n0\n1\n```\n\n##### 输出结果竟然是 x为0 y为1 !!!\n##### 其实理解了类的加载过程也就不难理解，其过程如下：\n\n1. 执行链接过程，初始化所有的类变量：\ninstance -> null\nx -> 0\ny -> 0\n2. 执行初始化过程：\nnew Singleton() 调用构造方法\n之后 x -> 1 y -> 1\n再执行 x = 0 赋值\n最终\nx -> 0\ny -> 1","source":"_posts/note/jdk/javaClassLoading.md","raw":"---\nlayout: post\ntitle: java类加载过程\ndate: 2017/12/26\ntags: [tech, index]\ntag: [[java, java]]\n---\n\n# java类加载过程\n##### 类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载，验证，准备，解析，初始化，使用和卸载七个阶段。其中验证，准备和解析三个部分统称为连接，这七个阶段的发生顺序如图所示：\n<!--more-->\n\n![java类加载搓成](/img/note/javaClassLoading.png) <div class='img-note'>JAVA类加载过程</div>\n\n### 加载\n##### 加载既是将class文件字节码加载到内存中，并将这些静态数据转换为jvm方法区运行时数据结构。在堆中生成一个代表这个类的java.lang.Class对象，作为方法区访问对象的入口。\n### 链接\n##### 将已读入内存的二进制数据合并到JVM运行状态中去的过程。包含验证、准备、解析等过程。\n#### 验证:\n1. 类文件结构检查：确保加载的类信息符合JVM规范，遵从类文件结构的固定格式。\n2. 元数据验证：确保类本身符合Java语言的语法规定，比如验证final类型的类没有子类，以及final类型的方法没有被覆盖。注意，语义检查的错误在编译器编译阶段就会通不过，但是如果有程序员通过非编译的手段生成了类文件，其中有可能会含有语义错误，此时的语义检查主要是防止这种没有编译而生成的class文件引入的错误。\n3. 字节码验证：确保字节码流可以被Java虚拟机安全地执行。字节码流代表Java方法(包括静态方法和实例方法)，它是由被称作操作码的单字节指令组成的序列，每一个操作码后都跟着一个或多个操作数。字节码验证步骤会检查每个操作码是否合法，即是否有着合法的操作数。\n4. 二进制兼容性验证：确保相互引用的类之间的协调一致。例如，在Worker类的gotoWork()方法中会调用Car类的run()方法，Java虚拟机在验证Worker类时，会检查在方法区内是否存在Car类的run()方法，假如不存在(当Worker类和Car类的版本不兼容就会出现这种问题)，就会抛出NoSuchMethodError错误。\n\n#### 准备:\n1. 正式为类变量分配内存，并设置类变量初始值的阶段。这些内存都将在方法区分配。这个时候进行内存分配的仅包括类变量（static变量），而不包括实例变量。实例变量将会在对象实例化时随着对象一起分配在java堆中\n2. 这里所说的初始值\"通常情况下\"是数据类型的零值，假设一个类型变量定义为：`public static int value = 123;`，那么变量value在准备过后的初始值为0而不是123。而把value赋值为123的动作存放于类构造器&lt;clinit&gt;中，该方法将在初始化阶段才会执行。\n3. 上面所说的是通常情况，会有一些\"特殊情况下\"：如果类字段的字段属性表中存在ConstantValues属性，那么准备阶段value就会被初始化为ConstantValues。例如：`public static final int value = 123;`\n\n#### 解析：\n1. 虚拟机常量池内的符号引用替换为直接引用的过程。\n2. 例如在Worker类的gotoWork()方法中会引用Car类的run()方法。\n```java\npublic void gotoWork() {\n    car.run();// 这段代码在Worker类的二进制数据中表示为符号引用\n}\n```\n3. 在Worker类的二进制数据中，包含了一个对Car类的run()方法的符号引用，它由run()方法的全名和相关描述符组成。\n4. 在解析阶段，Java虚拟机会把这个符号引用替换为一个指针，该指针指向Car类的run()方法在方法区内的内存位置，这个指针就是直接引用。\n\n### 初始化\n##### 类初始化是类加载过程的最后一步，前面的类加载过程，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码。初始化是执行类的构造器&lt;clinit&gt;()方法的过程。\n##### 类构造器&lt;clinit&gt;()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static块）中的语句合并产生的。\n##### 当初始化一个类的时候，如果发现其父类还没有进行过初始化、则需要先触发其父类的初始化。\n##### 虚拟机会保证一个类的&lt;clinit&gt;()方法在多线程环境中被正确加锁和同步。\n##### 当访问一个java类的静态域时，只有真正声明这个域的类才会被初始化。\n\n#### 说明 &lt;clinit&gt; 与&lt;init&gt;方法\n##### 可能出现在class文件中的两种编译器产生的方法是：实例初始化方法(名为&lt;init&gt;)和类与接口初始化方法(名为&lt;clinit&gt;)。\n##### 这两个方法一个是虚拟机在装载一个类初始化的时候调用的（clinit）。另一个是在类实例化时调用的（init）\n##### &lt;clinit&gt;方法：所有的类变量初始化语句和类型的静态初始化语句都被Java编译器收集到了一起，放在一个特殊的方法中。这个方法就是&lt;clinit&gt;\n##### &lt;init&gt;方法：是在一个类进行对象实例化时调用的。实例化一个类有四种途径：调用new操作符；调用Class或java.lang.reflect.Constructor对象的newInstance()方法；调用任何现有对象的clone()方法；通过java.io.ObjectInputStream类的getObject()方法反序列化。Java编译器会为它的每一个类都至少生成一个实例初始化方法。在Class文件中,被称为\"&lt;init&gt;\"\n##### 区别：一个是用于初始化静态的类变量， 一个是初始化实例变量!\n\n### 使用\n##### 使用既是所需要的对象开始被调用。\n\n### 卸载\n##### 对象被jvm回收。\n\n#### 示例\n\n```java\npublic class InitDemo {\n\n    static {\n        System.out.println(\"InitDemo static init ...\");\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"InitDemo main begin\");\n        InitA a = new InitA();\n        System.out.println(InitA.width);\n        InitA b = new InitA();\n\n    }\n}\n```\n\n```java\nclass InitBase{\n\n    static {\n        System.out.println(\"InitBase static init ...\");\n    }\n}\n```\n\n```java\nclass InitA extends InitBase {\n\n    public static int width = 60;\n\n    static {\n        System.out.println(\"InitA static init ...\");\n        width = 30;\n    }\n\n    public InitA() {\n        System.out.println(\" InitA init ... \");\n    }\n}\n```\n\n##### 运行结果：\n\n```\nInitDemo static init ...\nInitDemo main begin\nInitBase static init ...\nInitA static init ...\n InitA init ...\n30\n InitA init ...\n```\n\n##### 可以看到，在执行结果中，先运行main方法所在类的初始化方法，之后运行main函数。然后运行父类InitBase的初始化方法。之后运行InitA的静态初始化。以及InitA的构造函数。此后虽然new了多个InitA，但是其静态的初始化方法&lt;clinit&gt;只运行了一次。\n\n# 被动引用和主动引用\n##### 在java虚拟机规范中，严格规定了，只有对类进行主动引用，才会触发其初始化方法。而除此之外的引用方式称之为被动引用，不会触发类的初始化方法。\n### 主动引用\n##### 虚拟机规范规定只有如下四种情况才能触发主动引用：\n#### 遇到new、getstatic、setstatic、invokestatic 4条指令时，如果类没有初始化，则需要触发其初始化（final修饰的常量除外）。\n#### (1).使用new关键字实例化对象\n\n```java\npublic class NewClass {\n\n    static {\n        System.out.println(\"NewClass init ...\");\n    }\n\n}\n```\n\n```java\nclass Init1{\n    public static void main(String[] args) {\n        new NewClass();\n    }\n}\n```\n\n##### 运行结果：\n```\nNewClass init ...\n```\n\n#### (2).读取类的静态成员变量\n\n```java\npublic class StaticAttributeClass {\n\n    public static int value = 10;\n\n    public static void staticMethod() {\n\n    }\n\n    static {\n        System.out.println(\"StaticAttributeClass init ...\");\n    }\n}\n```\n\n```java\nclass Init2{\n    public static void main(String[] args) {\n        //1.读取静态变量\n        int value = StaticAttributeClass.value;\n    }\n}\n```\n##### 运行结果：\n```\nStaticAttributeClass init ...\n```\n\n#### (3).设置类的静态成员变量\n```java\nclass Init2{\n    public static void main(String[] args) {\n        StaticAttributeClass.value = 5\n    }\n}\n```\n##### 运行结果：\n```\nStaticAttributeClass init ...\n```\n\n#### (4).调用静态方法\n```java\nclass Init2{\n    public static void main(String[] args) {\n        StaticAttributeClass.staticMethod();\n    }\n}\n\n```\n##### 运行结果：\n```\nStaticAttributeClass init ...\n```\n\n#### 使用java.lang.reflenct包的方法对类进行放射调用，如果没有进行初始化，则需要触发其初始化。\n```java\npublic class ReflectClass {\n\n    static {\n        System.out.println(\"ReflectClass init ...\");\n    }\n}\n```\n\n```java\nclass Init3{\n    public static void main(String[] args) {\n        try {\n            Class clazz = Class.forName(\"com.dhb.classload.ReflectClass\");\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n##### 运行结果：\n```\nReflectClass init ..\n```\n\n#### 当一个类初始化的时候，如果其父类还没有初始化，则需要先对其父类进行初始化。\n```java\npublic class SuperClass {\n    static {\n        System.out.println(\"SuperClass init ...\");\n    }\n    public static int value = 10;\n}\n```\n\n```java\nclass SubClass extends SuperClass {\n    static {\n        System.out.println(\"SubClass init ...\");\n    }\n}\n```\n\n```java\nclass Init4 {\n    public static void main(String[] args) {\n        new SubClass();\n    }\n}\n```\n##### 运行结果：\n```\nSuperClass init ...\nSubClass init ...\n```\n\n#### 当虚拟机启动时，用户需要指定一个执行的主类，虚拟机会首先初始化这个主类\n```java\npublic class MainClass {\n\n    static {\n        System.out.println(\"MainClass init ...\");\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"main begin ...\");\n    }\n}\n```\n##### 运行结果：\n```\nMainClass init ...\nmain begin ...\n```\n\n### 被动引用\n##### 主动引用之外的引用情况都称之为被动引用，这些引用不会进行初始化。\n#### 通过子类引用父类的静态字段，不会导致子类初始化\n```java\npublic class SuperClass {\n    static {\n        System.out.println(\"SuperClass init ...\");\n    }\n    public static int value = 10;\n}\n```\n\n```java\nclass SubClass extends SuperClass {\n    static {\n        System.out.println(\"SubClass init ...\");\n    }\n\n}\n```\n\n```java\nclass Init4 {\n    public static void main(String[] args) {\n        int value = SubClass.value;\n    }\n}\n```\n##### 运行结果：\n```\nSuperClass init ...\n```\n\n#### 通过数组定义来引用，不会触发此类的初始化\n```java\npublic class ArrayClass {\n\n    static {\n        System.out.println(\"ArrayClass init ...\");\n    }\n}\n```\n\n```java\nclass Init5{\n    public static void main(String[] args) {\n        ArrayClass[] arrays = new  ArrayClass[10];\n    }\n}\n```\n##### 运行结果为空\n\n#### 常量在编译阶段会存入调用类的常量池中，本质没有直接引用到定义的常量类中，因此不会触发定义的常量类初始化\n```java\npublic class ConstClass {\n    static {\n        System.out.println(\"ConstClass init ...\");\n    }\n\n    public static final int value = 10;\n}\n```\n\n```java\nclass Init6{\n    public static void main(String[] args) {\n        int value = ConstClass.value;\n    }\n}\n```\n##### 运行结果为空\n\n### 2.3练习题\n如下类的输出：\n```java\npublic class Singleton {\n\n    private static Singleton instance = new Singleton();\n\n    public static int x = 0;\n    public static int y;\n\n    private Singleton () {\n        x ++;\n        y ++;\n    }\n\n    public static Singleton getInstance() {\n        return instance;\n    }\n\n    public static void main(String[] args) {\n        Singleton singleton = getInstance();\n        System.out.println(x);\n        System.out.println(y);\n    }\n }\n```\n##### 运行结果:\n```\n0\n1\n```\n\n##### 输出结果竟然是 x为0 y为1 !!!\n##### 其实理解了类的加载过程也就不难理解，其过程如下：\n\n1. 执行链接过程，初始化所有的类变量：\ninstance -> null\nx -> 0\ny -> 0\n2. 执行初始化过程：\nnew Singleton() 调用构造方法\n之后 x -> 1 y -> 1\n再执行 x = 0 赋值\n最终\nx -> 0\ny -> 1","slug":"note/jdk/javaClassLoading","published":1,"updated":"2018-05-08T13:00:14.279Z","comments":1,"photos":[],"link":"","_id":"cjgxop3nj003ijah1b77wsana","content":"<h1 id=\"java类加载过程\"><a href=\"#java类加载过程\" class=\"headerlink\" title=\"java类加载过程\"></a>java类加载过程</h1><h5 id=\"类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载，验证，准备，解析，初始化，使用和卸载七个阶段。其中验证，准备和解析三个部分统称为连接，这七个阶段的发生顺序如图所示：\"><a href=\"#类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载，验证，准备，解析，初始化，使用和卸载七个阶段。其中验证，准备和解析三个部分统称为连接，这七个阶段的发生顺序如图所示：\" class=\"headerlink\" title=\"类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载，验证，准备，解析，初始化，使用和卸载七个阶段。其中验证，准备和解析三个部分统称为连接，这七个阶段的发生顺序如图所示：\"></a>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载，验证，准备，解析，初始化，使用和卸载七个阶段。其中验证，准备和解析三个部分统称为连接，这七个阶段的发生顺序如图所示：</h5><a id=\"more\"></a>\n<p><img src=\"/img/note/javaClassLoading.png\" alt=\"java类加载搓成\"> <div class=\"img-note\">JAVA类加载过程</div></p>\n<h3 id=\"加载\"><a href=\"#加载\" class=\"headerlink\" title=\"加载\"></a>加载</h3><h5 id=\"加载既是将class文件字节码加载到内存中，并将这些静态数据转换为jvm方法区运行时数据结构。在堆中生成一个代表这个类的java-lang-Class对象，作为方法区访问对象的入口。\"><a href=\"#加载既是将class文件字节码加载到内存中，并将这些静态数据转换为jvm方法区运行时数据结构。在堆中生成一个代表这个类的java-lang-Class对象，作为方法区访问对象的入口。\" class=\"headerlink\" title=\"加载既是将class文件字节码加载到内存中，并将这些静态数据转换为jvm方法区运行时数据结构。在堆中生成一个代表这个类的java.lang.Class对象，作为方法区访问对象的入口。\"></a>加载既是将class文件字节码加载到内存中，并将这些静态数据转换为jvm方法区运行时数据结构。在堆中生成一个代表这个类的java.lang.Class对象，作为方法区访问对象的入口。</h5><h3 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h3><h5 id=\"将已读入内存的二进制数据合并到JVM运行状态中去的过程。包含验证、准备、解析等过程。\"><a href=\"#将已读入内存的二进制数据合并到JVM运行状态中去的过程。包含验证、准备、解析等过程。\" class=\"headerlink\" title=\"将已读入内存的二进制数据合并到JVM运行状态中去的过程。包含验证、准备、解析等过程。\"></a>将已读入内存的二进制数据合并到JVM运行状态中去的过程。包含验证、准备、解析等过程。</h5><h4 id=\"验证\"><a href=\"#验证\" class=\"headerlink\" title=\"验证:\"></a>验证:</h4><ol>\n<li>类文件结构检查：确保加载的类信息符合JVM规范，遵从类文件结构的固定格式。</li>\n<li>元数据验证：确保类本身符合Java语言的语法规定，比如验证final类型的类没有子类，以及final类型的方法没有被覆盖。注意，语义检查的错误在编译器编译阶段就会通不过，但是如果有程序员通过非编译的手段生成了类文件，其中有可能会含有语义错误，此时的语义检查主要是防止这种没有编译而生成的class文件引入的错误。</li>\n<li>字节码验证：确保字节码流可以被Java虚拟机安全地执行。字节码流代表Java方法(包括静态方法和实例方法)，它是由被称作操作码的单字节指令组成的序列，每一个操作码后都跟着一个或多个操作数。字节码验证步骤会检查每个操作码是否合法，即是否有着合法的操作数。</li>\n<li>二进制兼容性验证：确保相互引用的类之间的协调一致。例如，在Worker类的gotoWork()方法中会调用Car类的run()方法，Java虚拟机在验证Worker类时，会检查在方法区内是否存在Car类的run()方法，假如不存在(当Worker类和Car类的版本不兼容就会出现这种问题)，就会抛出NoSuchMethodError错误。</li>\n</ol>\n<h4 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备:\"></a>准备:</h4><ol>\n<li>正式为类变量分配内存，并设置类变量初始值的阶段。这些内存都将在方法区分配。这个时候进行内存分配的仅包括类变量（static变量），而不包括实例变量。实例变量将会在对象实例化时随着对象一起分配在java堆中</li>\n<li>这里所说的初始值”通常情况下”是数据类型的零值，假设一个类型变量定义为：<code>public static int value = 123;</code>，那么变量value在准备过后的初始值为0而不是123。而把value赋值为123的动作存放于类构造器&lt;clinit&gt;中，该方法将在初始化阶段才会执行。</li>\n<li>上面所说的是通常情况，会有一些”特殊情况下”：如果类字段的字段属性表中存在ConstantValues属性，那么准备阶段value就会被初始化为ConstantValues。例如：<code>public static final int value = 123;</code></li>\n</ol>\n<h4 id=\"解析：\"><a href=\"#解析：\" class=\"headerlink\" title=\"解析：\"></a>解析：</h4><ol>\n<li>虚拟机常量池内的符号引用替换为直接引用的过程。</li>\n<li>例如在Worker类的gotoWork()方法中会引用Car类的run()方法。<pre><code class=\"lang-java\">public void gotoWork() {\n car.run();// 这段代码在Worker类的二进制数据中表示为符号引用\n}\n</code></pre>\n</li>\n<li>在Worker类的二进制数据中，包含了一个对Car类的run()方法的符号引用，它由run()方法的全名和相关描述符组成。</li>\n<li>在解析阶段，Java虚拟机会把这个符号引用替换为一个指针，该指针指向Car类的run()方法在方法区内的内存位置，这个指针就是直接引用。</li>\n</ol>\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><h5 id=\"类初始化是类加载过程的最后一步，前面的类加载过程，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码。初始化是执行类的构造器-lt-clinit-gt-方法的过程。\"><a href=\"#类初始化是类加载过程的最后一步，前面的类加载过程，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码。初始化是执行类的构造器-lt-clinit-gt-方法的过程。\" class=\"headerlink\" title=\"类初始化是类加载过程的最后一步，前面的类加载过程，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码。初始化是执行类的构造器&lt;clinit&gt;()方法的过程。\"></a>类初始化是类加载过程的最后一步，前面的类加载过程，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码。初始化是执行类的构造器&lt;clinit&gt;()方法的过程。</h5><h5 id=\"类构造器-lt-clinit-gt-方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static块）中的语句合并产生的。\"><a href=\"#类构造器-lt-clinit-gt-方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static块）中的语句合并产生的。\" class=\"headerlink\" title=\"类构造器&lt;clinit&gt;()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static块）中的语句合并产生的。\"></a>类构造器&lt;clinit&gt;()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static块）中的语句合并产生的。</h5><h5 id=\"当初始化一个类的时候，如果发现其父类还没有进行过初始化、则需要先触发其父类的初始化。\"><a href=\"#当初始化一个类的时候，如果发现其父类还没有进行过初始化、则需要先触发其父类的初始化。\" class=\"headerlink\" title=\"当初始化一个类的时候，如果发现其父类还没有进行过初始化、则需要先触发其父类的初始化。\"></a>当初始化一个类的时候，如果发现其父类还没有进行过初始化、则需要先触发其父类的初始化。</h5><h5 id=\"虚拟机会保证一个类的-lt-clinit-gt-方法在多线程环境中被正确加锁和同步。\"><a href=\"#虚拟机会保证一个类的-lt-clinit-gt-方法在多线程环境中被正确加锁和同步。\" class=\"headerlink\" title=\"虚拟机会保证一个类的&lt;clinit&gt;()方法在多线程环境中被正确加锁和同步。\"></a>虚拟机会保证一个类的&lt;clinit&gt;()方法在多线程环境中被正确加锁和同步。</h5><h5 id=\"当访问一个java类的静态域时，只有真正声明这个域的类才会被初始化。\"><a href=\"#当访问一个java类的静态域时，只有真正声明这个域的类才会被初始化。\" class=\"headerlink\" title=\"当访问一个java类的静态域时，只有真正声明这个域的类才会被初始化。\"></a>当访问一个java类的静态域时，只有真正声明这个域的类才会被初始化。</h5><h4 id=\"说明-lt-clinit-gt-与-lt-init-gt-方法\"><a href=\"#说明-lt-clinit-gt-与-lt-init-gt-方法\" class=\"headerlink\" title=\"说明 &lt;clinit&gt; 与&lt;init&gt;方法\"></a>说明 &lt;clinit&gt; 与&lt;init&gt;方法</h4><h5 id=\"可能出现在class文件中的两种编译器产生的方法是：实例初始化方法-名为-lt-init-gt-和类与接口初始化方法-名为-lt-clinit-gt-。\"><a href=\"#可能出现在class文件中的两种编译器产生的方法是：实例初始化方法-名为-lt-init-gt-和类与接口初始化方法-名为-lt-clinit-gt-。\" class=\"headerlink\" title=\"可能出现在class文件中的两种编译器产生的方法是：实例初始化方法(名为&lt;init&gt;)和类与接口初始化方法(名为&lt;clinit&gt;)。\"></a>可能出现在class文件中的两种编译器产生的方法是：实例初始化方法(名为&lt;init&gt;)和类与接口初始化方法(名为&lt;clinit&gt;)。</h5><h5 id=\"这两个方法一个是虚拟机在装载一个类初始化的时候调用的（clinit）。另一个是在类实例化时调用的（init）\"><a href=\"#这两个方法一个是虚拟机在装载一个类初始化的时候调用的（clinit）。另一个是在类实例化时调用的（init）\" class=\"headerlink\" title=\"这两个方法一个是虚拟机在装载一个类初始化的时候调用的（clinit）。另一个是在类实例化时调用的（init）\"></a>这两个方法一个是虚拟机在装载一个类初始化的时候调用的（clinit）。另一个是在类实例化时调用的（init）</h5><h5 id=\"lt-clinit-gt-方法：所有的类变量初始化语句和类型的静态初始化语句都被Java编译器收集到了一起，放在一个特殊的方法中。这个方法就是-lt-clinit-gt\"><a href=\"#lt-clinit-gt-方法：所有的类变量初始化语句和类型的静态初始化语句都被Java编译器收集到了一起，放在一个特殊的方法中。这个方法就是-lt-clinit-gt\" class=\"headerlink\" title=\"&lt;clinit&gt;方法：所有的类变量初始化语句和类型的静态初始化语句都被Java编译器收集到了一起，放在一个特殊的方法中。这个方法就是&lt;clinit&gt;\"></a>&lt;clinit&gt;方法：所有的类变量初始化语句和类型的静态初始化语句都被Java编译器收集到了一起，放在一个特殊的方法中。这个方法就是&lt;clinit&gt;</h5><h5 id=\"lt-init-gt-方法：是在一个类进行对象实例化时调用的。实例化一个类有四种途径：调用new操作符；调用Class或java-lang-reflect-Constructor对象的newInstance-方法；调用任何现有对象的clone-方法；通过java-io-ObjectInputStream类的getObject-方法反序列化。Java编译器会为它的每一个类都至少生成一个实例初始化方法。在Class文件中-被称为”-lt-init-gt-”\"><a href=\"#lt-init-gt-方法：是在一个类进行对象实例化时调用的。实例化一个类有四种途径：调用new操作符；调用Class或java-lang-reflect-Constructor对象的newInstance-方法；调用任何现有对象的clone-方法；通过java-io-ObjectInputStream类的getObject-方法反序列化。Java编译器会为它的每一个类都至少生成一个实例初始化方法。在Class文件中-被称为”-lt-init-gt-”\" class=\"headerlink\" title=\"&lt;init&gt;方法：是在一个类进行对象实例化时调用的。实例化一个类有四种途径：调用new操作符；调用Class或java.lang.reflect.Constructor对象的newInstance()方法；调用任何现有对象的clone()方法；通过java.io.ObjectInputStream类的getObject()方法反序列化。Java编译器会为它的每一个类都至少生成一个实例初始化方法。在Class文件中,被称为”&lt;init&gt;”\"></a>&lt;init&gt;方法：是在一个类进行对象实例化时调用的。实例化一个类有四种途径：调用new操作符；调用Class或java.lang.reflect.Constructor对象的newInstance()方法；调用任何现有对象的clone()方法；通过java.io.ObjectInputStream类的getObject()方法反序列化。Java编译器会为它的每一个类都至少生成一个实例初始化方法。在Class文件中,被称为”&lt;init&gt;”</h5><h5 id=\"区别：一个是用于初始化静态的类变量，-一个是初始化实例变量\"><a href=\"#区别：一个是用于初始化静态的类变量，-一个是初始化实例变量\" class=\"headerlink\" title=\"区别：一个是用于初始化静态的类变量， 一个是初始化实例变量!\"></a>区别：一个是用于初始化静态的类变量， 一个是初始化实例变量!</h5><h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><h5 id=\"使用既是所需要的对象开始被调用。\"><a href=\"#使用既是所需要的对象开始被调用。\" class=\"headerlink\" title=\"使用既是所需要的对象开始被调用。\"></a>使用既是所需要的对象开始被调用。</h5><h3 id=\"卸载\"><a href=\"#卸载\" class=\"headerlink\" title=\"卸载\"></a>卸载</h3><h5 id=\"对象被jvm回收。\"><a href=\"#对象被jvm回收。\" class=\"headerlink\" title=\"对象被jvm回收。\"></a>对象被jvm回收。</h5><h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><pre><code class=\"lang-java\">public class InitDemo {\n\n    static {\n        System.out.println(&quot;InitDemo static init ...&quot;);\n    }\n\n    public static void main(String[] args) {\n        System.out.println(&quot;InitDemo main begin&quot;);\n        InitA a = new InitA();\n        System.out.println(InitA.width);\n        InitA b = new InitA();\n\n    }\n}\n</code></pre>\n<pre><code class=\"lang-java\">class InitBase{\n\n    static {\n        System.out.println(&quot;InitBase static init ...&quot;);\n    }\n}\n</code></pre>\n<pre><code class=\"lang-java\">class InitA extends InitBase {\n\n    public static int width = 60;\n\n    static {\n        System.out.println(&quot;InitA static init ...&quot;);\n        width = 30;\n    }\n\n    public InitA() {\n        System.out.println(&quot; InitA init ... &quot;);\n    }\n}\n</code></pre>\n<h5 id=\"运行结果：\"><a href=\"#运行结果：\" class=\"headerlink\" title=\"运行结果：\"></a>运行结果：</h5><pre><code>InitDemo static init ...\nInitDemo main begin\nInitBase static init ...\nInitA static init ...\n InitA init ...\n30\n InitA init ...\n</code></pre><h5 id=\"可以看到，在执行结果中，先运行main方法所在类的初始化方法，之后运行main函数。然后运行父类InitBase的初始化方法。之后运行InitA的静态初始化。以及InitA的构造函数。此后虽然new了多个InitA，但是其静态的初始化方法-lt-clinit-gt-只运行了一次。\"><a href=\"#可以看到，在执行结果中，先运行main方法所在类的初始化方法，之后运行main函数。然后运行父类InitBase的初始化方法。之后运行InitA的静态初始化。以及InitA的构造函数。此后虽然new了多个InitA，但是其静态的初始化方法-lt-clinit-gt-只运行了一次。\" class=\"headerlink\" title=\"可以看到，在执行结果中，先运行main方法所在类的初始化方法，之后运行main函数。然后运行父类InitBase的初始化方法。之后运行InitA的静态初始化。以及InitA的构造函数。此后虽然new了多个InitA，但是其静态的初始化方法&lt;clinit&gt;只运行了一次。\"></a>可以看到，在执行结果中，先运行main方法所在类的初始化方法，之后运行main函数。然后运行父类InitBase的初始化方法。之后运行InitA的静态初始化。以及InitA的构造函数。此后虽然new了多个InitA，但是其静态的初始化方法&lt;clinit&gt;只运行了一次。</h5><h1 id=\"被动引用和主动引用\"><a href=\"#被动引用和主动引用\" class=\"headerlink\" title=\"被动引用和主动引用\"></a>被动引用和主动引用</h1><h5 id=\"在java虚拟机规范中，严格规定了，只有对类进行主动引用，才会触发其初始化方法。而除此之外的引用方式称之为被动引用，不会触发类的初始化方法。\"><a href=\"#在java虚拟机规范中，严格规定了，只有对类进行主动引用，才会触发其初始化方法。而除此之外的引用方式称之为被动引用，不会触发类的初始化方法。\" class=\"headerlink\" title=\"在java虚拟机规范中，严格规定了，只有对类进行主动引用，才会触发其初始化方法。而除此之外的引用方式称之为被动引用，不会触发类的初始化方法。\"></a>在java虚拟机规范中，严格规定了，只有对类进行主动引用，才会触发其初始化方法。而除此之外的引用方式称之为被动引用，不会触发类的初始化方法。</h5><h3 id=\"主动引用\"><a href=\"#主动引用\" class=\"headerlink\" title=\"主动引用\"></a>主动引用</h3><h5 id=\"虚拟机规范规定只有如下四种情况才能触发主动引用：\"><a href=\"#虚拟机规范规定只有如下四种情况才能触发主动引用：\" class=\"headerlink\" title=\"虚拟机规范规定只有如下四种情况才能触发主动引用：\"></a>虚拟机规范规定只有如下四种情况才能触发主动引用：</h5><h4 id=\"遇到new、getstatic、setstatic、invokestatic-4条指令时，如果类没有初始化，则需要触发其初始化（final修饰的常量除外）。\"><a href=\"#遇到new、getstatic、setstatic、invokestatic-4条指令时，如果类没有初始化，则需要触发其初始化（final修饰的常量除外）。\" class=\"headerlink\" title=\"遇到new、getstatic、setstatic、invokestatic 4条指令时，如果类没有初始化，则需要触发其初始化（final修饰的常量除外）。\"></a>遇到new、getstatic、setstatic、invokestatic 4条指令时，如果类没有初始化，则需要触发其初始化（final修饰的常量除外）。</h4><h4 id=\"1-使用new关键字实例化对象\"><a href=\"#1-使用new关键字实例化对象\" class=\"headerlink\" title=\"(1).使用new关键字实例化对象\"></a>(1).使用new关键字实例化对象</h4><pre><code class=\"lang-java\">public class NewClass {\n\n    static {\n        System.out.println(&quot;NewClass init ...&quot;);\n    }\n\n}\n</code></pre>\n<pre><code class=\"lang-java\">class Init1{\n    public static void main(String[] args) {\n        new NewClass();\n    }\n}\n</code></pre>\n<h5 id=\"运行结果：-1\"><a href=\"#运行结果：-1\" class=\"headerlink\" title=\"运行结果：\"></a>运行结果：</h5><pre><code>NewClass init ...\n</code></pre><h4 id=\"2-读取类的静态成员变量\"><a href=\"#2-读取类的静态成员变量\" class=\"headerlink\" title=\"(2).读取类的静态成员变量\"></a>(2).读取类的静态成员变量</h4><pre><code class=\"lang-java\">public class StaticAttributeClass {\n\n    public static int value = 10;\n\n    public static void staticMethod() {\n\n    }\n\n    static {\n        System.out.println(&quot;StaticAttributeClass init ...&quot;);\n    }\n}\n</code></pre>\n<pre><code class=\"lang-java\">class Init2{\n    public static void main(String[] args) {\n        //1.读取静态变量\n        int value = StaticAttributeClass.value;\n    }\n}\n</code></pre>\n<h5 id=\"运行结果：-2\"><a href=\"#运行结果：-2\" class=\"headerlink\" title=\"运行结果：\"></a>运行结果：</h5><pre><code>StaticAttributeClass init ...\n</code></pre><h4 id=\"3-设置类的静态成员变量\"><a href=\"#3-设置类的静态成员变量\" class=\"headerlink\" title=\"(3).设置类的静态成员变量\"></a>(3).设置类的静态成员变量</h4><pre><code class=\"lang-java\">class Init2{\n    public static void main(String[] args) {\n        StaticAttributeClass.value = 5\n    }\n}\n</code></pre>\n<h5 id=\"运行结果：-3\"><a href=\"#运行结果：-3\" class=\"headerlink\" title=\"运行结果：\"></a>运行结果：</h5><pre><code>StaticAttributeClass init ...\n</code></pre><h4 id=\"4-调用静态方法\"><a href=\"#4-调用静态方法\" class=\"headerlink\" title=\"(4).调用静态方法\"></a>(4).调用静态方法</h4><pre><code class=\"lang-java\">class Init2{\n    public static void main(String[] args) {\n        StaticAttributeClass.staticMethod();\n    }\n}\n</code></pre>\n<h5 id=\"运行结果：-4\"><a href=\"#运行结果：-4\" class=\"headerlink\" title=\"运行结果：\"></a>运行结果：</h5><pre><code>StaticAttributeClass init ...\n</code></pre><h4 id=\"使用java-lang-reflenct包的方法对类进行放射调用，如果没有进行初始化，则需要触发其初始化。\"><a href=\"#使用java-lang-reflenct包的方法对类进行放射调用，如果没有进行初始化，则需要触发其初始化。\" class=\"headerlink\" title=\"使用java.lang.reflenct包的方法对类进行放射调用，如果没有进行初始化，则需要触发其初始化。\"></a>使用java.lang.reflenct包的方法对类进行放射调用，如果没有进行初始化，则需要触发其初始化。</h4><pre><code class=\"lang-java\">public class ReflectClass {\n\n    static {\n        System.out.println(&quot;ReflectClass init ...&quot;);\n    }\n}\n</code></pre>\n<pre><code class=\"lang-java\">class Init3{\n    public static void main(String[] args) {\n        try {\n            Class clazz = Class.forName(&quot;com.dhb.classload.ReflectClass&quot;);\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre>\n<h5 id=\"运行结果：-5\"><a href=\"#运行结果：-5\" class=\"headerlink\" title=\"运行结果：\"></a>运行结果：</h5><pre><code>ReflectClass init ..\n</code></pre><h4 id=\"当一个类初始化的时候，如果其父类还没有初始化，则需要先对其父类进行初始化。\"><a href=\"#当一个类初始化的时候，如果其父类还没有初始化，则需要先对其父类进行初始化。\" class=\"headerlink\" title=\"当一个类初始化的时候，如果其父类还没有初始化，则需要先对其父类进行初始化。\"></a>当一个类初始化的时候，如果其父类还没有初始化，则需要先对其父类进行初始化。</h4><pre><code class=\"lang-java\">public class SuperClass {\n    static {\n        System.out.println(&quot;SuperClass init ...&quot;);\n    }\n    public static int value = 10;\n}\n</code></pre>\n<pre><code class=\"lang-java\">class SubClass extends SuperClass {\n    static {\n        System.out.println(&quot;SubClass init ...&quot;);\n    }\n}\n</code></pre>\n<pre><code class=\"lang-java\">class Init4 {\n    public static void main(String[] args) {\n        new SubClass();\n    }\n}\n</code></pre>\n<h5 id=\"运行结果：-6\"><a href=\"#运行结果：-6\" class=\"headerlink\" title=\"运行结果：\"></a>运行结果：</h5><pre><code>SuperClass init ...\nSubClass init ...\n</code></pre><h4 id=\"当虚拟机启动时，用户需要指定一个执行的主类，虚拟机会首先初始化这个主类\"><a href=\"#当虚拟机启动时，用户需要指定一个执行的主类，虚拟机会首先初始化这个主类\" class=\"headerlink\" title=\"当虚拟机启动时，用户需要指定一个执行的主类，虚拟机会首先初始化这个主类\"></a>当虚拟机启动时，用户需要指定一个执行的主类，虚拟机会首先初始化这个主类</h4><pre><code class=\"lang-java\">public class MainClass {\n\n    static {\n        System.out.println(&quot;MainClass init ...&quot;);\n    }\n\n    public static void main(String[] args) {\n        System.out.println(&quot;main begin ...&quot;);\n    }\n}\n</code></pre>\n<h5 id=\"运行结果：-7\"><a href=\"#运行结果：-7\" class=\"headerlink\" title=\"运行结果：\"></a>运行结果：</h5><pre><code>MainClass init ...\nmain begin ...\n</code></pre><h3 id=\"被动引用\"><a href=\"#被动引用\" class=\"headerlink\" title=\"被动引用\"></a>被动引用</h3><h5 id=\"主动引用之外的引用情况都称之为被动引用，这些引用不会进行初始化。\"><a href=\"#主动引用之外的引用情况都称之为被动引用，这些引用不会进行初始化。\" class=\"headerlink\" title=\"主动引用之外的引用情况都称之为被动引用，这些引用不会进行初始化。\"></a>主动引用之外的引用情况都称之为被动引用，这些引用不会进行初始化。</h5><h4 id=\"通过子类引用父类的静态字段，不会导致子类初始化\"><a href=\"#通过子类引用父类的静态字段，不会导致子类初始化\" class=\"headerlink\" title=\"通过子类引用父类的静态字段，不会导致子类初始化\"></a>通过子类引用父类的静态字段，不会导致子类初始化</h4><pre><code class=\"lang-java\">public class SuperClass {\n    static {\n        System.out.println(&quot;SuperClass init ...&quot;);\n    }\n    public static int value = 10;\n}\n</code></pre>\n<pre><code class=\"lang-java\">class SubClass extends SuperClass {\n    static {\n        System.out.println(&quot;SubClass init ...&quot;);\n    }\n\n}\n</code></pre>\n<pre><code class=\"lang-java\">class Init4 {\n    public static void main(String[] args) {\n        int value = SubClass.value;\n    }\n}\n</code></pre>\n<h5 id=\"运行结果：-8\"><a href=\"#运行结果：-8\" class=\"headerlink\" title=\"运行结果：\"></a>运行结果：</h5><pre><code>SuperClass init ...\n</code></pre><h4 id=\"通过数组定义来引用，不会触发此类的初始化\"><a href=\"#通过数组定义来引用，不会触发此类的初始化\" class=\"headerlink\" title=\"通过数组定义来引用，不会触发此类的初始化\"></a>通过数组定义来引用，不会触发此类的初始化</h4><pre><code class=\"lang-java\">public class ArrayClass {\n\n    static {\n        System.out.println(&quot;ArrayClass init ...&quot;);\n    }\n}\n</code></pre>\n<pre><code class=\"lang-java\">class Init5{\n    public static void main(String[] args) {\n        ArrayClass[] arrays = new  ArrayClass[10];\n    }\n}\n</code></pre>\n<h5 id=\"运行结果为空\"><a href=\"#运行结果为空\" class=\"headerlink\" title=\"运行结果为空\"></a>运行结果为空</h5><h4 id=\"常量在编译阶段会存入调用类的常量池中，本质没有直接引用到定义的常量类中，因此不会触发定义的常量类初始化\"><a href=\"#常量在编译阶段会存入调用类的常量池中，本质没有直接引用到定义的常量类中，因此不会触发定义的常量类初始化\" class=\"headerlink\" title=\"常量在编译阶段会存入调用类的常量池中，本质没有直接引用到定义的常量类中，因此不会触发定义的常量类初始化\"></a>常量在编译阶段会存入调用类的常量池中，本质没有直接引用到定义的常量类中，因此不会触发定义的常量类初始化</h4><pre><code class=\"lang-java\">public class ConstClass {\n    static {\n        System.out.println(&quot;ConstClass init ...&quot;);\n    }\n\n    public static final int value = 10;\n}\n</code></pre>\n<pre><code class=\"lang-java\">class Init6{\n    public static void main(String[] args) {\n        int value = ConstClass.value;\n    }\n}\n</code></pre>\n<h5 id=\"运行结果为空-1\"><a href=\"#运行结果为空-1\" class=\"headerlink\" title=\"运行结果为空\"></a>运行结果为空</h5><h3 id=\"2-3练习题\"><a href=\"#2-3练习题\" class=\"headerlink\" title=\"2.3练习题\"></a>2.3练习题</h3><p>如下类的输出：</p>\n<pre><code class=\"lang-java\">public class Singleton {\n\n    private static Singleton instance = new Singleton();\n\n    public static int x = 0;\n    public static int y;\n\n    private Singleton () {\n        x ++;\n        y ++;\n    }\n\n    public static Singleton getInstance() {\n        return instance;\n    }\n\n    public static void main(String[] args) {\n        Singleton singleton = getInstance();\n        System.out.println(x);\n        System.out.println(y);\n    }\n }\n</code></pre>\n<h5 id=\"运行结果\"><a href=\"#运行结果\" class=\"headerlink\" title=\"运行结果:\"></a>运行结果:</h5><pre><code>0\n1\n</code></pre><h5 id=\"输出结果竟然是-x为0-y为1\"><a href=\"#输出结果竟然是-x为0-y为1\" class=\"headerlink\" title=\"输出结果竟然是 x为0 y为1 !!!\"></a>输出结果竟然是 x为0 y为1 !!!</h5><h5 id=\"其实理解了类的加载过程也就不难理解，其过程如下：\"><a href=\"#其实理解了类的加载过程也就不难理解，其过程如下：\" class=\"headerlink\" title=\"其实理解了类的加载过程也就不难理解，其过程如下：\"></a>其实理解了类的加载过程也就不难理解，其过程如下：</h5><ol>\n<li>执行链接过程，初始化所有的类变量：<br>instance -&gt; null<br>x -&gt; 0<br>y -&gt; 0</li>\n<li>执行初始化过程：<br>new Singleton() 调用构造方法<br>之后 x -&gt; 1 y -&gt; 1<br>再执行 x = 0 赋值<br>最终<br>x -&gt; 0<br>y -&gt; 1</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h1 id=\"java类加载过程\"><a href=\"#java类加载过程\" class=\"headerlink\" title=\"java类加载过程\"></a>java类加载过程</h1><h5 id=\"类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载，验证，准备，解析，初始化，使用和卸载七个阶段。其中验证，准备和解析三个部分统称为连接，这七个阶段的发生顺序如图所示：\"><a href=\"#类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载，验证，准备，解析，初始化，使用和卸载七个阶段。其中验证，准备和解析三个部分统称为连接，这七个阶段的发生顺序如图所示：\" class=\"headerlink\" title=\"类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载，验证，准备，解析，初始化，使用和卸载七个阶段。其中验证，准备和解析三个部分统称为连接，这七个阶段的发生顺序如图所示：\"></a>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载，验证，准备，解析，初始化，使用和卸载七个阶段。其中验证，准备和解析三个部分统称为连接，这七个阶段的发生顺序如图所示：</h5>","more":"<p><img src=\"/img/note/javaClassLoading.png\" alt=\"java类加载搓成\"> <div class=\"img-note\">JAVA类加载过程</div></p>\n<h3 id=\"加载\"><a href=\"#加载\" class=\"headerlink\" title=\"加载\"></a>加载</h3><h5 id=\"加载既是将class文件字节码加载到内存中，并将这些静态数据转换为jvm方法区运行时数据结构。在堆中生成一个代表这个类的java-lang-Class对象，作为方法区访问对象的入口。\"><a href=\"#加载既是将class文件字节码加载到内存中，并将这些静态数据转换为jvm方法区运行时数据结构。在堆中生成一个代表这个类的java-lang-Class对象，作为方法区访问对象的入口。\" class=\"headerlink\" title=\"加载既是将class文件字节码加载到内存中，并将这些静态数据转换为jvm方法区运行时数据结构。在堆中生成一个代表这个类的java.lang.Class对象，作为方法区访问对象的入口。\"></a>加载既是将class文件字节码加载到内存中，并将这些静态数据转换为jvm方法区运行时数据结构。在堆中生成一个代表这个类的java.lang.Class对象，作为方法区访问对象的入口。</h5><h3 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h3><h5 id=\"将已读入内存的二进制数据合并到JVM运行状态中去的过程。包含验证、准备、解析等过程。\"><a href=\"#将已读入内存的二进制数据合并到JVM运行状态中去的过程。包含验证、准备、解析等过程。\" class=\"headerlink\" title=\"将已读入内存的二进制数据合并到JVM运行状态中去的过程。包含验证、准备、解析等过程。\"></a>将已读入内存的二进制数据合并到JVM运行状态中去的过程。包含验证、准备、解析等过程。</h5><h4 id=\"验证\"><a href=\"#验证\" class=\"headerlink\" title=\"验证:\"></a>验证:</h4><ol>\n<li>类文件结构检查：确保加载的类信息符合JVM规范，遵从类文件结构的固定格式。</li>\n<li>元数据验证：确保类本身符合Java语言的语法规定，比如验证final类型的类没有子类，以及final类型的方法没有被覆盖。注意，语义检查的错误在编译器编译阶段就会通不过，但是如果有程序员通过非编译的手段生成了类文件，其中有可能会含有语义错误，此时的语义检查主要是防止这种没有编译而生成的class文件引入的错误。</li>\n<li>字节码验证：确保字节码流可以被Java虚拟机安全地执行。字节码流代表Java方法(包括静态方法和实例方法)，它是由被称作操作码的单字节指令组成的序列，每一个操作码后都跟着一个或多个操作数。字节码验证步骤会检查每个操作码是否合法，即是否有着合法的操作数。</li>\n<li>二进制兼容性验证：确保相互引用的类之间的协调一致。例如，在Worker类的gotoWork()方法中会调用Car类的run()方法，Java虚拟机在验证Worker类时，会检查在方法区内是否存在Car类的run()方法，假如不存在(当Worker类和Car类的版本不兼容就会出现这种问题)，就会抛出NoSuchMethodError错误。</li>\n</ol>\n<h4 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备:\"></a>准备:</h4><ol>\n<li>正式为类变量分配内存，并设置类变量初始值的阶段。这些内存都将在方法区分配。这个时候进行内存分配的仅包括类变量（static变量），而不包括实例变量。实例变量将会在对象实例化时随着对象一起分配在java堆中</li>\n<li>这里所说的初始值”通常情况下”是数据类型的零值，假设一个类型变量定义为：<code>public static int value = 123;</code>，那么变量value在准备过后的初始值为0而不是123。而把value赋值为123的动作存放于类构造器&lt;clinit&gt;中，该方法将在初始化阶段才会执行。</li>\n<li>上面所说的是通常情况，会有一些”特殊情况下”：如果类字段的字段属性表中存在ConstantValues属性，那么准备阶段value就会被初始化为ConstantValues。例如：<code>public static final int value = 123;</code></li>\n</ol>\n<h4 id=\"解析：\"><a href=\"#解析：\" class=\"headerlink\" title=\"解析：\"></a>解析：</h4><ol>\n<li>虚拟机常量池内的符号引用替换为直接引用的过程。</li>\n<li>例如在Worker类的gotoWork()方法中会引用Car类的run()方法。<pre><code class=\"lang-java\">public void gotoWork() {\n car.run();// 这段代码在Worker类的二进制数据中表示为符号引用\n}\n</code></pre>\n</li>\n<li>在Worker类的二进制数据中，包含了一个对Car类的run()方法的符号引用，它由run()方法的全名和相关描述符组成。</li>\n<li>在解析阶段，Java虚拟机会把这个符号引用替换为一个指针，该指针指向Car类的run()方法在方法区内的内存位置，这个指针就是直接引用。</li>\n</ol>\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><h5 id=\"类初始化是类加载过程的最后一步，前面的类加载过程，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码。初始化是执行类的构造器-lt-clinit-gt-方法的过程。\"><a href=\"#类初始化是类加载过程的最后一步，前面的类加载过程，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码。初始化是执行类的构造器-lt-clinit-gt-方法的过程。\" class=\"headerlink\" title=\"类初始化是类加载过程的最后一步，前面的类加载过程，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码。初始化是执行类的构造器&lt;clinit&gt;()方法的过程。\"></a>类初始化是类加载过程的最后一步，前面的类加载过程，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码。初始化是执行类的构造器&lt;clinit&gt;()方法的过程。</h5><h5 id=\"类构造器-lt-clinit-gt-方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static块）中的语句合并产生的。\"><a href=\"#类构造器-lt-clinit-gt-方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static块）中的语句合并产生的。\" class=\"headerlink\" title=\"类构造器&lt;clinit&gt;()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static块）中的语句合并产生的。\"></a>类构造器&lt;clinit&gt;()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static块）中的语句合并产生的。</h5><h5 id=\"当初始化一个类的时候，如果发现其父类还没有进行过初始化、则需要先触发其父类的初始化。\"><a href=\"#当初始化一个类的时候，如果发现其父类还没有进行过初始化、则需要先触发其父类的初始化。\" class=\"headerlink\" title=\"当初始化一个类的时候，如果发现其父类还没有进行过初始化、则需要先触发其父类的初始化。\"></a>当初始化一个类的时候，如果发现其父类还没有进行过初始化、则需要先触发其父类的初始化。</h5><h5 id=\"虚拟机会保证一个类的-lt-clinit-gt-方法在多线程环境中被正确加锁和同步。\"><a href=\"#虚拟机会保证一个类的-lt-clinit-gt-方法在多线程环境中被正确加锁和同步。\" class=\"headerlink\" title=\"虚拟机会保证一个类的&lt;clinit&gt;()方法在多线程环境中被正确加锁和同步。\"></a>虚拟机会保证一个类的&lt;clinit&gt;()方法在多线程环境中被正确加锁和同步。</h5><h5 id=\"当访问一个java类的静态域时，只有真正声明这个域的类才会被初始化。\"><a href=\"#当访问一个java类的静态域时，只有真正声明这个域的类才会被初始化。\" class=\"headerlink\" title=\"当访问一个java类的静态域时，只有真正声明这个域的类才会被初始化。\"></a>当访问一个java类的静态域时，只有真正声明这个域的类才会被初始化。</h5><h4 id=\"说明-lt-clinit-gt-与-lt-init-gt-方法\"><a href=\"#说明-lt-clinit-gt-与-lt-init-gt-方法\" class=\"headerlink\" title=\"说明 &lt;clinit&gt; 与&lt;init&gt;方法\"></a>说明 &lt;clinit&gt; 与&lt;init&gt;方法</h4><h5 id=\"可能出现在class文件中的两种编译器产生的方法是：实例初始化方法-名为-lt-init-gt-和类与接口初始化方法-名为-lt-clinit-gt-。\"><a href=\"#可能出现在class文件中的两种编译器产生的方法是：实例初始化方法-名为-lt-init-gt-和类与接口初始化方法-名为-lt-clinit-gt-。\" class=\"headerlink\" title=\"可能出现在class文件中的两种编译器产生的方法是：实例初始化方法(名为&lt;init&gt;)和类与接口初始化方法(名为&lt;clinit&gt;)。\"></a>可能出现在class文件中的两种编译器产生的方法是：实例初始化方法(名为&lt;init&gt;)和类与接口初始化方法(名为&lt;clinit&gt;)。</h5><h5 id=\"这两个方法一个是虚拟机在装载一个类初始化的时候调用的（clinit）。另一个是在类实例化时调用的（init）\"><a href=\"#这两个方法一个是虚拟机在装载一个类初始化的时候调用的（clinit）。另一个是在类实例化时调用的（init）\" class=\"headerlink\" title=\"这两个方法一个是虚拟机在装载一个类初始化的时候调用的（clinit）。另一个是在类实例化时调用的（init）\"></a>这两个方法一个是虚拟机在装载一个类初始化的时候调用的（clinit）。另一个是在类实例化时调用的（init）</h5><h5 id=\"lt-clinit-gt-方法：所有的类变量初始化语句和类型的静态初始化语句都被Java编译器收集到了一起，放在一个特殊的方法中。这个方法就是-lt-clinit-gt\"><a href=\"#lt-clinit-gt-方法：所有的类变量初始化语句和类型的静态初始化语句都被Java编译器收集到了一起，放在一个特殊的方法中。这个方法就是-lt-clinit-gt\" class=\"headerlink\" title=\"&lt;clinit&gt;方法：所有的类变量初始化语句和类型的静态初始化语句都被Java编译器收集到了一起，放在一个特殊的方法中。这个方法就是&lt;clinit&gt;\"></a>&lt;clinit&gt;方法：所有的类变量初始化语句和类型的静态初始化语句都被Java编译器收集到了一起，放在一个特殊的方法中。这个方法就是&lt;clinit&gt;</h5><h5 id=\"lt-init-gt-方法：是在一个类进行对象实例化时调用的。实例化一个类有四种途径：调用new操作符；调用Class或java-lang-reflect-Constructor对象的newInstance-方法；调用任何现有对象的clone-方法；通过java-io-ObjectInputStream类的getObject-方法反序列化。Java编译器会为它的每一个类都至少生成一个实例初始化方法。在Class文件中-被称为”-lt-init-gt-”\"><a href=\"#lt-init-gt-方法：是在一个类进行对象实例化时调用的。实例化一个类有四种途径：调用new操作符；调用Class或java-lang-reflect-Constructor对象的newInstance-方法；调用任何现有对象的clone-方法；通过java-io-ObjectInputStream类的getObject-方法反序列化。Java编译器会为它的每一个类都至少生成一个实例初始化方法。在Class文件中-被称为”-lt-init-gt-”\" class=\"headerlink\" title=\"&lt;init&gt;方法：是在一个类进行对象实例化时调用的。实例化一个类有四种途径：调用new操作符；调用Class或java.lang.reflect.Constructor对象的newInstance()方法；调用任何现有对象的clone()方法；通过java.io.ObjectInputStream类的getObject()方法反序列化。Java编译器会为它的每一个类都至少生成一个实例初始化方法。在Class文件中,被称为”&lt;init&gt;”\"></a>&lt;init&gt;方法：是在一个类进行对象实例化时调用的。实例化一个类有四种途径：调用new操作符；调用Class或java.lang.reflect.Constructor对象的newInstance()方法；调用任何现有对象的clone()方法；通过java.io.ObjectInputStream类的getObject()方法反序列化。Java编译器会为它的每一个类都至少生成一个实例初始化方法。在Class文件中,被称为”&lt;init&gt;”</h5><h5 id=\"区别：一个是用于初始化静态的类变量，-一个是初始化实例变量\"><a href=\"#区别：一个是用于初始化静态的类变量，-一个是初始化实例变量\" class=\"headerlink\" title=\"区别：一个是用于初始化静态的类变量， 一个是初始化实例变量!\"></a>区别：一个是用于初始化静态的类变量， 一个是初始化实例变量!</h5><h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><h5 id=\"使用既是所需要的对象开始被调用。\"><a href=\"#使用既是所需要的对象开始被调用。\" class=\"headerlink\" title=\"使用既是所需要的对象开始被调用。\"></a>使用既是所需要的对象开始被调用。</h5><h3 id=\"卸载\"><a href=\"#卸载\" class=\"headerlink\" title=\"卸载\"></a>卸载</h3><h5 id=\"对象被jvm回收。\"><a href=\"#对象被jvm回收。\" class=\"headerlink\" title=\"对象被jvm回收。\"></a>对象被jvm回收。</h5><h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><pre><code class=\"lang-java\">public class InitDemo {\n\n    static {\n        System.out.println(&quot;InitDemo static init ...&quot;);\n    }\n\n    public static void main(String[] args) {\n        System.out.println(&quot;InitDemo main begin&quot;);\n        InitA a = new InitA();\n        System.out.println(InitA.width);\n        InitA b = new InitA();\n\n    }\n}\n</code></pre>\n<pre><code class=\"lang-java\">class InitBase{\n\n    static {\n        System.out.println(&quot;InitBase static init ...&quot;);\n    }\n}\n</code></pre>\n<pre><code class=\"lang-java\">class InitA extends InitBase {\n\n    public static int width = 60;\n\n    static {\n        System.out.println(&quot;InitA static init ...&quot;);\n        width = 30;\n    }\n\n    public InitA() {\n        System.out.println(&quot; InitA init ... &quot;);\n    }\n}\n</code></pre>\n<h5 id=\"运行结果：\"><a href=\"#运行结果：\" class=\"headerlink\" title=\"运行结果：\"></a>运行结果：</h5><pre><code>InitDemo static init ...\nInitDemo main begin\nInitBase static init ...\nInitA static init ...\n InitA init ...\n30\n InitA init ...\n</code></pre><h5 id=\"可以看到，在执行结果中，先运行main方法所在类的初始化方法，之后运行main函数。然后运行父类InitBase的初始化方法。之后运行InitA的静态初始化。以及InitA的构造函数。此后虽然new了多个InitA，但是其静态的初始化方法-lt-clinit-gt-只运行了一次。\"><a href=\"#可以看到，在执行结果中，先运行main方法所在类的初始化方法，之后运行main函数。然后运行父类InitBase的初始化方法。之后运行InitA的静态初始化。以及InitA的构造函数。此后虽然new了多个InitA，但是其静态的初始化方法-lt-clinit-gt-只运行了一次。\" class=\"headerlink\" title=\"可以看到，在执行结果中，先运行main方法所在类的初始化方法，之后运行main函数。然后运行父类InitBase的初始化方法。之后运行InitA的静态初始化。以及InitA的构造函数。此后虽然new了多个InitA，但是其静态的初始化方法&lt;clinit&gt;只运行了一次。\"></a>可以看到，在执行结果中，先运行main方法所在类的初始化方法，之后运行main函数。然后运行父类InitBase的初始化方法。之后运行InitA的静态初始化。以及InitA的构造函数。此后虽然new了多个InitA，但是其静态的初始化方法&lt;clinit&gt;只运行了一次。</h5><h1 id=\"被动引用和主动引用\"><a href=\"#被动引用和主动引用\" class=\"headerlink\" title=\"被动引用和主动引用\"></a>被动引用和主动引用</h1><h5 id=\"在java虚拟机规范中，严格规定了，只有对类进行主动引用，才会触发其初始化方法。而除此之外的引用方式称之为被动引用，不会触发类的初始化方法。\"><a href=\"#在java虚拟机规范中，严格规定了，只有对类进行主动引用，才会触发其初始化方法。而除此之外的引用方式称之为被动引用，不会触发类的初始化方法。\" class=\"headerlink\" title=\"在java虚拟机规范中，严格规定了，只有对类进行主动引用，才会触发其初始化方法。而除此之外的引用方式称之为被动引用，不会触发类的初始化方法。\"></a>在java虚拟机规范中，严格规定了，只有对类进行主动引用，才会触发其初始化方法。而除此之外的引用方式称之为被动引用，不会触发类的初始化方法。</h5><h3 id=\"主动引用\"><a href=\"#主动引用\" class=\"headerlink\" title=\"主动引用\"></a>主动引用</h3><h5 id=\"虚拟机规范规定只有如下四种情况才能触发主动引用：\"><a href=\"#虚拟机规范规定只有如下四种情况才能触发主动引用：\" class=\"headerlink\" title=\"虚拟机规范规定只有如下四种情况才能触发主动引用：\"></a>虚拟机规范规定只有如下四种情况才能触发主动引用：</h5><h4 id=\"遇到new、getstatic、setstatic、invokestatic-4条指令时，如果类没有初始化，则需要触发其初始化（final修饰的常量除外）。\"><a href=\"#遇到new、getstatic、setstatic、invokestatic-4条指令时，如果类没有初始化，则需要触发其初始化（final修饰的常量除外）。\" class=\"headerlink\" title=\"遇到new、getstatic、setstatic、invokestatic 4条指令时，如果类没有初始化，则需要触发其初始化（final修饰的常量除外）。\"></a>遇到new、getstatic、setstatic、invokestatic 4条指令时，如果类没有初始化，则需要触发其初始化（final修饰的常量除外）。</h4><h4 id=\"1-使用new关键字实例化对象\"><a href=\"#1-使用new关键字实例化对象\" class=\"headerlink\" title=\"(1).使用new关键字实例化对象\"></a>(1).使用new关键字实例化对象</h4><pre><code class=\"lang-java\">public class NewClass {\n\n    static {\n        System.out.println(&quot;NewClass init ...&quot;);\n    }\n\n}\n</code></pre>\n<pre><code class=\"lang-java\">class Init1{\n    public static void main(String[] args) {\n        new NewClass();\n    }\n}\n</code></pre>\n<h5 id=\"运行结果：-1\"><a href=\"#运行结果：-1\" class=\"headerlink\" title=\"运行结果：\"></a>运行结果：</h5><pre><code>NewClass init ...\n</code></pre><h4 id=\"2-读取类的静态成员变量\"><a href=\"#2-读取类的静态成员变量\" class=\"headerlink\" title=\"(2).读取类的静态成员变量\"></a>(2).读取类的静态成员变量</h4><pre><code class=\"lang-java\">public class StaticAttributeClass {\n\n    public static int value = 10;\n\n    public static void staticMethod() {\n\n    }\n\n    static {\n        System.out.println(&quot;StaticAttributeClass init ...&quot;);\n    }\n}\n</code></pre>\n<pre><code class=\"lang-java\">class Init2{\n    public static void main(String[] args) {\n        //1.读取静态变量\n        int value = StaticAttributeClass.value;\n    }\n}\n</code></pre>\n<h5 id=\"运行结果：-2\"><a href=\"#运行结果：-2\" class=\"headerlink\" title=\"运行结果：\"></a>运行结果：</h5><pre><code>StaticAttributeClass init ...\n</code></pre><h4 id=\"3-设置类的静态成员变量\"><a href=\"#3-设置类的静态成员变量\" class=\"headerlink\" title=\"(3).设置类的静态成员变量\"></a>(3).设置类的静态成员变量</h4><pre><code class=\"lang-java\">class Init2{\n    public static void main(String[] args) {\n        StaticAttributeClass.value = 5\n    }\n}\n</code></pre>\n<h5 id=\"运行结果：-3\"><a href=\"#运行结果：-3\" class=\"headerlink\" title=\"运行结果：\"></a>运行结果：</h5><pre><code>StaticAttributeClass init ...\n</code></pre><h4 id=\"4-调用静态方法\"><a href=\"#4-调用静态方法\" class=\"headerlink\" title=\"(4).调用静态方法\"></a>(4).调用静态方法</h4><pre><code class=\"lang-java\">class Init2{\n    public static void main(String[] args) {\n        StaticAttributeClass.staticMethod();\n    }\n}\n</code></pre>\n<h5 id=\"运行结果：-4\"><a href=\"#运行结果：-4\" class=\"headerlink\" title=\"运行结果：\"></a>运行结果：</h5><pre><code>StaticAttributeClass init ...\n</code></pre><h4 id=\"使用java-lang-reflenct包的方法对类进行放射调用，如果没有进行初始化，则需要触发其初始化。\"><a href=\"#使用java-lang-reflenct包的方法对类进行放射调用，如果没有进行初始化，则需要触发其初始化。\" class=\"headerlink\" title=\"使用java.lang.reflenct包的方法对类进行放射调用，如果没有进行初始化，则需要触发其初始化。\"></a>使用java.lang.reflenct包的方法对类进行放射调用，如果没有进行初始化，则需要触发其初始化。</h4><pre><code class=\"lang-java\">public class ReflectClass {\n\n    static {\n        System.out.println(&quot;ReflectClass init ...&quot;);\n    }\n}\n</code></pre>\n<pre><code class=\"lang-java\">class Init3{\n    public static void main(String[] args) {\n        try {\n            Class clazz = Class.forName(&quot;com.dhb.classload.ReflectClass&quot;);\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre>\n<h5 id=\"运行结果：-5\"><a href=\"#运行结果：-5\" class=\"headerlink\" title=\"运行结果：\"></a>运行结果：</h5><pre><code>ReflectClass init ..\n</code></pre><h4 id=\"当一个类初始化的时候，如果其父类还没有初始化，则需要先对其父类进行初始化。\"><a href=\"#当一个类初始化的时候，如果其父类还没有初始化，则需要先对其父类进行初始化。\" class=\"headerlink\" title=\"当一个类初始化的时候，如果其父类还没有初始化，则需要先对其父类进行初始化。\"></a>当一个类初始化的时候，如果其父类还没有初始化，则需要先对其父类进行初始化。</h4><pre><code class=\"lang-java\">public class SuperClass {\n    static {\n        System.out.println(&quot;SuperClass init ...&quot;);\n    }\n    public static int value = 10;\n}\n</code></pre>\n<pre><code class=\"lang-java\">class SubClass extends SuperClass {\n    static {\n        System.out.println(&quot;SubClass init ...&quot;);\n    }\n}\n</code></pre>\n<pre><code class=\"lang-java\">class Init4 {\n    public static void main(String[] args) {\n        new SubClass();\n    }\n}\n</code></pre>\n<h5 id=\"运行结果：-6\"><a href=\"#运行结果：-6\" class=\"headerlink\" title=\"运行结果：\"></a>运行结果：</h5><pre><code>SuperClass init ...\nSubClass init ...\n</code></pre><h4 id=\"当虚拟机启动时，用户需要指定一个执行的主类，虚拟机会首先初始化这个主类\"><a href=\"#当虚拟机启动时，用户需要指定一个执行的主类，虚拟机会首先初始化这个主类\" class=\"headerlink\" title=\"当虚拟机启动时，用户需要指定一个执行的主类，虚拟机会首先初始化这个主类\"></a>当虚拟机启动时，用户需要指定一个执行的主类，虚拟机会首先初始化这个主类</h4><pre><code class=\"lang-java\">public class MainClass {\n\n    static {\n        System.out.println(&quot;MainClass init ...&quot;);\n    }\n\n    public static void main(String[] args) {\n        System.out.println(&quot;main begin ...&quot;);\n    }\n}\n</code></pre>\n<h5 id=\"运行结果：-7\"><a href=\"#运行结果：-7\" class=\"headerlink\" title=\"运行结果：\"></a>运行结果：</h5><pre><code>MainClass init ...\nmain begin ...\n</code></pre><h3 id=\"被动引用\"><a href=\"#被动引用\" class=\"headerlink\" title=\"被动引用\"></a>被动引用</h3><h5 id=\"主动引用之外的引用情况都称之为被动引用，这些引用不会进行初始化。\"><a href=\"#主动引用之外的引用情况都称之为被动引用，这些引用不会进行初始化。\" class=\"headerlink\" title=\"主动引用之外的引用情况都称之为被动引用，这些引用不会进行初始化。\"></a>主动引用之外的引用情况都称之为被动引用，这些引用不会进行初始化。</h5><h4 id=\"通过子类引用父类的静态字段，不会导致子类初始化\"><a href=\"#通过子类引用父类的静态字段，不会导致子类初始化\" class=\"headerlink\" title=\"通过子类引用父类的静态字段，不会导致子类初始化\"></a>通过子类引用父类的静态字段，不会导致子类初始化</h4><pre><code class=\"lang-java\">public class SuperClass {\n    static {\n        System.out.println(&quot;SuperClass init ...&quot;);\n    }\n    public static int value = 10;\n}\n</code></pre>\n<pre><code class=\"lang-java\">class SubClass extends SuperClass {\n    static {\n        System.out.println(&quot;SubClass init ...&quot;);\n    }\n\n}\n</code></pre>\n<pre><code class=\"lang-java\">class Init4 {\n    public static void main(String[] args) {\n        int value = SubClass.value;\n    }\n}\n</code></pre>\n<h5 id=\"运行结果：-8\"><a href=\"#运行结果：-8\" class=\"headerlink\" title=\"运行结果：\"></a>运行结果：</h5><pre><code>SuperClass init ...\n</code></pre><h4 id=\"通过数组定义来引用，不会触发此类的初始化\"><a href=\"#通过数组定义来引用，不会触发此类的初始化\" class=\"headerlink\" title=\"通过数组定义来引用，不会触发此类的初始化\"></a>通过数组定义来引用，不会触发此类的初始化</h4><pre><code class=\"lang-java\">public class ArrayClass {\n\n    static {\n        System.out.println(&quot;ArrayClass init ...&quot;);\n    }\n}\n</code></pre>\n<pre><code class=\"lang-java\">class Init5{\n    public static void main(String[] args) {\n        ArrayClass[] arrays = new  ArrayClass[10];\n    }\n}\n</code></pre>\n<h5 id=\"运行结果为空\"><a href=\"#运行结果为空\" class=\"headerlink\" title=\"运行结果为空\"></a>运行结果为空</h5><h4 id=\"常量在编译阶段会存入调用类的常量池中，本质没有直接引用到定义的常量类中，因此不会触发定义的常量类初始化\"><a href=\"#常量在编译阶段会存入调用类的常量池中，本质没有直接引用到定义的常量类中，因此不会触发定义的常量类初始化\" class=\"headerlink\" title=\"常量在编译阶段会存入调用类的常量池中，本质没有直接引用到定义的常量类中，因此不会触发定义的常量类初始化\"></a>常量在编译阶段会存入调用类的常量池中，本质没有直接引用到定义的常量类中，因此不会触发定义的常量类初始化</h4><pre><code class=\"lang-java\">public class ConstClass {\n    static {\n        System.out.println(&quot;ConstClass init ...&quot;);\n    }\n\n    public static final int value = 10;\n}\n</code></pre>\n<pre><code class=\"lang-java\">class Init6{\n    public static void main(String[] args) {\n        int value = ConstClass.value;\n    }\n}\n</code></pre>\n<h5 id=\"运行结果为空-1\"><a href=\"#运行结果为空-1\" class=\"headerlink\" title=\"运行结果为空\"></a>运行结果为空</h5><h3 id=\"2-3练习题\"><a href=\"#2-3练习题\" class=\"headerlink\" title=\"2.3练习题\"></a>2.3练习题</h3><p>如下类的输出：</p>\n<pre><code class=\"lang-java\">public class Singleton {\n\n    private static Singleton instance = new Singleton();\n\n    public static int x = 0;\n    public static int y;\n\n    private Singleton () {\n        x ++;\n        y ++;\n    }\n\n    public static Singleton getInstance() {\n        return instance;\n    }\n\n    public static void main(String[] args) {\n        Singleton singleton = getInstance();\n        System.out.println(x);\n        System.out.println(y);\n    }\n }\n</code></pre>\n<h5 id=\"运行结果\"><a href=\"#运行结果\" class=\"headerlink\" title=\"运行结果:\"></a>运行结果:</h5><pre><code>0\n1\n</code></pre><h5 id=\"输出结果竟然是-x为0-y为1\"><a href=\"#输出结果竟然是-x为0-y为1\" class=\"headerlink\" title=\"输出结果竟然是 x为0 y为1 !!!\"></a>输出结果竟然是 x为0 y为1 !!!</h5><h5 id=\"其实理解了类的加载过程也就不难理解，其过程如下：\"><a href=\"#其实理解了类的加载过程也就不难理解，其过程如下：\" class=\"headerlink\" title=\"其实理解了类的加载过程也就不难理解，其过程如下：\"></a>其实理解了类的加载过程也就不难理解，其过程如下：</h5><ol>\n<li>执行链接过程，初始化所有的类变量：<br>instance -&gt; null<br>x -&gt; 0<br>y -&gt; 0</li>\n<li>执行初始化过程：<br>new Singleton() 调用构造方法<br>之后 x -&gt; 1 y -&gt; 1<br>再执行 x = 0 赋值<br>最终<br>x -&gt; 0<br>y -&gt; 1</li>\n</ol>"},{"layout":"post","title":"Java并发之AQS","date":"2018-04-08T16:00:00.000Z","tag":[["java","java"]],"_content":"\n##### Java的并发工具，我们常用的有ReentrantLock/Semaphore/CountDownLatch等工具，而这些工具类又是如何实现的呢？这就不得不提到AbstractQueuedSynchronizer类，也就是AQS！类如其名，抽象的队列式的同步器，AQS定义了一套多线程访问共享资源的同步器框架。\n<!-- more -->\n\n## 框架\n![AQS队列](/img/note/jdk/aqs.png) <div class='img-note'>AQS队列</div>\n\n##### **AbstractQueuedSynchronizer**类它维护了一个volatile int state（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列）。这里volatile是核心关键词，具体volatile的语义，在此不述。state的访问方式有三种:\n* getState\n* setState\n* compareAndSetState\n\n##### AQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore/CountDownLatch）。\n\n##### 不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：\n* **isHeldExclusively()**：该线程是否正在独占资源。只有用到condition才需要去实现它。\n* **tryAcquire(int)**：独占方式。尝试获取资源，成功则返回true，失败则返回false。\n* **tryRelease(int)**：独占方式。尝试释放资源，成功则返回true，失败则返回false。\n* **tryAcquireShared(int)**：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。\n* **tryReleaseShared(int)**：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。\n\n##### 以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。\n\n##### 再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS减1。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。\n\n##### 一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。\n\n## 源码详解\n### acquire(int)\n##### 此方法是独占模式下线程获取共享资源的顶层入口。如果获取到资源，线程直接返回，否则进入等待队列，直到获取到资源为止，且整个过程忽略中断的影响。这也正是lock()的语义，当然不仅仅只限于lock()。获取到资源后，线程就可以去执行其临界区代码了。下面是acquire()的源码：\n```java\npublic final void acquire(int arg) {\n    if (!tryAcquire(arg) &&\n        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        selfInterrupt();\n}\n```\n#### 函数流程如下：\n1. tryAcquire()尝试直接去获取资源，如果成功则直接返回；\n2. addWaiter()将该线程加入等待队列的尾部，并标记为独占模式；\n3. acquireQueued()使线程在等待队列中获取资源，一直获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。\n4. 如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。\n\n##### 这时单凭这4个抽象的函数来看流程还有点朦胧，不要紧，看完接下来的分析后，你就会明白了。\n\n### tryAcquire(int)\n##### 此方法尝试去获取独占资源。如果获取成功，则直接返回true，否则直接返回false。这也正是tryLock()的语义，还是那句话，当然不仅仅只限于tryLock()。如下是tryAcquire()的源码：\n```java\nprotected boolean tryAcquire(int arg) {\n    throw new UnsupportedOperationException();\n}\n```\n\n##### 什么？直接throw异常？说好的功能呢？好吧，还记得概述里讲的AQS只是一个框架，具体资源的获取/释放方式交由自定义同步器去实现吗？就是这里了！！！AQS这里只定义了一个接口，具体资源的获取交由自定义同步器去实现了（通过state的get/set/CAS）！！！至于能不能重入，能不能加塞，那就看具体的自定义同步器怎么去设计了！！！当然，自定义同步器在进行资源访问时要考虑线程安全的影响。\n\n##### 这里之所以没有定义成abstract，是因为独占模式下只用实现tryAcquire-tryRelease，而共享模式下只用实现tryAcquireShared-tryReleaseShared。如果都定义成abstract，那么每个模式也要去实现另一模式下的接口。说到底，Doug Lea还是站在咱们开发者的角度，尽量减少不必要的工作量。\n\n### addWaiter(Node)\n##### 此方法用于将当前线程加入到等待队列的队尾，并返回当前线程所在的结点。还是上源码吧：\n```java\nprivate Node addWaiter(Node mode) {\n    //以给定模式构造结点。mode有两种：EXCLUSIVE（独占）和SHARED（共享）\n    Node node = new Node(Thread.currentThread(), mode);\n    //尝试快速方式直接放到队尾。\n    Node pred = tail;\n    if (pred != null) {\n        node.prev = pred;\n        if (compareAndSetTail(pred, node)) {\n            pred.next = node;\n            return node;\n        }\n    }\n    //上一步失败则通过enq入队。\n    enq(node);\n    return node;\n}\n```\n\n### enq(Node)\n##### 此方法用于将node加入队尾。源码如下：\n\n```java\nprivate Node enq(final Node node) {\n    //CAS\"自旋\"，直到成功加入队尾\n    for (;;) {\n        Node t = tail;\n        if (t == null) { // 队列为空，创建一个空的标志结点作为head结点，并将tail也指向它。\n            if (compareAndSetHead(new Node()))\n                tail = head;\n        } else {//正常流程，放入队尾\n            node.prev = t;\n            if (compareAndSetTail(t, node)) {\n                t.next = node;\n                return t;\n            }\n        }\n    }\n}\n```\n\n##### 如果你看过AtomicInteger.getAndIncrement()函数源码，那么相信你一眼便看出这段代码的精华。CAS自旋volatile变量，是一种很经典的用法。还不太了解的，自己去百度一下吧。\n\n### acquireQueued(Node, int)\n##### OK，通过tryAcquire()和addWaiter()，该线程获取资源失败，已经被放入等待队列尾部了。聪明的你立刻应该能想到该线程下一部该干什么了吧：进入等待状态休息，直到其他线程彻底释放资源后唤醒自己，自己再拿到资源，然后就可以去干自己想干的事了。没错，就是这样！是不是跟医院排队拿号有点相似~~acquireQueued()就是干这件事：在等待队列中排队拿号（中间没其它事干可以休息），直到拿到号后再返回。这个函数非常关键，还是上源码吧：\n\n```java\nfinal boolean acquireQueued(final Node node, int arg) {\n    boolean failed = true;//标记是否成功拿到资源\n    try {\n        boolean interrupted = false;//标记等待过程中是否被中断过\n        //又是一个“自旋”！\n        for (;;) {\n            final Node p = node.predecessor();//拿到前驱\n            //如果前驱是head，即该结点已成老二，那么便有资格去尝试获取资源（可能是老大释放完资源唤醒自己的，当然也可能被interrupt了）。\n            if (p == head && tryAcquire(arg)) {\n                setHead(node);//拿到资源后，将head指向该结点。所以head所指的标杆结点，就是当前获取到资源的那个结点或null。\n                p.next = null; // setHead中node.prev已置为null，此处再将head.next置为null，就是为了方便GC回收以前的head结点。也就意味着之前拿完资源的结点出队了！\n                failed = false;\n                return interrupted;//返回等待过程中是否被中断过\n            }\n            //如果自己可以休息了，就进入waiting状态，直到被unpark()\n            if (shouldParkAfterFailedAcquire(p, node) &&\n                parkAndCheckInterrupt())\n                interrupted = true;//如果等待过程中被中断过，哪怕只有那么一次，就将interrupted标记为true\n        }\n    } finally {\n        if (failed)\n            cancelAcquire(node);\n    }\n}\n```\n\n##### 到这里了，我们先不急着总结acquireQueued()的函数流程，先看看shouldParkAfterFailedAcquire()和parkAndCheckInterrupt()具体干些什么。\n\n### shouldParkAfterFailedAcquire(Node, Node)\n##### 此方法主要用于检查状态，看看自己是否真的可以去休息了（进入waiting状态，如果线程状态转换不熟，可以参考本人上一篇写的Thread详解），万一队列前边的线程都放弃了只是瞎站着，那也说不定，对吧！\n\n```java\nprivate static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {\n    int ws = pred.waitStatus;//拿到前驱的状态\n    if (ws == Node.SIGNAL)\n        //如果已经告诉前驱拿完号后通知自己一下，那就可以安心休息了\n        return true;\n    if (ws > 0) {\n        /*\n         * 如果前驱放弃了，那就一直往前找，直到找到最近一个正常等待的状态，并排在它的后边。\n         * 注意：那些放弃的结点，由于被自己“加塞”到它们前边，它们相当于形成一个无引用链，稍后就会被保安大叔赶走了(GC回收)！\n         */\n        do {\n            node.prev = pred = pred.prev;\n        } while (pred.waitStatus > 0);\n        pred.next = node;\n    } else {\n         //如果前驱正常，那就把前驱的状态设置成SIGNAL，告诉它拿完号后通知自己一下。有可能失败，人家说不定刚刚释放完呢！\n        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);\n    }\n    return false;\n}\n```\n\n##### 整个流程中，如果前驱结点的状态不是SIGNAL，那么自己就不能安心去休息，需要去找个安心的休息点，同时可以再尝试下看有没有机会轮到自己拿号。\n\n### parkAndCheckInterrupt()\n##### 如果线程找好安全休息点后，那就可以安心去休息了。此方法就是让线程去休息，真正进入等待状态。\n```java\nprivate final boolean parkAndCheckInterrupt() {\n    LockSupport.park(this);//调用park()使线程进入waiting状态\n    return Thread.interrupted();//如果被唤醒，查看自己是不是被中断的。\n}\n```\n##### park()会让当前线程进入waiting状态。在此状态下，有两种途径可以唤醒该线程：1）被unpark()；2）被interrupt()。（再说一句，如果线程状态转换不熟，可以参考本人写的Thread详解）。需要注意的是，Thread.interrupted()会清除当前线程的中断标记位。\n\n#### 小结\n##### OK，看了shouldParkAfterFailedAcquire()和parkAndCheckInterrupt()，现在让我们再回到acquireQueued()，总结下该函数的具体流程：\n1. 结点进入队尾后，检查状态，找到安全休息点；\n2. 调用park()进入waiting状态，等待unpark()或interrupt()唤醒自己；\n3. 被唤醒后，看自己是不是有资格能拿到号。如果拿到，head指向当前结点，并返回从入队到拿到号的整个过程中是否被中断过；如果没拿到，继续流程1。\n\n### 小结\n##### OKOK，acquireQueued()分析完之后，我们接下来再回到acquire()！再贴上它的源码吧：\n\n```java\npublic final void acquire(int arg) {\n    if (!tryAcquire(arg) &&\n        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        selfInterrupt();\n}\n```\n##### 再来总结下它的流程吧：\n1. 调用自定义同步器的tryAcquire()尝试直接去获取资源，如果成功则直接返回；\n2. 没成功，则addWaiter()将该线程加入等待队列的尾部，并标记为独占模式；\n3. acquireQueued()使线程在等待队列中休息，有机会时（轮到自己，会被unpark()）会去尝试获取资源。获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。\n4. 如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。\n\n##### 由于此函数是重中之重，我再用流程图总结一下：\n![AQS队列](/img/note/jdk/aqs1.png)\n\n##### 至此，acquire()的流程终于算是告一段落了。这也就是ReentrantLock.lock()的流程，不信你去看其lock()源码吧，整个函数就是一条acquire(1)！！！\n\n### release(int)\n##### 上一小节已经把acquire()说完了，这一小节就来讲讲它的反操作release()吧。此方法是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state=0）,它会唤醒等待队列里的其他线程来获取资源。这也正是unlock()的语义，当然不仅仅只限于unlock()。下面是release()的源码：\n\n```java\npublic final boolean release(int arg) {\n    if (tryRelease(arg)) {\n        Node h = head;//找到头结点\n        if (h != null && h.waitStatus != 0)\n            unparkSuccessor(h);//唤醒等待队列里的下一个线程\n        return true;\n    }\n    return false;\n}\n```\n\n##### 逻辑并不复杂。它调用tryRelease()来释放资源。有一点需要注意的是，它是根据tryRelease()的返回值来判断该线程是否已经完成释放掉资源了！所以自定义同步器在设计tryRelease()的时候要明确这一点！！\n\n### tryRelease(int)\n##### 此方法尝试去释放指定量的资源。下面是tryRelease()的源码：\n```java\nprotected boolean tryRelease(int arg) {\n    throw new UnsupportedOperationException();\n}\n```\n\n##### 跟tryAcquire()一样，这个方法是需要独占模式的自定义同步器去实现的。正常来说，tryRelease()都会成功的，因为这是独占模式，该线程来释放资源，那么它肯定已经拿到独占资源了，直接减掉相应量的资源即可(state-=arg)，也不需要考虑线程安全的问题。但要注意它的返回值，上面已经提到了，release()是根据tryRelease()的返回值来判断该线程是否已经完成释放掉资源了！所以自义定同步器在实现时，如果已经彻底释放资源(state=0)，要返回true，否则返回false。\n\n### unparkSuccessor(Node)\n##### 此方法用于唤醒等待队列中下一个线程。下面是源码：\n\n```java\nprivate void unparkSuccessor(Node node) {\n    //这里，node一般为当前线程所在的结点。\n    int ws = node.waitStatus;\n    if (ws < 0)//置零当前线程所在的结点状态，允许失败。\n        compareAndSetWaitStatus(node, ws, 0);\n    Node s = node.next;//找到下一个需要唤醒的结点s\n    if (s == null || s.waitStatus > 0) {//如果为空或已取消\n        s = null;\n        for (Node t = tail; t != null && t != node; t = t.prev)\n            if (t.waitStatus <= 0)//从这里可以看出，<=0的结点，都是还有效的结点。\n                s = t;\n    }\n    if (s != null)\n        LockSupport.unpark(s.thread);//唤醒\n}\n```\n\n##### 这个函数并不复杂。一句话概括：用unpark()唤醒等待队列中最前边的那个未放弃线程，这里我们也用s来表示吧。此时，再和acquireQueued()联系起来，s被唤醒后，进入if (p == head && tryAcquire(arg))的判断（即使p!=head也没关系，它会再进入shouldParkAfterFailedAcquire()寻找一个安全点。这里既然s已经是等待队列中最前边的那个未放弃线程了，那么通过shouldParkAfterFailedAcquire()的调整，s也必然会跑到head的next结点，下一次自旋p==head就成立啦），然后s把自己设置成head标杆结点，表示自己已经获取到资源了，acquire()也返回了！！And then, DO what you WANT!\n\n### 小结\n##### release()是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state=0）,它会唤醒等待队列里的其他线程来获取资源。\n\n### acquireShared(int)\n##### 此方法是共享模式下线程获取共享资源的顶层入口。它会获取指定量的资源，获取成功则直接返回，获取失败则进入等待队列，直到获取到资源为止，整个过程忽略中断。下面是acquireShared()的源码：\n```java\npublic final void acquireShared(int arg) {\n    if (tryAcquireShared(arg) < 0)\n        doAcquireShared(arg);\n}\n```\n\n##### 这里tryAcquireShared()依然需要自定义同步器去实现。但是AQS已经把其返回值的语义定义好了：负值代表获取失败；0代表获取成功，但没有剩余资源；正数表示获取成功，还有剩余资源，其他线程还可以去获取。所以这里acquireShared()的流程就是：\n\n1. tryAcquireShared()尝试获取资源，成功则直接返回；\n2. 失败则通过doAcquireShared()进入等待队列，直到获取到资源为止才返回。\n\n### doAcquireShared(int)\n##### 此方法用于将当前线程加入等待队列尾部休息，直到其他线程释放资源唤醒自己，自己成功拿到相应量的资源后才返回。下面是doAcquireShared()的源码：\n\n```java\nprivate void doAcquireShared(int arg) {\n    final Node node = addWaiter(Node.SHARED);//加入队列尾部\n    boolean failed = true;//是否成功标志\n    try {\n        boolean interrupted = false;//等待过程中是否被中断过的标志\n        for (;;) {\n            final Node p = node.predecessor();//前驱\n            if (p == head) {//如果到head的下一个，因为head是拿到资源的线程，此时node被唤醒，很可能是head用完资源来唤醒自己的\n                int r = tryAcquireShared(arg);//尝试获取资源\n                if (r >= 0) {//成功\n                    setHeadAndPropagate(node, r);//将head指向自己，还有剩余资源可以再唤醒之后的线程\n                    p.next = null; // help GC\n                    if (interrupted)//如果等待过程中被打断过，此时将中断补上。\n                        selfInterrupt();\n                    failed = false;\n                    return;\n                }\n            }\n            //判断状态，寻找安全点，进入waiting状态，等着被unpark()或interrupt()\n            if (shouldParkAfterFailedAcquire(p, node) &&\n                parkAndCheckInterrupt())\n                interrupted = true;\n        }\n    } finally {\n        if (failed)\n            cancelAcquire(node);\n    }\n}\n```\n\n##### 有木有觉得跟acquireQueued()很相似？对，其实流程并没有太大区别。只不过这里将补中断的selfInterrupt()放到doAcquireShared()里了，而独占模式是放到acquireQueued()之外，其实都一样，不知道Doug Lea是怎么想的。\n\n##### 跟独占模式比，还有一点需要注意的是，这里只有线程是head.next时（“老二”），才会去尝试获取资源，有剩余的话还会唤醒之后的队友。那么问题就来了，假如老大用完后释放了5个资源，而老二需要6个，老三需要1个，老四需要2个。老大先唤醒老二，老二一看资源不够，他是把资源让给老三呢，还是不让？答案是否定的！老二会继续park()等待其他线程释放资源，也更不会去唤醒老三和老四了。独占模式，同一时刻只有一个线程去执行，这样做未尝不可；但共享模式下，多个线程是可以同时执行的，现在因为老二的资源需求量大，而把后面量小的老三和老四也都卡住了。当然，这并不是问题，只是AQS保证严格按照入队顺序唤醒罢了（保证公平，但降低了并发）。\n\n### setHeadAndPropagate(Node, int)\n```java\nprivate void setHeadAndPropagate(Node node, int propagate) {\n    Node h = head;\n    setHead(node);//head指向自己\n     //如果还有剩余量，继续唤醒下一个邻居线程\n    if (propagate > 0 || h == null || h.waitStatus < 0) {\n        Node s = node.next;\n        if (s == null || s.isShared())\n            doReleaseShared();\n    }\n}\n```\n\n##### 此方法在setHead()的基础上多了一步，就是自己苏醒的同时，如果条件符合（比如还有剩余资源），还会去唤醒后继结点，毕竟是共享模式！\n##### doReleaseShared()我们留着下一小节的releaseShared()里来讲。\n\n### 小结\n##### OK，至此，acquireShared()也要告一段落了。让我们再梳理一下它的流程：\n\n1. tryAcquireShared()尝试获取资源，成功则直接返回；\n2. 失败则通过doAcquireShared()进入等待队列park()，直到被unpark()/interrupt()并成功获取到资源才返回。整个等待过程也是忽略中断的。\n　　\n##### 其实跟acquire()的流程大同小异，只不过多了个自己拿到资源后，还会去唤醒后继队友的操作（这才是共享嘛）。\n\n### releaseShared()\n##### 上一小节已经把acquireShared()说完了，这一小节就来讲讲它的反操作releaseShared()吧。此方法是共享模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果成功释放且允许唤醒等待线程，它会唤醒等待队列里的其他线程来获取资源。下面是releaseShared()的源码：\n\n```java\npublic final boolean releaseShared(int arg) {\n    if (tryReleaseShared(arg)) {//尝试释放资源\n        doReleaseShared();//唤醒后继结点\n        return true;\n    }\n    return false;\n}\n```\n\n##### 此方法的流程也比较简单，一句话：释放掉资源后，唤醒后继。跟独占模式下的release()相似，但有一点稍微需要注意：独占模式下的tryRelease()在完全释放掉资源（state=0）后，才会返回true去唤醒其他线程，这主要是基于独占下可重入的考量；而共享模式下的releaseShared()则没有这种要求，共享模式实质就是控制一定量的线程并发执行，那么拥有资源的线程在释放掉部分资源时就可以唤醒后继等待结点。例如，资源总量是13，A（5）和B（7）分别获取到资源并发运行，C（4）来时只剩1个资源就需要等待。A在运行过程中释放掉2个资源量，然后tryReleaseShared(2)返回true唤醒C，C一看只有3个仍不够继续等待；随后B又释放2个，tryReleaseShared(2)返回true唤醒C，C一看有5个够自己用了，然后C就可以跟A和B一起运行。而ReentrantReadWriteLock读锁的tryReleaseShared()只有在完全释放掉资源（state=0）才返回true，所以自定义同步器可以根据需要决定tryReleaseShared()的返回值。\n\n### doReleaseShared()\n##### 此方法主要用于唤醒后继。下面是它的源码：\n\n```java\nprivate void doReleaseShared() {\n    for (;;) {\n        Node h = head;\n        if (h != null && h != tail) {\n            int ws = h.waitStatus;\n            if (ws == Node.SIGNAL) {\n                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))\n                    continue;\n                unparkSuccessor(h);//唤醒后继\n            }\n            else if (ws == 0 &&\n                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))\n                continue;\n        }\n        if (h == head)// head发生变化\n            break;\n    }\n}\n```\n\n### 小结\n##### 本节我们详解了独占和共享两种模式下获取-释放资源(acquire-release、acquireShared-releaseShared)的源码，相信大家都有一定认识了。值得注意的是，acquire()和acquireSahred()两种方法下，线程在等待队列中都是忽略中断的。AQS也支持响应中断的，acquireInterruptibly()/acquireSharedInterruptibly()即是，这里相应的源码跟acquire()和acquireSahred()差不多，这里就不再详解了。\n\n## 简单应用\n##### OK，下面我们就以AQS源码里的Mutex为例，讲一下AQS的简单应用。\n### Mutex（互斥锁）\n##### Mutex是一个不可重入的互斥锁实现。锁资源（AQS里的state）只有两种状态：0表示未锁定，1表示锁定。下边是Mutex的核心源码：\n```java\nclass Mutex implements Lock, java.io.Serializable {\n    // 自定义同步器\n    private static class Sync extends AbstractQueuedSynchronizer {\n        // 判断是否锁定状态\n        protected boolean isHeldExclusively() {\n            return getState() == 1;\n        }\n        // 尝试获取资源，立即返回。成功则返回true，否则false。\n        public boolean tryAcquire(int acquires) {\n            assert acquires == 1; // 这里限定只能为1个量\n            if (compareAndSetState(0, 1)) {//state为0才设置为1，不可重入！\n                setExclusiveOwnerThread(Thread.currentThread());//设置为当前线程独占资源\n                return true;\n            }\n            return false;\n        }\n        // 尝试释放资源，立即返回。成功则为true，否则false。\n        protected boolean tryRelease(int releases) {\n            assert releases == 1; // 限定为1个量\n            if (getState() == 0)//既然来释放，那肯定就是已占有状态了。只是为了保险，多层判断！\n                throw new IllegalMonitorStateException();\n            setExclusiveOwnerThread(null);\n            setState(0);//释放资源，放弃占有状态\n            return true;\n        }\n    }\n    // 真正同步类的实现都依赖继承于AQS的自定义同步器！\n    private final Sync sync = new Sync();\n    //lock<-->acquire。两者语义一样：获取资源，即便等待，直到成功才返回。\n    public void lock() {\n        sync.acquire(1);\n    }\n    //tryLock<-->tryAcquire。两者语义一样：尝试获取资源，要求立即返回。成功则为true，失败则为false。\n    public boolean tryLock() {\n        return sync.tryAcquire(1);\n    }\n    //unlock<-->release。两者语文一样：释放资源。\n    public void unlock() {\n        sync.release(1);\n    }\n    //锁是否占有状态\n    public boolean isLocked() {\n        return sync.isHeldExclusively();\n    }\n}\n```\n\n##### 同步类在实现时一般都将自定义同步器（sync）定义为内部类，供自己使用；而同步类自己（Mutex）则实现某个接口，对外服务。当然，接口的实现要直接依赖sync，它们在语义上也存在某种对应关系！！而sync只用实现资源state的获取-释放方式tryAcquire-tryRelelase，至于线程的排队、等待、唤醒等，上层的AQS都已经实现好了，我们不用关心。\n\n##### 除了Mutex，ReentrantLock/CountDownLatch/Semphore这些同步类的实现方式都差不多，不同的地方就在获取-释放资源的方式tryAcquire-tryRelelase。掌握了这点，AQS的核心便被攻破了！\n\n##### OK，至此，整个AQS的讲解也要落下帷幕了。希望本文能够对学习Java并发编程的同学有所借鉴，中间写的有不对的地方，也欢迎讨论和指正~\n\n### 文章转载自：[https://www.cnblogs.com/waterystone/p/4920797.html](https://www.cnblogs.com/waterystone/p/4920797.html)","source":"_posts/note/jdk/javaAQS.md","raw":"---\nlayout: post\ntitle: Java并发之AQS\ndate: 2018/04/09\ntags: [tech, index]\ntag: [[java, java]]\n---\n\n##### Java的并发工具，我们常用的有ReentrantLock/Semaphore/CountDownLatch等工具，而这些工具类又是如何实现的呢？这就不得不提到AbstractQueuedSynchronizer类，也就是AQS！类如其名，抽象的队列式的同步器，AQS定义了一套多线程访问共享资源的同步器框架。\n<!-- more -->\n\n## 框架\n![AQS队列](/img/note/jdk/aqs.png) <div class='img-note'>AQS队列</div>\n\n##### **AbstractQueuedSynchronizer**类它维护了一个volatile int state（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列）。这里volatile是核心关键词，具体volatile的语义，在此不述。state的访问方式有三种:\n* getState\n* setState\n* compareAndSetState\n\n##### AQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore/CountDownLatch）。\n\n##### 不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：\n* **isHeldExclusively()**：该线程是否正在独占资源。只有用到condition才需要去实现它。\n* **tryAcquire(int)**：独占方式。尝试获取资源，成功则返回true，失败则返回false。\n* **tryRelease(int)**：独占方式。尝试释放资源，成功则返回true，失败则返回false。\n* **tryAcquireShared(int)**：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。\n* **tryReleaseShared(int)**：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。\n\n##### 以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。\n\n##### 再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS减1。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。\n\n##### 一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。\n\n## 源码详解\n### acquire(int)\n##### 此方法是独占模式下线程获取共享资源的顶层入口。如果获取到资源，线程直接返回，否则进入等待队列，直到获取到资源为止，且整个过程忽略中断的影响。这也正是lock()的语义，当然不仅仅只限于lock()。获取到资源后，线程就可以去执行其临界区代码了。下面是acquire()的源码：\n```java\npublic final void acquire(int arg) {\n    if (!tryAcquire(arg) &&\n        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        selfInterrupt();\n}\n```\n#### 函数流程如下：\n1. tryAcquire()尝试直接去获取资源，如果成功则直接返回；\n2. addWaiter()将该线程加入等待队列的尾部，并标记为独占模式；\n3. acquireQueued()使线程在等待队列中获取资源，一直获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。\n4. 如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。\n\n##### 这时单凭这4个抽象的函数来看流程还有点朦胧，不要紧，看完接下来的分析后，你就会明白了。\n\n### tryAcquire(int)\n##### 此方法尝试去获取独占资源。如果获取成功，则直接返回true，否则直接返回false。这也正是tryLock()的语义，还是那句话，当然不仅仅只限于tryLock()。如下是tryAcquire()的源码：\n```java\nprotected boolean tryAcquire(int arg) {\n    throw new UnsupportedOperationException();\n}\n```\n\n##### 什么？直接throw异常？说好的功能呢？好吧，还记得概述里讲的AQS只是一个框架，具体资源的获取/释放方式交由自定义同步器去实现吗？就是这里了！！！AQS这里只定义了一个接口，具体资源的获取交由自定义同步器去实现了（通过state的get/set/CAS）！！！至于能不能重入，能不能加塞，那就看具体的自定义同步器怎么去设计了！！！当然，自定义同步器在进行资源访问时要考虑线程安全的影响。\n\n##### 这里之所以没有定义成abstract，是因为独占模式下只用实现tryAcquire-tryRelease，而共享模式下只用实现tryAcquireShared-tryReleaseShared。如果都定义成abstract，那么每个模式也要去实现另一模式下的接口。说到底，Doug Lea还是站在咱们开发者的角度，尽量减少不必要的工作量。\n\n### addWaiter(Node)\n##### 此方法用于将当前线程加入到等待队列的队尾，并返回当前线程所在的结点。还是上源码吧：\n```java\nprivate Node addWaiter(Node mode) {\n    //以给定模式构造结点。mode有两种：EXCLUSIVE（独占）和SHARED（共享）\n    Node node = new Node(Thread.currentThread(), mode);\n    //尝试快速方式直接放到队尾。\n    Node pred = tail;\n    if (pred != null) {\n        node.prev = pred;\n        if (compareAndSetTail(pred, node)) {\n            pred.next = node;\n            return node;\n        }\n    }\n    //上一步失败则通过enq入队。\n    enq(node);\n    return node;\n}\n```\n\n### enq(Node)\n##### 此方法用于将node加入队尾。源码如下：\n\n```java\nprivate Node enq(final Node node) {\n    //CAS\"自旋\"，直到成功加入队尾\n    for (;;) {\n        Node t = tail;\n        if (t == null) { // 队列为空，创建一个空的标志结点作为head结点，并将tail也指向它。\n            if (compareAndSetHead(new Node()))\n                tail = head;\n        } else {//正常流程，放入队尾\n            node.prev = t;\n            if (compareAndSetTail(t, node)) {\n                t.next = node;\n                return t;\n            }\n        }\n    }\n}\n```\n\n##### 如果你看过AtomicInteger.getAndIncrement()函数源码，那么相信你一眼便看出这段代码的精华。CAS自旋volatile变量，是一种很经典的用法。还不太了解的，自己去百度一下吧。\n\n### acquireQueued(Node, int)\n##### OK，通过tryAcquire()和addWaiter()，该线程获取资源失败，已经被放入等待队列尾部了。聪明的你立刻应该能想到该线程下一部该干什么了吧：进入等待状态休息，直到其他线程彻底释放资源后唤醒自己，自己再拿到资源，然后就可以去干自己想干的事了。没错，就是这样！是不是跟医院排队拿号有点相似~~acquireQueued()就是干这件事：在等待队列中排队拿号（中间没其它事干可以休息），直到拿到号后再返回。这个函数非常关键，还是上源码吧：\n\n```java\nfinal boolean acquireQueued(final Node node, int arg) {\n    boolean failed = true;//标记是否成功拿到资源\n    try {\n        boolean interrupted = false;//标记等待过程中是否被中断过\n        //又是一个“自旋”！\n        for (;;) {\n            final Node p = node.predecessor();//拿到前驱\n            //如果前驱是head，即该结点已成老二，那么便有资格去尝试获取资源（可能是老大释放完资源唤醒自己的，当然也可能被interrupt了）。\n            if (p == head && tryAcquire(arg)) {\n                setHead(node);//拿到资源后，将head指向该结点。所以head所指的标杆结点，就是当前获取到资源的那个结点或null。\n                p.next = null; // setHead中node.prev已置为null，此处再将head.next置为null，就是为了方便GC回收以前的head结点。也就意味着之前拿完资源的结点出队了！\n                failed = false;\n                return interrupted;//返回等待过程中是否被中断过\n            }\n            //如果自己可以休息了，就进入waiting状态，直到被unpark()\n            if (shouldParkAfterFailedAcquire(p, node) &&\n                parkAndCheckInterrupt())\n                interrupted = true;//如果等待过程中被中断过，哪怕只有那么一次，就将interrupted标记为true\n        }\n    } finally {\n        if (failed)\n            cancelAcquire(node);\n    }\n}\n```\n\n##### 到这里了，我们先不急着总结acquireQueued()的函数流程，先看看shouldParkAfterFailedAcquire()和parkAndCheckInterrupt()具体干些什么。\n\n### shouldParkAfterFailedAcquire(Node, Node)\n##### 此方法主要用于检查状态，看看自己是否真的可以去休息了（进入waiting状态，如果线程状态转换不熟，可以参考本人上一篇写的Thread详解），万一队列前边的线程都放弃了只是瞎站着，那也说不定，对吧！\n\n```java\nprivate static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {\n    int ws = pred.waitStatus;//拿到前驱的状态\n    if (ws == Node.SIGNAL)\n        //如果已经告诉前驱拿完号后通知自己一下，那就可以安心休息了\n        return true;\n    if (ws > 0) {\n        /*\n         * 如果前驱放弃了，那就一直往前找，直到找到最近一个正常等待的状态，并排在它的后边。\n         * 注意：那些放弃的结点，由于被自己“加塞”到它们前边，它们相当于形成一个无引用链，稍后就会被保安大叔赶走了(GC回收)！\n         */\n        do {\n            node.prev = pred = pred.prev;\n        } while (pred.waitStatus > 0);\n        pred.next = node;\n    } else {\n         //如果前驱正常，那就把前驱的状态设置成SIGNAL，告诉它拿完号后通知自己一下。有可能失败，人家说不定刚刚释放完呢！\n        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);\n    }\n    return false;\n}\n```\n\n##### 整个流程中，如果前驱结点的状态不是SIGNAL，那么自己就不能安心去休息，需要去找个安心的休息点，同时可以再尝试下看有没有机会轮到自己拿号。\n\n### parkAndCheckInterrupt()\n##### 如果线程找好安全休息点后，那就可以安心去休息了。此方法就是让线程去休息，真正进入等待状态。\n```java\nprivate final boolean parkAndCheckInterrupt() {\n    LockSupport.park(this);//调用park()使线程进入waiting状态\n    return Thread.interrupted();//如果被唤醒，查看自己是不是被中断的。\n}\n```\n##### park()会让当前线程进入waiting状态。在此状态下，有两种途径可以唤醒该线程：1）被unpark()；2）被interrupt()。（再说一句，如果线程状态转换不熟，可以参考本人写的Thread详解）。需要注意的是，Thread.interrupted()会清除当前线程的中断标记位。\n\n#### 小结\n##### OK，看了shouldParkAfterFailedAcquire()和parkAndCheckInterrupt()，现在让我们再回到acquireQueued()，总结下该函数的具体流程：\n1. 结点进入队尾后，检查状态，找到安全休息点；\n2. 调用park()进入waiting状态，等待unpark()或interrupt()唤醒自己；\n3. 被唤醒后，看自己是不是有资格能拿到号。如果拿到，head指向当前结点，并返回从入队到拿到号的整个过程中是否被中断过；如果没拿到，继续流程1。\n\n### 小结\n##### OKOK，acquireQueued()分析完之后，我们接下来再回到acquire()！再贴上它的源码吧：\n\n```java\npublic final void acquire(int arg) {\n    if (!tryAcquire(arg) &&\n        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        selfInterrupt();\n}\n```\n##### 再来总结下它的流程吧：\n1. 调用自定义同步器的tryAcquire()尝试直接去获取资源，如果成功则直接返回；\n2. 没成功，则addWaiter()将该线程加入等待队列的尾部，并标记为独占模式；\n3. acquireQueued()使线程在等待队列中休息，有机会时（轮到自己，会被unpark()）会去尝试获取资源。获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。\n4. 如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。\n\n##### 由于此函数是重中之重，我再用流程图总结一下：\n![AQS队列](/img/note/jdk/aqs1.png)\n\n##### 至此，acquire()的流程终于算是告一段落了。这也就是ReentrantLock.lock()的流程，不信你去看其lock()源码吧，整个函数就是一条acquire(1)！！！\n\n### release(int)\n##### 上一小节已经把acquire()说完了，这一小节就来讲讲它的反操作release()吧。此方法是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state=0）,它会唤醒等待队列里的其他线程来获取资源。这也正是unlock()的语义，当然不仅仅只限于unlock()。下面是release()的源码：\n\n```java\npublic final boolean release(int arg) {\n    if (tryRelease(arg)) {\n        Node h = head;//找到头结点\n        if (h != null && h.waitStatus != 0)\n            unparkSuccessor(h);//唤醒等待队列里的下一个线程\n        return true;\n    }\n    return false;\n}\n```\n\n##### 逻辑并不复杂。它调用tryRelease()来释放资源。有一点需要注意的是，它是根据tryRelease()的返回值来判断该线程是否已经完成释放掉资源了！所以自定义同步器在设计tryRelease()的时候要明确这一点！！\n\n### tryRelease(int)\n##### 此方法尝试去释放指定量的资源。下面是tryRelease()的源码：\n```java\nprotected boolean tryRelease(int arg) {\n    throw new UnsupportedOperationException();\n}\n```\n\n##### 跟tryAcquire()一样，这个方法是需要独占模式的自定义同步器去实现的。正常来说，tryRelease()都会成功的，因为这是独占模式，该线程来释放资源，那么它肯定已经拿到独占资源了，直接减掉相应量的资源即可(state-=arg)，也不需要考虑线程安全的问题。但要注意它的返回值，上面已经提到了，release()是根据tryRelease()的返回值来判断该线程是否已经完成释放掉资源了！所以自义定同步器在实现时，如果已经彻底释放资源(state=0)，要返回true，否则返回false。\n\n### unparkSuccessor(Node)\n##### 此方法用于唤醒等待队列中下一个线程。下面是源码：\n\n```java\nprivate void unparkSuccessor(Node node) {\n    //这里，node一般为当前线程所在的结点。\n    int ws = node.waitStatus;\n    if (ws < 0)//置零当前线程所在的结点状态，允许失败。\n        compareAndSetWaitStatus(node, ws, 0);\n    Node s = node.next;//找到下一个需要唤醒的结点s\n    if (s == null || s.waitStatus > 0) {//如果为空或已取消\n        s = null;\n        for (Node t = tail; t != null && t != node; t = t.prev)\n            if (t.waitStatus <= 0)//从这里可以看出，<=0的结点，都是还有效的结点。\n                s = t;\n    }\n    if (s != null)\n        LockSupport.unpark(s.thread);//唤醒\n}\n```\n\n##### 这个函数并不复杂。一句话概括：用unpark()唤醒等待队列中最前边的那个未放弃线程，这里我们也用s来表示吧。此时，再和acquireQueued()联系起来，s被唤醒后，进入if (p == head && tryAcquire(arg))的判断（即使p!=head也没关系，它会再进入shouldParkAfterFailedAcquire()寻找一个安全点。这里既然s已经是等待队列中最前边的那个未放弃线程了，那么通过shouldParkAfterFailedAcquire()的调整，s也必然会跑到head的next结点，下一次自旋p==head就成立啦），然后s把自己设置成head标杆结点，表示自己已经获取到资源了，acquire()也返回了！！And then, DO what you WANT!\n\n### 小结\n##### release()是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state=0）,它会唤醒等待队列里的其他线程来获取资源。\n\n### acquireShared(int)\n##### 此方法是共享模式下线程获取共享资源的顶层入口。它会获取指定量的资源，获取成功则直接返回，获取失败则进入等待队列，直到获取到资源为止，整个过程忽略中断。下面是acquireShared()的源码：\n```java\npublic final void acquireShared(int arg) {\n    if (tryAcquireShared(arg) < 0)\n        doAcquireShared(arg);\n}\n```\n\n##### 这里tryAcquireShared()依然需要自定义同步器去实现。但是AQS已经把其返回值的语义定义好了：负值代表获取失败；0代表获取成功，但没有剩余资源；正数表示获取成功，还有剩余资源，其他线程还可以去获取。所以这里acquireShared()的流程就是：\n\n1. tryAcquireShared()尝试获取资源，成功则直接返回；\n2. 失败则通过doAcquireShared()进入等待队列，直到获取到资源为止才返回。\n\n### doAcquireShared(int)\n##### 此方法用于将当前线程加入等待队列尾部休息，直到其他线程释放资源唤醒自己，自己成功拿到相应量的资源后才返回。下面是doAcquireShared()的源码：\n\n```java\nprivate void doAcquireShared(int arg) {\n    final Node node = addWaiter(Node.SHARED);//加入队列尾部\n    boolean failed = true;//是否成功标志\n    try {\n        boolean interrupted = false;//等待过程中是否被中断过的标志\n        for (;;) {\n            final Node p = node.predecessor();//前驱\n            if (p == head) {//如果到head的下一个，因为head是拿到资源的线程，此时node被唤醒，很可能是head用完资源来唤醒自己的\n                int r = tryAcquireShared(arg);//尝试获取资源\n                if (r >= 0) {//成功\n                    setHeadAndPropagate(node, r);//将head指向自己，还有剩余资源可以再唤醒之后的线程\n                    p.next = null; // help GC\n                    if (interrupted)//如果等待过程中被打断过，此时将中断补上。\n                        selfInterrupt();\n                    failed = false;\n                    return;\n                }\n            }\n            //判断状态，寻找安全点，进入waiting状态，等着被unpark()或interrupt()\n            if (shouldParkAfterFailedAcquire(p, node) &&\n                parkAndCheckInterrupt())\n                interrupted = true;\n        }\n    } finally {\n        if (failed)\n            cancelAcquire(node);\n    }\n}\n```\n\n##### 有木有觉得跟acquireQueued()很相似？对，其实流程并没有太大区别。只不过这里将补中断的selfInterrupt()放到doAcquireShared()里了，而独占模式是放到acquireQueued()之外，其实都一样，不知道Doug Lea是怎么想的。\n\n##### 跟独占模式比，还有一点需要注意的是，这里只有线程是head.next时（“老二”），才会去尝试获取资源，有剩余的话还会唤醒之后的队友。那么问题就来了，假如老大用完后释放了5个资源，而老二需要6个，老三需要1个，老四需要2个。老大先唤醒老二，老二一看资源不够，他是把资源让给老三呢，还是不让？答案是否定的！老二会继续park()等待其他线程释放资源，也更不会去唤醒老三和老四了。独占模式，同一时刻只有一个线程去执行，这样做未尝不可；但共享模式下，多个线程是可以同时执行的，现在因为老二的资源需求量大，而把后面量小的老三和老四也都卡住了。当然，这并不是问题，只是AQS保证严格按照入队顺序唤醒罢了（保证公平，但降低了并发）。\n\n### setHeadAndPropagate(Node, int)\n```java\nprivate void setHeadAndPropagate(Node node, int propagate) {\n    Node h = head;\n    setHead(node);//head指向自己\n     //如果还有剩余量，继续唤醒下一个邻居线程\n    if (propagate > 0 || h == null || h.waitStatus < 0) {\n        Node s = node.next;\n        if (s == null || s.isShared())\n            doReleaseShared();\n    }\n}\n```\n\n##### 此方法在setHead()的基础上多了一步，就是自己苏醒的同时，如果条件符合（比如还有剩余资源），还会去唤醒后继结点，毕竟是共享模式！\n##### doReleaseShared()我们留着下一小节的releaseShared()里来讲。\n\n### 小结\n##### OK，至此，acquireShared()也要告一段落了。让我们再梳理一下它的流程：\n\n1. tryAcquireShared()尝试获取资源，成功则直接返回；\n2. 失败则通过doAcquireShared()进入等待队列park()，直到被unpark()/interrupt()并成功获取到资源才返回。整个等待过程也是忽略中断的。\n　　\n##### 其实跟acquire()的流程大同小异，只不过多了个自己拿到资源后，还会去唤醒后继队友的操作（这才是共享嘛）。\n\n### releaseShared()\n##### 上一小节已经把acquireShared()说完了，这一小节就来讲讲它的反操作releaseShared()吧。此方法是共享模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果成功释放且允许唤醒等待线程，它会唤醒等待队列里的其他线程来获取资源。下面是releaseShared()的源码：\n\n```java\npublic final boolean releaseShared(int arg) {\n    if (tryReleaseShared(arg)) {//尝试释放资源\n        doReleaseShared();//唤醒后继结点\n        return true;\n    }\n    return false;\n}\n```\n\n##### 此方法的流程也比较简单，一句话：释放掉资源后，唤醒后继。跟独占模式下的release()相似，但有一点稍微需要注意：独占模式下的tryRelease()在完全释放掉资源（state=0）后，才会返回true去唤醒其他线程，这主要是基于独占下可重入的考量；而共享模式下的releaseShared()则没有这种要求，共享模式实质就是控制一定量的线程并发执行，那么拥有资源的线程在释放掉部分资源时就可以唤醒后继等待结点。例如，资源总量是13，A（5）和B（7）分别获取到资源并发运行，C（4）来时只剩1个资源就需要等待。A在运行过程中释放掉2个资源量，然后tryReleaseShared(2)返回true唤醒C，C一看只有3个仍不够继续等待；随后B又释放2个，tryReleaseShared(2)返回true唤醒C，C一看有5个够自己用了，然后C就可以跟A和B一起运行。而ReentrantReadWriteLock读锁的tryReleaseShared()只有在完全释放掉资源（state=0）才返回true，所以自定义同步器可以根据需要决定tryReleaseShared()的返回值。\n\n### doReleaseShared()\n##### 此方法主要用于唤醒后继。下面是它的源码：\n\n```java\nprivate void doReleaseShared() {\n    for (;;) {\n        Node h = head;\n        if (h != null && h != tail) {\n            int ws = h.waitStatus;\n            if (ws == Node.SIGNAL) {\n                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))\n                    continue;\n                unparkSuccessor(h);//唤醒后继\n            }\n            else if (ws == 0 &&\n                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))\n                continue;\n        }\n        if (h == head)// head发生变化\n            break;\n    }\n}\n```\n\n### 小结\n##### 本节我们详解了独占和共享两种模式下获取-释放资源(acquire-release、acquireShared-releaseShared)的源码，相信大家都有一定认识了。值得注意的是，acquire()和acquireSahred()两种方法下，线程在等待队列中都是忽略中断的。AQS也支持响应中断的，acquireInterruptibly()/acquireSharedInterruptibly()即是，这里相应的源码跟acquire()和acquireSahred()差不多，这里就不再详解了。\n\n## 简单应用\n##### OK，下面我们就以AQS源码里的Mutex为例，讲一下AQS的简单应用。\n### Mutex（互斥锁）\n##### Mutex是一个不可重入的互斥锁实现。锁资源（AQS里的state）只有两种状态：0表示未锁定，1表示锁定。下边是Mutex的核心源码：\n```java\nclass Mutex implements Lock, java.io.Serializable {\n    // 自定义同步器\n    private static class Sync extends AbstractQueuedSynchronizer {\n        // 判断是否锁定状态\n        protected boolean isHeldExclusively() {\n            return getState() == 1;\n        }\n        // 尝试获取资源，立即返回。成功则返回true，否则false。\n        public boolean tryAcquire(int acquires) {\n            assert acquires == 1; // 这里限定只能为1个量\n            if (compareAndSetState(0, 1)) {//state为0才设置为1，不可重入！\n                setExclusiveOwnerThread(Thread.currentThread());//设置为当前线程独占资源\n                return true;\n            }\n            return false;\n        }\n        // 尝试释放资源，立即返回。成功则为true，否则false。\n        protected boolean tryRelease(int releases) {\n            assert releases == 1; // 限定为1个量\n            if (getState() == 0)//既然来释放，那肯定就是已占有状态了。只是为了保险，多层判断！\n                throw new IllegalMonitorStateException();\n            setExclusiveOwnerThread(null);\n            setState(0);//释放资源，放弃占有状态\n            return true;\n        }\n    }\n    // 真正同步类的实现都依赖继承于AQS的自定义同步器！\n    private final Sync sync = new Sync();\n    //lock<-->acquire。两者语义一样：获取资源，即便等待，直到成功才返回。\n    public void lock() {\n        sync.acquire(1);\n    }\n    //tryLock<-->tryAcquire。两者语义一样：尝试获取资源，要求立即返回。成功则为true，失败则为false。\n    public boolean tryLock() {\n        return sync.tryAcquire(1);\n    }\n    //unlock<-->release。两者语文一样：释放资源。\n    public void unlock() {\n        sync.release(1);\n    }\n    //锁是否占有状态\n    public boolean isLocked() {\n        return sync.isHeldExclusively();\n    }\n}\n```\n\n##### 同步类在实现时一般都将自定义同步器（sync）定义为内部类，供自己使用；而同步类自己（Mutex）则实现某个接口，对外服务。当然，接口的实现要直接依赖sync，它们在语义上也存在某种对应关系！！而sync只用实现资源state的获取-释放方式tryAcquire-tryRelelase，至于线程的排队、等待、唤醒等，上层的AQS都已经实现好了，我们不用关心。\n\n##### 除了Mutex，ReentrantLock/CountDownLatch/Semphore这些同步类的实现方式都差不多，不同的地方就在获取-释放资源的方式tryAcquire-tryRelelase。掌握了这点，AQS的核心便被攻破了！\n\n##### OK，至此，整个AQS的讲解也要落下帷幕了。希望本文能够对学习Java并发编程的同学有所借鉴，中间写的有不对的地方，也欢迎讨论和指正~\n\n### 文章转载自：[https://www.cnblogs.com/waterystone/p/4920797.html](https://www.cnblogs.com/waterystone/p/4920797.html)","slug":"note/jdk/javaAQS","published":1,"updated":"2018-05-08T13:00:14.278Z","comments":1,"photos":[],"link":"","_id":"cjgxop3nl003kjah10brritcc","content":"<h5 id=\"Java的并发工具，我们常用的有ReentrantLock-Semaphore-CountDownLatch等工具，而这些工具类又是如何实现的呢？这就不得不提到AbstractQueuedSynchronizer类，也就是AQS！类如其名，抽象的队列式的同步器，AQS定义了一套多线程访问共享资源的同步器框架。\"><a href=\"#Java的并发工具，我们常用的有ReentrantLock-Semaphore-CountDownLatch等工具，而这些工具类又是如何实现的呢？这就不得不提到AbstractQueuedSynchronizer类，也就是AQS！类如其名，抽象的队列式的同步器，AQS定义了一套多线程访问共享资源的同步器框架。\" class=\"headerlink\" title=\"Java的并发工具，我们常用的有ReentrantLock/Semaphore/CountDownLatch等工具，而这些工具类又是如何实现的呢？这就不得不提到AbstractQueuedSynchronizer类，也就是AQS！类如其名，抽象的队列式的同步器，AQS定义了一套多线程访问共享资源的同步器框架。\"></a>Java的并发工具，我们常用的有ReentrantLock/Semaphore/CountDownLatch等工具，而这些工具类又是如何实现的呢？这就不得不提到AbstractQueuedSynchronizer类，也就是AQS！类如其名，抽象的队列式的同步器，AQS定义了一套多线程访问共享资源的同步器框架。</h5><a id=\"more\"></a>\n<h2 id=\"框架\"><a href=\"#框架\" class=\"headerlink\" title=\"框架\"></a>框架</h2><p><img src=\"/img/note/jdk/aqs.png\" alt=\"AQS队列\"> <div class=\"img-note\">AQS队列</div></p>\n<h5 id=\"AbstractQueuedSynchronizer类它维护了一个volatile-int-state（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列）。这里volatile是核心关键词，具体volatile的语义，在此不述。state的访问方式有三种\"><a href=\"#AbstractQueuedSynchronizer类它维护了一个volatile-int-state（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列）。这里volatile是核心关键词，具体volatile的语义，在此不述。state的访问方式有三种\" class=\"headerlink\" title=\"AbstractQueuedSynchronizer类它维护了一个volatile int state（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列）。这里volatile是核心关键词，具体volatile的语义，在此不述。state的访问方式有三种:\"></a><strong>AbstractQueuedSynchronizer</strong>类它维护了一个volatile int state（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列）。这里volatile是核心关键词，具体volatile的语义，在此不述。state的访问方式有三种:</h5><ul>\n<li>getState</li>\n<li>setState</li>\n<li>compareAndSetState</li>\n</ul>\n<h5 id=\"AQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore-CountDownLatch）。\"><a href=\"#AQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore-CountDownLatch）。\" class=\"headerlink\" title=\"AQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore/CountDownLatch）。\"></a>AQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore/CountDownLatch）。</h5><h5 id=\"不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队-唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：\"><a href=\"#不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队-唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：\" class=\"headerlink\" title=\"不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：\"></a>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：</h5><ul>\n<li><strong>isHeldExclusively()</strong>：该线程是否正在独占资源。只有用到condition才需要去实现它。</li>\n<li><strong>tryAcquire(int)</strong>：独占方式。尝试获取资源，成功则返回true，失败则返回false。</li>\n<li><strong>tryRelease(int)</strong>：独占方式。尝试释放资源，成功则返回true，失败则返回false。</li>\n<li><strong>tryAcquireShared(int)</strong>：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li>\n<li><strong>tryReleaseShared(int)</strong>：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</li>\n</ul>\n<h5 id=\"以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock-时，会调用tryAcquire-独占该锁并将state-1。此后，其他线程再tryAcquire-时就会失败，直到A线程unlock-到state-0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。\"><a href=\"#以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock-时，会调用tryAcquire-独占该锁并将state-1。此后，其他线程再tryAcquire-时就会失败，直到A线程unlock-到state-0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。\" class=\"headerlink\" title=\"以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。\"></a>以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。</h5><h5 id=\"再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown-一次，state会CAS减1。等到所有子线程都执行完后-即state-0-，会unpark-主调用线程，然后主调用线程就会从await-函数返回，继续后余动作。\"><a href=\"#再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown-一次，state会CAS减1。等到所有子线程都执行完后-即state-0-，会unpark-主调用线程，然后主调用线程就会从await-函数返回，继续后余动作。\" class=\"headerlink\" title=\"再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS减1。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。\"></a>再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS减1。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。</h5><h5 id=\"一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。\"><a href=\"#一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。\" class=\"headerlink\" title=\"一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。\"></a>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。</h5><h2 id=\"源码详解\"><a href=\"#源码详解\" class=\"headerlink\" title=\"源码详解\"></a>源码详解</h2><h3 id=\"acquire-int\"><a href=\"#acquire-int\" class=\"headerlink\" title=\"acquire(int)\"></a>acquire(int)</h3><h5 id=\"此方法是独占模式下线程获取共享资源的顶层入口。如果获取到资源，线程直接返回，否则进入等待队列，直到获取到资源为止，且整个过程忽略中断的影响。这也正是lock-的语义，当然不仅仅只限于lock-。获取到资源后，线程就可以去执行其临界区代码了。下面是acquire-的源码：\"><a href=\"#此方法是独占模式下线程获取共享资源的顶层入口。如果获取到资源，线程直接返回，否则进入等待队列，直到获取到资源为止，且整个过程忽略中断的影响。这也正是lock-的语义，当然不仅仅只限于lock-。获取到资源后，线程就可以去执行其临界区代码了。下面是acquire-的源码：\" class=\"headerlink\" title=\"此方法是独占模式下线程获取共享资源的顶层入口。如果获取到资源，线程直接返回，否则进入等待队列，直到获取到资源为止，且整个过程忽略中断的影响。这也正是lock()的语义，当然不仅仅只限于lock()。获取到资源后，线程就可以去执行其临界区代码了。下面是acquire()的源码：\"></a>此方法是独占模式下线程获取共享资源的顶层入口。如果获取到资源，线程直接返回，否则进入等待队列，直到获取到资源为止，且整个过程忽略中断的影响。这也正是lock()的语义，当然不仅仅只限于lock()。获取到资源后，线程就可以去执行其临界区代码了。下面是acquire()的源码：</h5><pre><code class=\"lang-java\">public final void acquire(int arg) {\n    if (!tryAcquire(arg) &amp;&amp;\n        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        selfInterrupt();\n}\n</code></pre>\n<h4 id=\"函数流程如下：\"><a href=\"#函数流程如下：\" class=\"headerlink\" title=\"函数流程如下：\"></a>函数流程如下：</h4><ol>\n<li>tryAcquire()尝试直接去获取资源，如果成功则直接返回；</li>\n<li>addWaiter()将该线程加入等待队列的尾部，并标记为独占模式；</li>\n<li>acquireQueued()使线程在等待队列中获取资源，一直获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。</li>\n<li>如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。</li>\n</ol>\n<h5 id=\"这时单凭这4个抽象的函数来看流程还有点朦胧，不要紧，看完接下来的分析后，你就会明白了。\"><a href=\"#这时单凭这4个抽象的函数来看流程还有点朦胧，不要紧，看完接下来的分析后，你就会明白了。\" class=\"headerlink\" title=\"这时单凭这4个抽象的函数来看流程还有点朦胧，不要紧，看完接下来的分析后，你就会明白了。\"></a>这时单凭这4个抽象的函数来看流程还有点朦胧，不要紧，看完接下来的分析后，你就会明白了。</h5><h3 id=\"tryAcquire-int\"><a href=\"#tryAcquire-int\" class=\"headerlink\" title=\"tryAcquire(int)\"></a>tryAcquire(int)</h3><h5 id=\"此方法尝试去获取独占资源。如果获取成功，则直接返回true，否则直接返回false。这也正是tryLock-的语义，还是那句话，当然不仅仅只限于tryLock-。如下是tryAcquire-的源码：\"><a href=\"#此方法尝试去获取独占资源。如果获取成功，则直接返回true，否则直接返回false。这也正是tryLock-的语义，还是那句话，当然不仅仅只限于tryLock-。如下是tryAcquire-的源码：\" class=\"headerlink\" title=\"此方法尝试去获取独占资源。如果获取成功，则直接返回true，否则直接返回false。这也正是tryLock()的语义，还是那句话，当然不仅仅只限于tryLock()。如下是tryAcquire()的源码：\"></a>此方法尝试去获取独占资源。如果获取成功，则直接返回true，否则直接返回false。这也正是tryLock()的语义，还是那句话，当然不仅仅只限于tryLock()。如下是tryAcquire()的源码：</h5><pre><code class=\"lang-java\">protected boolean tryAcquire(int arg) {\n    throw new UnsupportedOperationException();\n}\n</code></pre>\n<h5 id=\"什么？直接throw异常？说好的功能呢？好吧，还记得概述里讲的AQS只是一个框架，具体资源的获取-释放方式交由自定义同步器去实现吗？就是这里了！！！AQS这里只定义了一个接口，具体资源的获取交由自定义同步器去实现了（通过state的get-set-CAS）！！！至于能不能重入，能不能加塞，那就看具体的自定义同步器怎么去设计了！！！当然，自定义同步器在进行资源访问时要考虑线程安全的影响。\"><a href=\"#什么？直接throw异常？说好的功能呢？好吧，还记得概述里讲的AQS只是一个框架，具体资源的获取-释放方式交由自定义同步器去实现吗？就是这里了！！！AQS这里只定义了一个接口，具体资源的获取交由自定义同步器去实现了（通过state的get-set-CAS）！！！至于能不能重入，能不能加塞，那就看具体的自定义同步器怎么去设计了！！！当然，自定义同步器在进行资源访问时要考虑线程安全的影响。\" class=\"headerlink\" title=\"什么？直接throw异常？说好的功能呢？好吧，还记得概述里讲的AQS只是一个框架，具体资源的获取/释放方式交由自定义同步器去实现吗？就是这里了！！！AQS这里只定义了一个接口，具体资源的获取交由自定义同步器去实现了（通过state的get/set/CAS）！！！至于能不能重入，能不能加塞，那就看具体的自定义同步器怎么去设计了！！！当然，自定义同步器在进行资源访问时要考虑线程安全的影响。\"></a>什么？直接throw异常？说好的功能呢？好吧，还记得概述里讲的AQS只是一个框架，具体资源的获取/释放方式交由自定义同步器去实现吗？就是这里了！！！AQS这里只定义了一个接口，具体资源的获取交由自定义同步器去实现了（通过state的get/set/CAS）！！！至于能不能重入，能不能加塞，那就看具体的自定义同步器怎么去设计了！！！当然，自定义同步器在进行资源访问时要考虑线程安全的影响。</h5><h5 id=\"这里之所以没有定义成abstract，是因为独占模式下只用实现tryAcquire-tryRelease，而共享模式下只用实现tryAcquireShared-tryReleaseShared。如果都定义成abstract，那么每个模式也要去实现另一模式下的接口。说到底，Doug-Lea还是站在咱们开发者的角度，尽量减少不必要的工作量。\"><a href=\"#这里之所以没有定义成abstract，是因为独占模式下只用实现tryAcquire-tryRelease，而共享模式下只用实现tryAcquireShared-tryReleaseShared。如果都定义成abstract，那么每个模式也要去实现另一模式下的接口。说到底，Doug-Lea还是站在咱们开发者的角度，尽量减少不必要的工作量。\" class=\"headerlink\" title=\"这里之所以没有定义成abstract，是因为独占模式下只用实现tryAcquire-tryRelease，而共享模式下只用实现tryAcquireShared-tryReleaseShared。如果都定义成abstract，那么每个模式也要去实现另一模式下的接口。说到底，Doug Lea还是站在咱们开发者的角度，尽量减少不必要的工作量。\"></a>这里之所以没有定义成abstract，是因为独占模式下只用实现tryAcquire-tryRelease，而共享模式下只用实现tryAcquireShared-tryReleaseShared。如果都定义成abstract，那么每个模式也要去实现另一模式下的接口。说到底，Doug Lea还是站在咱们开发者的角度，尽量减少不必要的工作量。</h5><h3 id=\"addWaiter-Node\"><a href=\"#addWaiter-Node\" class=\"headerlink\" title=\"addWaiter(Node)\"></a>addWaiter(Node)</h3><h5 id=\"此方法用于将当前线程加入到等待队列的队尾，并返回当前线程所在的结点。还是上源码吧：\"><a href=\"#此方法用于将当前线程加入到等待队列的队尾，并返回当前线程所在的结点。还是上源码吧：\" class=\"headerlink\" title=\"此方法用于将当前线程加入到等待队列的队尾，并返回当前线程所在的结点。还是上源码吧：\"></a>此方法用于将当前线程加入到等待队列的队尾，并返回当前线程所在的结点。还是上源码吧：</h5><pre><code class=\"lang-java\">private Node addWaiter(Node mode) {\n    //以给定模式构造结点。mode有两种：EXCLUSIVE（独占）和SHARED（共享）\n    Node node = new Node(Thread.currentThread(), mode);\n    //尝试快速方式直接放到队尾。\n    Node pred = tail;\n    if (pred != null) {\n        node.prev = pred;\n        if (compareAndSetTail(pred, node)) {\n            pred.next = node;\n            return node;\n        }\n    }\n    //上一步失败则通过enq入队。\n    enq(node);\n    return node;\n}\n</code></pre>\n<h3 id=\"enq-Node\"><a href=\"#enq-Node\" class=\"headerlink\" title=\"enq(Node)\"></a>enq(Node)</h3><h5 id=\"此方法用于将node加入队尾。源码如下：\"><a href=\"#此方法用于将node加入队尾。源码如下：\" class=\"headerlink\" title=\"此方法用于将node加入队尾。源码如下：\"></a>此方法用于将node加入队尾。源码如下：</h5><pre><code class=\"lang-java\">private Node enq(final Node node) {\n    //CAS&quot;自旋&quot;，直到成功加入队尾\n    for (;;) {\n        Node t = tail;\n        if (t == null) { // 队列为空，创建一个空的标志结点作为head结点，并将tail也指向它。\n            if (compareAndSetHead(new Node()))\n                tail = head;\n        } else {//正常流程，放入队尾\n            node.prev = t;\n            if (compareAndSetTail(t, node)) {\n                t.next = node;\n                return t;\n            }\n        }\n    }\n}\n</code></pre>\n<h5 id=\"如果你看过AtomicInteger-getAndIncrement-函数源码，那么相信你一眼便看出这段代码的精华。CAS自旋volatile变量，是一种很经典的用法。还不太了解的，自己去百度一下吧。\"><a href=\"#如果你看过AtomicInteger-getAndIncrement-函数源码，那么相信你一眼便看出这段代码的精华。CAS自旋volatile变量，是一种很经典的用法。还不太了解的，自己去百度一下吧。\" class=\"headerlink\" title=\"如果你看过AtomicInteger.getAndIncrement()函数源码，那么相信你一眼便看出这段代码的精华。CAS自旋volatile变量，是一种很经典的用法。还不太了解的，自己去百度一下吧。\"></a>如果你看过AtomicInteger.getAndIncrement()函数源码，那么相信你一眼便看出这段代码的精华。CAS自旋volatile变量，是一种很经典的用法。还不太了解的，自己去百度一下吧。</h5><h3 id=\"acquireQueued-Node-int\"><a href=\"#acquireQueued-Node-int\" class=\"headerlink\" title=\"acquireQueued(Node, int)\"></a>acquireQueued(Node, int)</h3><h5 id=\"OK，通过tryAcquire-和addWaiter-，该线程获取资源失败，已经被放入等待队列尾部了。聪明的你立刻应该能想到该线程下一部该干什么了吧：进入等待状态休息，直到其他线程彻底释放资源后唤醒自己，自己再拿到资源，然后就可以去干自己想干的事了。没错，就是这样！是不是跟医院排队拿号有点相似-acquireQueued-就是干这件事：在等待队列中排队拿号（中间没其它事干可以休息），直到拿到号后再返回。这个函数非常关键，还是上源码吧：\"><a href=\"#OK，通过tryAcquire-和addWaiter-，该线程获取资源失败，已经被放入等待队列尾部了。聪明的你立刻应该能想到该线程下一部该干什么了吧：进入等待状态休息，直到其他线程彻底释放资源后唤醒自己，自己再拿到资源，然后就可以去干自己想干的事了。没错，就是这样！是不是跟医院排队拿号有点相似-acquireQueued-就是干这件事：在等待队列中排队拿号（中间没其它事干可以休息），直到拿到号后再返回。这个函数非常关键，还是上源码吧：\" class=\"headerlink\" title=\"OK，通过tryAcquire()和addWaiter()，该线程获取资源失败，已经被放入等待队列尾部了。聪明的你立刻应该能想到该线程下一部该干什么了吧：进入等待状态休息，直到其他线程彻底释放资源后唤醒自己，自己再拿到资源，然后就可以去干自己想干的事了。没错，就是这样！是不是跟医院排队拿号有点相似~~acquireQueued()就是干这件事：在等待队列中排队拿号（中间没其它事干可以休息），直到拿到号后再返回。这个函数非常关键，还是上源码吧：\"></a>OK，通过tryAcquire()和addWaiter()，该线程获取资源失败，已经被放入等待队列尾部了。聪明的你立刻应该能想到该线程下一部该干什么了吧：进入等待状态休息，直到其他线程彻底释放资源后唤醒自己，自己再拿到资源，然后就可以去干自己想干的事了。没错，就是这样！是不是跟医院排队拿号有点相似~~acquireQueued()就是干这件事：在等待队列中排队拿号（中间没其它事干可以休息），直到拿到号后再返回。这个函数非常关键，还是上源码吧：</h5><pre><code class=\"lang-java\">final boolean acquireQueued(final Node node, int arg) {\n    boolean failed = true;//标记是否成功拿到资源\n    try {\n        boolean interrupted = false;//标记等待过程中是否被中断过\n        //又是一个“自旋”！\n        for (;;) {\n            final Node p = node.predecessor();//拿到前驱\n            //如果前驱是head，即该结点已成老二，那么便有资格去尝试获取资源（可能是老大释放完资源唤醒自己的，当然也可能被interrupt了）。\n            if (p == head &amp;&amp; tryAcquire(arg)) {\n                setHead(node);//拿到资源后，将head指向该结点。所以head所指的标杆结点，就是当前获取到资源的那个结点或null。\n                p.next = null; // setHead中node.prev已置为null，此处再将head.next置为null，就是为了方便GC回收以前的head结点。也就意味着之前拿完资源的结点出队了！\n                failed = false;\n                return interrupted;//返回等待过程中是否被中断过\n            }\n            //如果自己可以休息了，就进入waiting状态，直到被unpark()\n            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;\n                parkAndCheckInterrupt())\n                interrupted = true;//如果等待过程中被中断过，哪怕只有那么一次，就将interrupted标记为true\n        }\n    } finally {\n        if (failed)\n            cancelAcquire(node);\n    }\n}\n</code></pre>\n<h5 id=\"到这里了，我们先不急着总结acquireQueued-的函数流程，先看看shouldParkAfterFailedAcquire-和parkAndCheckInterrupt-具体干些什么。\"><a href=\"#到这里了，我们先不急着总结acquireQueued-的函数流程，先看看shouldParkAfterFailedAcquire-和parkAndCheckInterrupt-具体干些什么。\" class=\"headerlink\" title=\"到这里了，我们先不急着总结acquireQueued()的函数流程，先看看shouldParkAfterFailedAcquire()和parkAndCheckInterrupt()具体干些什么。\"></a>到这里了，我们先不急着总结acquireQueued()的函数流程，先看看shouldParkAfterFailedAcquire()和parkAndCheckInterrupt()具体干些什么。</h5><h3 id=\"shouldParkAfterFailedAcquire-Node-Node\"><a href=\"#shouldParkAfterFailedAcquire-Node-Node\" class=\"headerlink\" title=\"shouldParkAfterFailedAcquire(Node, Node)\"></a>shouldParkAfterFailedAcquire(Node, Node)</h3><h5 id=\"此方法主要用于检查状态，看看自己是否真的可以去休息了（进入waiting状态，如果线程状态转换不熟，可以参考本人上一篇写的Thread详解），万一队列前边的线程都放弃了只是瞎站着，那也说不定，对吧！\"><a href=\"#此方法主要用于检查状态，看看自己是否真的可以去休息了（进入waiting状态，如果线程状态转换不熟，可以参考本人上一篇写的Thread详解），万一队列前边的线程都放弃了只是瞎站着，那也说不定，对吧！\" class=\"headerlink\" title=\"此方法主要用于检查状态，看看自己是否真的可以去休息了（进入waiting状态，如果线程状态转换不熟，可以参考本人上一篇写的Thread详解），万一队列前边的线程都放弃了只是瞎站着，那也说不定，对吧！\"></a>此方法主要用于检查状态，看看自己是否真的可以去休息了（进入waiting状态，如果线程状态转换不熟，可以参考本人上一篇写的Thread详解），万一队列前边的线程都放弃了只是瞎站着，那也说不定，对吧！</h5><pre><code class=\"lang-java\">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {\n    int ws = pred.waitStatus;//拿到前驱的状态\n    if (ws == Node.SIGNAL)\n        //如果已经告诉前驱拿完号后通知自己一下，那就可以安心休息了\n        return true;\n    if (ws &gt; 0) {\n        /*\n         * 如果前驱放弃了，那就一直往前找，直到找到最近一个正常等待的状态，并排在它的后边。\n         * 注意：那些放弃的结点，由于被自己“加塞”到它们前边，它们相当于形成一个无引用链，稍后就会被保安大叔赶走了(GC回收)！\n         */\n        do {\n            node.prev = pred = pred.prev;\n        } while (pred.waitStatus &gt; 0);\n        pred.next = node;\n    } else {\n         //如果前驱正常，那就把前驱的状态设置成SIGNAL，告诉它拿完号后通知自己一下。有可能失败，人家说不定刚刚释放完呢！\n        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);\n    }\n    return false;\n}\n</code></pre>\n<h5 id=\"整个流程中，如果前驱结点的状态不是SIGNAL，那么自己就不能安心去休息，需要去找个安心的休息点，同时可以再尝试下看有没有机会轮到自己拿号。\"><a href=\"#整个流程中，如果前驱结点的状态不是SIGNAL，那么自己就不能安心去休息，需要去找个安心的休息点，同时可以再尝试下看有没有机会轮到自己拿号。\" class=\"headerlink\" title=\"整个流程中，如果前驱结点的状态不是SIGNAL，那么自己就不能安心去休息，需要去找个安心的休息点，同时可以再尝试下看有没有机会轮到自己拿号。\"></a>整个流程中，如果前驱结点的状态不是SIGNAL，那么自己就不能安心去休息，需要去找个安心的休息点，同时可以再尝试下看有没有机会轮到自己拿号。</h5><h3 id=\"parkAndCheckInterrupt\"><a href=\"#parkAndCheckInterrupt\" class=\"headerlink\" title=\"parkAndCheckInterrupt()\"></a>parkAndCheckInterrupt()</h3><h5 id=\"如果线程找好安全休息点后，那就可以安心去休息了。此方法就是让线程去休息，真正进入等待状态。\"><a href=\"#如果线程找好安全休息点后，那就可以安心去休息了。此方法就是让线程去休息，真正进入等待状态。\" class=\"headerlink\" title=\"如果线程找好安全休息点后，那就可以安心去休息了。此方法就是让线程去休息，真正进入等待状态。\"></a>如果线程找好安全休息点后，那就可以安心去休息了。此方法就是让线程去休息，真正进入等待状态。</h5><pre><code class=\"lang-java\">private final boolean parkAndCheckInterrupt() {\n    LockSupport.park(this);//调用park()使线程进入waiting状态\n    return Thread.interrupted();//如果被唤醒，查看自己是不是被中断的。\n}\n</code></pre>\n<h5 id=\"park-会让当前线程进入waiting状态。在此状态下，有两种途径可以唤醒该线程：1）被unpark-；2）被interrupt-。（再说一句，如果线程状态转换不熟，可以参考本人写的Thread详解）。需要注意的是，Thread-interrupted-会清除当前线程的中断标记位。\"><a href=\"#park-会让当前线程进入waiting状态。在此状态下，有两种途径可以唤醒该线程：1）被unpark-；2）被interrupt-。（再说一句，如果线程状态转换不熟，可以参考本人写的Thread详解）。需要注意的是，Thread-interrupted-会清除当前线程的中断标记位。\" class=\"headerlink\" title=\"park()会让当前线程进入waiting状态。在此状态下，有两种途径可以唤醒该线程：1）被unpark()；2）被interrupt()。（再说一句，如果线程状态转换不熟，可以参考本人写的Thread详解）。需要注意的是，Thread.interrupted()会清除当前线程的中断标记位。\"></a>park()会让当前线程进入waiting状态。在此状态下，有两种途径可以唤醒该线程：1）被unpark()；2）被interrupt()。（再说一句，如果线程状态转换不熟，可以参考本人写的Thread详解）。需要注意的是，Thread.interrupted()会清除当前线程的中断标记位。</h5><h4 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h4><h5 id=\"OK，看了shouldParkAfterFailedAcquire-和parkAndCheckInterrupt-，现在让我们再回到acquireQueued-，总结下该函数的具体流程：\"><a href=\"#OK，看了shouldParkAfterFailedAcquire-和parkAndCheckInterrupt-，现在让我们再回到acquireQueued-，总结下该函数的具体流程：\" class=\"headerlink\" title=\"OK，看了shouldParkAfterFailedAcquire()和parkAndCheckInterrupt()，现在让我们再回到acquireQueued()，总结下该函数的具体流程：\"></a>OK，看了shouldParkAfterFailedAcquire()和parkAndCheckInterrupt()，现在让我们再回到acquireQueued()，总结下该函数的具体流程：</h5><ol>\n<li>结点进入队尾后，检查状态，找到安全休息点；</li>\n<li>调用park()进入waiting状态，等待unpark()或interrupt()唤醒自己；</li>\n<li>被唤醒后，看自己是不是有资格能拿到号。如果拿到，head指向当前结点，并返回从入队到拿到号的整个过程中是否被中断过；如果没拿到，继续流程1。</li>\n</ol>\n<h3 id=\"小结-1\"><a href=\"#小结-1\" class=\"headerlink\" title=\"小结\"></a>小结</h3><h5 id=\"OKOK，acquireQueued-分析完之后，我们接下来再回到acquire-！再贴上它的源码吧：\"><a href=\"#OKOK，acquireQueued-分析完之后，我们接下来再回到acquire-！再贴上它的源码吧：\" class=\"headerlink\" title=\"OKOK，acquireQueued()分析完之后，我们接下来再回到acquire()！再贴上它的源码吧：\"></a>OKOK，acquireQueued()分析完之后，我们接下来再回到acquire()！再贴上它的源码吧：</h5><pre><code class=\"lang-java\">public final void acquire(int arg) {\n    if (!tryAcquire(arg) &amp;&amp;\n        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        selfInterrupt();\n}\n</code></pre>\n<h5 id=\"再来总结下它的流程吧：\"><a href=\"#再来总结下它的流程吧：\" class=\"headerlink\" title=\"再来总结下它的流程吧：\"></a>再来总结下它的流程吧：</h5><ol>\n<li>调用自定义同步器的tryAcquire()尝试直接去获取资源，如果成功则直接返回；</li>\n<li>没成功，则addWaiter()将该线程加入等待队列的尾部，并标记为独占模式；</li>\n<li>acquireQueued()使线程在等待队列中休息，有机会时（轮到自己，会被unpark()）会去尝试获取资源。获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。</li>\n<li>如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。</li>\n</ol>\n<h5 id=\"由于此函数是重中之重，我再用流程图总结一下：\"><a href=\"#由于此函数是重中之重，我再用流程图总结一下：\" class=\"headerlink\" title=\"由于此函数是重中之重，我再用流程图总结一下：\"></a>由于此函数是重中之重，我再用流程图总结一下：</h5><p><img src=\"/img/note/jdk/aqs1.png\" alt=\"AQS队列\"></p>\n<h5 id=\"至此，acquire-的流程终于算是告一段落了。这也就是ReentrantLock-lock-的流程，不信你去看其lock-源码吧，整个函数就是一条acquire-1-！！！\"><a href=\"#至此，acquire-的流程终于算是告一段落了。这也就是ReentrantLock-lock-的流程，不信你去看其lock-源码吧，整个函数就是一条acquire-1-！！！\" class=\"headerlink\" title=\"至此，acquire()的流程终于算是告一段落了。这也就是ReentrantLock.lock()的流程，不信你去看其lock()源码吧，整个函数就是一条acquire(1)！！！\"></a>至此，acquire()的流程终于算是告一段落了。这也就是ReentrantLock.lock()的流程，不信你去看其lock()源码吧，整个函数就是一条acquire(1)！！！</h5><h3 id=\"release-int\"><a href=\"#release-int\" class=\"headerlink\" title=\"release(int)\"></a>release(int)</h3><h5 id=\"上一小节已经把acquire-说完了，这一小节就来讲讲它的反操作release-吧。此方法是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state-0）-它会唤醒等待队列里的其他线程来获取资源。这也正是unlock-的语义，当然不仅仅只限于unlock-。下面是release-的源码：\"><a href=\"#上一小节已经把acquire-说完了，这一小节就来讲讲它的反操作release-吧。此方法是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state-0）-它会唤醒等待队列里的其他线程来获取资源。这也正是unlock-的语义，当然不仅仅只限于unlock-。下面是release-的源码：\" class=\"headerlink\" title=\"上一小节已经把acquire()说完了，这一小节就来讲讲它的反操作release()吧。此方法是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state=0）,它会唤醒等待队列里的其他线程来获取资源。这也正是unlock()的语义，当然不仅仅只限于unlock()。下面是release()的源码：\"></a>上一小节已经把acquire()说完了，这一小节就来讲讲它的反操作release()吧。此方法是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state=0）,它会唤醒等待队列里的其他线程来获取资源。这也正是unlock()的语义，当然不仅仅只限于unlock()。下面是release()的源码：</h5><pre><code class=\"lang-java\">public final boolean release(int arg) {\n    if (tryRelease(arg)) {\n        Node h = head;//找到头结点\n        if (h != null &amp;&amp; h.waitStatus != 0)\n            unparkSuccessor(h);//唤醒等待队列里的下一个线程\n        return true;\n    }\n    return false;\n}\n</code></pre>\n<h5 id=\"逻辑并不复杂。它调用tryRelease-来释放资源。有一点需要注意的是，它是根据tryRelease-的返回值来判断该线程是否已经完成释放掉资源了！所以自定义同步器在设计tryRelease-的时候要明确这一点！！\"><a href=\"#逻辑并不复杂。它调用tryRelease-来释放资源。有一点需要注意的是，它是根据tryRelease-的返回值来判断该线程是否已经完成释放掉资源了！所以自定义同步器在设计tryRelease-的时候要明确这一点！！\" class=\"headerlink\" title=\"逻辑并不复杂。它调用tryRelease()来释放资源。有一点需要注意的是，它是根据tryRelease()的返回值来判断该线程是否已经完成释放掉资源了！所以自定义同步器在设计tryRelease()的时候要明确这一点！！\"></a>逻辑并不复杂。它调用tryRelease()来释放资源。有一点需要注意的是，它是根据tryRelease()的返回值来判断该线程是否已经完成释放掉资源了！所以自定义同步器在设计tryRelease()的时候要明确这一点！！</h5><h3 id=\"tryRelease-int\"><a href=\"#tryRelease-int\" class=\"headerlink\" title=\"tryRelease(int)\"></a>tryRelease(int)</h3><h5 id=\"此方法尝试去释放指定量的资源。下面是tryRelease-的源码：\"><a href=\"#此方法尝试去释放指定量的资源。下面是tryRelease-的源码：\" class=\"headerlink\" title=\"此方法尝试去释放指定量的资源。下面是tryRelease()的源码：\"></a>此方法尝试去释放指定量的资源。下面是tryRelease()的源码：</h5><pre><code class=\"lang-java\">protected boolean tryRelease(int arg) {\n    throw new UnsupportedOperationException();\n}\n</code></pre>\n<h5 id=\"跟tryAcquire-一样，这个方法是需要独占模式的自定义同步器去实现的。正常来说，tryRelease-都会成功的，因为这是独占模式，该线程来释放资源，那么它肯定已经拿到独占资源了，直接减掉相应量的资源即可-state-arg-，也不需要考虑线程安全的问题。但要注意它的返回值，上面已经提到了，release-是根据tryRelease-的返回值来判断该线程是否已经完成释放掉资源了！所以自义定同步器在实现时，如果已经彻底释放资源-state-0-，要返回true，否则返回false。\"><a href=\"#跟tryAcquire-一样，这个方法是需要独占模式的自定义同步器去实现的。正常来说，tryRelease-都会成功的，因为这是独占模式，该线程来释放资源，那么它肯定已经拿到独占资源了，直接减掉相应量的资源即可-state-arg-，也不需要考虑线程安全的问题。但要注意它的返回值，上面已经提到了，release-是根据tryRelease-的返回值来判断该线程是否已经完成释放掉资源了！所以自义定同步器在实现时，如果已经彻底释放资源-state-0-，要返回true，否则返回false。\" class=\"headerlink\" title=\"跟tryAcquire()一样，这个方法是需要独占模式的自定义同步器去实现的。正常来说，tryRelease()都会成功的，因为这是独占模式，该线程来释放资源，那么它肯定已经拿到独占资源了，直接减掉相应量的资源即可(state-=arg)，也不需要考虑线程安全的问题。但要注意它的返回值，上面已经提到了，release()是根据tryRelease()的返回值来判断该线程是否已经完成释放掉资源了！所以自义定同步器在实现时，如果已经彻底释放资源(state=0)，要返回true，否则返回false。\"></a>跟tryAcquire()一样，这个方法是需要独占模式的自定义同步器去实现的。正常来说，tryRelease()都会成功的，因为这是独占模式，该线程来释放资源，那么它肯定已经拿到独占资源了，直接减掉相应量的资源即可(state-=arg)，也不需要考虑线程安全的问题。但要注意它的返回值，上面已经提到了，release()是根据tryRelease()的返回值来判断该线程是否已经完成释放掉资源了！所以自义定同步器在实现时，如果已经彻底释放资源(state=0)，要返回true，否则返回false。</h5><h3 id=\"unparkSuccessor-Node\"><a href=\"#unparkSuccessor-Node\" class=\"headerlink\" title=\"unparkSuccessor(Node)\"></a>unparkSuccessor(Node)</h3><h5 id=\"此方法用于唤醒等待队列中下一个线程。下面是源码：\"><a href=\"#此方法用于唤醒等待队列中下一个线程。下面是源码：\" class=\"headerlink\" title=\"此方法用于唤醒等待队列中下一个线程。下面是源码：\"></a>此方法用于唤醒等待队列中下一个线程。下面是源码：</h5><pre><code class=\"lang-java\">private void unparkSuccessor(Node node) {\n    //这里，node一般为当前线程所在的结点。\n    int ws = node.waitStatus;\n    if (ws &lt; 0)//置零当前线程所在的结点状态，允许失败。\n        compareAndSetWaitStatus(node, ws, 0);\n    Node s = node.next;//找到下一个需要唤醒的结点s\n    if (s == null || s.waitStatus &gt; 0) {//如果为空或已取消\n        s = null;\n        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)\n            if (t.waitStatus &lt;= 0)//从这里可以看出，&lt;=0的结点，都是还有效的结点。\n                s = t;\n    }\n    if (s != null)\n        LockSupport.unpark(s.thread);//唤醒\n}\n</code></pre>\n<h5 id=\"这个函数并不复杂。一句话概括：用unpark-唤醒等待队列中最前边的那个未放弃线程，这里我们也用s来表示吧。此时，再和acquireQueued-联系起来，s被唤醒后，进入if-p-head-amp-amp-tryAcquire-arg-的判断（即使p-head也没关系，它会再进入shouldParkAfterFailedAcquire-寻找一个安全点。这里既然s已经是等待队列中最前边的那个未放弃线程了，那么通过shouldParkAfterFailedAcquire-的调整，s也必然会跑到head的next结点，下一次自旋p-head就成立啦），然后s把自己设置成head标杆结点，表示自己已经获取到资源了，acquire-也返回了！！And-then-DO-what-you-WANT\"><a href=\"#这个函数并不复杂。一句话概括：用unpark-唤醒等待队列中最前边的那个未放弃线程，这里我们也用s来表示吧。此时，再和acquireQueued-联系起来，s被唤醒后，进入if-p-head-amp-amp-tryAcquire-arg-的判断（即使p-head也没关系，它会再进入shouldParkAfterFailedAcquire-寻找一个安全点。这里既然s已经是等待队列中最前边的那个未放弃线程了，那么通过shouldParkAfterFailedAcquire-的调整，s也必然会跑到head的next结点，下一次自旋p-head就成立啦），然后s把自己设置成head标杆结点，表示自己已经获取到资源了，acquire-也返回了！！And-then-DO-what-you-WANT\" class=\"headerlink\" title=\"这个函数并不复杂。一句话概括：用unpark()唤醒等待队列中最前边的那个未放弃线程，这里我们也用s来表示吧。此时，再和acquireQueued()联系起来，s被唤醒后，进入if (p == head &amp;&amp; tryAcquire(arg))的判断（即使p!=head也没关系，它会再进入shouldParkAfterFailedAcquire()寻找一个安全点。这里既然s已经是等待队列中最前边的那个未放弃线程了，那么通过shouldParkAfterFailedAcquire()的调整，s也必然会跑到head的next结点，下一次自旋p==head就成立啦），然后s把自己设置成head标杆结点，表示自己已经获取到资源了，acquire()也返回了！！And then, DO what you WANT!\"></a>这个函数并不复杂。一句话概括：用unpark()唤醒等待队列中最前边的那个未放弃线程，这里我们也用s来表示吧。此时，再和acquireQueued()联系起来，s被唤醒后，进入if (p == head &amp;&amp; tryAcquire(arg))的判断（即使p!=head也没关系，它会再进入shouldParkAfterFailedAcquire()寻找一个安全点。这里既然s已经是等待队列中最前边的那个未放弃线程了，那么通过shouldParkAfterFailedAcquire()的调整，s也必然会跑到head的next结点，下一次自旋p==head就成立啦），然后s把自己设置成head标杆结点，表示自己已经获取到资源了，acquire()也返回了！！And then, DO what you WANT!</h5><h3 id=\"小结-2\"><a href=\"#小结-2\" class=\"headerlink\" title=\"小结\"></a>小结</h3><h5 id=\"release-是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state-0）-它会唤醒等待队列里的其他线程来获取资源。\"><a href=\"#release-是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state-0）-它会唤醒等待队列里的其他线程来获取资源。\" class=\"headerlink\" title=\"release()是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state=0）,它会唤醒等待队列里的其他线程来获取资源。\"></a>release()是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state=0）,它会唤醒等待队列里的其他线程来获取资源。</h5><h3 id=\"acquireShared-int\"><a href=\"#acquireShared-int\" class=\"headerlink\" title=\"acquireShared(int)\"></a>acquireShared(int)</h3><h5 id=\"此方法是共享模式下线程获取共享资源的顶层入口。它会获取指定量的资源，获取成功则直接返回，获取失败则进入等待队列，直到获取到资源为止，整个过程忽略中断。下面是acquireShared-的源码：\"><a href=\"#此方法是共享模式下线程获取共享资源的顶层入口。它会获取指定量的资源，获取成功则直接返回，获取失败则进入等待队列，直到获取到资源为止，整个过程忽略中断。下面是acquireShared-的源码：\" class=\"headerlink\" title=\"此方法是共享模式下线程获取共享资源的顶层入口。它会获取指定量的资源，获取成功则直接返回，获取失败则进入等待队列，直到获取到资源为止，整个过程忽略中断。下面是acquireShared()的源码：\"></a>此方法是共享模式下线程获取共享资源的顶层入口。它会获取指定量的资源，获取成功则直接返回，获取失败则进入等待队列，直到获取到资源为止，整个过程忽略中断。下面是acquireShared()的源码：</h5><pre><code class=\"lang-java\">public final void acquireShared(int arg) {\n    if (tryAcquireShared(arg) &lt; 0)\n        doAcquireShared(arg);\n}\n</code></pre>\n<h5 id=\"这里tryAcquireShared-依然需要自定义同步器去实现。但是AQS已经把其返回值的语义定义好了：负值代表获取失败；0代表获取成功，但没有剩余资源；正数表示获取成功，还有剩余资源，其他线程还可以去获取。所以这里acquireShared-的流程就是：\"><a href=\"#这里tryAcquireShared-依然需要自定义同步器去实现。但是AQS已经把其返回值的语义定义好了：负值代表获取失败；0代表获取成功，但没有剩余资源；正数表示获取成功，还有剩余资源，其他线程还可以去获取。所以这里acquireShared-的流程就是：\" class=\"headerlink\" title=\"这里tryAcquireShared()依然需要自定义同步器去实现。但是AQS已经把其返回值的语义定义好了：负值代表获取失败；0代表获取成功，但没有剩余资源；正数表示获取成功，还有剩余资源，其他线程还可以去获取。所以这里acquireShared()的流程就是：\"></a>这里tryAcquireShared()依然需要自定义同步器去实现。但是AQS已经把其返回值的语义定义好了：负值代表获取失败；0代表获取成功，但没有剩余资源；正数表示获取成功，还有剩余资源，其他线程还可以去获取。所以这里acquireShared()的流程就是：</h5><ol>\n<li>tryAcquireShared()尝试获取资源，成功则直接返回；</li>\n<li>失败则通过doAcquireShared()进入等待队列，直到获取到资源为止才返回。</li>\n</ol>\n<h3 id=\"doAcquireShared-int\"><a href=\"#doAcquireShared-int\" class=\"headerlink\" title=\"doAcquireShared(int)\"></a>doAcquireShared(int)</h3><h5 id=\"此方法用于将当前线程加入等待队列尾部休息，直到其他线程释放资源唤醒自己，自己成功拿到相应量的资源后才返回。下面是doAcquireShared-的源码：\"><a href=\"#此方法用于将当前线程加入等待队列尾部休息，直到其他线程释放资源唤醒自己，自己成功拿到相应量的资源后才返回。下面是doAcquireShared-的源码：\" class=\"headerlink\" title=\"此方法用于将当前线程加入等待队列尾部休息，直到其他线程释放资源唤醒自己，自己成功拿到相应量的资源后才返回。下面是doAcquireShared()的源码：\"></a>此方法用于将当前线程加入等待队列尾部休息，直到其他线程释放资源唤醒自己，自己成功拿到相应量的资源后才返回。下面是doAcquireShared()的源码：</h5><pre><code class=\"lang-java\">private void doAcquireShared(int arg) {\n    final Node node = addWaiter(Node.SHARED);//加入队列尾部\n    boolean failed = true;//是否成功标志\n    try {\n        boolean interrupted = false;//等待过程中是否被中断过的标志\n        for (;;) {\n            final Node p = node.predecessor();//前驱\n            if (p == head) {//如果到head的下一个，因为head是拿到资源的线程，此时node被唤醒，很可能是head用完资源来唤醒自己的\n                int r = tryAcquireShared(arg);//尝试获取资源\n                if (r &gt;= 0) {//成功\n                    setHeadAndPropagate(node, r);//将head指向自己，还有剩余资源可以再唤醒之后的线程\n                    p.next = null; // help GC\n                    if (interrupted)//如果等待过程中被打断过，此时将中断补上。\n                        selfInterrupt();\n                    failed = false;\n                    return;\n                }\n            }\n            //判断状态，寻找安全点，进入waiting状态，等着被unpark()或interrupt()\n            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;\n                parkAndCheckInterrupt())\n                interrupted = true;\n        }\n    } finally {\n        if (failed)\n            cancelAcquire(node);\n    }\n}\n</code></pre>\n<h5 id=\"有木有觉得跟acquireQueued-很相似？对，其实流程并没有太大区别。只不过这里将补中断的selfInterrupt-放到doAcquireShared-里了，而独占模式是放到acquireQueued-之外，其实都一样，不知道Doug-Lea是怎么想的。\"><a href=\"#有木有觉得跟acquireQueued-很相似？对，其实流程并没有太大区别。只不过这里将补中断的selfInterrupt-放到doAcquireShared-里了，而独占模式是放到acquireQueued-之外，其实都一样，不知道Doug-Lea是怎么想的。\" class=\"headerlink\" title=\"有木有觉得跟acquireQueued()很相似？对，其实流程并没有太大区别。只不过这里将补中断的selfInterrupt()放到doAcquireShared()里了，而独占模式是放到acquireQueued()之外，其实都一样，不知道Doug Lea是怎么想的。\"></a>有木有觉得跟acquireQueued()很相似？对，其实流程并没有太大区别。只不过这里将补中断的selfInterrupt()放到doAcquireShared()里了，而独占模式是放到acquireQueued()之外，其实都一样，不知道Doug Lea是怎么想的。</h5><h5 id=\"跟独占模式比，还有一点需要注意的是，这里只有线程是head-next时（“老二”），才会去尝试获取资源，有剩余的话还会唤醒之后的队友。那么问题就来了，假如老大用完后释放了5个资源，而老二需要6个，老三需要1个，老四需要2个。老大先唤醒老二，老二一看资源不够，他是把资源让给老三呢，还是不让？答案是否定的！老二会继续park-等待其他线程释放资源，也更不会去唤醒老三和老四了。独占模式，同一时刻只有一个线程去执行，这样做未尝不可；但共享模式下，多个线程是可以同时执行的，现在因为老二的资源需求量大，而把后面量小的老三和老四也都卡住了。当然，这并不是问题，只是AQS保证严格按照入队顺序唤醒罢了（保证公平，但降低了并发）。\"><a href=\"#跟独占模式比，还有一点需要注意的是，这里只有线程是head-next时（“老二”），才会去尝试获取资源，有剩余的话还会唤醒之后的队友。那么问题就来了，假如老大用完后释放了5个资源，而老二需要6个，老三需要1个，老四需要2个。老大先唤醒老二，老二一看资源不够，他是把资源让给老三呢，还是不让？答案是否定的！老二会继续park-等待其他线程释放资源，也更不会去唤醒老三和老四了。独占模式，同一时刻只有一个线程去执行，这样做未尝不可；但共享模式下，多个线程是可以同时执行的，现在因为老二的资源需求量大，而把后面量小的老三和老四也都卡住了。当然，这并不是问题，只是AQS保证严格按照入队顺序唤醒罢了（保证公平，但降低了并发）。\" class=\"headerlink\" title=\"跟独占模式比，还有一点需要注意的是，这里只有线程是head.next时（“老二”），才会去尝试获取资源，有剩余的话还会唤醒之后的队友。那么问题就来了，假如老大用完后释放了5个资源，而老二需要6个，老三需要1个，老四需要2个。老大先唤醒老二，老二一看资源不够，他是把资源让给老三呢，还是不让？答案是否定的！老二会继续park()等待其他线程释放资源，也更不会去唤醒老三和老四了。独占模式，同一时刻只有一个线程去执行，这样做未尝不可；但共享模式下，多个线程是可以同时执行的，现在因为老二的资源需求量大，而把后面量小的老三和老四也都卡住了。当然，这并不是问题，只是AQS保证严格按照入队顺序唤醒罢了（保证公平，但降低了并发）。\"></a>跟独占模式比，还有一点需要注意的是，这里只有线程是head.next时（“老二”），才会去尝试获取资源，有剩余的话还会唤醒之后的队友。那么问题就来了，假如老大用完后释放了5个资源，而老二需要6个，老三需要1个，老四需要2个。老大先唤醒老二，老二一看资源不够，他是把资源让给老三呢，还是不让？答案是否定的！老二会继续park()等待其他线程释放资源，也更不会去唤醒老三和老四了。独占模式，同一时刻只有一个线程去执行，这样做未尝不可；但共享模式下，多个线程是可以同时执行的，现在因为老二的资源需求量大，而把后面量小的老三和老四也都卡住了。当然，这并不是问题，只是AQS保证严格按照入队顺序唤醒罢了（保证公平，但降低了并发）。</h5><h3 id=\"setHeadAndPropagate-Node-int\"><a href=\"#setHeadAndPropagate-Node-int\" class=\"headerlink\" title=\"setHeadAndPropagate(Node, int)\"></a>setHeadAndPropagate(Node, int)</h3><pre><code class=\"lang-java\">private void setHeadAndPropagate(Node node, int propagate) {\n    Node h = head;\n    setHead(node);//head指向自己\n     //如果还有剩余量，继续唤醒下一个邻居线程\n    if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0) {\n        Node s = node.next;\n        if (s == null || s.isShared())\n            doReleaseShared();\n    }\n}\n</code></pre>\n<h5 id=\"此方法在setHead-的基础上多了一步，就是自己苏醒的同时，如果条件符合（比如还有剩余资源），还会去唤醒后继结点，毕竟是共享模式！\"><a href=\"#此方法在setHead-的基础上多了一步，就是自己苏醒的同时，如果条件符合（比如还有剩余资源），还会去唤醒后继结点，毕竟是共享模式！\" class=\"headerlink\" title=\"此方法在setHead()的基础上多了一步，就是自己苏醒的同时，如果条件符合（比如还有剩余资源），还会去唤醒后继结点，毕竟是共享模式！\"></a>此方法在setHead()的基础上多了一步，就是自己苏醒的同时，如果条件符合（比如还有剩余资源），还会去唤醒后继结点，毕竟是共享模式！</h5><h5 id=\"doReleaseShared-我们留着下一小节的releaseShared-里来讲。\"><a href=\"#doReleaseShared-我们留着下一小节的releaseShared-里来讲。\" class=\"headerlink\" title=\"doReleaseShared()我们留着下一小节的releaseShared()里来讲。\"></a>doReleaseShared()我们留着下一小节的releaseShared()里来讲。</h5><h3 id=\"小结-3\"><a href=\"#小结-3\" class=\"headerlink\" title=\"小结\"></a>小结</h3><h5 id=\"OK，至此，acquireShared-也要告一段落了。让我们再梳理一下它的流程：\"><a href=\"#OK，至此，acquireShared-也要告一段落了。让我们再梳理一下它的流程：\" class=\"headerlink\" title=\"OK，至此，acquireShared()也要告一段落了。让我们再梳理一下它的流程：\"></a>OK，至此，acquireShared()也要告一段落了。让我们再梳理一下它的流程：</h5><ol>\n<li>tryAcquireShared()尝试获取资源，成功则直接返回；</li>\n<li>失败则通过doAcquireShared()进入等待队列park()，直到被unpark()/interrupt()并成功获取到资源才返回。整个等待过程也是忽略中断的。\n　　<h5 id=\"其实跟acquire-的流程大同小异，只不过多了个自己拿到资源后，还会去唤醒后继队友的操作（这才是共享嘛）。\"><a href=\"#其实跟acquire-的流程大同小异，只不过多了个自己拿到资源后，还会去唤醒后继队友的操作（这才是共享嘛）。\" class=\"headerlink\" title=\"其实跟acquire()的流程大同小异，只不过多了个自己拿到资源后，还会去唤醒后继队友的操作（这才是共享嘛）。\"></a>其实跟acquire()的流程大同小异，只不过多了个自己拿到资源后，还会去唤醒后继队友的操作（这才是共享嘛）。</h5></li>\n</ol>\n<h3 id=\"releaseShared\"><a href=\"#releaseShared\" class=\"headerlink\" title=\"releaseShared()\"></a>releaseShared()</h3><h5 id=\"上一小节已经把acquireShared-说完了，这一小节就来讲讲它的反操作releaseShared-吧。此方法是共享模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果成功释放且允许唤醒等待线程，它会唤醒等待队列里的其他线程来获取资源。下面是releaseShared-的源码：\"><a href=\"#上一小节已经把acquireShared-说完了，这一小节就来讲讲它的反操作releaseShared-吧。此方法是共享模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果成功释放且允许唤醒等待线程，它会唤醒等待队列里的其他线程来获取资源。下面是releaseShared-的源码：\" class=\"headerlink\" title=\"上一小节已经把acquireShared()说完了，这一小节就来讲讲它的反操作releaseShared()吧。此方法是共享模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果成功释放且允许唤醒等待线程，它会唤醒等待队列里的其他线程来获取资源。下面是releaseShared()的源码：\"></a>上一小节已经把acquireShared()说完了，这一小节就来讲讲它的反操作releaseShared()吧。此方法是共享模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果成功释放且允许唤醒等待线程，它会唤醒等待队列里的其他线程来获取资源。下面是releaseShared()的源码：</h5><pre><code class=\"lang-java\">public final boolean releaseShared(int arg) {\n    if (tryReleaseShared(arg)) {//尝试释放资源\n        doReleaseShared();//唤醒后继结点\n        return true;\n    }\n    return false;\n}\n</code></pre>\n<h5 id=\"此方法的流程也比较简单，一句话：释放掉资源后，唤醒后继。跟独占模式下的release-相似，但有一点稍微需要注意：独占模式下的tryRelease-在完全释放掉资源（state-0）后，才会返回true去唤醒其他线程，这主要是基于独占下可重入的考量；而共享模式下的releaseShared-则没有这种要求，共享模式实质就是控制一定量的线程并发执行，那么拥有资源的线程在释放掉部分资源时就可以唤醒后继等待结点。例如，资源总量是13，A（5）和B（7）分别获取到资源并发运行，C（4）来时只剩1个资源就需要等待。A在运行过程中释放掉2个资源量，然后tryReleaseShared-2-返回true唤醒C，C一看只有3个仍不够继续等待；随后B又释放2个，tryReleaseShared-2-返回true唤醒C，C一看有5个够自己用了，然后C就可以跟A和B一起运行。而ReentrantReadWriteLock读锁的tryReleaseShared-只有在完全释放掉资源（state-0）才返回true，所以自定义同步器可以根据需要决定tryReleaseShared-的返回值。\"><a href=\"#此方法的流程也比较简单，一句话：释放掉资源后，唤醒后继。跟独占模式下的release-相似，但有一点稍微需要注意：独占模式下的tryRelease-在完全释放掉资源（state-0）后，才会返回true去唤醒其他线程，这主要是基于独占下可重入的考量；而共享模式下的releaseShared-则没有这种要求，共享模式实质就是控制一定量的线程并发执行，那么拥有资源的线程在释放掉部分资源时就可以唤醒后继等待结点。例如，资源总量是13，A（5）和B（7）分别获取到资源并发运行，C（4）来时只剩1个资源就需要等待。A在运行过程中释放掉2个资源量，然后tryReleaseShared-2-返回true唤醒C，C一看只有3个仍不够继续等待；随后B又释放2个，tryReleaseShared-2-返回true唤醒C，C一看有5个够自己用了，然后C就可以跟A和B一起运行。而ReentrantReadWriteLock读锁的tryReleaseShared-只有在完全释放掉资源（state-0）才返回true，所以自定义同步器可以根据需要决定tryReleaseShared-的返回值。\" class=\"headerlink\" title=\"此方法的流程也比较简单，一句话：释放掉资源后，唤醒后继。跟独占模式下的release()相似，但有一点稍微需要注意：独占模式下的tryRelease()在完全释放掉资源（state=0）后，才会返回true去唤醒其他线程，这主要是基于独占下可重入的考量；而共享模式下的releaseShared()则没有这种要求，共享模式实质就是控制一定量的线程并发执行，那么拥有资源的线程在释放掉部分资源时就可以唤醒后继等待结点。例如，资源总量是13，A（5）和B（7）分别获取到资源并发运行，C（4）来时只剩1个资源就需要等待。A在运行过程中释放掉2个资源量，然后tryReleaseShared(2)返回true唤醒C，C一看只有3个仍不够继续等待；随后B又释放2个，tryReleaseShared(2)返回true唤醒C，C一看有5个够自己用了，然后C就可以跟A和B一起运行。而ReentrantReadWriteLock读锁的tryReleaseShared()只有在完全释放掉资源（state=0）才返回true，所以自定义同步器可以根据需要决定tryReleaseShared()的返回值。\"></a>此方法的流程也比较简单，一句话：释放掉资源后，唤醒后继。跟独占模式下的release()相似，但有一点稍微需要注意：独占模式下的tryRelease()在完全释放掉资源（state=0）后，才会返回true去唤醒其他线程，这主要是基于独占下可重入的考量；而共享模式下的releaseShared()则没有这种要求，共享模式实质就是控制一定量的线程并发执行，那么拥有资源的线程在释放掉部分资源时就可以唤醒后继等待结点。例如，资源总量是13，A（5）和B（7）分别获取到资源并发运行，C（4）来时只剩1个资源就需要等待。A在运行过程中释放掉2个资源量，然后tryReleaseShared(2)返回true唤醒C，C一看只有3个仍不够继续等待；随后B又释放2个，tryReleaseShared(2)返回true唤醒C，C一看有5个够自己用了，然后C就可以跟A和B一起运行。而ReentrantReadWriteLock读锁的tryReleaseShared()只有在完全释放掉资源（state=0）才返回true，所以自定义同步器可以根据需要决定tryReleaseShared()的返回值。</h5><h3 id=\"doReleaseShared\"><a href=\"#doReleaseShared\" class=\"headerlink\" title=\"doReleaseShared()\"></a>doReleaseShared()</h3><h5 id=\"此方法主要用于唤醒后继。下面是它的源码：\"><a href=\"#此方法主要用于唤醒后继。下面是它的源码：\" class=\"headerlink\" title=\"此方法主要用于唤醒后继。下面是它的源码：\"></a>此方法主要用于唤醒后继。下面是它的源码：</h5><pre><code class=\"lang-java\">private void doReleaseShared() {\n    for (;;) {\n        Node h = head;\n        if (h != null &amp;&amp; h != tail) {\n            int ws = h.waitStatus;\n            if (ws == Node.SIGNAL) {\n                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))\n                    continue;\n                unparkSuccessor(h);//唤醒后继\n            }\n            else if (ws == 0 &amp;&amp;\n                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))\n                continue;\n        }\n        if (h == head)// head发生变化\n            break;\n    }\n}\n</code></pre>\n<h3 id=\"小结-4\"><a href=\"#小结-4\" class=\"headerlink\" title=\"小结\"></a>小结</h3><h5 id=\"本节我们详解了独占和共享两种模式下获取-释放资源-acquire-release、acquireShared-releaseShared-的源码，相信大家都有一定认识了。值得注意的是，acquire-和acquireSahred-两种方法下，线程在等待队列中都是忽略中断的。AQS也支持响应中断的，acquireInterruptibly-acquireSharedInterruptibly-即是，这里相应的源码跟acquire-和acquireSahred-差不多，这里就不再详解了。\"><a href=\"#本节我们详解了独占和共享两种模式下获取-释放资源-acquire-release、acquireShared-releaseShared-的源码，相信大家都有一定认识了。值得注意的是，acquire-和acquireSahred-两种方法下，线程在等待队列中都是忽略中断的。AQS也支持响应中断的，acquireInterruptibly-acquireSharedInterruptibly-即是，这里相应的源码跟acquire-和acquireSahred-差不多，这里就不再详解了。\" class=\"headerlink\" title=\"本节我们详解了独占和共享两种模式下获取-释放资源(acquire-release、acquireShared-releaseShared)的源码，相信大家都有一定认识了。值得注意的是，acquire()和acquireSahred()两种方法下，线程在等待队列中都是忽略中断的。AQS也支持响应中断的，acquireInterruptibly()/acquireSharedInterruptibly()即是，这里相应的源码跟acquire()和acquireSahred()差不多，这里就不再详解了。\"></a>本节我们详解了独占和共享两种模式下获取-释放资源(acquire-release、acquireShared-releaseShared)的源码，相信大家都有一定认识了。值得注意的是，acquire()和acquireSahred()两种方法下，线程在等待队列中都是忽略中断的。AQS也支持响应中断的，acquireInterruptibly()/acquireSharedInterruptibly()即是，这里相应的源码跟acquire()和acquireSahred()差不多，这里就不再详解了。</h5><h2 id=\"简单应用\"><a href=\"#简单应用\" class=\"headerlink\" title=\"简单应用\"></a>简单应用</h2><h5 id=\"OK，下面我们就以AQS源码里的Mutex为例，讲一下AQS的简单应用。\"><a href=\"#OK，下面我们就以AQS源码里的Mutex为例，讲一下AQS的简单应用。\" class=\"headerlink\" title=\"OK，下面我们就以AQS源码里的Mutex为例，讲一下AQS的简单应用。\"></a>OK，下面我们就以AQS源码里的Mutex为例，讲一下AQS的简单应用。</h5><h3 id=\"Mutex（互斥锁）\"><a href=\"#Mutex（互斥锁）\" class=\"headerlink\" title=\"Mutex（互斥锁）\"></a>Mutex（互斥锁）</h3><h5 id=\"Mutex是一个不可重入的互斥锁实现。锁资源（AQS里的state）只有两种状态：0表示未锁定，1表示锁定。下边是Mutex的核心源码：\"><a href=\"#Mutex是一个不可重入的互斥锁实现。锁资源（AQS里的state）只有两种状态：0表示未锁定，1表示锁定。下边是Mutex的核心源码：\" class=\"headerlink\" title=\"Mutex是一个不可重入的互斥锁实现。锁资源（AQS里的state）只有两种状态：0表示未锁定，1表示锁定。下边是Mutex的核心源码：\"></a>Mutex是一个不可重入的互斥锁实现。锁资源（AQS里的state）只有两种状态：0表示未锁定，1表示锁定。下边是Mutex的核心源码：</h5><pre><code class=\"lang-java\">class Mutex implements Lock, java.io.Serializable {\n    // 自定义同步器\n    private static class Sync extends AbstractQueuedSynchronizer {\n        // 判断是否锁定状态\n        protected boolean isHeldExclusively() {\n            return getState() == 1;\n        }\n        // 尝试获取资源，立即返回。成功则返回true，否则false。\n        public boolean tryAcquire(int acquires) {\n            assert acquires == 1; // 这里限定只能为1个量\n            if (compareAndSetState(0, 1)) {//state为0才设置为1，不可重入！\n                setExclusiveOwnerThread(Thread.currentThread());//设置为当前线程独占资源\n                return true;\n            }\n            return false;\n        }\n        // 尝试释放资源，立即返回。成功则为true，否则false。\n        protected boolean tryRelease(int releases) {\n            assert releases == 1; // 限定为1个量\n            if (getState() == 0)//既然来释放，那肯定就是已占有状态了。只是为了保险，多层判断！\n                throw new IllegalMonitorStateException();\n            setExclusiveOwnerThread(null);\n            setState(0);//释放资源，放弃占有状态\n            return true;\n        }\n    }\n    // 真正同步类的实现都依赖继承于AQS的自定义同步器！\n    private final Sync sync = new Sync();\n    //lock&lt;--&gt;acquire。两者语义一样：获取资源，即便等待，直到成功才返回。\n    public void lock() {\n        sync.acquire(1);\n    }\n    //tryLock&lt;--&gt;tryAcquire。两者语义一样：尝试获取资源，要求立即返回。成功则为true，失败则为false。\n    public boolean tryLock() {\n        return sync.tryAcquire(1);\n    }\n    //unlock&lt;--&gt;release。两者语文一样：释放资源。\n    public void unlock() {\n        sync.release(1);\n    }\n    //锁是否占有状态\n    public boolean isLocked() {\n        return sync.isHeldExclusively();\n    }\n}\n</code></pre>\n<h5 id=\"同步类在实现时一般都将自定义同步器（sync）定义为内部类，供自己使用；而同步类自己（Mutex）则实现某个接口，对外服务。当然，接口的实现要直接依赖sync，它们在语义上也存在某种对应关系！！而sync只用实现资源state的获取-释放方式tryAcquire-tryRelelase，至于线程的排队、等待、唤醒等，上层的AQS都已经实现好了，我们不用关心。\"><a href=\"#同步类在实现时一般都将自定义同步器（sync）定义为内部类，供自己使用；而同步类自己（Mutex）则实现某个接口，对外服务。当然，接口的实现要直接依赖sync，它们在语义上也存在某种对应关系！！而sync只用实现资源state的获取-释放方式tryAcquire-tryRelelase，至于线程的排队、等待、唤醒等，上层的AQS都已经实现好了，我们不用关心。\" class=\"headerlink\" title=\"同步类在实现时一般都将自定义同步器（sync）定义为内部类，供自己使用；而同步类自己（Mutex）则实现某个接口，对外服务。当然，接口的实现要直接依赖sync，它们在语义上也存在某种对应关系！！而sync只用实现资源state的获取-释放方式tryAcquire-tryRelelase，至于线程的排队、等待、唤醒等，上层的AQS都已经实现好了，我们不用关心。\"></a>同步类在实现时一般都将自定义同步器（sync）定义为内部类，供自己使用；而同步类自己（Mutex）则实现某个接口，对外服务。当然，接口的实现要直接依赖sync，它们在语义上也存在某种对应关系！！而sync只用实现资源state的获取-释放方式tryAcquire-tryRelelase，至于线程的排队、等待、唤醒等，上层的AQS都已经实现好了，我们不用关心。</h5><h5 id=\"除了Mutex，ReentrantLock-CountDownLatch-Semphore这些同步类的实现方式都差不多，不同的地方就在获取-释放资源的方式tryAcquire-tryRelelase。掌握了这点，AQS的核心便被攻破了！\"><a href=\"#除了Mutex，ReentrantLock-CountDownLatch-Semphore这些同步类的实现方式都差不多，不同的地方就在获取-释放资源的方式tryAcquire-tryRelelase。掌握了这点，AQS的核心便被攻破了！\" class=\"headerlink\" title=\"除了Mutex，ReentrantLock/CountDownLatch/Semphore这些同步类的实现方式都差不多，不同的地方就在获取-释放资源的方式tryAcquire-tryRelelase。掌握了这点，AQS的核心便被攻破了！\"></a>除了Mutex，ReentrantLock/CountDownLatch/Semphore这些同步类的实现方式都差不多，不同的地方就在获取-释放资源的方式tryAcquire-tryRelelase。掌握了这点，AQS的核心便被攻破了！</h5><h5 id=\"OK，至此，整个AQS的讲解也要落下帷幕了。希望本文能够对学习Java并发编程的同学有所借鉴，中间写的有不对的地方，也欢迎讨论和指正\"><a href=\"#OK，至此，整个AQS的讲解也要落下帷幕了。希望本文能够对学习Java并发编程的同学有所借鉴，中间写的有不对的地方，也欢迎讨论和指正\" class=\"headerlink\" title=\"OK，至此，整个AQS的讲解也要落下帷幕了。希望本文能够对学习Java并发编程的同学有所借鉴，中间写的有不对的地方，也欢迎讨论和指正~\"></a>OK，至此，整个AQS的讲解也要落下帷幕了。希望本文能够对学习Java并发编程的同学有所借鉴，中间写的有不对的地方，也欢迎讨论和指正~</h5><h3 id=\"文章转载自：https-www-cnblogs-com-waterystone-p-4920797-html\"><a href=\"#文章转载自：https-www-cnblogs-com-waterystone-p-4920797-html\" class=\"headerlink\" title=\"文章转载自：https://www.cnblogs.com/waterystone/p/4920797.html\"></a>文章转载自：<a href=\"https://www.cnblogs.com/waterystone/p/4920797.html\" target=\"_blank\" rel=\"external\">https://www.cnblogs.com/waterystone/p/4920797.html</a></h3>","site":{"data":{}},"excerpt":"<h5 id=\"Java的并发工具，我们常用的有ReentrantLock-Semaphore-CountDownLatch等工具，而这些工具类又是如何实现的呢？这就不得不提到AbstractQueuedSynchronizer类，也就是AQS！类如其名，抽象的队列式的同步器，AQS定义了一套多线程访问共享资源的同步器框架。\"><a href=\"#Java的并发工具，我们常用的有ReentrantLock-Semaphore-CountDownLatch等工具，而这些工具类又是如何实现的呢？这就不得不提到AbstractQueuedSynchronizer类，也就是AQS！类如其名，抽象的队列式的同步器，AQS定义了一套多线程访问共享资源的同步器框架。\" class=\"headerlink\" title=\"Java的并发工具，我们常用的有ReentrantLock/Semaphore/CountDownLatch等工具，而这些工具类又是如何实现的呢？这就不得不提到AbstractQueuedSynchronizer类，也就是AQS！类如其名，抽象的队列式的同步器，AQS定义了一套多线程访问共享资源的同步器框架。\"></a>Java的并发工具，我们常用的有ReentrantLock/Semaphore/CountDownLatch等工具，而这些工具类又是如何实现的呢？这就不得不提到AbstractQueuedSynchronizer类，也就是AQS！类如其名，抽象的队列式的同步器，AQS定义了一套多线程访问共享资源的同步器框架。</h5>","more":"<h2 id=\"框架\"><a href=\"#框架\" class=\"headerlink\" title=\"框架\"></a>框架</h2><p><img src=\"/img/note/jdk/aqs.png\" alt=\"AQS队列\"> <div class=\"img-note\">AQS队列</div></p>\n<h5 id=\"AbstractQueuedSynchronizer类它维护了一个volatile-int-state（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列）。这里volatile是核心关键词，具体volatile的语义，在此不述。state的访问方式有三种\"><a href=\"#AbstractQueuedSynchronizer类它维护了一个volatile-int-state（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列）。这里volatile是核心关键词，具体volatile的语义，在此不述。state的访问方式有三种\" class=\"headerlink\" title=\"AbstractQueuedSynchronizer类它维护了一个volatile int state（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列）。这里volatile是核心关键词，具体volatile的语义，在此不述。state的访问方式有三种:\"></a><strong>AbstractQueuedSynchronizer</strong>类它维护了一个volatile int state（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列）。这里volatile是核心关键词，具体volatile的语义，在此不述。state的访问方式有三种:</h5><ul>\n<li>getState</li>\n<li>setState</li>\n<li>compareAndSetState</li>\n</ul>\n<h5 id=\"AQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore-CountDownLatch）。\"><a href=\"#AQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore-CountDownLatch）。\" class=\"headerlink\" title=\"AQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore/CountDownLatch）。\"></a>AQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore/CountDownLatch）。</h5><h5 id=\"不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队-唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：\"><a href=\"#不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队-唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：\" class=\"headerlink\" title=\"不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：\"></a>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：</h5><ul>\n<li><strong>isHeldExclusively()</strong>：该线程是否正在独占资源。只有用到condition才需要去实现它。</li>\n<li><strong>tryAcquire(int)</strong>：独占方式。尝试获取资源，成功则返回true，失败则返回false。</li>\n<li><strong>tryRelease(int)</strong>：独占方式。尝试释放资源，成功则返回true，失败则返回false。</li>\n<li><strong>tryAcquireShared(int)</strong>：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li>\n<li><strong>tryReleaseShared(int)</strong>：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</li>\n</ul>\n<h5 id=\"以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock-时，会调用tryAcquire-独占该锁并将state-1。此后，其他线程再tryAcquire-时就会失败，直到A线程unlock-到state-0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。\"><a href=\"#以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock-时，会调用tryAcquire-独占该锁并将state-1。此后，其他线程再tryAcquire-时就会失败，直到A线程unlock-到state-0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。\" class=\"headerlink\" title=\"以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。\"></a>以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。</h5><h5 id=\"再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown-一次，state会CAS减1。等到所有子线程都执行完后-即state-0-，会unpark-主调用线程，然后主调用线程就会从await-函数返回，继续后余动作。\"><a href=\"#再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown-一次，state会CAS减1。等到所有子线程都执行完后-即state-0-，会unpark-主调用线程，然后主调用线程就会从await-函数返回，继续后余动作。\" class=\"headerlink\" title=\"再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS减1。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。\"></a>再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS减1。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。</h5><h5 id=\"一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。\"><a href=\"#一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。\" class=\"headerlink\" title=\"一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。\"></a>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。</h5><h2 id=\"源码详解\"><a href=\"#源码详解\" class=\"headerlink\" title=\"源码详解\"></a>源码详解</h2><h3 id=\"acquire-int\"><a href=\"#acquire-int\" class=\"headerlink\" title=\"acquire(int)\"></a>acquire(int)</h3><h5 id=\"此方法是独占模式下线程获取共享资源的顶层入口。如果获取到资源，线程直接返回，否则进入等待队列，直到获取到资源为止，且整个过程忽略中断的影响。这也正是lock-的语义，当然不仅仅只限于lock-。获取到资源后，线程就可以去执行其临界区代码了。下面是acquire-的源码：\"><a href=\"#此方法是独占模式下线程获取共享资源的顶层入口。如果获取到资源，线程直接返回，否则进入等待队列，直到获取到资源为止，且整个过程忽略中断的影响。这也正是lock-的语义，当然不仅仅只限于lock-。获取到资源后，线程就可以去执行其临界区代码了。下面是acquire-的源码：\" class=\"headerlink\" title=\"此方法是独占模式下线程获取共享资源的顶层入口。如果获取到资源，线程直接返回，否则进入等待队列，直到获取到资源为止，且整个过程忽略中断的影响。这也正是lock()的语义，当然不仅仅只限于lock()。获取到资源后，线程就可以去执行其临界区代码了。下面是acquire()的源码：\"></a>此方法是独占模式下线程获取共享资源的顶层入口。如果获取到资源，线程直接返回，否则进入等待队列，直到获取到资源为止，且整个过程忽略中断的影响。这也正是lock()的语义，当然不仅仅只限于lock()。获取到资源后，线程就可以去执行其临界区代码了。下面是acquire()的源码：</h5><pre><code class=\"lang-java\">public final void acquire(int arg) {\n    if (!tryAcquire(arg) &amp;&amp;\n        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        selfInterrupt();\n}\n</code></pre>\n<h4 id=\"函数流程如下：\"><a href=\"#函数流程如下：\" class=\"headerlink\" title=\"函数流程如下：\"></a>函数流程如下：</h4><ol>\n<li>tryAcquire()尝试直接去获取资源，如果成功则直接返回；</li>\n<li>addWaiter()将该线程加入等待队列的尾部，并标记为独占模式；</li>\n<li>acquireQueued()使线程在等待队列中获取资源，一直获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。</li>\n<li>如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。</li>\n</ol>\n<h5 id=\"这时单凭这4个抽象的函数来看流程还有点朦胧，不要紧，看完接下来的分析后，你就会明白了。\"><a href=\"#这时单凭这4个抽象的函数来看流程还有点朦胧，不要紧，看完接下来的分析后，你就会明白了。\" class=\"headerlink\" title=\"这时单凭这4个抽象的函数来看流程还有点朦胧，不要紧，看完接下来的分析后，你就会明白了。\"></a>这时单凭这4个抽象的函数来看流程还有点朦胧，不要紧，看完接下来的分析后，你就会明白了。</h5><h3 id=\"tryAcquire-int\"><a href=\"#tryAcquire-int\" class=\"headerlink\" title=\"tryAcquire(int)\"></a>tryAcquire(int)</h3><h5 id=\"此方法尝试去获取独占资源。如果获取成功，则直接返回true，否则直接返回false。这也正是tryLock-的语义，还是那句话，当然不仅仅只限于tryLock-。如下是tryAcquire-的源码：\"><a href=\"#此方法尝试去获取独占资源。如果获取成功，则直接返回true，否则直接返回false。这也正是tryLock-的语义，还是那句话，当然不仅仅只限于tryLock-。如下是tryAcquire-的源码：\" class=\"headerlink\" title=\"此方法尝试去获取独占资源。如果获取成功，则直接返回true，否则直接返回false。这也正是tryLock()的语义，还是那句话，当然不仅仅只限于tryLock()。如下是tryAcquire()的源码：\"></a>此方法尝试去获取独占资源。如果获取成功，则直接返回true，否则直接返回false。这也正是tryLock()的语义，还是那句话，当然不仅仅只限于tryLock()。如下是tryAcquire()的源码：</h5><pre><code class=\"lang-java\">protected boolean tryAcquire(int arg) {\n    throw new UnsupportedOperationException();\n}\n</code></pre>\n<h5 id=\"什么？直接throw异常？说好的功能呢？好吧，还记得概述里讲的AQS只是一个框架，具体资源的获取-释放方式交由自定义同步器去实现吗？就是这里了！！！AQS这里只定义了一个接口，具体资源的获取交由自定义同步器去实现了（通过state的get-set-CAS）！！！至于能不能重入，能不能加塞，那就看具体的自定义同步器怎么去设计了！！！当然，自定义同步器在进行资源访问时要考虑线程安全的影响。\"><a href=\"#什么？直接throw异常？说好的功能呢？好吧，还记得概述里讲的AQS只是一个框架，具体资源的获取-释放方式交由自定义同步器去实现吗？就是这里了！！！AQS这里只定义了一个接口，具体资源的获取交由自定义同步器去实现了（通过state的get-set-CAS）！！！至于能不能重入，能不能加塞，那就看具体的自定义同步器怎么去设计了！！！当然，自定义同步器在进行资源访问时要考虑线程安全的影响。\" class=\"headerlink\" title=\"什么？直接throw异常？说好的功能呢？好吧，还记得概述里讲的AQS只是一个框架，具体资源的获取/释放方式交由自定义同步器去实现吗？就是这里了！！！AQS这里只定义了一个接口，具体资源的获取交由自定义同步器去实现了（通过state的get/set/CAS）！！！至于能不能重入，能不能加塞，那就看具体的自定义同步器怎么去设计了！！！当然，自定义同步器在进行资源访问时要考虑线程安全的影响。\"></a>什么？直接throw异常？说好的功能呢？好吧，还记得概述里讲的AQS只是一个框架，具体资源的获取/释放方式交由自定义同步器去实现吗？就是这里了！！！AQS这里只定义了一个接口，具体资源的获取交由自定义同步器去实现了（通过state的get/set/CAS）！！！至于能不能重入，能不能加塞，那就看具体的自定义同步器怎么去设计了！！！当然，自定义同步器在进行资源访问时要考虑线程安全的影响。</h5><h5 id=\"这里之所以没有定义成abstract，是因为独占模式下只用实现tryAcquire-tryRelease，而共享模式下只用实现tryAcquireShared-tryReleaseShared。如果都定义成abstract，那么每个模式也要去实现另一模式下的接口。说到底，Doug-Lea还是站在咱们开发者的角度，尽量减少不必要的工作量。\"><a href=\"#这里之所以没有定义成abstract，是因为独占模式下只用实现tryAcquire-tryRelease，而共享模式下只用实现tryAcquireShared-tryReleaseShared。如果都定义成abstract，那么每个模式也要去实现另一模式下的接口。说到底，Doug-Lea还是站在咱们开发者的角度，尽量减少不必要的工作量。\" class=\"headerlink\" title=\"这里之所以没有定义成abstract，是因为独占模式下只用实现tryAcquire-tryRelease，而共享模式下只用实现tryAcquireShared-tryReleaseShared。如果都定义成abstract，那么每个模式也要去实现另一模式下的接口。说到底，Doug Lea还是站在咱们开发者的角度，尽量减少不必要的工作量。\"></a>这里之所以没有定义成abstract，是因为独占模式下只用实现tryAcquire-tryRelease，而共享模式下只用实现tryAcquireShared-tryReleaseShared。如果都定义成abstract，那么每个模式也要去实现另一模式下的接口。说到底，Doug Lea还是站在咱们开发者的角度，尽量减少不必要的工作量。</h5><h3 id=\"addWaiter-Node\"><a href=\"#addWaiter-Node\" class=\"headerlink\" title=\"addWaiter(Node)\"></a>addWaiter(Node)</h3><h5 id=\"此方法用于将当前线程加入到等待队列的队尾，并返回当前线程所在的结点。还是上源码吧：\"><a href=\"#此方法用于将当前线程加入到等待队列的队尾，并返回当前线程所在的结点。还是上源码吧：\" class=\"headerlink\" title=\"此方法用于将当前线程加入到等待队列的队尾，并返回当前线程所在的结点。还是上源码吧：\"></a>此方法用于将当前线程加入到等待队列的队尾，并返回当前线程所在的结点。还是上源码吧：</h5><pre><code class=\"lang-java\">private Node addWaiter(Node mode) {\n    //以给定模式构造结点。mode有两种：EXCLUSIVE（独占）和SHARED（共享）\n    Node node = new Node(Thread.currentThread(), mode);\n    //尝试快速方式直接放到队尾。\n    Node pred = tail;\n    if (pred != null) {\n        node.prev = pred;\n        if (compareAndSetTail(pred, node)) {\n            pred.next = node;\n            return node;\n        }\n    }\n    //上一步失败则通过enq入队。\n    enq(node);\n    return node;\n}\n</code></pre>\n<h3 id=\"enq-Node\"><a href=\"#enq-Node\" class=\"headerlink\" title=\"enq(Node)\"></a>enq(Node)</h3><h5 id=\"此方法用于将node加入队尾。源码如下：\"><a href=\"#此方法用于将node加入队尾。源码如下：\" class=\"headerlink\" title=\"此方法用于将node加入队尾。源码如下：\"></a>此方法用于将node加入队尾。源码如下：</h5><pre><code class=\"lang-java\">private Node enq(final Node node) {\n    //CAS&quot;自旋&quot;，直到成功加入队尾\n    for (;;) {\n        Node t = tail;\n        if (t == null) { // 队列为空，创建一个空的标志结点作为head结点，并将tail也指向它。\n            if (compareAndSetHead(new Node()))\n                tail = head;\n        } else {//正常流程，放入队尾\n            node.prev = t;\n            if (compareAndSetTail(t, node)) {\n                t.next = node;\n                return t;\n            }\n        }\n    }\n}\n</code></pre>\n<h5 id=\"如果你看过AtomicInteger-getAndIncrement-函数源码，那么相信你一眼便看出这段代码的精华。CAS自旋volatile变量，是一种很经典的用法。还不太了解的，自己去百度一下吧。\"><a href=\"#如果你看过AtomicInteger-getAndIncrement-函数源码，那么相信你一眼便看出这段代码的精华。CAS自旋volatile变量，是一种很经典的用法。还不太了解的，自己去百度一下吧。\" class=\"headerlink\" title=\"如果你看过AtomicInteger.getAndIncrement()函数源码，那么相信你一眼便看出这段代码的精华。CAS自旋volatile变量，是一种很经典的用法。还不太了解的，自己去百度一下吧。\"></a>如果你看过AtomicInteger.getAndIncrement()函数源码，那么相信你一眼便看出这段代码的精华。CAS自旋volatile变量，是一种很经典的用法。还不太了解的，自己去百度一下吧。</h5><h3 id=\"acquireQueued-Node-int\"><a href=\"#acquireQueued-Node-int\" class=\"headerlink\" title=\"acquireQueued(Node, int)\"></a>acquireQueued(Node, int)</h3><h5 id=\"OK，通过tryAcquire-和addWaiter-，该线程获取资源失败，已经被放入等待队列尾部了。聪明的你立刻应该能想到该线程下一部该干什么了吧：进入等待状态休息，直到其他线程彻底释放资源后唤醒自己，自己再拿到资源，然后就可以去干自己想干的事了。没错，就是这样！是不是跟医院排队拿号有点相似-acquireQueued-就是干这件事：在等待队列中排队拿号（中间没其它事干可以休息），直到拿到号后再返回。这个函数非常关键，还是上源码吧：\"><a href=\"#OK，通过tryAcquire-和addWaiter-，该线程获取资源失败，已经被放入等待队列尾部了。聪明的你立刻应该能想到该线程下一部该干什么了吧：进入等待状态休息，直到其他线程彻底释放资源后唤醒自己，自己再拿到资源，然后就可以去干自己想干的事了。没错，就是这样！是不是跟医院排队拿号有点相似-acquireQueued-就是干这件事：在等待队列中排队拿号（中间没其它事干可以休息），直到拿到号后再返回。这个函数非常关键，还是上源码吧：\" class=\"headerlink\" title=\"OK，通过tryAcquire()和addWaiter()，该线程获取资源失败，已经被放入等待队列尾部了。聪明的你立刻应该能想到该线程下一部该干什么了吧：进入等待状态休息，直到其他线程彻底释放资源后唤醒自己，自己再拿到资源，然后就可以去干自己想干的事了。没错，就是这样！是不是跟医院排队拿号有点相似~~acquireQueued()就是干这件事：在等待队列中排队拿号（中间没其它事干可以休息），直到拿到号后再返回。这个函数非常关键，还是上源码吧：\"></a>OK，通过tryAcquire()和addWaiter()，该线程获取资源失败，已经被放入等待队列尾部了。聪明的你立刻应该能想到该线程下一部该干什么了吧：进入等待状态休息，直到其他线程彻底释放资源后唤醒自己，自己再拿到资源，然后就可以去干自己想干的事了。没错，就是这样！是不是跟医院排队拿号有点相似~~acquireQueued()就是干这件事：在等待队列中排队拿号（中间没其它事干可以休息），直到拿到号后再返回。这个函数非常关键，还是上源码吧：</h5><pre><code class=\"lang-java\">final boolean acquireQueued(final Node node, int arg) {\n    boolean failed = true;//标记是否成功拿到资源\n    try {\n        boolean interrupted = false;//标记等待过程中是否被中断过\n        //又是一个“自旋”！\n        for (;;) {\n            final Node p = node.predecessor();//拿到前驱\n            //如果前驱是head，即该结点已成老二，那么便有资格去尝试获取资源（可能是老大释放完资源唤醒自己的，当然也可能被interrupt了）。\n            if (p == head &amp;&amp; tryAcquire(arg)) {\n                setHead(node);//拿到资源后，将head指向该结点。所以head所指的标杆结点，就是当前获取到资源的那个结点或null。\n                p.next = null; // setHead中node.prev已置为null，此处再将head.next置为null，就是为了方便GC回收以前的head结点。也就意味着之前拿完资源的结点出队了！\n                failed = false;\n                return interrupted;//返回等待过程中是否被中断过\n            }\n            //如果自己可以休息了，就进入waiting状态，直到被unpark()\n            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;\n                parkAndCheckInterrupt())\n                interrupted = true;//如果等待过程中被中断过，哪怕只有那么一次，就将interrupted标记为true\n        }\n    } finally {\n        if (failed)\n            cancelAcquire(node);\n    }\n}\n</code></pre>\n<h5 id=\"到这里了，我们先不急着总结acquireQueued-的函数流程，先看看shouldParkAfterFailedAcquire-和parkAndCheckInterrupt-具体干些什么。\"><a href=\"#到这里了，我们先不急着总结acquireQueued-的函数流程，先看看shouldParkAfterFailedAcquire-和parkAndCheckInterrupt-具体干些什么。\" class=\"headerlink\" title=\"到这里了，我们先不急着总结acquireQueued()的函数流程，先看看shouldParkAfterFailedAcquire()和parkAndCheckInterrupt()具体干些什么。\"></a>到这里了，我们先不急着总结acquireQueued()的函数流程，先看看shouldParkAfterFailedAcquire()和parkAndCheckInterrupt()具体干些什么。</h5><h3 id=\"shouldParkAfterFailedAcquire-Node-Node\"><a href=\"#shouldParkAfterFailedAcquire-Node-Node\" class=\"headerlink\" title=\"shouldParkAfterFailedAcquire(Node, Node)\"></a>shouldParkAfterFailedAcquire(Node, Node)</h3><h5 id=\"此方法主要用于检查状态，看看自己是否真的可以去休息了（进入waiting状态，如果线程状态转换不熟，可以参考本人上一篇写的Thread详解），万一队列前边的线程都放弃了只是瞎站着，那也说不定，对吧！\"><a href=\"#此方法主要用于检查状态，看看自己是否真的可以去休息了（进入waiting状态，如果线程状态转换不熟，可以参考本人上一篇写的Thread详解），万一队列前边的线程都放弃了只是瞎站着，那也说不定，对吧！\" class=\"headerlink\" title=\"此方法主要用于检查状态，看看自己是否真的可以去休息了（进入waiting状态，如果线程状态转换不熟，可以参考本人上一篇写的Thread详解），万一队列前边的线程都放弃了只是瞎站着，那也说不定，对吧！\"></a>此方法主要用于检查状态，看看自己是否真的可以去休息了（进入waiting状态，如果线程状态转换不熟，可以参考本人上一篇写的Thread详解），万一队列前边的线程都放弃了只是瞎站着，那也说不定，对吧！</h5><pre><code class=\"lang-java\">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {\n    int ws = pred.waitStatus;//拿到前驱的状态\n    if (ws == Node.SIGNAL)\n        //如果已经告诉前驱拿完号后通知自己一下，那就可以安心休息了\n        return true;\n    if (ws &gt; 0) {\n        /*\n         * 如果前驱放弃了，那就一直往前找，直到找到最近一个正常等待的状态，并排在它的后边。\n         * 注意：那些放弃的结点，由于被自己“加塞”到它们前边，它们相当于形成一个无引用链，稍后就会被保安大叔赶走了(GC回收)！\n         */\n        do {\n            node.prev = pred = pred.prev;\n        } while (pred.waitStatus &gt; 0);\n        pred.next = node;\n    } else {\n         //如果前驱正常，那就把前驱的状态设置成SIGNAL，告诉它拿完号后通知自己一下。有可能失败，人家说不定刚刚释放完呢！\n        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);\n    }\n    return false;\n}\n</code></pre>\n<h5 id=\"整个流程中，如果前驱结点的状态不是SIGNAL，那么自己就不能安心去休息，需要去找个安心的休息点，同时可以再尝试下看有没有机会轮到自己拿号。\"><a href=\"#整个流程中，如果前驱结点的状态不是SIGNAL，那么自己就不能安心去休息，需要去找个安心的休息点，同时可以再尝试下看有没有机会轮到自己拿号。\" class=\"headerlink\" title=\"整个流程中，如果前驱结点的状态不是SIGNAL，那么自己就不能安心去休息，需要去找个安心的休息点，同时可以再尝试下看有没有机会轮到自己拿号。\"></a>整个流程中，如果前驱结点的状态不是SIGNAL，那么自己就不能安心去休息，需要去找个安心的休息点，同时可以再尝试下看有没有机会轮到自己拿号。</h5><h3 id=\"parkAndCheckInterrupt\"><a href=\"#parkAndCheckInterrupt\" class=\"headerlink\" title=\"parkAndCheckInterrupt()\"></a>parkAndCheckInterrupt()</h3><h5 id=\"如果线程找好安全休息点后，那就可以安心去休息了。此方法就是让线程去休息，真正进入等待状态。\"><a href=\"#如果线程找好安全休息点后，那就可以安心去休息了。此方法就是让线程去休息，真正进入等待状态。\" class=\"headerlink\" title=\"如果线程找好安全休息点后，那就可以安心去休息了。此方法就是让线程去休息，真正进入等待状态。\"></a>如果线程找好安全休息点后，那就可以安心去休息了。此方法就是让线程去休息，真正进入等待状态。</h5><pre><code class=\"lang-java\">private final boolean parkAndCheckInterrupt() {\n    LockSupport.park(this);//调用park()使线程进入waiting状态\n    return Thread.interrupted();//如果被唤醒，查看自己是不是被中断的。\n}\n</code></pre>\n<h5 id=\"park-会让当前线程进入waiting状态。在此状态下，有两种途径可以唤醒该线程：1）被unpark-；2）被interrupt-。（再说一句，如果线程状态转换不熟，可以参考本人写的Thread详解）。需要注意的是，Thread-interrupted-会清除当前线程的中断标记位。\"><a href=\"#park-会让当前线程进入waiting状态。在此状态下，有两种途径可以唤醒该线程：1）被unpark-；2）被interrupt-。（再说一句，如果线程状态转换不熟，可以参考本人写的Thread详解）。需要注意的是，Thread-interrupted-会清除当前线程的中断标记位。\" class=\"headerlink\" title=\"park()会让当前线程进入waiting状态。在此状态下，有两种途径可以唤醒该线程：1）被unpark()；2）被interrupt()。（再说一句，如果线程状态转换不熟，可以参考本人写的Thread详解）。需要注意的是，Thread.interrupted()会清除当前线程的中断标记位。\"></a>park()会让当前线程进入waiting状态。在此状态下，有两种途径可以唤醒该线程：1）被unpark()；2）被interrupt()。（再说一句，如果线程状态转换不熟，可以参考本人写的Thread详解）。需要注意的是，Thread.interrupted()会清除当前线程的中断标记位。</h5><h4 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h4><h5 id=\"OK，看了shouldParkAfterFailedAcquire-和parkAndCheckInterrupt-，现在让我们再回到acquireQueued-，总结下该函数的具体流程：\"><a href=\"#OK，看了shouldParkAfterFailedAcquire-和parkAndCheckInterrupt-，现在让我们再回到acquireQueued-，总结下该函数的具体流程：\" class=\"headerlink\" title=\"OK，看了shouldParkAfterFailedAcquire()和parkAndCheckInterrupt()，现在让我们再回到acquireQueued()，总结下该函数的具体流程：\"></a>OK，看了shouldParkAfterFailedAcquire()和parkAndCheckInterrupt()，现在让我们再回到acquireQueued()，总结下该函数的具体流程：</h5><ol>\n<li>结点进入队尾后，检查状态，找到安全休息点；</li>\n<li>调用park()进入waiting状态，等待unpark()或interrupt()唤醒自己；</li>\n<li>被唤醒后，看自己是不是有资格能拿到号。如果拿到，head指向当前结点，并返回从入队到拿到号的整个过程中是否被中断过；如果没拿到，继续流程1。</li>\n</ol>\n<h3 id=\"小结-1\"><a href=\"#小结-1\" class=\"headerlink\" title=\"小结\"></a>小结</h3><h5 id=\"OKOK，acquireQueued-分析完之后，我们接下来再回到acquire-！再贴上它的源码吧：\"><a href=\"#OKOK，acquireQueued-分析完之后，我们接下来再回到acquire-！再贴上它的源码吧：\" class=\"headerlink\" title=\"OKOK，acquireQueued()分析完之后，我们接下来再回到acquire()！再贴上它的源码吧：\"></a>OKOK，acquireQueued()分析完之后，我们接下来再回到acquire()！再贴上它的源码吧：</h5><pre><code class=\"lang-java\">public final void acquire(int arg) {\n    if (!tryAcquire(arg) &amp;&amp;\n        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        selfInterrupt();\n}\n</code></pre>\n<h5 id=\"再来总结下它的流程吧：\"><a href=\"#再来总结下它的流程吧：\" class=\"headerlink\" title=\"再来总结下它的流程吧：\"></a>再来总结下它的流程吧：</h5><ol>\n<li>调用自定义同步器的tryAcquire()尝试直接去获取资源，如果成功则直接返回；</li>\n<li>没成功，则addWaiter()将该线程加入等待队列的尾部，并标记为独占模式；</li>\n<li>acquireQueued()使线程在等待队列中休息，有机会时（轮到自己，会被unpark()）会去尝试获取资源。获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。</li>\n<li>如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。</li>\n</ol>\n<h5 id=\"由于此函数是重中之重，我再用流程图总结一下：\"><a href=\"#由于此函数是重中之重，我再用流程图总结一下：\" class=\"headerlink\" title=\"由于此函数是重中之重，我再用流程图总结一下：\"></a>由于此函数是重中之重，我再用流程图总结一下：</h5><p><img src=\"/img/note/jdk/aqs1.png\" alt=\"AQS队列\"></p>\n<h5 id=\"至此，acquire-的流程终于算是告一段落了。这也就是ReentrantLock-lock-的流程，不信你去看其lock-源码吧，整个函数就是一条acquire-1-！！！\"><a href=\"#至此，acquire-的流程终于算是告一段落了。这也就是ReentrantLock-lock-的流程，不信你去看其lock-源码吧，整个函数就是一条acquire-1-！！！\" class=\"headerlink\" title=\"至此，acquire()的流程终于算是告一段落了。这也就是ReentrantLock.lock()的流程，不信你去看其lock()源码吧，整个函数就是一条acquire(1)！！！\"></a>至此，acquire()的流程终于算是告一段落了。这也就是ReentrantLock.lock()的流程，不信你去看其lock()源码吧，整个函数就是一条acquire(1)！！！</h5><h3 id=\"release-int\"><a href=\"#release-int\" class=\"headerlink\" title=\"release(int)\"></a>release(int)</h3><h5 id=\"上一小节已经把acquire-说完了，这一小节就来讲讲它的反操作release-吧。此方法是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state-0）-它会唤醒等待队列里的其他线程来获取资源。这也正是unlock-的语义，当然不仅仅只限于unlock-。下面是release-的源码：\"><a href=\"#上一小节已经把acquire-说完了，这一小节就来讲讲它的反操作release-吧。此方法是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state-0）-它会唤醒等待队列里的其他线程来获取资源。这也正是unlock-的语义，当然不仅仅只限于unlock-。下面是release-的源码：\" class=\"headerlink\" title=\"上一小节已经把acquire()说完了，这一小节就来讲讲它的反操作release()吧。此方法是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state=0）,它会唤醒等待队列里的其他线程来获取资源。这也正是unlock()的语义，当然不仅仅只限于unlock()。下面是release()的源码：\"></a>上一小节已经把acquire()说完了，这一小节就来讲讲它的反操作release()吧。此方法是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state=0）,它会唤醒等待队列里的其他线程来获取资源。这也正是unlock()的语义，当然不仅仅只限于unlock()。下面是release()的源码：</h5><pre><code class=\"lang-java\">public final boolean release(int arg) {\n    if (tryRelease(arg)) {\n        Node h = head;//找到头结点\n        if (h != null &amp;&amp; h.waitStatus != 0)\n            unparkSuccessor(h);//唤醒等待队列里的下一个线程\n        return true;\n    }\n    return false;\n}\n</code></pre>\n<h5 id=\"逻辑并不复杂。它调用tryRelease-来释放资源。有一点需要注意的是，它是根据tryRelease-的返回值来判断该线程是否已经完成释放掉资源了！所以自定义同步器在设计tryRelease-的时候要明确这一点！！\"><a href=\"#逻辑并不复杂。它调用tryRelease-来释放资源。有一点需要注意的是，它是根据tryRelease-的返回值来判断该线程是否已经完成释放掉资源了！所以自定义同步器在设计tryRelease-的时候要明确这一点！！\" class=\"headerlink\" title=\"逻辑并不复杂。它调用tryRelease()来释放资源。有一点需要注意的是，它是根据tryRelease()的返回值来判断该线程是否已经完成释放掉资源了！所以自定义同步器在设计tryRelease()的时候要明确这一点！！\"></a>逻辑并不复杂。它调用tryRelease()来释放资源。有一点需要注意的是，它是根据tryRelease()的返回值来判断该线程是否已经完成释放掉资源了！所以自定义同步器在设计tryRelease()的时候要明确这一点！！</h5><h3 id=\"tryRelease-int\"><a href=\"#tryRelease-int\" class=\"headerlink\" title=\"tryRelease(int)\"></a>tryRelease(int)</h3><h5 id=\"此方法尝试去释放指定量的资源。下面是tryRelease-的源码：\"><a href=\"#此方法尝试去释放指定量的资源。下面是tryRelease-的源码：\" class=\"headerlink\" title=\"此方法尝试去释放指定量的资源。下面是tryRelease()的源码：\"></a>此方法尝试去释放指定量的资源。下面是tryRelease()的源码：</h5><pre><code class=\"lang-java\">protected boolean tryRelease(int arg) {\n    throw new UnsupportedOperationException();\n}\n</code></pre>\n<h5 id=\"跟tryAcquire-一样，这个方法是需要独占模式的自定义同步器去实现的。正常来说，tryRelease-都会成功的，因为这是独占模式，该线程来释放资源，那么它肯定已经拿到独占资源了，直接减掉相应量的资源即可-state-arg-，也不需要考虑线程安全的问题。但要注意它的返回值，上面已经提到了，release-是根据tryRelease-的返回值来判断该线程是否已经完成释放掉资源了！所以自义定同步器在实现时，如果已经彻底释放资源-state-0-，要返回true，否则返回false。\"><a href=\"#跟tryAcquire-一样，这个方法是需要独占模式的自定义同步器去实现的。正常来说，tryRelease-都会成功的，因为这是独占模式，该线程来释放资源，那么它肯定已经拿到独占资源了，直接减掉相应量的资源即可-state-arg-，也不需要考虑线程安全的问题。但要注意它的返回值，上面已经提到了，release-是根据tryRelease-的返回值来判断该线程是否已经完成释放掉资源了！所以自义定同步器在实现时，如果已经彻底释放资源-state-0-，要返回true，否则返回false。\" class=\"headerlink\" title=\"跟tryAcquire()一样，这个方法是需要独占模式的自定义同步器去实现的。正常来说，tryRelease()都会成功的，因为这是独占模式，该线程来释放资源，那么它肯定已经拿到独占资源了，直接减掉相应量的资源即可(state-=arg)，也不需要考虑线程安全的问题。但要注意它的返回值，上面已经提到了，release()是根据tryRelease()的返回值来判断该线程是否已经完成释放掉资源了！所以自义定同步器在实现时，如果已经彻底释放资源(state=0)，要返回true，否则返回false。\"></a>跟tryAcquire()一样，这个方法是需要独占模式的自定义同步器去实现的。正常来说，tryRelease()都会成功的，因为这是独占模式，该线程来释放资源，那么它肯定已经拿到独占资源了，直接减掉相应量的资源即可(state-=arg)，也不需要考虑线程安全的问题。但要注意它的返回值，上面已经提到了，release()是根据tryRelease()的返回值来判断该线程是否已经完成释放掉资源了！所以自义定同步器在实现时，如果已经彻底释放资源(state=0)，要返回true，否则返回false。</h5><h3 id=\"unparkSuccessor-Node\"><a href=\"#unparkSuccessor-Node\" class=\"headerlink\" title=\"unparkSuccessor(Node)\"></a>unparkSuccessor(Node)</h3><h5 id=\"此方法用于唤醒等待队列中下一个线程。下面是源码：\"><a href=\"#此方法用于唤醒等待队列中下一个线程。下面是源码：\" class=\"headerlink\" title=\"此方法用于唤醒等待队列中下一个线程。下面是源码：\"></a>此方法用于唤醒等待队列中下一个线程。下面是源码：</h5><pre><code class=\"lang-java\">private void unparkSuccessor(Node node) {\n    //这里，node一般为当前线程所在的结点。\n    int ws = node.waitStatus;\n    if (ws &lt; 0)//置零当前线程所在的结点状态，允许失败。\n        compareAndSetWaitStatus(node, ws, 0);\n    Node s = node.next;//找到下一个需要唤醒的结点s\n    if (s == null || s.waitStatus &gt; 0) {//如果为空或已取消\n        s = null;\n        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)\n            if (t.waitStatus &lt;= 0)//从这里可以看出，&lt;=0的结点，都是还有效的结点。\n                s = t;\n    }\n    if (s != null)\n        LockSupport.unpark(s.thread);//唤醒\n}\n</code></pre>\n<h5 id=\"这个函数并不复杂。一句话概括：用unpark-唤醒等待队列中最前边的那个未放弃线程，这里我们也用s来表示吧。此时，再和acquireQueued-联系起来，s被唤醒后，进入if-p-head-amp-amp-tryAcquire-arg-的判断（即使p-head也没关系，它会再进入shouldParkAfterFailedAcquire-寻找一个安全点。这里既然s已经是等待队列中最前边的那个未放弃线程了，那么通过shouldParkAfterFailedAcquire-的调整，s也必然会跑到head的next结点，下一次自旋p-head就成立啦），然后s把自己设置成head标杆结点，表示自己已经获取到资源了，acquire-也返回了！！And-then-DO-what-you-WANT\"><a href=\"#这个函数并不复杂。一句话概括：用unpark-唤醒等待队列中最前边的那个未放弃线程，这里我们也用s来表示吧。此时，再和acquireQueued-联系起来，s被唤醒后，进入if-p-head-amp-amp-tryAcquire-arg-的判断（即使p-head也没关系，它会再进入shouldParkAfterFailedAcquire-寻找一个安全点。这里既然s已经是等待队列中最前边的那个未放弃线程了，那么通过shouldParkAfterFailedAcquire-的调整，s也必然会跑到head的next结点，下一次自旋p-head就成立啦），然后s把自己设置成head标杆结点，表示自己已经获取到资源了，acquire-也返回了！！And-then-DO-what-you-WANT\" class=\"headerlink\" title=\"这个函数并不复杂。一句话概括：用unpark()唤醒等待队列中最前边的那个未放弃线程，这里我们也用s来表示吧。此时，再和acquireQueued()联系起来，s被唤醒后，进入if (p == head &amp;&amp; tryAcquire(arg))的判断（即使p!=head也没关系，它会再进入shouldParkAfterFailedAcquire()寻找一个安全点。这里既然s已经是等待队列中最前边的那个未放弃线程了，那么通过shouldParkAfterFailedAcquire()的调整，s也必然会跑到head的next结点，下一次自旋p==head就成立啦），然后s把自己设置成head标杆结点，表示自己已经获取到资源了，acquire()也返回了！！And then, DO what you WANT!\"></a>这个函数并不复杂。一句话概括：用unpark()唤醒等待队列中最前边的那个未放弃线程，这里我们也用s来表示吧。此时，再和acquireQueued()联系起来，s被唤醒后，进入if (p == head &amp;&amp; tryAcquire(arg))的判断（即使p!=head也没关系，它会再进入shouldParkAfterFailedAcquire()寻找一个安全点。这里既然s已经是等待队列中最前边的那个未放弃线程了，那么通过shouldParkAfterFailedAcquire()的调整，s也必然会跑到head的next结点，下一次自旋p==head就成立啦），然后s把自己设置成head标杆结点，表示自己已经获取到资源了，acquire()也返回了！！And then, DO what you WANT!</h5><h3 id=\"小结-2\"><a href=\"#小结-2\" class=\"headerlink\" title=\"小结\"></a>小结</h3><h5 id=\"release-是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state-0）-它会唤醒等待队列里的其他线程来获取资源。\"><a href=\"#release-是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state-0）-它会唤醒等待队列里的其他线程来获取资源。\" class=\"headerlink\" title=\"release()是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state=0）,它会唤醒等待队列里的其他线程来获取资源。\"></a>release()是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state=0）,它会唤醒等待队列里的其他线程来获取资源。</h5><h3 id=\"acquireShared-int\"><a href=\"#acquireShared-int\" class=\"headerlink\" title=\"acquireShared(int)\"></a>acquireShared(int)</h3><h5 id=\"此方法是共享模式下线程获取共享资源的顶层入口。它会获取指定量的资源，获取成功则直接返回，获取失败则进入等待队列，直到获取到资源为止，整个过程忽略中断。下面是acquireShared-的源码：\"><a href=\"#此方法是共享模式下线程获取共享资源的顶层入口。它会获取指定量的资源，获取成功则直接返回，获取失败则进入等待队列，直到获取到资源为止，整个过程忽略中断。下面是acquireShared-的源码：\" class=\"headerlink\" title=\"此方法是共享模式下线程获取共享资源的顶层入口。它会获取指定量的资源，获取成功则直接返回，获取失败则进入等待队列，直到获取到资源为止，整个过程忽略中断。下面是acquireShared()的源码：\"></a>此方法是共享模式下线程获取共享资源的顶层入口。它会获取指定量的资源，获取成功则直接返回，获取失败则进入等待队列，直到获取到资源为止，整个过程忽略中断。下面是acquireShared()的源码：</h5><pre><code class=\"lang-java\">public final void acquireShared(int arg) {\n    if (tryAcquireShared(arg) &lt; 0)\n        doAcquireShared(arg);\n}\n</code></pre>\n<h5 id=\"这里tryAcquireShared-依然需要自定义同步器去实现。但是AQS已经把其返回值的语义定义好了：负值代表获取失败；0代表获取成功，但没有剩余资源；正数表示获取成功，还有剩余资源，其他线程还可以去获取。所以这里acquireShared-的流程就是：\"><a href=\"#这里tryAcquireShared-依然需要自定义同步器去实现。但是AQS已经把其返回值的语义定义好了：负值代表获取失败；0代表获取成功，但没有剩余资源；正数表示获取成功，还有剩余资源，其他线程还可以去获取。所以这里acquireShared-的流程就是：\" class=\"headerlink\" title=\"这里tryAcquireShared()依然需要自定义同步器去实现。但是AQS已经把其返回值的语义定义好了：负值代表获取失败；0代表获取成功，但没有剩余资源；正数表示获取成功，还有剩余资源，其他线程还可以去获取。所以这里acquireShared()的流程就是：\"></a>这里tryAcquireShared()依然需要自定义同步器去实现。但是AQS已经把其返回值的语义定义好了：负值代表获取失败；0代表获取成功，但没有剩余资源；正数表示获取成功，还有剩余资源，其他线程还可以去获取。所以这里acquireShared()的流程就是：</h5><ol>\n<li>tryAcquireShared()尝试获取资源，成功则直接返回；</li>\n<li>失败则通过doAcquireShared()进入等待队列，直到获取到资源为止才返回。</li>\n</ol>\n<h3 id=\"doAcquireShared-int\"><a href=\"#doAcquireShared-int\" class=\"headerlink\" title=\"doAcquireShared(int)\"></a>doAcquireShared(int)</h3><h5 id=\"此方法用于将当前线程加入等待队列尾部休息，直到其他线程释放资源唤醒自己，自己成功拿到相应量的资源后才返回。下面是doAcquireShared-的源码：\"><a href=\"#此方法用于将当前线程加入等待队列尾部休息，直到其他线程释放资源唤醒自己，自己成功拿到相应量的资源后才返回。下面是doAcquireShared-的源码：\" class=\"headerlink\" title=\"此方法用于将当前线程加入等待队列尾部休息，直到其他线程释放资源唤醒自己，自己成功拿到相应量的资源后才返回。下面是doAcquireShared()的源码：\"></a>此方法用于将当前线程加入等待队列尾部休息，直到其他线程释放资源唤醒自己，自己成功拿到相应量的资源后才返回。下面是doAcquireShared()的源码：</h5><pre><code class=\"lang-java\">private void doAcquireShared(int arg) {\n    final Node node = addWaiter(Node.SHARED);//加入队列尾部\n    boolean failed = true;//是否成功标志\n    try {\n        boolean interrupted = false;//等待过程中是否被中断过的标志\n        for (;;) {\n            final Node p = node.predecessor();//前驱\n            if (p == head) {//如果到head的下一个，因为head是拿到资源的线程，此时node被唤醒，很可能是head用完资源来唤醒自己的\n                int r = tryAcquireShared(arg);//尝试获取资源\n                if (r &gt;= 0) {//成功\n                    setHeadAndPropagate(node, r);//将head指向自己，还有剩余资源可以再唤醒之后的线程\n                    p.next = null; // help GC\n                    if (interrupted)//如果等待过程中被打断过，此时将中断补上。\n                        selfInterrupt();\n                    failed = false;\n                    return;\n                }\n            }\n            //判断状态，寻找安全点，进入waiting状态，等着被unpark()或interrupt()\n            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;\n                parkAndCheckInterrupt())\n                interrupted = true;\n        }\n    } finally {\n        if (failed)\n            cancelAcquire(node);\n    }\n}\n</code></pre>\n<h5 id=\"有木有觉得跟acquireQueued-很相似？对，其实流程并没有太大区别。只不过这里将补中断的selfInterrupt-放到doAcquireShared-里了，而独占模式是放到acquireQueued-之外，其实都一样，不知道Doug-Lea是怎么想的。\"><a href=\"#有木有觉得跟acquireQueued-很相似？对，其实流程并没有太大区别。只不过这里将补中断的selfInterrupt-放到doAcquireShared-里了，而独占模式是放到acquireQueued-之外，其实都一样，不知道Doug-Lea是怎么想的。\" class=\"headerlink\" title=\"有木有觉得跟acquireQueued()很相似？对，其实流程并没有太大区别。只不过这里将补中断的selfInterrupt()放到doAcquireShared()里了，而独占模式是放到acquireQueued()之外，其实都一样，不知道Doug Lea是怎么想的。\"></a>有木有觉得跟acquireQueued()很相似？对，其实流程并没有太大区别。只不过这里将补中断的selfInterrupt()放到doAcquireShared()里了，而独占模式是放到acquireQueued()之外，其实都一样，不知道Doug Lea是怎么想的。</h5><h5 id=\"跟独占模式比，还有一点需要注意的是，这里只有线程是head-next时（“老二”），才会去尝试获取资源，有剩余的话还会唤醒之后的队友。那么问题就来了，假如老大用完后释放了5个资源，而老二需要6个，老三需要1个，老四需要2个。老大先唤醒老二，老二一看资源不够，他是把资源让给老三呢，还是不让？答案是否定的！老二会继续park-等待其他线程释放资源，也更不会去唤醒老三和老四了。独占模式，同一时刻只有一个线程去执行，这样做未尝不可；但共享模式下，多个线程是可以同时执行的，现在因为老二的资源需求量大，而把后面量小的老三和老四也都卡住了。当然，这并不是问题，只是AQS保证严格按照入队顺序唤醒罢了（保证公平，但降低了并发）。\"><a href=\"#跟独占模式比，还有一点需要注意的是，这里只有线程是head-next时（“老二”），才会去尝试获取资源，有剩余的话还会唤醒之后的队友。那么问题就来了，假如老大用完后释放了5个资源，而老二需要6个，老三需要1个，老四需要2个。老大先唤醒老二，老二一看资源不够，他是把资源让给老三呢，还是不让？答案是否定的！老二会继续park-等待其他线程释放资源，也更不会去唤醒老三和老四了。独占模式，同一时刻只有一个线程去执行，这样做未尝不可；但共享模式下，多个线程是可以同时执行的，现在因为老二的资源需求量大，而把后面量小的老三和老四也都卡住了。当然，这并不是问题，只是AQS保证严格按照入队顺序唤醒罢了（保证公平，但降低了并发）。\" class=\"headerlink\" title=\"跟独占模式比，还有一点需要注意的是，这里只有线程是head.next时（“老二”），才会去尝试获取资源，有剩余的话还会唤醒之后的队友。那么问题就来了，假如老大用完后释放了5个资源，而老二需要6个，老三需要1个，老四需要2个。老大先唤醒老二，老二一看资源不够，他是把资源让给老三呢，还是不让？答案是否定的！老二会继续park()等待其他线程释放资源，也更不会去唤醒老三和老四了。独占模式，同一时刻只有一个线程去执行，这样做未尝不可；但共享模式下，多个线程是可以同时执行的，现在因为老二的资源需求量大，而把后面量小的老三和老四也都卡住了。当然，这并不是问题，只是AQS保证严格按照入队顺序唤醒罢了（保证公平，但降低了并发）。\"></a>跟独占模式比，还有一点需要注意的是，这里只有线程是head.next时（“老二”），才会去尝试获取资源，有剩余的话还会唤醒之后的队友。那么问题就来了，假如老大用完后释放了5个资源，而老二需要6个，老三需要1个，老四需要2个。老大先唤醒老二，老二一看资源不够，他是把资源让给老三呢，还是不让？答案是否定的！老二会继续park()等待其他线程释放资源，也更不会去唤醒老三和老四了。独占模式，同一时刻只有一个线程去执行，这样做未尝不可；但共享模式下，多个线程是可以同时执行的，现在因为老二的资源需求量大，而把后面量小的老三和老四也都卡住了。当然，这并不是问题，只是AQS保证严格按照入队顺序唤醒罢了（保证公平，但降低了并发）。</h5><h3 id=\"setHeadAndPropagate-Node-int\"><a href=\"#setHeadAndPropagate-Node-int\" class=\"headerlink\" title=\"setHeadAndPropagate(Node, int)\"></a>setHeadAndPropagate(Node, int)</h3><pre><code class=\"lang-java\">private void setHeadAndPropagate(Node node, int propagate) {\n    Node h = head;\n    setHead(node);//head指向自己\n     //如果还有剩余量，继续唤醒下一个邻居线程\n    if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0) {\n        Node s = node.next;\n        if (s == null || s.isShared())\n            doReleaseShared();\n    }\n}\n</code></pre>\n<h5 id=\"此方法在setHead-的基础上多了一步，就是自己苏醒的同时，如果条件符合（比如还有剩余资源），还会去唤醒后继结点，毕竟是共享模式！\"><a href=\"#此方法在setHead-的基础上多了一步，就是自己苏醒的同时，如果条件符合（比如还有剩余资源），还会去唤醒后继结点，毕竟是共享模式！\" class=\"headerlink\" title=\"此方法在setHead()的基础上多了一步，就是自己苏醒的同时，如果条件符合（比如还有剩余资源），还会去唤醒后继结点，毕竟是共享模式！\"></a>此方法在setHead()的基础上多了一步，就是自己苏醒的同时，如果条件符合（比如还有剩余资源），还会去唤醒后继结点，毕竟是共享模式！</h5><h5 id=\"doReleaseShared-我们留着下一小节的releaseShared-里来讲。\"><a href=\"#doReleaseShared-我们留着下一小节的releaseShared-里来讲。\" class=\"headerlink\" title=\"doReleaseShared()我们留着下一小节的releaseShared()里来讲。\"></a>doReleaseShared()我们留着下一小节的releaseShared()里来讲。</h5><h3 id=\"小结-3\"><a href=\"#小结-3\" class=\"headerlink\" title=\"小结\"></a>小结</h3><h5 id=\"OK，至此，acquireShared-也要告一段落了。让我们再梳理一下它的流程：\"><a href=\"#OK，至此，acquireShared-也要告一段落了。让我们再梳理一下它的流程：\" class=\"headerlink\" title=\"OK，至此，acquireShared()也要告一段落了。让我们再梳理一下它的流程：\"></a>OK，至此，acquireShared()也要告一段落了。让我们再梳理一下它的流程：</h5><ol>\n<li>tryAcquireShared()尝试获取资源，成功则直接返回；</li>\n<li>失败则通过doAcquireShared()进入等待队列park()，直到被unpark()/interrupt()并成功获取到资源才返回。整个等待过程也是忽略中断的。\n　　<h5 id=\"其实跟acquire-的流程大同小异，只不过多了个自己拿到资源后，还会去唤醒后继队友的操作（这才是共享嘛）。\"><a href=\"#其实跟acquire-的流程大同小异，只不过多了个自己拿到资源后，还会去唤醒后继队友的操作（这才是共享嘛）。\" class=\"headerlink\" title=\"其实跟acquire()的流程大同小异，只不过多了个自己拿到资源后，还会去唤醒后继队友的操作（这才是共享嘛）。\"></a>其实跟acquire()的流程大同小异，只不过多了个自己拿到资源后，还会去唤醒后继队友的操作（这才是共享嘛）。</h5></li>\n</ol>\n<h3 id=\"releaseShared\"><a href=\"#releaseShared\" class=\"headerlink\" title=\"releaseShared()\"></a>releaseShared()</h3><h5 id=\"上一小节已经把acquireShared-说完了，这一小节就来讲讲它的反操作releaseShared-吧。此方法是共享模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果成功释放且允许唤醒等待线程，它会唤醒等待队列里的其他线程来获取资源。下面是releaseShared-的源码：\"><a href=\"#上一小节已经把acquireShared-说完了，这一小节就来讲讲它的反操作releaseShared-吧。此方法是共享模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果成功释放且允许唤醒等待线程，它会唤醒等待队列里的其他线程来获取资源。下面是releaseShared-的源码：\" class=\"headerlink\" title=\"上一小节已经把acquireShared()说完了，这一小节就来讲讲它的反操作releaseShared()吧。此方法是共享模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果成功释放且允许唤醒等待线程，它会唤醒等待队列里的其他线程来获取资源。下面是releaseShared()的源码：\"></a>上一小节已经把acquireShared()说完了，这一小节就来讲讲它的反操作releaseShared()吧。此方法是共享模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果成功释放且允许唤醒等待线程，它会唤醒等待队列里的其他线程来获取资源。下面是releaseShared()的源码：</h5><pre><code class=\"lang-java\">public final boolean releaseShared(int arg) {\n    if (tryReleaseShared(arg)) {//尝试释放资源\n        doReleaseShared();//唤醒后继结点\n        return true;\n    }\n    return false;\n}\n</code></pre>\n<h5 id=\"此方法的流程也比较简单，一句话：释放掉资源后，唤醒后继。跟独占模式下的release-相似，但有一点稍微需要注意：独占模式下的tryRelease-在完全释放掉资源（state-0）后，才会返回true去唤醒其他线程，这主要是基于独占下可重入的考量；而共享模式下的releaseShared-则没有这种要求，共享模式实质就是控制一定量的线程并发执行，那么拥有资源的线程在释放掉部分资源时就可以唤醒后继等待结点。例如，资源总量是13，A（5）和B（7）分别获取到资源并发运行，C（4）来时只剩1个资源就需要等待。A在运行过程中释放掉2个资源量，然后tryReleaseShared-2-返回true唤醒C，C一看只有3个仍不够继续等待；随后B又释放2个，tryReleaseShared-2-返回true唤醒C，C一看有5个够自己用了，然后C就可以跟A和B一起运行。而ReentrantReadWriteLock读锁的tryReleaseShared-只有在完全释放掉资源（state-0）才返回true，所以自定义同步器可以根据需要决定tryReleaseShared-的返回值。\"><a href=\"#此方法的流程也比较简单，一句话：释放掉资源后，唤醒后继。跟独占模式下的release-相似，但有一点稍微需要注意：独占模式下的tryRelease-在完全释放掉资源（state-0）后，才会返回true去唤醒其他线程，这主要是基于独占下可重入的考量；而共享模式下的releaseShared-则没有这种要求，共享模式实质就是控制一定量的线程并发执行，那么拥有资源的线程在释放掉部分资源时就可以唤醒后继等待结点。例如，资源总量是13，A（5）和B（7）分别获取到资源并发运行，C（4）来时只剩1个资源就需要等待。A在运行过程中释放掉2个资源量，然后tryReleaseShared-2-返回true唤醒C，C一看只有3个仍不够继续等待；随后B又释放2个，tryReleaseShared-2-返回true唤醒C，C一看有5个够自己用了，然后C就可以跟A和B一起运行。而ReentrantReadWriteLock读锁的tryReleaseShared-只有在完全释放掉资源（state-0）才返回true，所以自定义同步器可以根据需要决定tryReleaseShared-的返回值。\" class=\"headerlink\" title=\"此方法的流程也比较简单，一句话：释放掉资源后，唤醒后继。跟独占模式下的release()相似，但有一点稍微需要注意：独占模式下的tryRelease()在完全释放掉资源（state=0）后，才会返回true去唤醒其他线程，这主要是基于独占下可重入的考量；而共享模式下的releaseShared()则没有这种要求，共享模式实质就是控制一定量的线程并发执行，那么拥有资源的线程在释放掉部分资源时就可以唤醒后继等待结点。例如，资源总量是13，A（5）和B（7）分别获取到资源并发运行，C（4）来时只剩1个资源就需要等待。A在运行过程中释放掉2个资源量，然后tryReleaseShared(2)返回true唤醒C，C一看只有3个仍不够继续等待；随后B又释放2个，tryReleaseShared(2)返回true唤醒C，C一看有5个够自己用了，然后C就可以跟A和B一起运行。而ReentrantReadWriteLock读锁的tryReleaseShared()只有在完全释放掉资源（state=0）才返回true，所以自定义同步器可以根据需要决定tryReleaseShared()的返回值。\"></a>此方法的流程也比较简单，一句话：释放掉资源后，唤醒后继。跟独占模式下的release()相似，但有一点稍微需要注意：独占模式下的tryRelease()在完全释放掉资源（state=0）后，才会返回true去唤醒其他线程，这主要是基于独占下可重入的考量；而共享模式下的releaseShared()则没有这种要求，共享模式实质就是控制一定量的线程并发执行，那么拥有资源的线程在释放掉部分资源时就可以唤醒后继等待结点。例如，资源总量是13，A（5）和B（7）分别获取到资源并发运行，C（4）来时只剩1个资源就需要等待。A在运行过程中释放掉2个资源量，然后tryReleaseShared(2)返回true唤醒C，C一看只有3个仍不够继续等待；随后B又释放2个，tryReleaseShared(2)返回true唤醒C，C一看有5个够自己用了，然后C就可以跟A和B一起运行。而ReentrantReadWriteLock读锁的tryReleaseShared()只有在完全释放掉资源（state=0）才返回true，所以自定义同步器可以根据需要决定tryReleaseShared()的返回值。</h5><h3 id=\"doReleaseShared\"><a href=\"#doReleaseShared\" class=\"headerlink\" title=\"doReleaseShared()\"></a>doReleaseShared()</h3><h5 id=\"此方法主要用于唤醒后继。下面是它的源码：\"><a href=\"#此方法主要用于唤醒后继。下面是它的源码：\" class=\"headerlink\" title=\"此方法主要用于唤醒后继。下面是它的源码：\"></a>此方法主要用于唤醒后继。下面是它的源码：</h5><pre><code class=\"lang-java\">private void doReleaseShared() {\n    for (;;) {\n        Node h = head;\n        if (h != null &amp;&amp; h != tail) {\n            int ws = h.waitStatus;\n            if (ws == Node.SIGNAL) {\n                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))\n                    continue;\n                unparkSuccessor(h);//唤醒后继\n            }\n            else if (ws == 0 &amp;&amp;\n                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))\n                continue;\n        }\n        if (h == head)// head发生变化\n            break;\n    }\n}\n</code></pre>\n<h3 id=\"小结-4\"><a href=\"#小结-4\" class=\"headerlink\" title=\"小结\"></a>小结</h3><h5 id=\"本节我们详解了独占和共享两种模式下获取-释放资源-acquire-release、acquireShared-releaseShared-的源码，相信大家都有一定认识了。值得注意的是，acquire-和acquireSahred-两种方法下，线程在等待队列中都是忽略中断的。AQS也支持响应中断的，acquireInterruptibly-acquireSharedInterruptibly-即是，这里相应的源码跟acquire-和acquireSahred-差不多，这里就不再详解了。\"><a href=\"#本节我们详解了独占和共享两种模式下获取-释放资源-acquire-release、acquireShared-releaseShared-的源码，相信大家都有一定认识了。值得注意的是，acquire-和acquireSahred-两种方法下，线程在等待队列中都是忽略中断的。AQS也支持响应中断的，acquireInterruptibly-acquireSharedInterruptibly-即是，这里相应的源码跟acquire-和acquireSahred-差不多，这里就不再详解了。\" class=\"headerlink\" title=\"本节我们详解了独占和共享两种模式下获取-释放资源(acquire-release、acquireShared-releaseShared)的源码，相信大家都有一定认识了。值得注意的是，acquire()和acquireSahred()两种方法下，线程在等待队列中都是忽略中断的。AQS也支持响应中断的，acquireInterruptibly()/acquireSharedInterruptibly()即是，这里相应的源码跟acquire()和acquireSahred()差不多，这里就不再详解了。\"></a>本节我们详解了独占和共享两种模式下获取-释放资源(acquire-release、acquireShared-releaseShared)的源码，相信大家都有一定认识了。值得注意的是，acquire()和acquireSahred()两种方法下，线程在等待队列中都是忽略中断的。AQS也支持响应中断的，acquireInterruptibly()/acquireSharedInterruptibly()即是，这里相应的源码跟acquire()和acquireSahred()差不多，这里就不再详解了。</h5><h2 id=\"简单应用\"><a href=\"#简单应用\" class=\"headerlink\" title=\"简单应用\"></a>简单应用</h2><h5 id=\"OK，下面我们就以AQS源码里的Mutex为例，讲一下AQS的简单应用。\"><a href=\"#OK，下面我们就以AQS源码里的Mutex为例，讲一下AQS的简单应用。\" class=\"headerlink\" title=\"OK，下面我们就以AQS源码里的Mutex为例，讲一下AQS的简单应用。\"></a>OK，下面我们就以AQS源码里的Mutex为例，讲一下AQS的简单应用。</h5><h3 id=\"Mutex（互斥锁）\"><a href=\"#Mutex（互斥锁）\" class=\"headerlink\" title=\"Mutex（互斥锁）\"></a>Mutex（互斥锁）</h3><h5 id=\"Mutex是一个不可重入的互斥锁实现。锁资源（AQS里的state）只有两种状态：0表示未锁定，1表示锁定。下边是Mutex的核心源码：\"><a href=\"#Mutex是一个不可重入的互斥锁实现。锁资源（AQS里的state）只有两种状态：0表示未锁定，1表示锁定。下边是Mutex的核心源码：\" class=\"headerlink\" title=\"Mutex是一个不可重入的互斥锁实现。锁资源（AQS里的state）只有两种状态：0表示未锁定，1表示锁定。下边是Mutex的核心源码：\"></a>Mutex是一个不可重入的互斥锁实现。锁资源（AQS里的state）只有两种状态：0表示未锁定，1表示锁定。下边是Mutex的核心源码：</h5><pre><code class=\"lang-java\">class Mutex implements Lock, java.io.Serializable {\n    // 自定义同步器\n    private static class Sync extends AbstractQueuedSynchronizer {\n        // 判断是否锁定状态\n        protected boolean isHeldExclusively() {\n            return getState() == 1;\n        }\n        // 尝试获取资源，立即返回。成功则返回true，否则false。\n        public boolean tryAcquire(int acquires) {\n            assert acquires == 1; // 这里限定只能为1个量\n            if (compareAndSetState(0, 1)) {//state为0才设置为1，不可重入！\n                setExclusiveOwnerThread(Thread.currentThread());//设置为当前线程独占资源\n                return true;\n            }\n            return false;\n        }\n        // 尝试释放资源，立即返回。成功则为true，否则false。\n        protected boolean tryRelease(int releases) {\n            assert releases == 1; // 限定为1个量\n            if (getState() == 0)//既然来释放，那肯定就是已占有状态了。只是为了保险，多层判断！\n                throw new IllegalMonitorStateException();\n            setExclusiveOwnerThread(null);\n            setState(0);//释放资源，放弃占有状态\n            return true;\n        }\n    }\n    // 真正同步类的实现都依赖继承于AQS的自定义同步器！\n    private final Sync sync = new Sync();\n    //lock&lt;--&gt;acquire。两者语义一样：获取资源，即便等待，直到成功才返回。\n    public void lock() {\n        sync.acquire(1);\n    }\n    //tryLock&lt;--&gt;tryAcquire。两者语义一样：尝试获取资源，要求立即返回。成功则为true，失败则为false。\n    public boolean tryLock() {\n        return sync.tryAcquire(1);\n    }\n    //unlock&lt;--&gt;release。两者语文一样：释放资源。\n    public void unlock() {\n        sync.release(1);\n    }\n    //锁是否占有状态\n    public boolean isLocked() {\n        return sync.isHeldExclusively();\n    }\n}\n</code></pre>\n<h5 id=\"同步类在实现时一般都将自定义同步器（sync）定义为内部类，供自己使用；而同步类自己（Mutex）则实现某个接口，对外服务。当然，接口的实现要直接依赖sync，它们在语义上也存在某种对应关系！！而sync只用实现资源state的获取-释放方式tryAcquire-tryRelelase，至于线程的排队、等待、唤醒等，上层的AQS都已经实现好了，我们不用关心。\"><a href=\"#同步类在实现时一般都将自定义同步器（sync）定义为内部类，供自己使用；而同步类自己（Mutex）则实现某个接口，对外服务。当然，接口的实现要直接依赖sync，它们在语义上也存在某种对应关系！！而sync只用实现资源state的获取-释放方式tryAcquire-tryRelelase，至于线程的排队、等待、唤醒等，上层的AQS都已经实现好了，我们不用关心。\" class=\"headerlink\" title=\"同步类在实现时一般都将自定义同步器（sync）定义为内部类，供自己使用；而同步类自己（Mutex）则实现某个接口，对外服务。当然，接口的实现要直接依赖sync，它们在语义上也存在某种对应关系！！而sync只用实现资源state的获取-释放方式tryAcquire-tryRelelase，至于线程的排队、等待、唤醒等，上层的AQS都已经实现好了，我们不用关心。\"></a>同步类在实现时一般都将自定义同步器（sync）定义为内部类，供自己使用；而同步类自己（Mutex）则实现某个接口，对外服务。当然，接口的实现要直接依赖sync，它们在语义上也存在某种对应关系！！而sync只用实现资源state的获取-释放方式tryAcquire-tryRelelase，至于线程的排队、等待、唤醒等，上层的AQS都已经实现好了，我们不用关心。</h5><h5 id=\"除了Mutex，ReentrantLock-CountDownLatch-Semphore这些同步类的实现方式都差不多，不同的地方就在获取-释放资源的方式tryAcquire-tryRelelase。掌握了这点，AQS的核心便被攻破了！\"><a href=\"#除了Mutex，ReentrantLock-CountDownLatch-Semphore这些同步类的实现方式都差不多，不同的地方就在获取-释放资源的方式tryAcquire-tryRelelase。掌握了这点，AQS的核心便被攻破了！\" class=\"headerlink\" title=\"除了Mutex，ReentrantLock/CountDownLatch/Semphore这些同步类的实现方式都差不多，不同的地方就在获取-释放资源的方式tryAcquire-tryRelelase。掌握了这点，AQS的核心便被攻破了！\"></a>除了Mutex，ReentrantLock/CountDownLatch/Semphore这些同步类的实现方式都差不多，不同的地方就在获取-释放资源的方式tryAcquire-tryRelelase。掌握了这点，AQS的核心便被攻破了！</h5><h5 id=\"OK，至此，整个AQS的讲解也要落下帷幕了。希望本文能够对学习Java并发编程的同学有所借鉴，中间写的有不对的地方，也欢迎讨论和指正\"><a href=\"#OK，至此，整个AQS的讲解也要落下帷幕了。希望本文能够对学习Java并发编程的同学有所借鉴，中间写的有不对的地方，也欢迎讨论和指正\" class=\"headerlink\" title=\"OK，至此，整个AQS的讲解也要落下帷幕了。希望本文能够对学习Java并发编程的同学有所借鉴，中间写的有不对的地方，也欢迎讨论和指正~\"></a>OK，至此，整个AQS的讲解也要落下帷幕了。希望本文能够对学习Java并发编程的同学有所借鉴，中间写的有不对的地方，也欢迎讨论和指正~</h5><h3 id=\"文章转载自：https-www-cnblogs-com-waterystone-p-4920797-html\"><a href=\"#文章转载自：https-www-cnblogs-com-waterystone-p-4920797-html\" class=\"headerlink\" title=\"文章转载自：https://www.cnblogs.com/waterystone/p/4920797.html\"></a>文章转载自：<a href=\"https://www.cnblogs.com/waterystone/p/4920797.html\" target=\"_blank\" rel=\"external\">https://www.cnblogs.com/waterystone/p/4920797.html</a></h3>"},{"layout":"post","title":"java动态代理实现","date":"2018-01-07T16:00:00.000Z","original":true,"tag":[["java","java"]],"_content":"\n### 什么是java代理\n#### 为其他对象提供一种代理以控制对这个对象的访问。\n##### 代理是一种常见的设计模式，通过代理层这一中间层，有效的控制对于真实委托类对象的直接访问，同时可以实现自定义的控制策略，设计上获得更大的灵活性。\n<!-- more -->\n\n#### java代理模型\n![java代理](/img/note/proxy.png) <div class='img-note'>java代理</div>\n\n### java中常见的的代理实现\n1. spring aop (@Transactional)\n2. dubbo\n\n### 对目标方法的增强\n1. 缓存\n2. 流量控制、筛选、统计\n3. 线程池\n4. 失败重试\n5. 权限验证\n\n## 静态代理\n##### 实现java代理相对简单的一种方式\n##### 接口类：\n```java\npublic interface A {\n    void doIt();\n}\n```\n\n##### 接口实现类：\n```java\npublic class AImpl implements A{\n\n    public void doIt() {\n        System.out.println(\"I am a impl class\");\n    }\n}\n```\n\n##### 代理类：\n```java\npublic class AProxy implements A{\n\n    //被代理的对象实例\n    private A a;\n\n    public AProxy(A a) {\n        this.a = a;\n    }\n\n    public void doIt() {\n        //do something\n        System.out.println(\"I am a proxy class\");\n        //调用真正的实现类\n        a.doIt();\n        //do something\n    }\n}\n```\n\n##### Main：\n```java\npublic static void main(String[] args) {\n        //获取目标类\n        A a = new AImpl();\n\n        //通过目标类生成代理类\n        A a1 = new AProxy(a);\n\n        //调用目标方法\n        a1.doIt();\n}\n```\n\n##### 输出结果：\n```\nI am a proxy class\nI am a impl class\n```\n\n##### 假如需要在接口A、接口B、接口C的某个方法前后加上相同的逻辑（方法的耗时监控）。则需要分别实现AProxy、BProxy、CProxy。\n##### 因此这种静态的实现方式很不通用，也很不好扩展\n\n## JDK动态代理\n##### 动态代理避免了开发人员编写各个繁锁的静态代理类，只需简单地指定一组接口及目标类对象就能动态的获得代理对象。\n```java\npublic interface A {\n    void doIt();\n\n    void doItAgain();\n}\n```\n\n##### 接口实现类：\n```java\npublic class AImpl implements A{\n\n    public void doIt() {\n        System.out.println(\"I am a impl class\");\n    }\n\n    public void doItAgain(){\n        System.out.println(\"I am a impl class 2\");\n    }\n}\n```\n\n##### 代理类植入方法：\n```java\npublic class HWInvocationHandler implements InvocationHandler {\n\n    //目标对象\n    private Object target;\n\n    public HWInvocationHandler(Object target){\n        this.target = target;\n    }\n\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        System.out.println(\"------插入前置通知代码-------------\");\n        //执行相应的目标方法\n        Object rs = method.invoke(target,args);\n        System.out.println(\"------插入后置处理代码-------------\");\n        return rs;\n    }\n}\n```\n\n##### Main：\n```java\npublic static void main(String[] args)\n    {\n        //代理的真实对象\n        A a = new AImpl();\n\n        /**\n         * InvocationHandlerImpl 实现了 InvocationHandler 接口，并能实现方法调用从代理类到委托类的分派转发\n         */\n        InvocationHandler handler = new HWInvocationHandler(a);\n\n        ClassLoader loader = a.getClass().getClassLoader();\n        Class[] interfaces = a.getClass().getInterfaces();\n        /**\n         * 该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例\n         */\n        A proxy = (A) Proxy.newProxyInstance(loader, interfaces, handler);\n\n        proxy.doIt();\n\n        proxy.doItAgain();\n    }\n```\n\n##### 输出结果：\n```\n------插入前置通知代码-------------\nI am a impl class\n------插入后置处理代码-------------\n------插入前置通知代码-------------\nI am a impl class 2\n------插入后置处理代码-------------\n```\n\n##### 那么，可看到实现过程都是围绕着接口类来的，如果一个类没有定义接口。或者需要代理的方法不属于接口方法时。就没有办法进行代理\n\n## CGLIB动态代理实现\n\n##### CGLib采用了底层的字节码技术，利用asm开源包，通过字节码为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用\n\n#### 结构原理示例\n##### 目标类：\n```java\npublic class B{\n    void doIt(){\n        System.out.println(\"I am B\");\n    }\n}\n```\n\n##### 代理类：\n```java\nclass BProxy extends B{\n    void doIt(){\n        System.out.println(\"I am a proxy\");\n        //do something\n        super.doIt();\n        //do something\n    }\n}\n```\n\n##### Main：\n```java\npublic static void main(String[] args) {\n    //返回对象依然为目标类。但是实际拿到的对象是代理类\n    B b = new BProxy();\n\n    b.doIt();\n}\n```\n\n##### 输出结果：\n```\nI am a proxy\nI am B\n```\n\n##### 以上是CGLIB的基本实现原理。CGLIB需要做的就是用字节码实现BProxy类。以及找到那些方法是需要被代理的，然后重写代理方法。\n\n#### CGLIB语法\n##### 目标类：\n```java\npublic class B{\n    void doIt(){\n        System.out.println(\"I am B\");\n    }\n}\n```\n\n##### 代理实现：\n```java\nclass CglibProxy implements MethodInterceptor {\n    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {\n        System.out.println(\"I am a proxy\");\n        //do something\n        Object result = proxy.invokeSuper(obj, args);\n        //do something\n        return result;\n    }\n}\n```\n\n##### Main：\n```java\npublic static void main(String[] args) {\n    //创建CGLIB代理对象\n    CglibProxy proxy = new CglibProxy();\n    Enhancer enhancer = new Enhancer();\n    //设置父类\n    enhancer.setSuperclass(B.class);\n    enhancer.setCallback(proxy);\n    //创建子类实例\n    B b = (B) enhancer.create();\n    b.doIt();\n}\n```\n\n#### 输出结果：\n```\nI am a proxy\nI am B\n```\n\n##### 以上两种方案就是spring aop的代理实现原理。CGLIB的实现范围几乎包含了JDK动态代理的访问。为什么spring还需要实现两种方式，而不是直接使用CGLIB：\n1. 性能：CGLIB毕竟是第三方的实现，在优化方面是没有JDK的优势。按照非官方测试，从jdk6到jdk7再到jdk8。JDK动态代理的效率有质的飞跃。而CGLIB几乎没有变化。\n2. 安全：CGLIB毕竟是第三方的实现，虽然通过了JVM的语法检测，但是其实现方式比较底层。仍然有可能会有安全问题，比如内存泄漏。\n\n#### 之前遇到的一个问题：\n\n##### 实现类：\n```java\npublic class Impl {\n    public void m1(){\n        m2();\n    }\n\n    @Transactional\n    public void m2(){\n        //do something\n    }\n}\n```\n\n##### 接口A：\n```java\npublic interface A {\n    void m1();\n}\n```\n\n##### 接口B：\n```java\npublic interface B {\n    void m2();\n}\n```\n\n##### 接口C：\n```java\npublic interface C {\n    void m1();\n    void m2();\n}\n```\n\n##### 以及一些其他问题：\n1. private\n2. final\n3. static\n\n## JAVASSIST\n\n##### Javassist是一个执行字节码操作的强而有力的驱动代码库。它允许开发者自由的在一个已经编译好的类中添加新的方法，或者是修改已有的方法\n\n```java\npublic class Test {\n\n    protected String get(String s){\n        System.out.println(s);\n        return null;\n    }\n}\n```\n\n```java\npublic static void main(String[] args) throws Exception {\n        ClassPool aDefault = ClassPool.getDefault();\n        aDefault.insertClassPath(new ClassClassPath(JavassistTest.class));\n        CtClass ctClass = aDefault.get(\"com.river.Test\");\n        CtMethod get = ctClass.getDeclaredMethod(\"get\");\n        get.insertBefore(\"System.out.println(\\\"s\\\");\");\n//        Class<Test> testClass = Test.class;\n        Class aClass = ctClass.toClass();\n        Test o = (Test)aClass.newInstance();\n        o.get(\"a\");\n        Test test = new Test();\n        test.get(\"b\");\n        System.out.println(o.getClass());\n        System.out.println(test.getClass());\n    }\n```\n\n```\ns\na\ns\nb\nclass com.river.Test\nclass com.river.Test\n```\n\n#### 一些问题：\n1. 一个类可以被修改吗\n2. 不同类加载器加载的类还是同一个类吗\n3. 类在什么时候被加载\n4. 一个类可以被加载多少次\n\n##### 实现的大致过程如下\n![](/img/note/javassist.png)","source":"_posts/note/jdk/javaDynamicProxy.md","raw":"---\nlayout: post\ntitle: java动态代理实现\ndate: 2018/01/08\ntags: [tech, index]\noriginal: true\ntag: [[java, java]]\n---\n\n### 什么是java代理\n#### 为其他对象提供一种代理以控制对这个对象的访问。\n##### 代理是一种常见的设计模式，通过代理层这一中间层，有效的控制对于真实委托类对象的直接访问，同时可以实现自定义的控制策略，设计上获得更大的灵活性。\n<!-- more -->\n\n#### java代理模型\n![java代理](/img/note/proxy.png) <div class='img-note'>java代理</div>\n\n### java中常见的的代理实现\n1. spring aop (@Transactional)\n2. dubbo\n\n### 对目标方法的增强\n1. 缓存\n2. 流量控制、筛选、统计\n3. 线程池\n4. 失败重试\n5. 权限验证\n\n## 静态代理\n##### 实现java代理相对简单的一种方式\n##### 接口类：\n```java\npublic interface A {\n    void doIt();\n}\n```\n\n##### 接口实现类：\n```java\npublic class AImpl implements A{\n\n    public void doIt() {\n        System.out.println(\"I am a impl class\");\n    }\n}\n```\n\n##### 代理类：\n```java\npublic class AProxy implements A{\n\n    //被代理的对象实例\n    private A a;\n\n    public AProxy(A a) {\n        this.a = a;\n    }\n\n    public void doIt() {\n        //do something\n        System.out.println(\"I am a proxy class\");\n        //调用真正的实现类\n        a.doIt();\n        //do something\n    }\n}\n```\n\n##### Main：\n```java\npublic static void main(String[] args) {\n        //获取目标类\n        A a = new AImpl();\n\n        //通过目标类生成代理类\n        A a1 = new AProxy(a);\n\n        //调用目标方法\n        a1.doIt();\n}\n```\n\n##### 输出结果：\n```\nI am a proxy class\nI am a impl class\n```\n\n##### 假如需要在接口A、接口B、接口C的某个方法前后加上相同的逻辑（方法的耗时监控）。则需要分别实现AProxy、BProxy、CProxy。\n##### 因此这种静态的实现方式很不通用，也很不好扩展\n\n## JDK动态代理\n##### 动态代理避免了开发人员编写各个繁锁的静态代理类，只需简单地指定一组接口及目标类对象就能动态的获得代理对象。\n```java\npublic interface A {\n    void doIt();\n\n    void doItAgain();\n}\n```\n\n##### 接口实现类：\n```java\npublic class AImpl implements A{\n\n    public void doIt() {\n        System.out.println(\"I am a impl class\");\n    }\n\n    public void doItAgain(){\n        System.out.println(\"I am a impl class 2\");\n    }\n}\n```\n\n##### 代理类植入方法：\n```java\npublic class HWInvocationHandler implements InvocationHandler {\n\n    //目标对象\n    private Object target;\n\n    public HWInvocationHandler(Object target){\n        this.target = target;\n    }\n\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        System.out.println(\"------插入前置通知代码-------------\");\n        //执行相应的目标方法\n        Object rs = method.invoke(target,args);\n        System.out.println(\"------插入后置处理代码-------------\");\n        return rs;\n    }\n}\n```\n\n##### Main：\n```java\npublic static void main(String[] args)\n    {\n        //代理的真实对象\n        A a = new AImpl();\n\n        /**\n         * InvocationHandlerImpl 实现了 InvocationHandler 接口，并能实现方法调用从代理类到委托类的分派转发\n         */\n        InvocationHandler handler = new HWInvocationHandler(a);\n\n        ClassLoader loader = a.getClass().getClassLoader();\n        Class[] interfaces = a.getClass().getInterfaces();\n        /**\n         * 该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例\n         */\n        A proxy = (A) Proxy.newProxyInstance(loader, interfaces, handler);\n\n        proxy.doIt();\n\n        proxy.doItAgain();\n    }\n```\n\n##### 输出结果：\n```\n------插入前置通知代码-------------\nI am a impl class\n------插入后置处理代码-------------\n------插入前置通知代码-------------\nI am a impl class 2\n------插入后置处理代码-------------\n```\n\n##### 那么，可看到实现过程都是围绕着接口类来的，如果一个类没有定义接口。或者需要代理的方法不属于接口方法时。就没有办法进行代理\n\n## CGLIB动态代理实现\n\n##### CGLib采用了底层的字节码技术，利用asm开源包，通过字节码为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用\n\n#### 结构原理示例\n##### 目标类：\n```java\npublic class B{\n    void doIt(){\n        System.out.println(\"I am B\");\n    }\n}\n```\n\n##### 代理类：\n```java\nclass BProxy extends B{\n    void doIt(){\n        System.out.println(\"I am a proxy\");\n        //do something\n        super.doIt();\n        //do something\n    }\n}\n```\n\n##### Main：\n```java\npublic static void main(String[] args) {\n    //返回对象依然为目标类。但是实际拿到的对象是代理类\n    B b = new BProxy();\n\n    b.doIt();\n}\n```\n\n##### 输出结果：\n```\nI am a proxy\nI am B\n```\n\n##### 以上是CGLIB的基本实现原理。CGLIB需要做的就是用字节码实现BProxy类。以及找到那些方法是需要被代理的，然后重写代理方法。\n\n#### CGLIB语法\n##### 目标类：\n```java\npublic class B{\n    void doIt(){\n        System.out.println(\"I am B\");\n    }\n}\n```\n\n##### 代理实现：\n```java\nclass CglibProxy implements MethodInterceptor {\n    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {\n        System.out.println(\"I am a proxy\");\n        //do something\n        Object result = proxy.invokeSuper(obj, args);\n        //do something\n        return result;\n    }\n}\n```\n\n##### Main：\n```java\npublic static void main(String[] args) {\n    //创建CGLIB代理对象\n    CglibProxy proxy = new CglibProxy();\n    Enhancer enhancer = new Enhancer();\n    //设置父类\n    enhancer.setSuperclass(B.class);\n    enhancer.setCallback(proxy);\n    //创建子类实例\n    B b = (B) enhancer.create();\n    b.doIt();\n}\n```\n\n#### 输出结果：\n```\nI am a proxy\nI am B\n```\n\n##### 以上两种方案就是spring aop的代理实现原理。CGLIB的实现范围几乎包含了JDK动态代理的访问。为什么spring还需要实现两种方式，而不是直接使用CGLIB：\n1. 性能：CGLIB毕竟是第三方的实现，在优化方面是没有JDK的优势。按照非官方测试，从jdk6到jdk7再到jdk8。JDK动态代理的效率有质的飞跃。而CGLIB几乎没有变化。\n2. 安全：CGLIB毕竟是第三方的实现，虽然通过了JVM的语法检测，但是其实现方式比较底层。仍然有可能会有安全问题，比如内存泄漏。\n\n#### 之前遇到的一个问题：\n\n##### 实现类：\n```java\npublic class Impl {\n    public void m1(){\n        m2();\n    }\n\n    @Transactional\n    public void m2(){\n        //do something\n    }\n}\n```\n\n##### 接口A：\n```java\npublic interface A {\n    void m1();\n}\n```\n\n##### 接口B：\n```java\npublic interface B {\n    void m2();\n}\n```\n\n##### 接口C：\n```java\npublic interface C {\n    void m1();\n    void m2();\n}\n```\n\n##### 以及一些其他问题：\n1. private\n2. final\n3. static\n\n## JAVASSIST\n\n##### Javassist是一个执行字节码操作的强而有力的驱动代码库。它允许开发者自由的在一个已经编译好的类中添加新的方法，或者是修改已有的方法\n\n```java\npublic class Test {\n\n    protected String get(String s){\n        System.out.println(s);\n        return null;\n    }\n}\n```\n\n```java\npublic static void main(String[] args) throws Exception {\n        ClassPool aDefault = ClassPool.getDefault();\n        aDefault.insertClassPath(new ClassClassPath(JavassistTest.class));\n        CtClass ctClass = aDefault.get(\"com.river.Test\");\n        CtMethod get = ctClass.getDeclaredMethod(\"get\");\n        get.insertBefore(\"System.out.println(\\\"s\\\");\");\n//        Class<Test> testClass = Test.class;\n        Class aClass = ctClass.toClass();\n        Test o = (Test)aClass.newInstance();\n        o.get(\"a\");\n        Test test = new Test();\n        test.get(\"b\");\n        System.out.println(o.getClass());\n        System.out.println(test.getClass());\n    }\n```\n\n```\ns\na\ns\nb\nclass com.river.Test\nclass com.river.Test\n```\n\n#### 一些问题：\n1. 一个类可以被修改吗\n2. 不同类加载器加载的类还是同一个类吗\n3. 类在什么时候被加载\n4. 一个类可以被加载多少次\n\n##### 实现的大致过程如下\n![](/img/note/javassist.png)","slug":"note/jdk/javaDynamicProxy","published":1,"updated":"2018-05-08T13:00:14.279Z","comments":1,"photos":[],"link":"","_id":"cjgxop3nn003njah1okvb9bs6","content":"<h3 id=\"什么是java代理\"><a href=\"#什么是java代理\" class=\"headerlink\" title=\"什么是java代理\"></a>什么是java代理</h3><h4 id=\"为其他对象提供一种代理以控制对这个对象的访问。\"><a href=\"#为其他对象提供一种代理以控制对这个对象的访问。\" class=\"headerlink\" title=\"为其他对象提供一种代理以控制对这个对象的访问。\"></a>为其他对象提供一种代理以控制对这个对象的访问。</h4><h5 id=\"代理是一种常见的设计模式，通过代理层这一中间层，有效的控制对于真实委托类对象的直接访问，同时可以实现自定义的控制策略，设计上获得更大的灵活性。\"><a href=\"#代理是一种常见的设计模式，通过代理层这一中间层，有效的控制对于真实委托类对象的直接访问，同时可以实现自定义的控制策略，设计上获得更大的灵活性。\" class=\"headerlink\" title=\"代理是一种常见的设计模式，通过代理层这一中间层，有效的控制对于真实委托类对象的直接访问，同时可以实现自定义的控制策略，设计上获得更大的灵活性。\"></a>代理是一种常见的设计模式，通过代理层这一中间层，有效的控制对于真实委托类对象的直接访问，同时可以实现自定义的控制策略，设计上获得更大的灵活性。</h5><a id=\"more\"></a>\n<h4 id=\"java代理模型\"><a href=\"#java代理模型\" class=\"headerlink\" title=\"java代理模型\"></a>java代理模型</h4><p><img src=\"/img/note/proxy.png\" alt=\"java代理\"> <div class=\"img-note\">java代理</div></p>\n<h3 id=\"java中常见的的代理实现\"><a href=\"#java中常见的的代理实现\" class=\"headerlink\" title=\"java中常见的的代理实现\"></a>java中常见的的代理实现</h3><ol>\n<li>spring aop (@Transactional)</li>\n<li>dubbo</li>\n</ol>\n<h3 id=\"对目标方法的增强\"><a href=\"#对目标方法的增强\" class=\"headerlink\" title=\"对目标方法的增强\"></a>对目标方法的增强</h3><ol>\n<li>缓存</li>\n<li>流量控制、筛选、统计</li>\n<li>线程池</li>\n<li>失败重试</li>\n<li>权限验证</li>\n</ol>\n<h2 id=\"静态代理\"><a href=\"#静态代理\" class=\"headerlink\" title=\"静态代理\"></a>静态代理</h2><h5 id=\"实现java代理相对简单的一种方式\"><a href=\"#实现java代理相对简单的一种方式\" class=\"headerlink\" title=\"实现java代理相对简单的一种方式\"></a>实现java代理相对简单的一种方式</h5><h5 id=\"接口类：\"><a href=\"#接口类：\" class=\"headerlink\" title=\"接口类：\"></a>接口类：</h5><pre><code class=\"lang-java\">public interface A {\n    void doIt();\n}\n</code></pre>\n<h5 id=\"接口实现类：\"><a href=\"#接口实现类：\" class=\"headerlink\" title=\"接口实现类：\"></a>接口实现类：</h5><pre><code class=\"lang-java\">public class AImpl implements A{\n\n    public void doIt() {\n        System.out.println(&quot;I am a impl class&quot;);\n    }\n}\n</code></pre>\n<h5 id=\"代理类：\"><a href=\"#代理类：\" class=\"headerlink\" title=\"代理类：\"></a>代理类：</h5><pre><code class=\"lang-java\">public class AProxy implements A{\n\n    //被代理的对象实例\n    private A a;\n\n    public AProxy(A a) {\n        this.a = a;\n    }\n\n    public void doIt() {\n        //do something\n        System.out.println(&quot;I am a proxy class&quot;);\n        //调用真正的实现类\n        a.doIt();\n        //do something\n    }\n}\n</code></pre>\n<h5 id=\"Main：\"><a href=\"#Main：\" class=\"headerlink\" title=\"Main：\"></a>Main：</h5><pre><code class=\"lang-java\">public static void main(String[] args) {\n        //获取目标类\n        A a = new AImpl();\n\n        //通过目标类生成代理类\n        A a1 = new AProxy(a);\n\n        //调用目标方法\n        a1.doIt();\n}\n</code></pre>\n<h5 id=\"输出结果：\"><a href=\"#输出结果：\" class=\"headerlink\" title=\"输出结果：\"></a>输出结果：</h5><pre><code>I am a proxy class\nI am a impl class\n</code></pre><h5 id=\"假如需要在接口A、接口B、接口C的某个方法前后加上相同的逻辑（方法的耗时监控）。则需要分别实现AProxy、BProxy、CProxy。\"><a href=\"#假如需要在接口A、接口B、接口C的某个方法前后加上相同的逻辑（方法的耗时监控）。则需要分别实现AProxy、BProxy、CProxy。\" class=\"headerlink\" title=\"假如需要在接口A、接口B、接口C的某个方法前后加上相同的逻辑（方法的耗时监控）。则需要分别实现AProxy、BProxy、CProxy。\"></a>假如需要在接口A、接口B、接口C的某个方法前后加上相同的逻辑（方法的耗时监控）。则需要分别实现AProxy、BProxy、CProxy。</h5><h5 id=\"因此这种静态的实现方式很不通用，也很不好扩展\"><a href=\"#因此这种静态的实现方式很不通用，也很不好扩展\" class=\"headerlink\" title=\"因此这种静态的实现方式很不通用，也很不好扩展\"></a>因此这种静态的实现方式很不通用，也很不好扩展</h5><h2 id=\"JDK动态代理\"><a href=\"#JDK动态代理\" class=\"headerlink\" title=\"JDK动态代理\"></a>JDK动态代理</h2><h5 id=\"动态代理避免了开发人员编写各个繁锁的静态代理类，只需简单地指定一组接口及目标类对象就能动态的获得代理对象。\"><a href=\"#动态代理避免了开发人员编写各个繁锁的静态代理类，只需简单地指定一组接口及目标类对象就能动态的获得代理对象。\" class=\"headerlink\" title=\"动态代理避免了开发人员编写各个繁锁的静态代理类，只需简单地指定一组接口及目标类对象就能动态的获得代理对象。\"></a>动态代理避免了开发人员编写各个繁锁的静态代理类，只需简单地指定一组接口及目标类对象就能动态的获得代理对象。</h5><pre><code class=\"lang-java\">public interface A {\n    void doIt();\n\n    void doItAgain();\n}\n</code></pre>\n<h5 id=\"接口实现类：-1\"><a href=\"#接口实现类：-1\" class=\"headerlink\" title=\"接口实现类：\"></a>接口实现类：</h5><pre><code class=\"lang-java\">public class AImpl implements A{\n\n    public void doIt() {\n        System.out.println(&quot;I am a impl class&quot;);\n    }\n\n    public void doItAgain(){\n        System.out.println(&quot;I am a impl class 2&quot;);\n    }\n}\n</code></pre>\n<h5 id=\"代理类植入方法：\"><a href=\"#代理类植入方法：\" class=\"headerlink\" title=\"代理类植入方法：\"></a>代理类植入方法：</h5><pre><code class=\"lang-java\">public class HWInvocationHandler implements InvocationHandler {\n\n    //目标对象\n    private Object target;\n\n    public HWInvocationHandler(Object target){\n        this.target = target;\n    }\n\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        System.out.println(&quot;------插入前置通知代码-------------&quot;);\n        //执行相应的目标方法\n        Object rs = method.invoke(target,args);\n        System.out.println(&quot;------插入后置处理代码-------------&quot;);\n        return rs;\n    }\n}\n</code></pre>\n<h5 id=\"Main：-1\"><a href=\"#Main：-1\" class=\"headerlink\" title=\"Main：\"></a>Main：</h5><pre><code class=\"lang-java\">public static void main(String[] args)\n    {\n        //代理的真实对象\n        A a = new AImpl();\n\n        /**\n         * InvocationHandlerImpl 实现了 InvocationHandler 接口，并能实现方法调用从代理类到委托类的分派转发\n         */\n        InvocationHandler handler = new HWInvocationHandler(a);\n\n        ClassLoader loader = a.getClass().getClassLoader();\n        Class[] interfaces = a.getClass().getInterfaces();\n        /**\n         * 该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例\n         */\n        A proxy = (A) Proxy.newProxyInstance(loader, interfaces, handler);\n\n        proxy.doIt();\n\n        proxy.doItAgain();\n    }\n</code></pre>\n<h5 id=\"输出结果：-1\"><a href=\"#输出结果：-1\" class=\"headerlink\" title=\"输出结果：\"></a>输出结果：</h5><pre><code>------插入前置通知代码-------------\nI am a impl class\n------插入后置处理代码-------------\n------插入前置通知代码-------------\nI am a impl class 2\n------插入后置处理代码-------------\n</code></pre><h5 id=\"那么，可看到实现过程都是围绕着接口类来的，如果一个类没有定义接口。或者需要代理的方法不属于接口方法时。就没有办法进行代理\"><a href=\"#那么，可看到实现过程都是围绕着接口类来的，如果一个类没有定义接口。或者需要代理的方法不属于接口方法时。就没有办法进行代理\" class=\"headerlink\" title=\"那么，可看到实现过程都是围绕着接口类来的，如果一个类没有定义接口。或者需要代理的方法不属于接口方法时。就没有办法进行代理\"></a>那么，可看到实现过程都是围绕着接口类来的，如果一个类没有定义接口。或者需要代理的方法不属于接口方法时。就没有办法进行代理</h5><h2 id=\"CGLIB动态代理实现\"><a href=\"#CGLIB动态代理实现\" class=\"headerlink\" title=\"CGLIB动态代理实现\"></a>CGLIB动态代理实现</h2><h5 id=\"CGLib采用了底层的字节码技术，利用asm开源包，通过字节码为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用\"><a href=\"#CGLib采用了底层的字节码技术，利用asm开源包，通过字节码为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用\" class=\"headerlink\" title=\"CGLib采用了底层的字节码技术，利用asm开源包，通过字节码为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用\"></a>CGLib采用了底层的字节码技术，利用asm开源包，通过字节码为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用</h5><h4 id=\"结构原理示例\"><a href=\"#结构原理示例\" class=\"headerlink\" title=\"结构原理示例\"></a>结构原理示例</h4><h5 id=\"目标类：\"><a href=\"#目标类：\" class=\"headerlink\" title=\"目标类：\"></a>目标类：</h5><pre><code class=\"lang-java\">public class B{\n    void doIt(){\n        System.out.println(&quot;I am B&quot;);\n    }\n}\n</code></pre>\n<h5 id=\"代理类：-1\"><a href=\"#代理类：-1\" class=\"headerlink\" title=\"代理类：\"></a>代理类：</h5><pre><code class=\"lang-java\">class BProxy extends B{\n    void doIt(){\n        System.out.println(&quot;I am a proxy&quot;);\n        //do something\n        super.doIt();\n        //do something\n    }\n}\n</code></pre>\n<h5 id=\"Main：-2\"><a href=\"#Main：-2\" class=\"headerlink\" title=\"Main：\"></a>Main：</h5><pre><code class=\"lang-java\">public static void main(String[] args) {\n    //返回对象依然为目标类。但是实际拿到的对象是代理类\n    B b = new BProxy();\n\n    b.doIt();\n}\n</code></pre>\n<h5 id=\"输出结果：-2\"><a href=\"#输出结果：-2\" class=\"headerlink\" title=\"输出结果：\"></a>输出结果：</h5><pre><code>I am a proxy\nI am B\n</code></pre><h5 id=\"以上是CGLIB的基本实现原理。CGLIB需要做的就是用字节码实现BProxy类。以及找到那些方法是需要被代理的，然后重写代理方法。\"><a href=\"#以上是CGLIB的基本实现原理。CGLIB需要做的就是用字节码实现BProxy类。以及找到那些方法是需要被代理的，然后重写代理方法。\" class=\"headerlink\" title=\"以上是CGLIB的基本实现原理。CGLIB需要做的就是用字节码实现BProxy类。以及找到那些方法是需要被代理的，然后重写代理方法。\"></a>以上是CGLIB的基本实现原理。CGLIB需要做的就是用字节码实现BProxy类。以及找到那些方法是需要被代理的，然后重写代理方法。</h5><h4 id=\"CGLIB语法\"><a href=\"#CGLIB语法\" class=\"headerlink\" title=\"CGLIB语法\"></a>CGLIB语法</h4><h5 id=\"目标类：-1\"><a href=\"#目标类：-1\" class=\"headerlink\" title=\"目标类：\"></a>目标类：</h5><pre><code class=\"lang-java\">public class B{\n    void doIt(){\n        System.out.println(&quot;I am B&quot;);\n    }\n}\n</code></pre>\n<h5 id=\"代理实现：\"><a href=\"#代理实现：\" class=\"headerlink\" title=\"代理实现：\"></a>代理实现：</h5><pre><code class=\"lang-java\">class CglibProxy implements MethodInterceptor {\n    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {\n        System.out.println(&quot;I am a proxy&quot;);\n        //do something\n        Object result = proxy.invokeSuper(obj, args);\n        //do something\n        return result;\n    }\n}\n</code></pre>\n<h5 id=\"Main：-3\"><a href=\"#Main：-3\" class=\"headerlink\" title=\"Main：\"></a>Main：</h5><pre><code class=\"lang-java\">public static void main(String[] args) {\n    //创建CGLIB代理对象\n    CglibProxy proxy = new CglibProxy();\n    Enhancer enhancer = new Enhancer();\n    //设置父类\n    enhancer.setSuperclass(B.class);\n    enhancer.setCallback(proxy);\n    //创建子类实例\n    B b = (B) enhancer.create();\n    b.doIt();\n}\n</code></pre>\n<h4 id=\"输出结果：-3\"><a href=\"#输出结果：-3\" class=\"headerlink\" title=\"输出结果：\"></a>输出结果：</h4><pre><code>I am a proxy\nI am B\n</code></pre><h5 id=\"以上两种方案就是spring-aop的代理实现原理。CGLIB的实现范围几乎包含了JDK动态代理的访问。为什么spring还需要实现两种方式，而不是直接使用CGLIB：\"><a href=\"#以上两种方案就是spring-aop的代理实现原理。CGLIB的实现范围几乎包含了JDK动态代理的访问。为什么spring还需要实现两种方式，而不是直接使用CGLIB：\" class=\"headerlink\" title=\"以上两种方案就是spring aop的代理实现原理。CGLIB的实现范围几乎包含了JDK动态代理的访问。为什么spring还需要实现两种方式，而不是直接使用CGLIB：\"></a>以上两种方案就是spring aop的代理实现原理。CGLIB的实现范围几乎包含了JDK动态代理的访问。为什么spring还需要实现两种方式，而不是直接使用CGLIB：</h5><ol>\n<li>性能：CGLIB毕竟是第三方的实现，在优化方面是没有JDK的优势。按照非官方测试，从jdk6到jdk7再到jdk8。JDK动态代理的效率有质的飞跃。而CGLIB几乎没有变化。</li>\n<li>安全：CGLIB毕竟是第三方的实现，虽然通过了JVM的语法检测，但是其实现方式比较底层。仍然有可能会有安全问题，比如内存泄漏。</li>\n</ol>\n<h4 id=\"之前遇到的一个问题：\"><a href=\"#之前遇到的一个问题：\" class=\"headerlink\" title=\"之前遇到的一个问题：\"></a>之前遇到的一个问题：</h4><h5 id=\"实现类：\"><a href=\"#实现类：\" class=\"headerlink\" title=\"实现类：\"></a>实现类：</h5><pre><code class=\"lang-java\">public class Impl {\n    public void m1(){\n        m2();\n    }\n\n    @Transactional\n    public void m2(){\n        //do something\n    }\n}\n</code></pre>\n<h5 id=\"接口A：\"><a href=\"#接口A：\" class=\"headerlink\" title=\"接口A：\"></a>接口A：</h5><pre><code class=\"lang-java\">public interface A {\n    void m1();\n}\n</code></pre>\n<h5 id=\"接口B：\"><a href=\"#接口B：\" class=\"headerlink\" title=\"接口B：\"></a>接口B：</h5><pre><code class=\"lang-java\">public interface B {\n    void m2();\n}\n</code></pre>\n<h5 id=\"接口C：\"><a href=\"#接口C：\" class=\"headerlink\" title=\"接口C：\"></a>接口C：</h5><pre><code class=\"lang-java\">public interface C {\n    void m1();\n    void m2();\n}\n</code></pre>\n<h5 id=\"以及一些其他问题：\"><a href=\"#以及一些其他问题：\" class=\"headerlink\" title=\"以及一些其他问题：\"></a>以及一些其他问题：</h5><ol>\n<li>private</li>\n<li>final</li>\n<li>static</li>\n</ol>\n<h2 id=\"JAVASSIST\"><a href=\"#JAVASSIST\" class=\"headerlink\" title=\"JAVASSIST\"></a>JAVASSIST</h2><h5 id=\"Javassist是一个执行字节码操作的强而有力的驱动代码库。它允许开发者自由的在一个已经编译好的类中添加新的方法，或者是修改已有的方法\"><a href=\"#Javassist是一个执行字节码操作的强而有力的驱动代码库。它允许开发者自由的在一个已经编译好的类中添加新的方法，或者是修改已有的方法\" class=\"headerlink\" title=\"Javassist是一个执行字节码操作的强而有力的驱动代码库。它允许开发者自由的在一个已经编译好的类中添加新的方法，或者是修改已有的方法\"></a>Javassist是一个执行字节码操作的强而有力的驱动代码库。它允许开发者自由的在一个已经编译好的类中添加新的方法，或者是修改已有的方法</h5><pre><code class=\"lang-java\">public class Test {\n\n    protected String get(String s){\n        System.out.println(s);\n        return null;\n    }\n}\n</code></pre>\n<pre><code class=\"lang-java\">public static void main(String[] args) throws Exception {\n        ClassPool aDefault = ClassPool.getDefault();\n        aDefault.insertClassPath(new ClassClassPath(JavassistTest.class));\n        CtClass ctClass = aDefault.get(&quot;com.river.Test&quot;);\n        CtMethod get = ctClass.getDeclaredMethod(&quot;get&quot;);\n        get.insertBefore(&quot;System.out.println(\\&quot;s\\&quot;);&quot;);\n//        Class&lt;Test&gt; testClass = Test.class;\n        Class aClass = ctClass.toClass();\n        Test o = (Test)aClass.newInstance();\n        o.get(&quot;a&quot;);\n        Test test = new Test();\n        test.get(&quot;b&quot;);\n        System.out.println(o.getClass());\n        System.out.println(test.getClass());\n    }\n</code></pre>\n<pre><code>s\na\ns\nb\nclass com.river.Test\nclass com.river.Test\n</code></pre><h4 id=\"一些问题：\"><a href=\"#一些问题：\" class=\"headerlink\" title=\"一些问题：\"></a>一些问题：</h4><ol>\n<li>一个类可以被修改吗</li>\n<li>不同类加载器加载的类还是同一个类吗</li>\n<li>类在什么时候被加载</li>\n<li>一个类可以被加载多少次</li>\n</ol>\n<h5 id=\"实现的大致过程如下\"><a href=\"#实现的大致过程如下\" class=\"headerlink\" title=\"实现的大致过程如下\"></a>实现的大致过程如下</h5><p><img src=\"/img/note/javassist.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"什么是java代理\"><a href=\"#什么是java代理\" class=\"headerlink\" title=\"什么是java代理\"></a>什么是java代理</h3><h4 id=\"为其他对象提供一种代理以控制对这个对象的访问。\"><a href=\"#为其他对象提供一种代理以控制对这个对象的访问。\" class=\"headerlink\" title=\"为其他对象提供一种代理以控制对这个对象的访问。\"></a>为其他对象提供一种代理以控制对这个对象的访问。</h4><h5 id=\"代理是一种常见的设计模式，通过代理层这一中间层，有效的控制对于真实委托类对象的直接访问，同时可以实现自定义的控制策略，设计上获得更大的灵活性。\"><a href=\"#代理是一种常见的设计模式，通过代理层这一中间层，有效的控制对于真实委托类对象的直接访问，同时可以实现自定义的控制策略，设计上获得更大的灵活性。\" class=\"headerlink\" title=\"代理是一种常见的设计模式，通过代理层这一中间层，有效的控制对于真实委托类对象的直接访问，同时可以实现自定义的控制策略，设计上获得更大的灵活性。\"></a>代理是一种常见的设计模式，通过代理层这一中间层，有效的控制对于真实委托类对象的直接访问，同时可以实现自定义的控制策略，设计上获得更大的灵活性。</h5>","more":"<h4 id=\"java代理模型\"><a href=\"#java代理模型\" class=\"headerlink\" title=\"java代理模型\"></a>java代理模型</h4><p><img src=\"/img/note/proxy.png\" alt=\"java代理\"> <div class=\"img-note\">java代理</div></p>\n<h3 id=\"java中常见的的代理实现\"><a href=\"#java中常见的的代理实现\" class=\"headerlink\" title=\"java中常见的的代理实现\"></a>java中常见的的代理实现</h3><ol>\n<li>spring aop (@Transactional)</li>\n<li>dubbo</li>\n</ol>\n<h3 id=\"对目标方法的增强\"><a href=\"#对目标方法的增强\" class=\"headerlink\" title=\"对目标方法的增强\"></a>对目标方法的增强</h3><ol>\n<li>缓存</li>\n<li>流量控制、筛选、统计</li>\n<li>线程池</li>\n<li>失败重试</li>\n<li>权限验证</li>\n</ol>\n<h2 id=\"静态代理\"><a href=\"#静态代理\" class=\"headerlink\" title=\"静态代理\"></a>静态代理</h2><h5 id=\"实现java代理相对简单的一种方式\"><a href=\"#实现java代理相对简单的一种方式\" class=\"headerlink\" title=\"实现java代理相对简单的一种方式\"></a>实现java代理相对简单的一种方式</h5><h5 id=\"接口类：\"><a href=\"#接口类：\" class=\"headerlink\" title=\"接口类：\"></a>接口类：</h5><pre><code class=\"lang-java\">public interface A {\n    void doIt();\n}\n</code></pre>\n<h5 id=\"接口实现类：\"><a href=\"#接口实现类：\" class=\"headerlink\" title=\"接口实现类：\"></a>接口实现类：</h5><pre><code class=\"lang-java\">public class AImpl implements A{\n\n    public void doIt() {\n        System.out.println(&quot;I am a impl class&quot;);\n    }\n}\n</code></pre>\n<h5 id=\"代理类：\"><a href=\"#代理类：\" class=\"headerlink\" title=\"代理类：\"></a>代理类：</h5><pre><code class=\"lang-java\">public class AProxy implements A{\n\n    //被代理的对象实例\n    private A a;\n\n    public AProxy(A a) {\n        this.a = a;\n    }\n\n    public void doIt() {\n        //do something\n        System.out.println(&quot;I am a proxy class&quot;);\n        //调用真正的实现类\n        a.doIt();\n        //do something\n    }\n}\n</code></pre>\n<h5 id=\"Main：\"><a href=\"#Main：\" class=\"headerlink\" title=\"Main：\"></a>Main：</h5><pre><code class=\"lang-java\">public static void main(String[] args) {\n        //获取目标类\n        A a = new AImpl();\n\n        //通过目标类生成代理类\n        A a1 = new AProxy(a);\n\n        //调用目标方法\n        a1.doIt();\n}\n</code></pre>\n<h5 id=\"输出结果：\"><a href=\"#输出结果：\" class=\"headerlink\" title=\"输出结果：\"></a>输出结果：</h5><pre><code>I am a proxy class\nI am a impl class\n</code></pre><h5 id=\"假如需要在接口A、接口B、接口C的某个方法前后加上相同的逻辑（方法的耗时监控）。则需要分别实现AProxy、BProxy、CProxy。\"><a href=\"#假如需要在接口A、接口B、接口C的某个方法前后加上相同的逻辑（方法的耗时监控）。则需要分别实现AProxy、BProxy、CProxy。\" class=\"headerlink\" title=\"假如需要在接口A、接口B、接口C的某个方法前后加上相同的逻辑（方法的耗时监控）。则需要分别实现AProxy、BProxy、CProxy。\"></a>假如需要在接口A、接口B、接口C的某个方法前后加上相同的逻辑（方法的耗时监控）。则需要分别实现AProxy、BProxy、CProxy。</h5><h5 id=\"因此这种静态的实现方式很不通用，也很不好扩展\"><a href=\"#因此这种静态的实现方式很不通用，也很不好扩展\" class=\"headerlink\" title=\"因此这种静态的实现方式很不通用，也很不好扩展\"></a>因此这种静态的实现方式很不通用，也很不好扩展</h5><h2 id=\"JDK动态代理\"><a href=\"#JDK动态代理\" class=\"headerlink\" title=\"JDK动态代理\"></a>JDK动态代理</h2><h5 id=\"动态代理避免了开发人员编写各个繁锁的静态代理类，只需简单地指定一组接口及目标类对象就能动态的获得代理对象。\"><a href=\"#动态代理避免了开发人员编写各个繁锁的静态代理类，只需简单地指定一组接口及目标类对象就能动态的获得代理对象。\" class=\"headerlink\" title=\"动态代理避免了开发人员编写各个繁锁的静态代理类，只需简单地指定一组接口及目标类对象就能动态的获得代理对象。\"></a>动态代理避免了开发人员编写各个繁锁的静态代理类，只需简单地指定一组接口及目标类对象就能动态的获得代理对象。</h5><pre><code class=\"lang-java\">public interface A {\n    void doIt();\n\n    void doItAgain();\n}\n</code></pre>\n<h5 id=\"接口实现类：-1\"><a href=\"#接口实现类：-1\" class=\"headerlink\" title=\"接口实现类：\"></a>接口实现类：</h5><pre><code class=\"lang-java\">public class AImpl implements A{\n\n    public void doIt() {\n        System.out.println(&quot;I am a impl class&quot;);\n    }\n\n    public void doItAgain(){\n        System.out.println(&quot;I am a impl class 2&quot;);\n    }\n}\n</code></pre>\n<h5 id=\"代理类植入方法：\"><a href=\"#代理类植入方法：\" class=\"headerlink\" title=\"代理类植入方法：\"></a>代理类植入方法：</h5><pre><code class=\"lang-java\">public class HWInvocationHandler implements InvocationHandler {\n\n    //目标对象\n    private Object target;\n\n    public HWInvocationHandler(Object target){\n        this.target = target;\n    }\n\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        System.out.println(&quot;------插入前置通知代码-------------&quot;);\n        //执行相应的目标方法\n        Object rs = method.invoke(target,args);\n        System.out.println(&quot;------插入后置处理代码-------------&quot;);\n        return rs;\n    }\n}\n</code></pre>\n<h5 id=\"Main：-1\"><a href=\"#Main：-1\" class=\"headerlink\" title=\"Main：\"></a>Main：</h5><pre><code class=\"lang-java\">public static void main(String[] args)\n    {\n        //代理的真实对象\n        A a = new AImpl();\n\n        /**\n         * InvocationHandlerImpl 实现了 InvocationHandler 接口，并能实现方法调用从代理类到委托类的分派转发\n         */\n        InvocationHandler handler = new HWInvocationHandler(a);\n\n        ClassLoader loader = a.getClass().getClassLoader();\n        Class[] interfaces = a.getClass().getInterfaces();\n        /**\n         * 该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例\n         */\n        A proxy = (A) Proxy.newProxyInstance(loader, interfaces, handler);\n\n        proxy.doIt();\n\n        proxy.doItAgain();\n    }\n</code></pre>\n<h5 id=\"输出结果：-1\"><a href=\"#输出结果：-1\" class=\"headerlink\" title=\"输出结果：\"></a>输出结果：</h5><pre><code>------插入前置通知代码-------------\nI am a impl class\n------插入后置处理代码-------------\n------插入前置通知代码-------------\nI am a impl class 2\n------插入后置处理代码-------------\n</code></pre><h5 id=\"那么，可看到实现过程都是围绕着接口类来的，如果一个类没有定义接口。或者需要代理的方法不属于接口方法时。就没有办法进行代理\"><a href=\"#那么，可看到实现过程都是围绕着接口类来的，如果一个类没有定义接口。或者需要代理的方法不属于接口方法时。就没有办法进行代理\" class=\"headerlink\" title=\"那么，可看到实现过程都是围绕着接口类来的，如果一个类没有定义接口。或者需要代理的方法不属于接口方法时。就没有办法进行代理\"></a>那么，可看到实现过程都是围绕着接口类来的，如果一个类没有定义接口。或者需要代理的方法不属于接口方法时。就没有办法进行代理</h5><h2 id=\"CGLIB动态代理实现\"><a href=\"#CGLIB动态代理实现\" class=\"headerlink\" title=\"CGLIB动态代理实现\"></a>CGLIB动态代理实现</h2><h5 id=\"CGLib采用了底层的字节码技术，利用asm开源包，通过字节码为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用\"><a href=\"#CGLib采用了底层的字节码技术，利用asm开源包，通过字节码为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用\" class=\"headerlink\" title=\"CGLib采用了底层的字节码技术，利用asm开源包，通过字节码为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用\"></a>CGLib采用了底层的字节码技术，利用asm开源包，通过字节码为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用</h5><h4 id=\"结构原理示例\"><a href=\"#结构原理示例\" class=\"headerlink\" title=\"结构原理示例\"></a>结构原理示例</h4><h5 id=\"目标类：\"><a href=\"#目标类：\" class=\"headerlink\" title=\"目标类：\"></a>目标类：</h5><pre><code class=\"lang-java\">public class B{\n    void doIt(){\n        System.out.println(&quot;I am B&quot;);\n    }\n}\n</code></pre>\n<h5 id=\"代理类：-1\"><a href=\"#代理类：-1\" class=\"headerlink\" title=\"代理类：\"></a>代理类：</h5><pre><code class=\"lang-java\">class BProxy extends B{\n    void doIt(){\n        System.out.println(&quot;I am a proxy&quot;);\n        //do something\n        super.doIt();\n        //do something\n    }\n}\n</code></pre>\n<h5 id=\"Main：-2\"><a href=\"#Main：-2\" class=\"headerlink\" title=\"Main：\"></a>Main：</h5><pre><code class=\"lang-java\">public static void main(String[] args) {\n    //返回对象依然为目标类。但是实际拿到的对象是代理类\n    B b = new BProxy();\n\n    b.doIt();\n}\n</code></pre>\n<h5 id=\"输出结果：-2\"><a href=\"#输出结果：-2\" class=\"headerlink\" title=\"输出结果：\"></a>输出结果：</h5><pre><code>I am a proxy\nI am B\n</code></pre><h5 id=\"以上是CGLIB的基本实现原理。CGLIB需要做的就是用字节码实现BProxy类。以及找到那些方法是需要被代理的，然后重写代理方法。\"><a href=\"#以上是CGLIB的基本实现原理。CGLIB需要做的就是用字节码实现BProxy类。以及找到那些方法是需要被代理的，然后重写代理方法。\" class=\"headerlink\" title=\"以上是CGLIB的基本实现原理。CGLIB需要做的就是用字节码实现BProxy类。以及找到那些方法是需要被代理的，然后重写代理方法。\"></a>以上是CGLIB的基本实现原理。CGLIB需要做的就是用字节码实现BProxy类。以及找到那些方法是需要被代理的，然后重写代理方法。</h5><h4 id=\"CGLIB语法\"><a href=\"#CGLIB语法\" class=\"headerlink\" title=\"CGLIB语法\"></a>CGLIB语法</h4><h5 id=\"目标类：-1\"><a href=\"#目标类：-1\" class=\"headerlink\" title=\"目标类：\"></a>目标类：</h5><pre><code class=\"lang-java\">public class B{\n    void doIt(){\n        System.out.println(&quot;I am B&quot;);\n    }\n}\n</code></pre>\n<h5 id=\"代理实现：\"><a href=\"#代理实现：\" class=\"headerlink\" title=\"代理实现：\"></a>代理实现：</h5><pre><code class=\"lang-java\">class CglibProxy implements MethodInterceptor {\n    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {\n        System.out.println(&quot;I am a proxy&quot;);\n        //do something\n        Object result = proxy.invokeSuper(obj, args);\n        //do something\n        return result;\n    }\n}\n</code></pre>\n<h5 id=\"Main：-3\"><a href=\"#Main：-3\" class=\"headerlink\" title=\"Main：\"></a>Main：</h5><pre><code class=\"lang-java\">public static void main(String[] args) {\n    //创建CGLIB代理对象\n    CglibProxy proxy = new CglibProxy();\n    Enhancer enhancer = new Enhancer();\n    //设置父类\n    enhancer.setSuperclass(B.class);\n    enhancer.setCallback(proxy);\n    //创建子类实例\n    B b = (B) enhancer.create();\n    b.doIt();\n}\n</code></pre>\n<h4 id=\"输出结果：-3\"><a href=\"#输出结果：-3\" class=\"headerlink\" title=\"输出结果：\"></a>输出结果：</h4><pre><code>I am a proxy\nI am B\n</code></pre><h5 id=\"以上两种方案就是spring-aop的代理实现原理。CGLIB的实现范围几乎包含了JDK动态代理的访问。为什么spring还需要实现两种方式，而不是直接使用CGLIB：\"><a href=\"#以上两种方案就是spring-aop的代理实现原理。CGLIB的实现范围几乎包含了JDK动态代理的访问。为什么spring还需要实现两种方式，而不是直接使用CGLIB：\" class=\"headerlink\" title=\"以上两种方案就是spring aop的代理实现原理。CGLIB的实现范围几乎包含了JDK动态代理的访问。为什么spring还需要实现两种方式，而不是直接使用CGLIB：\"></a>以上两种方案就是spring aop的代理实现原理。CGLIB的实现范围几乎包含了JDK动态代理的访问。为什么spring还需要实现两种方式，而不是直接使用CGLIB：</h5><ol>\n<li>性能：CGLIB毕竟是第三方的实现，在优化方面是没有JDK的优势。按照非官方测试，从jdk6到jdk7再到jdk8。JDK动态代理的效率有质的飞跃。而CGLIB几乎没有变化。</li>\n<li>安全：CGLIB毕竟是第三方的实现，虽然通过了JVM的语法检测，但是其实现方式比较底层。仍然有可能会有安全问题，比如内存泄漏。</li>\n</ol>\n<h4 id=\"之前遇到的一个问题：\"><a href=\"#之前遇到的一个问题：\" class=\"headerlink\" title=\"之前遇到的一个问题：\"></a>之前遇到的一个问题：</h4><h5 id=\"实现类：\"><a href=\"#实现类：\" class=\"headerlink\" title=\"实现类：\"></a>实现类：</h5><pre><code class=\"lang-java\">public class Impl {\n    public void m1(){\n        m2();\n    }\n\n    @Transactional\n    public void m2(){\n        //do something\n    }\n}\n</code></pre>\n<h5 id=\"接口A：\"><a href=\"#接口A：\" class=\"headerlink\" title=\"接口A：\"></a>接口A：</h5><pre><code class=\"lang-java\">public interface A {\n    void m1();\n}\n</code></pre>\n<h5 id=\"接口B：\"><a href=\"#接口B：\" class=\"headerlink\" title=\"接口B：\"></a>接口B：</h5><pre><code class=\"lang-java\">public interface B {\n    void m2();\n}\n</code></pre>\n<h5 id=\"接口C：\"><a href=\"#接口C：\" class=\"headerlink\" title=\"接口C：\"></a>接口C：</h5><pre><code class=\"lang-java\">public interface C {\n    void m1();\n    void m2();\n}\n</code></pre>\n<h5 id=\"以及一些其他问题：\"><a href=\"#以及一些其他问题：\" class=\"headerlink\" title=\"以及一些其他问题：\"></a>以及一些其他问题：</h5><ol>\n<li>private</li>\n<li>final</li>\n<li>static</li>\n</ol>\n<h2 id=\"JAVASSIST\"><a href=\"#JAVASSIST\" class=\"headerlink\" title=\"JAVASSIST\"></a>JAVASSIST</h2><h5 id=\"Javassist是一个执行字节码操作的强而有力的驱动代码库。它允许开发者自由的在一个已经编译好的类中添加新的方法，或者是修改已有的方法\"><a href=\"#Javassist是一个执行字节码操作的强而有力的驱动代码库。它允许开发者自由的在一个已经编译好的类中添加新的方法，或者是修改已有的方法\" class=\"headerlink\" title=\"Javassist是一个执行字节码操作的强而有力的驱动代码库。它允许开发者自由的在一个已经编译好的类中添加新的方法，或者是修改已有的方法\"></a>Javassist是一个执行字节码操作的强而有力的驱动代码库。它允许开发者自由的在一个已经编译好的类中添加新的方法，或者是修改已有的方法</h5><pre><code class=\"lang-java\">public class Test {\n\n    protected String get(String s){\n        System.out.println(s);\n        return null;\n    }\n}\n</code></pre>\n<pre><code class=\"lang-java\">public static void main(String[] args) throws Exception {\n        ClassPool aDefault = ClassPool.getDefault();\n        aDefault.insertClassPath(new ClassClassPath(JavassistTest.class));\n        CtClass ctClass = aDefault.get(&quot;com.river.Test&quot;);\n        CtMethod get = ctClass.getDeclaredMethod(&quot;get&quot;);\n        get.insertBefore(&quot;System.out.println(\\&quot;s\\&quot;);&quot;);\n//        Class&lt;Test&gt; testClass = Test.class;\n        Class aClass = ctClass.toClass();\n        Test o = (Test)aClass.newInstance();\n        o.get(&quot;a&quot;);\n        Test test = new Test();\n        test.get(&quot;b&quot;);\n        System.out.println(o.getClass());\n        System.out.println(test.getClass());\n    }\n</code></pre>\n<pre><code>s\na\ns\nb\nclass com.river.Test\nclass com.river.Test\n</code></pre><h4 id=\"一些问题：\"><a href=\"#一些问题：\" class=\"headerlink\" title=\"一些问题：\"></a>一些问题：</h4><ol>\n<li>一个类可以被修改吗</li>\n<li>不同类加载器加载的类还是同一个类吗</li>\n<li>类在什么时候被加载</li>\n<li>一个类可以被加载多少次</li>\n</ol>\n<h5 id=\"实现的大致过程如下\"><a href=\"#实现的大致过程如下\" class=\"headerlink\" title=\"实现的大致过程如下\"></a>实现的大致过程如下</h5><p><img src=\"/img/note/javassist.png\" alt=\"\"></p>"},{"layout":"post","title":"Java并发之ReentrantLock","date":"2018-04-09T16:00:00.000Z","tag":[["java","java"]],"original":true,"_content":"\n##### Java 的**ReentrantLock**是我们最常用的java锁之一。**ReentrantLock**实现了我们最常用的一些锁的特性，那么它是如何实现这些过程的呢。其实现的原理是基于**AbstractQueuedSynchronizer**（AQS）和 自定义同步器 **sync** 的。关于AQS的实现原理可以去看我的另一篇文章：[Java并发之AQS](https://winx402.github.io/note/jdk/JavaAQS/)\n<!-- more -->\n\n## 结构\n##### **ReentrantLock**实现了公平锁和非公平锁，它的实现过程主要是通过对AQS的**state**状态采取独占的操作方式，我们知道在AQS中state为0表示正常状态（释放中），为1则表示线程占用状态（也就是排他锁的概念，当然还有可能大于1，因为锁可以重入），而这些对于AQS的操作方式又是通过自定义同步器**Sync**来完成的：\n```java\nprivate final Sync sync;\n```\n\n##### **ReentrantLock**相对应的实现了两个**Sync**：\n```java\n//非公平锁的实现\nstatic final class NonfairSync extends Sync\n```\n\n```java\n//公平锁的实现\nstatic final class FairSync extends Sync\n```\n\n##### 可以看到NonfairSync和NonfairSync都是继承的同一个Sync，而且他们是final类型的，都不能被再次继承。\n```java\n//基类Sync，继承了AQS\nabstract static class Sync extends AbstractQueuedSynchronizer\n```\n\n## 源码详解\n### 构造函数\n```java\npublic ReentrantLock() {\n    sync = new NonfairSync();\n}\n```\n\n##### 默认构造函数将使用非公平实现方案\n\n```java\npublic ReentrantLock(boolean fair) {\n    sync = fair ? new FairSync() : new NonfairSync();\n}\n```\n\n##### 公平或者非公平主要就体现在使用FairSync或者NonfairSync\n\n### lock()\n```java\npublic void lock() {\n    sync.lock();\n}\n```\n##### **ReentrantLock**的lock操作完全交给同步器Sync去执行，让我们来看下他们是怎么实现的：\n#### NonfairSync 的 lock()\n```java\nfinal void lock() {\n    if (compareAndSetState(0, 1))\n        setExclusiveOwnerThread(Thread.currentThread());\n    else\n        acquire(1);\n}\n```\n##### NonfairSync的lock操作是基于对AQS对state状态的修改，很简单，主要分两步：\n1. 直接通过CAS操作AQS的状态，如果是0则修改成1（该过程的语义可以理解成：如果没有线程正在占用锁，则占用该锁），修改成功则表示锁获取成功，之后设置AbstractOwnableSynchronizer的thread为当前线程\n2. 如果修改失败，则调用acquire（独占的方式）操作去获取锁。\n\n##### acquire(int) 在AQS中已经详细的说明了，这里简单提一下：\n```java\npublic final void acquire(int arg) {\n    if (!tryAcquire(arg) &&\n        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        selfInterrupt();\n}\n```\n\n1. tryAcquire()尝试直接去获取资源，如果成功则直接返回；\n2. addWaiter()将该线程加入等待队列的尾部，并标记为独占模式；\n3. acquireQueued()使线程在等待队列中获取资源，一直获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。\n4. 如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。\n\n##### 而我们主要需要实现的就是tryAcquire(int)函数：\n```java\n//NonfairSync\nprotected final boolean tryAcquire(int acquires) {\n    return nonfairTryAcquire(acquires);\n}\n```\n##### 在非公平实现中主要通过基类Sync的nonfairTryAcquire(int)来实现：\n```java\nfinal boolean nonfairTryAcquire(int acquires) {\n    //获取当前线程\n    final Thread current = Thread.currentThread();\n    //获取AQS状态（state为volatile变量）\n    int c = getState();\n    if (c == 0) {\n        //这一步和NonfairSync 的 lock()的第一步是一样的，不重复解释了\n        if (compareAndSetState(0, acquires)) {\n            setExclusiveOwnerThread(current);\n            return true;\n        }\n    }\n    //判断当前线程是否已经获取到锁，可重入锁的实现\n    else if (current == getExclusiveOwnerThread()) {\n        int nextc = c + acquires;\n        if (nextc < 0) // overflow\n            throw new Error(\"Maximum lock count exceeded\");\n        setState(nextc);\n        return true;\n    }\n    return false;\n}\n```\n##### nonfairTryAcquire的过程在上面代码中已经简单说明，可以看到tryAcquire（nonfairTryAcquire）操作只是针对一次性的获取操作，这里并没有重试或者自旋。因为相应的过程都在acquire(int)中实现。\n\n#### FairSync 的 lock()\n```java\nfinal void lock() {\n    acquire(1);\n}\n```\n##### 和非公平的实现相比，少了一步cas操作，直接通过AQS的acquire去独占state。这里也是非公平的区别之一，非公平的实现导致新加入的线程不用经过队列而是直接尝试获取锁，这个时候队列中很有可能存在其他的等待线程，这些队列中的线程可能正在唤醒的过程中。而非公平的这种操作对于系统来说性能是更高的，因为线程的唤醒需要时间。\n\n##### **acquire(int)**的操作和非公平一样，我们直接看**FairSync**的**tryAcquire(int)**:\n```java\nprotected final boolean tryAcquire(int acquires) {\n    //获取当前线程\n    final Thread current = Thread.currentThread();\n    //获取锁的状态\n    int c = getState();\n    if (c == 0) {\n        //如果锁是释放的，并且队列中有其他线程正在前面等待。\n        if (!hasQueuedPredecessors() &&\n            compareAndSetState(0, acquires)) {\n            setExclusiveOwnerThread(current);\n            return true;\n        }\n    }\n    else if (current == getExclusiveOwnerThread()) {\n        int nextc = c + acquires;\n        if (nextc < 0)\n            throw new Error(\"Maximum lock count exceeded\");\n        setState(nextc);\n        return true;\n    }\n    return false;\n}\n```\n\n##### 这里和非公平的实现**nonfairTryAcquire**也很像，唯一的区别在于获取锁的时候需要判断一次队列情况，也正是这个操作，导致了公平锁的实现是不能插队的，我们看下hasQueuedPredecessors的实现：\n```java\npublic final boolean hasQueuedPredecessors() {\n    Node t = tail;\n    Node h = head;\n    Node s;\n    return h != t &&\n        ((s = h.next) == null || s.thread != Thread.currentThread());\n}\n```\n\n##### 简单来说hasQueuedPredecessors返回true需要同时满足下面2个条件：\n1. 操作state的等待队列不为空\n2. 队列的下一个操作线程和当前线程不是同一个线程（这里的语义和acquireQueued中很像，都是判断是否为队列的第二个节点，因为第一个节点为操作state的线程，所以第二个节点很可能是第一个节点唤醒的，所以是有机会的）。\n\n### unlock()\n```java\npublic void unlock() {\n    sync.release(1);\n}\n```\n##### 通过操作AQS的释放操作，完成解锁语义，看下release(int):\n```java\npublic final boolean release(int arg) {\n    if (tryRelease(arg)) {\n        Node h = head;//找到头结点\n        if (h != null && h.waitStatus != 0)\n            unparkSuccessor(h);//唤醒等待队列里的下一个线程\n        return true;\n    }\n    return false;\n}\n```\n##### release操作在AQS文章中也已经说明，不再赘诉，直接看tryRelease(int)实现。\n```java\nprotected final boolean tryRelease(int releases) {\n    int c = getState() - releases;\n    if (Thread.currentThread() != getExclusiveOwnerThread())\n        throw new IllegalMonitorStateException();\n    boolean free = false;\n    if (c == 0) {\n        free = true;\n        setExclusiveOwnerThread(null);\n    }\n    setState(c);\n    return free;\n}\n```\n##### tryRelease的实现不区分公平非公平，其主要流程如下：\n1. 计算state释放releases后的值\n2. 查看当前线程是否持有该锁，如果不持有。抛出异常\n3. 如果锁被完全释放(state == 0)，设置持有线程为null\n4. 则设置剩余状态值\n\n### lockInterruptibly()\n```java\npublic void lockInterruptibly() throws InterruptedException {\n    sync.acquireInterruptibly(1);\n}\n```\n\n##### 直接看AQS的acquireInterruptibly(int)和doAcquireInterruptibly(int):\n```java\npublic final void acquireInterruptibly(int arg)\n        throws InterruptedException {\n    if (Thread.interrupted())\n        throw new InterruptedException();\n    if (!tryAcquire(arg))\n        doAcquireInterruptibly(arg);\n}\n```\n\n```java\nprivate void doAcquireInterruptibly(int arg)\n    throws InterruptedException {\n    final Node node = addWaiter(Node.EXCLUSIVE);\n    boolean failed = true;\n    try {\n        for (;;) {\n            final Node p = node.predecessor();\n            if (p == head && tryAcquire(arg)) {\n                setHead(node);\n                p.next = null; // help GC\n                failed = false;\n                return;\n            }\n            if (shouldParkAfterFailedAcquire(p, node) &&\n                parkAndCheckInterrupt())\n                throw new InterruptedException();\n        }\n    } finally {\n        if (failed)\n            cancelAcquire(node);\n    }\n}\n```\n\n##### 如果你和AQS的acquireQueued方法做对比会发现doAcquireInterruptibly的一个主要区别就是如果中断则直接抛出中断异常，而acquireQueued中只是记录中断。\n\n### tryLock()\n```java\npublic boolean tryLock() {\n    return sync.nonfairTryAcquire(1);\n}\n```\n\n##### 如果调用tryLock()，则并不关心是否公平，和非公平的tryAcquire操作相同，不做等待和重试操作\n\n### getHoldCount()\n```java\npublic int getHoldCount() {\n    return sync.getHoldCount();\n}\n```\n\n##### 获取**ReentrantLock**的**lock()**方法被调用了几次（重入了几次），就是**state**的当前值\n\n### getOwner()\n```java\nprotected Thread getOwner() {\n    return sync.getOwner();\n}\n```\n\n```java\nfinal Thread getOwner() {\n    return getState() == 0 ? null : getExclusiveOwnerThread();\n}\n```\n\n##### 获取当前占有锁的线程，就是**AbstractOwnableSynchronizer**中**exclusiveOwnerThread**的值\n\n### getQueuedThreads()\n```java\nprotected Collection<Thread> getQueuedThreads() {\n    return sync.getQueuedThreads();\n}\n```\n\n```java\npublic final Collection<Thread> getQueuedThreads() {\n    ArrayList<Thread> list = new ArrayList<Thread>();\n    for (Node p = tail; p != null; p = p.prev) {\n        Thread t = p.thread;\n        if (t != null)\n            list.add(t);\n    }\n    return list;\n}\n```\n\n##### 获取等待持有锁的线程集合。队列从后向前遍历\n\n### getQueuedLength()\n```java\npublic final int getQueueLength() {\n    return sync.getQueueLength();\n}\n```\n\n```java\npublic final int getQueueLength() {\n    int n = 0;\n    for (Node p = tail; p != null; p = p.prev) {\n        if (p.thread != null)\n            ++n;\n    }\n    return n;\n}\n```\n\n##### 获取等待持有锁的队列长度，和**getQueuedThreads**类似，通过遍历计数后返回\n\n## 总结\n##### 通过源码分析，发现其实**ReentrantLock**的实现是非常简单的，只要理解了AQS的实现过程，剩下的就是自定义同步器**NonfairSync**和**FairSync**对于**AQS**的**state**采用独占方式的获取和释放。锁的特性和概念也正是在这个过程中被实现和赋予其含义的。","source":"_posts/note/jdk/javaReenTrantLock.md","raw":"---\nlayout: post\ntitle: Java并发之ReentrantLock\ndate: 2018/04/10\ntags: [tech, index]\ntag: [[java, java]]\noriginal: true\n---\n\n##### Java 的**ReentrantLock**是我们最常用的java锁之一。**ReentrantLock**实现了我们最常用的一些锁的特性，那么它是如何实现这些过程的呢。其实现的原理是基于**AbstractQueuedSynchronizer**（AQS）和 自定义同步器 **sync** 的。关于AQS的实现原理可以去看我的另一篇文章：[Java并发之AQS](https://winx402.github.io/note/jdk/JavaAQS/)\n<!-- more -->\n\n## 结构\n##### **ReentrantLock**实现了公平锁和非公平锁，它的实现过程主要是通过对AQS的**state**状态采取独占的操作方式，我们知道在AQS中state为0表示正常状态（释放中），为1则表示线程占用状态（也就是排他锁的概念，当然还有可能大于1，因为锁可以重入），而这些对于AQS的操作方式又是通过自定义同步器**Sync**来完成的：\n```java\nprivate final Sync sync;\n```\n\n##### **ReentrantLock**相对应的实现了两个**Sync**：\n```java\n//非公平锁的实现\nstatic final class NonfairSync extends Sync\n```\n\n```java\n//公平锁的实现\nstatic final class FairSync extends Sync\n```\n\n##### 可以看到NonfairSync和NonfairSync都是继承的同一个Sync，而且他们是final类型的，都不能被再次继承。\n```java\n//基类Sync，继承了AQS\nabstract static class Sync extends AbstractQueuedSynchronizer\n```\n\n## 源码详解\n### 构造函数\n```java\npublic ReentrantLock() {\n    sync = new NonfairSync();\n}\n```\n\n##### 默认构造函数将使用非公平实现方案\n\n```java\npublic ReentrantLock(boolean fair) {\n    sync = fair ? new FairSync() : new NonfairSync();\n}\n```\n\n##### 公平或者非公平主要就体现在使用FairSync或者NonfairSync\n\n### lock()\n```java\npublic void lock() {\n    sync.lock();\n}\n```\n##### **ReentrantLock**的lock操作完全交给同步器Sync去执行，让我们来看下他们是怎么实现的：\n#### NonfairSync 的 lock()\n```java\nfinal void lock() {\n    if (compareAndSetState(0, 1))\n        setExclusiveOwnerThread(Thread.currentThread());\n    else\n        acquire(1);\n}\n```\n##### NonfairSync的lock操作是基于对AQS对state状态的修改，很简单，主要分两步：\n1. 直接通过CAS操作AQS的状态，如果是0则修改成1（该过程的语义可以理解成：如果没有线程正在占用锁，则占用该锁），修改成功则表示锁获取成功，之后设置AbstractOwnableSynchronizer的thread为当前线程\n2. 如果修改失败，则调用acquire（独占的方式）操作去获取锁。\n\n##### acquire(int) 在AQS中已经详细的说明了，这里简单提一下：\n```java\npublic final void acquire(int arg) {\n    if (!tryAcquire(arg) &&\n        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        selfInterrupt();\n}\n```\n\n1. tryAcquire()尝试直接去获取资源，如果成功则直接返回；\n2. addWaiter()将该线程加入等待队列的尾部，并标记为独占模式；\n3. acquireQueued()使线程在等待队列中获取资源，一直获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。\n4. 如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。\n\n##### 而我们主要需要实现的就是tryAcquire(int)函数：\n```java\n//NonfairSync\nprotected final boolean tryAcquire(int acquires) {\n    return nonfairTryAcquire(acquires);\n}\n```\n##### 在非公平实现中主要通过基类Sync的nonfairTryAcquire(int)来实现：\n```java\nfinal boolean nonfairTryAcquire(int acquires) {\n    //获取当前线程\n    final Thread current = Thread.currentThread();\n    //获取AQS状态（state为volatile变量）\n    int c = getState();\n    if (c == 0) {\n        //这一步和NonfairSync 的 lock()的第一步是一样的，不重复解释了\n        if (compareAndSetState(0, acquires)) {\n            setExclusiveOwnerThread(current);\n            return true;\n        }\n    }\n    //判断当前线程是否已经获取到锁，可重入锁的实现\n    else if (current == getExclusiveOwnerThread()) {\n        int nextc = c + acquires;\n        if (nextc < 0) // overflow\n            throw new Error(\"Maximum lock count exceeded\");\n        setState(nextc);\n        return true;\n    }\n    return false;\n}\n```\n##### nonfairTryAcquire的过程在上面代码中已经简单说明，可以看到tryAcquire（nonfairTryAcquire）操作只是针对一次性的获取操作，这里并没有重试或者自旋。因为相应的过程都在acquire(int)中实现。\n\n#### FairSync 的 lock()\n```java\nfinal void lock() {\n    acquire(1);\n}\n```\n##### 和非公平的实现相比，少了一步cas操作，直接通过AQS的acquire去独占state。这里也是非公平的区别之一，非公平的实现导致新加入的线程不用经过队列而是直接尝试获取锁，这个时候队列中很有可能存在其他的等待线程，这些队列中的线程可能正在唤醒的过程中。而非公平的这种操作对于系统来说性能是更高的，因为线程的唤醒需要时间。\n\n##### **acquire(int)**的操作和非公平一样，我们直接看**FairSync**的**tryAcquire(int)**:\n```java\nprotected final boolean tryAcquire(int acquires) {\n    //获取当前线程\n    final Thread current = Thread.currentThread();\n    //获取锁的状态\n    int c = getState();\n    if (c == 0) {\n        //如果锁是释放的，并且队列中有其他线程正在前面等待。\n        if (!hasQueuedPredecessors() &&\n            compareAndSetState(0, acquires)) {\n            setExclusiveOwnerThread(current);\n            return true;\n        }\n    }\n    else if (current == getExclusiveOwnerThread()) {\n        int nextc = c + acquires;\n        if (nextc < 0)\n            throw new Error(\"Maximum lock count exceeded\");\n        setState(nextc);\n        return true;\n    }\n    return false;\n}\n```\n\n##### 这里和非公平的实现**nonfairTryAcquire**也很像，唯一的区别在于获取锁的时候需要判断一次队列情况，也正是这个操作，导致了公平锁的实现是不能插队的，我们看下hasQueuedPredecessors的实现：\n```java\npublic final boolean hasQueuedPredecessors() {\n    Node t = tail;\n    Node h = head;\n    Node s;\n    return h != t &&\n        ((s = h.next) == null || s.thread != Thread.currentThread());\n}\n```\n\n##### 简单来说hasQueuedPredecessors返回true需要同时满足下面2个条件：\n1. 操作state的等待队列不为空\n2. 队列的下一个操作线程和当前线程不是同一个线程（这里的语义和acquireQueued中很像，都是判断是否为队列的第二个节点，因为第一个节点为操作state的线程，所以第二个节点很可能是第一个节点唤醒的，所以是有机会的）。\n\n### unlock()\n```java\npublic void unlock() {\n    sync.release(1);\n}\n```\n##### 通过操作AQS的释放操作，完成解锁语义，看下release(int):\n```java\npublic final boolean release(int arg) {\n    if (tryRelease(arg)) {\n        Node h = head;//找到头结点\n        if (h != null && h.waitStatus != 0)\n            unparkSuccessor(h);//唤醒等待队列里的下一个线程\n        return true;\n    }\n    return false;\n}\n```\n##### release操作在AQS文章中也已经说明，不再赘诉，直接看tryRelease(int)实现。\n```java\nprotected final boolean tryRelease(int releases) {\n    int c = getState() - releases;\n    if (Thread.currentThread() != getExclusiveOwnerThread())\n        throw new IllegalMonitorStateException();\n    boolean free = false;\n    if (c == 0) {\n        free = true;\n        setExclusiveOwnerThread(null);\n    }\n    setState(c);\n    return free;\n}\n```\n##### tryRelease的实现不区分公平非公平，其主要流程如下：\n1. 计算state释放releases后的值\n2. 查看当前线程是否持有该锁，如果不持有。抛出异常\n3. 如果锁被完全释放(state == 0)，设置持有线程为null\n4. 则设置剩余状态值\n\n### lockInterruptibly()\n```java\npublic void lockInterruptibly() throws InterruptedException {\n    sync.acquireInterruptibly(1);\n}\n```\n\n##### 直接看AQS的acquireInterruptibly(int)和doAcquireInterruptibly(int):\n```java\npublic final void acquireInterruptibly(int arg)\n        throws InterruptedException {\n    if (Thread.interrupted())\n        throw new InterruptedException();\n    if (!tryAcquire(arg))\n        doAcquireInterruptibly(arg);\n}\n```\n\n```java\nprivate void doAcquireInterruptibly(int arg)\n    throws InterruptedException {\n    final Node node = addWaiter(Node.EXCLUSIVE);\n    boolean failed = true;\n    try {\n        for (;;) {\n            final Node p = node.predecessor();\n            if (p == head && tryAcquire(arg)) {\n                setHead(node);\n                p.next = null; // help GC\n                failed = false;\n                return;\n            }\n            if (shouldParkAfterFailedAcquire(p, node) &&\n                parkAndCheckInterrupt())\n                throw new InterruptedException();\n        }\n    } finally {\n        if (failed)\n            cancelAcquire(node);\n    }\n}\n```\n\n##### 如果你和AQS的acquireQueued方法做对比会发现doAcquireInterruptibly的一个主要区别就是如果中断则直接抛出中断异常，而acquireQueued中只是记录中断。\n\n### tryLock()\n```java\npublic boolean tryLock() {\n    return sync.nonfairTryAcquire(1);\n}\n```\n\n##### 如果调用tryLock()，则并不关心是否公平，和非公平的tryAcquire操作相同，不做等待和重试操作\n\n### getHoldCount()\n```java\npublic int getHoldCount() {\n    return sync.getHoldCount();\n}\n```\n\n##### 获取**ReentrantLock**的**lock()**方法被调用了几次（重入了几次），就是**state**的当前值\n\n### getOwner()\n```java\nprotected Thread getOwner() {\n    return sync.getOwner();\n}\n```\n\n```java\nfinal Thread getOwner() {\n    return getState() == 0 ? null : getExclusiveOwnerThread();\n}\n```\n\n##### 获取当前占有锁的线程，就是**AbstractOwnableSynchronizer**中**exclusiveOwnerThread**的值\n\n### getQueuedThreads()\n```java\nprotected Collection<Thread> getQueuedThreads() {\n    return sync.getQueuedThreads();\n}\n```\n\n```java\npublic final Collection<Thread> getQueuedThreads() {\n    ArrayList<Thread> list = new ArrayList<Thread>();\n    for (Node p = tail; p != null; p = p.prev) {\n        Thread t = p.thread;\n        if (t != null)\n            list.add(t);\n    }\n    return list;\n}\n```\n\n##### 获取等待持有锁的线程集合。队列从后向前遍历\n\n### getQueuedLength()\n```java\npublic final int getQueueLength() {\n    return sync.getQueueLength();\n}\n```\n\n```java\npublic final int getQueueLength() {\n    int n = 0;\n    for (Node p = tail; p != null; p = p.prev) {\n        if (p.thread != null)\n            ++n;\n    }\n    return n;\n}\n```\n\n##### 获取等待持有锁的队列长度，和**getQueuedThreads**类似，通过遍历计数后返回\n\n## 总结\n##### 通过源码分析，发现其实**ReentrantLock**的实现是非常简单的，只要理解了AQS的实现过程，剩下的就是自定义同步器**NonfairSync**和**FairSync**对于**AQS**的**state**采用独占方式的获取和释放。锁的特性和概念也正是在这个过程中被实现和赋予其含义的。","slug":"note/jdk/javaReenTrantLock","published":1,"updated":"2018-05-08T13:00:14.279Z","comments":1,"photos":[],"link":"","_id":"cjgxop3no003pjah1r4z8lhcy","content":"<h5 id=\"Java-的ReentrantLock是我们最常用的java锁之一。ReentrantLock实现了我们最常用的一些锁的特性，那么它是如何实现这些过程的呢。其实现的原理是基于AbstractQueuedSynchronizer（AQS）和-自定义同步器-sync-的。关于AQS的实现原理可以去看我的另一篇文章：Java并发之AQS\"><a href=\"#Java-的ReentrantLock是我们最常用的java锁之一。ReentrantLock实现了我们最常用的一些锁的特性，那么它是如何实现这些过程的呢。其实现的原理是基于AbstractQueuedSynchronizer（AQS）和-自定义同步器-sync-的。关于AQS的实现原理可以去看我的另一篇文章：Java并发之AQS\" class=\"headerlink\" title=\"Java 的ReentrantLock是我们最常用的java锁之一。ReentrantLock实现了我们最常用的一些锁的特性，那么它是如何实现这些过程的呢。其实现的原理是基于AbstractQueuedSynchronizer（AQS）和 自定义同步器 sync 的。关于AQS的实现原理可以去看我的另一篇文章：Java并发之AQS\"></a>Java 的<strong>ReentrantLock</strong>是我们最常用的java锁之一。<strong>ReentrantLock</strong>实现了我们最常用的一些锁的特性，那么它是如何实现这些过程的呢。其实现的原理是基于<strong>AbstractQueuedSynchronizer</strong>（AQS）和 自定义同步器 <strong>sync</strong> 的。关于AQS的实现原理可以去看我的另一篇文章：<a href=\"https://winx402.github.io/note/jdk/JavaAQS/\" target=\"_blank\" rel=\"external\">Java并发之AQS</a></h5><a id=\"more\"></a>\n<h2 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h2><h5 id=\"ReentrantLock实现了公平锁和非公平锁，它的实现过程主要是通过对AQS的state状态采取独占的操作方式，我们知道在AQS中state为0表示正常状态（释放中），为1则表示线程占用状态（也就是排他锁的概念，当然还有可能大于1，因为锁可以重入），而这些对于AQS的操作方式又是通过自定义同步器Sync来完成的：\"><a href=\"#ReentrantLock实现了公平锁和非公平锁，它的实现过程主要是通过对AQS的state状态采取独占的操作方式，我们知道在AQS中state为0表示正常状态（释放中），为1则表示线程占用状态（也就是排他锁的概念，当然还有可能大于1，因为锁可以重入），而这些对于AQS的操作方式又是通过自定义同步器Sync来完成的：\" class=\"headerlink\" title=\"ReentrantLock实现了公平锁和非公平锁，它的实现过程主要是通过对AQS的state状态采取独占的操作方式，我们知道在AQS中state为0表示正常状态（释放中），为1则表示线程占用状态（也就是排他锁的概念，当然还有可能大于1，因为锁可以重入），而这些对于AQS的操作方式又是通过自定义同步器Sync来完成的：\"></a><strong>ReentrantLock</strong>实现了公平锁和非公平锁，它的实现过程主要是通过对AQS的<strong>state</strong>状态采取独占的操作方式，我们知道在AQS中state为0表示正常状态（释放中），为1则表示线程占用状态（也就是排他锁的概念，当然还有可能大于1，因为锁可以重入），而这些对于AQS的操作方式又是通过自定义同步器<strong>Sync</strong>来完成的：</h5><pre><code class=\"lang-java\">private final Sync sync;\n</code></pre>\n<h5 id=\"ReentrantLock相对应的实现了两个Sync：\"><a href=\"#ReentrantLock相对应的实现了两个Sync：\" class=\"headerlink\" title=\"ReentrantLock相对应的实现了两个Sync：\"></a><strong>ReentrantLock</strong>相对应的实现了两个<strong>Sync</strong>：</h5><pre><code class=\"lang-java\">//非公平锁的实现\nstatic final class NonfairSync extends Sync\n</code></pre>\n<pre><code class=\"lang-java\">//公平锁的实现\nstatic final class FairSync extends Sync\n</code></pre>\n<h5 id=\"可以看到NonfairSync和NonfairSync都是继承的同一个Sync，而且他们是final类型的，都不能被再次继承。\"><a href=\"#可以看到NonfairSync和NonfairSync都是继承的同一个Sync，而且他们是final类型的，都不能被再次继承。\" class=\"headerlink\" title=\"可以看到NonfairSync和NonfairSync都是继承的同一个Sync，而且他们是final类型的，都不能被再次继承。\"></a>可以看到NonfairSync和NonfairSync都是继承的同一个Sync，而且他们是final类型的，都不能被再次继承。</h5><pre><code class=\"lang-java\">//基类Sync，继承了AQS\nabstract static class Sync extends AbstractQueuedSynchronizer\n</code></pre>\n<h2 id=\"源码详解\"><a href=\"#源码详解\" class=\"headerlink\" title=\"源码详解\"></a>源码详解</h2><h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><pre><code class=\"lang-java\">public ReentrantLock() {\n    sync = new NonfairSync();\n}\n</code></pre>\n<h5 id=\"默认构造函数将使用非公平实现方案\"><a href=\"#默认构造函数将使用非公平实现方案\" class=\"headerlink\" title=\"默认构造函数将使用非公平实现方案\"></a>默认构造函数将使用非公平实现方案</h5><pre><code class=\"lang-java\">public ReentrantLock(boolean fair) {\n    sync = fair ? new FairSync() : new NonfairSync();\n}\n</code></pre>\n<h5 id=\"公平或者非公平主要就体现在使用FairSync或者NonfairSync\"><a href=\"#公平或者非公平主要就体现在使用FairSync或者NonfairSync\" class=\"headerlink\" title=\"公平或者非公平主要就体现在使用FairSync或者NonfairSync\"></a>公平或者非公平主要就体现在使用FairSync或者NonfairSync</h5><h3 id=\"lock\"><a href=\"#lock\" class=\"headerlink\" title=\"lock()\"></a>lock()</h3><pre><code class=\"lang-java\">public void lock() {\n    sync.lock();\n}\n</code></pre>\n<h5 id=\"ReentrantLock的lock操作完全交给同步器Sync去执行，让我们来看下他们是怎么实现的：\"><a href=\"#ReentrantLock的lock操作完全交给同步器Sync去执行，让我们来看下他们是怎么实现的：\" class=\"headerlink\" title=\"ReentrantLock的lock操作完全交给同步器Sync去执行，让我们来看下他们是怎么实现的：\"></a><strong>ReentrantLock</strong>的lock操作完全交给同步器Sync去执行，让我们来看下他们是怎么实现的：</h5><h4 id=\"NonfairSync-的-lock\"><a href=\"#NonfairSync-的-lock\" class=\"headerlink\" title=\"NonfairSync 的 lock()\"></a>NonfairSync 的 lock()</h4><pre><code class=\"lang-java\">final void lock() {\n    if (compareAndSetState(0, 1))\n        setExclusiveOwnerThread(Thread.currentThread());\n    else\n        acquire(1);\n}\n</code></pre>\n<h5 id=\"NonfairSync的lock操作是基于对AQS对state状态的修改，很简单，主要分两步：\"><a href=\"#NonfairSync的lock操作是基于对AQS对state状态的修改，很简单，主要分两步：\" class=\"headerlink\" title=\"NonfairSync的lock操作是基于对AQS对state状态的修改，很简单，主要分两步：\"></a>NonfairSync的lock操作是基于对AQS对state状态的修改，很简单，主要分两步：</h5><ol>\n<li>直接通过CAS操作AQS的状态，如果是0则修改成1（该过程的语义可以理解成：如果没有线程正在占用锁，则占用该锁），修改成功则表示锁获取成功，之后设置AbstractOwnableSynchronizer的thread为当前线程</li>\n<li>如果修改失败，则调用acquire（独占的方式）操作去获取锁。</li>\n</ol>\n<h5 id=\"acquire-int-在AQS中已经详细的说明了，这里简单提一下：\"><a href=\"#acquire-int-在AQS中已经详细的说明了，这里简单提一下：\" class=\"headerlink\" title=\"acquire(int) 在AQS中已经详细的说明了，这里简单提一下：\"></a>acquire(int) 在AQS中已经详细的说明了，这里简单提一下：</h5><pre><code class=\"lang-java\">public final void acquire(int arg) {\n    if (!tryAcquire(arg) &amp;&amp;\n        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        selfInterrupt();\n}\n</code></pre>\n<ol>\n<li>tryAcquire()尝试直接去获取资源，如果成功则直接返回；</li>\n<li>addWaiter()将该线程加入等待队列的尾部，并标记为独占模式；</li>\n<li>acquireQueued()使线程在等待队列中获取资源，一直获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。</li>\n<li>如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。</li>\n</ol>\n<h5 id=\"而我们主要需要实现的就是tryAcquire-int-函数：\"><a href=\"#而我们主要需要实现的就是tryAcquire-int-函数：\" class=\"headerlink\" title=\"而我们主要需要实现的就是tryAcquire(int)函数：\"></a>而我们主要需要实现的就是tryAcquire(int)函数：</h5><pre><code class=\"lang-java\">//NonfairSync\nprotected final boolean tryAcquire(int acquires) {\n    return nonfairTryAcquire(acquires);\n}\n</code></pre>\n<h5 id=\"在非公平实现中主要通过基类Sync的nonfairTryAcquire-int-来实现：\"><a href=\"#在非公平实现中主要通过基类Sync的nonfairTryAcquire-int-来实现：\" class=\"headerlink\" title=\"在非公平实现中主要通过基类Sync的nonfairTryAcquire(int)来实现：\"></a>在非公平实现中主要通过基类Sync的nonfairTryAcquire(int)来实现：</h5><pre><code class=\"lang-java\">final boolean nonfairTryAcquire(int acquires) {\n    //获取当前线程\n    final Thread current = Thread.currentThread();\n    //获取AQS状态（state为volatile变量）\n    int c = getState();\n    if (c == 0) {\n        //这一步和NonfairSync 的 lock()的第一步是一样的，不重复解释了\n        if (compareAndSetState(0, acquires)) {\n            setExclusiveOwnerThread(current);\n            return true;\n        }\n    }\n    //判断当前线程是否已经获取到锁，可重入锁的实现\n    else if (current == getExclusiveOwnerThread()) {\n        int nextc = c + acquires;\n        if (nextc &lt; 0) // overflow\n            throw new Error(&quot;Maximum lock count exceeded&quot;);\n        setState(nextc);\n        return true;\n    }\n    return false;\n}\n</code></pre>\n<h5 id=\"nonfairTryAcquire的过程在上面代码中已经简单说明，可以看到tryAcquire（nonfairTryAcquire）操作只是针对一次性的获取操作，这里并没有重试或者自旋。因为相应的过程都在acquire-int-中实现。\"><a href=\"#nonfairTryAcquire的过程在上面代码中已经简单说明，可以看到tryAcquire（nonfairTryAcquire）操作只是针对一次性的获取操作，这里并没有重试或者自旋。因为相应的过程都在acquire-int-中实现。\" class=\"headerlink\" title=\"nonfairTryAcquire的过程在上面代码中已经简单说明，可以看到tryAcquire（nonfairTryAcquire）操作只是针对一次性的获取操作，这里并没有重试或者自旋。因为相应的过程都在acquire(int)中实现。\"></a>nonfairTryAcquire的过程在上面代码中已经简单说明，可以看到tryAcquire（nonfairTryAcquire）操作只是针对一次性的获取操作，这里并没有重试或者自旋。因为相应的过程都在acquire(int)中实现。</h5><h4 id=\"FairSync-的-lock\"><a href=\"#FairSync-的-lock\" class=\"headerlink\" title=\"FairSync 的 lock()\"></a>FairSync 的 lock()</h4><pre><code class=\"lang-java\">final void lock() {\n    acquire(1);\n}\n</code></pre>\n<h5 id=\"和非公平的实现相比，少了一步cas操作，直接通过AQS的acquire去独占state。这里也是非公平的区别之一，非公平的实现导致新加入的线程不用经过队列而是直接尝试获取锁，这个时候队列中很有可能存在其他的等待线程，这些队列中的线程可能正在唤醒的过程中。而非公平的这种操作对于系统来说性能是更高的，因为线程的唤醒需要时间。\"><a href=\"#和非公平的实现相比，少了一步cas操作，直接通过AQS的acquire去独占state。这里也是非公平的区别之一，非公平的实现导致新加入的线程不用经过队列而是直接尝试获取锁，这个时候队列中很有可能存在其他的等待线程，这些队列中的线程可能正在唤醒的过程中。而非公平的这种操作对于系统来说性能是更高的，因为线程的唤醒需要时间。\" class=\"headerlink\" title=\"和非公平的实现相比，少了一步cas操作，直接通过AQS的acquire去独占state。这里也是非公平的区别之一，非公平的实现导致新加入的线程不用经过队列而是直接尝试获取锁，这个时候队列中很有可能存在其他的等待线程，这些队列中的线程可能正在唤醒的过程中。而非公平的这种操作对于系统来说性能是更高的，因为线程的唤醒需要时间。\"></a>和非公平的实现相比，少了一步cas操作，直接通过AQS的acquire去独占state。这里也是非公平的区别之一，非公平的实现导致新加入的线程不用经过队列而是直接尝试获取锁，这个时候队列中很有可能存在其他的等待线程，这些队列中的线程可能正在唤醒的过程中。而非公平的这种操作对于系统来说性能是更高的，因为线程的唤醒需要时间。</h5><h5 id=\"acquire-int-的操作和非公平一样，我们直接看FairSync的tryAcquire-int\"><a href=\"#acquire-int-的操作和非公平一样，我们直接看FairSync的tryAcquire-int\" class=\"headerlink\" title=\"acquire(int)的操作和非公平一样，我们直接看FairSync的tryAcquire(int):\"></a><strong>acquire(int)</strong>的操作和非公平一样，我们直接看<strong>FairSync</strong>的<strong>tryAcquire(int)</strong>:</h5><pre><code class=\"lang-java\">protected final boolean tryAcquire(int acquires) {\n    //获取当前线程\n    final Thread current = Thread.currentThread();\n    //获取锁的状态\n    int c = getState();\n    if (c == 0) {\n        //如果锁是释放的，并且队列中有其他线程正在前面等待。\n        if (!hasQueuedPredecessors() &amp;&amp;\n            compareAndSetState(0, acquires)) {\n            setExclusiveOwnerThread(current);\n            return true;\n        }\n    }\n    else if (current == getExclusiveOwnerThread()) {\n        int nextc = c + acquires;\n        if (nextc &lt; 0)\n            throw new Error(&quot;Maximum lock count exceeded&quot;);\n        setState(nextc);\n        return true;\n    }\n    return false;\n}\n</code></pre>\n<h5 id=\"这里和非公平的实现nonfairTryAcquire也很像，唯一的区别在于获取锁的时候需要判断一次队列情况，也正是这个操作，导致了公平锁的实现是不能插队的，我们看下hasQueuedPredecessors的实现：\"><a href=\"#这里和非公平的实现nonfairTryAcquire也很像，唯一的区别在于获取锁的时候需要判断一次队列情况，也正是这个操作，导致了公平锁的实现是不能插队的，我们看下hasQueuedPredecessors的实现：\" class=\"headerlink\" title=\"这里和非公平的实现nonfairTryAcquire也很像，唯一的区别在于获取锁的时候需要判断一次队列情况，也正是这个操作，导致了公平锁的实现是不能插队的，我们看下hasQueuedPredecessors的实现：\"></a>这里和非公平的实现<strong>nonfairTryAcquire</strong>也很像，唯一的区别在于获取锁的时候需要判断一次队列情况，也正是这个操作，导致了公平锁的实现是不能插队的，我们看下hasQueuedPredecessors的实现：</h5><pre><code class=\"lang-java\">public final boolean hasQueuedPredecessors() {\n    Node t = tail;\n    Node h = head;\n    Node s;\n    return h != t &amp;&amp;\n        ((s = h.next) == null || s.thread != Thread.currentThread());\n}\n</code></pre>\n<h5 id=\"简单来说hasQueuedPredecessors返回true需要同时满足下面2个条件：\"><a href=\"#简单来说hasQueuedPredecessors返回true需要同时满足下面2个条件：\" class=\"headerlink\" title=\"简单来说hasQueuedPredecessors返回true需要同时满足下面2个条件：\"></a>简单来说hasQueuedPredecessors返回true需要同时满足下面2个条件：</h5><ol>\n<li>操作state的等待队列不为空</li>\n<li>队列的下一个操作线程和当前线程不是同一个线程（这里的语义和acquireQueued中很像，都是判断是否为队列的第二个节点，因为第一个节点为操作state的线程，所以第二个节点很可能是第一个节点唤醒的，所以是有机会的）。</li>\n</ol>\n<h3 id=\"unlock\"><a href=\"#unlock\" class=\"headerlink\" title=\"unlock()\"></a>unlock()</h3><pre><code class=\"lang-java\">public void unlock() {\n    sync.release(1);\n}\n</code></pre>\n<h5 id=\"通过操作AQS的释放操作，完成解锁语义，看下release-int\"><a href=\"#通过操作AQS的释放操作，完成解锁语义，看下release-int\" class=\"headerlink\" title=\"通过操作AQS的释放操作，完成解锁语义，看下release(int):\"></a>通过操作AQS的释放操作，完成解锁语义，看下release(int):</h5><pre><code class=\"lang-java\">public final boolean release(int arg) {\n    if (tryRelease(arg)) {\n        Node h = head;//找到头结点\n        if (h != null &amp;&amp; h.waitStatus != 0)\n            unparkSuccessor(h);//唤醒等待队列里的下一个线程\n        return true;\n    }\n    return false;\n}\n</code></pre>\n<h5 id=\"release操作在AQS文章中也已经说明，不再赘诉，直接看tryRelease-int-实现。\"><a href=\"#release操作在AQS文章中也已经说明，不再赘诉，直接看tryRelease-int-实现。\" class=\"headerlink\" title=\"release操作在AQS文章中也已经说明，不再赘诉，直接看tryRelease(int)实现。\"></a>release操作在AQS文章中也已经说明，不再赘诉，直接看tryRelease(int)实现。</h5><pre><code class=\"lang-java\">protected final boolean tryRelease(int releases) {\n    int c = getState() - releases;\n    if (Thread.currentThread() != getExclusiveOwnerThread())\n        throw new IllegalMonitorStateException();\n    boolean free = false;\n    if (c == 0) {\n        free = true;\n        setExclusiveOwnerThread(null);\n    }\n    setState(c);\n    return free;\n}\n</code></pre>\n<h5 id=\"tryRelease的实现不区分公平非公平，其主要流程如下：\"><a href=\"#tryRelease的实现不区分公平非公平，其主要流程如下：\" class=\"headerlink\" title=\"tryRelease的实现不区分公平非公平，其主要流程如下：\"></a>tryRelease的实现不区分公平非公平，其主要流程如下：</h5><ol>\n<li>计算state释放releases后的值</li>\n<li>查看当前线程是否持有该锁，如果不持有。抛出异常</li>\n<li>如果锁被完全释放(state == 0)，设置持有线程为null</li>\n<li>则设置剩余状态值</li>\n</ol>\n<h3 id=\"lockInterruptibly\"><a href=\"#lockInterruptibly\" class=\"headerlink\" title=\"lockInterruptibly()\"></a>lockInterruptibly()</h3><pre><code class=\"lang-java\">public void lockInterruptibly() throws InterruptedException {\n    sync.acquireInterruptibly(1);\n}\n</code></pre>\n<h5 id=\"直接看AQS的acquireInterruptibly-int-和doAcquireInterruptibly-int\"><a href=\"#直接看AQS的acquireInterruptibly-int-和doAcquireInterruptibly-int\" class=\"headerlink\" title=\"直接看AQS的acquireInterruptibly(int)和doAcquireInterruptibly(int):\"></a>直接看AQS的acquireInterruptibly(int)和doAcquireInterruptibly(int):</h5><pre><code class=\"lang-java\">public final void acquireInterruptibly(int arg)\n        throws InterruptedException {\n    if (Thread.interrupted())\n        throw new InterruptedException();\n    if (!tryAcquire(arg))\n        doAcquireInterruptibly(arg);\n}\n</code></pre>\n<pre><code class=\"lang-java\">private void doAcquireInterruptibly(int arg)\n    throws InterruptedException {\n    final Node node = addWaiter(Node.EXCLUSIVE);\n    boolean failed = true;\n    try {\n        for (;;) {\n            final Node p = node.predecessor();\n            if (p == head &amp;&amp; tryAcquire(arg)) {\n                setHead(node);\n                p.next = null; // help GC\n                failed = false;\n                return;\n            }\n            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;\n                parkAndCheckInterrupt())\n                throw new InterruptedException();\n        }\n    } finally {\n        if (failed)\n            cancelAcquire(node);\n    }\n}\n</code></pre>\n<h5 id=\"如果你和AQS的acquireQueued方法做对比会发现doAcquireInterruptibly的一个主要区别就是如果中断则直接抛出中断异常，而acquireQueued中只是记录中断。\"><a href=\"#如果你和AQS的acquireQueued方法做对比会发现doAcquireInterruptibly的一个主要区别就是如果中断则直接抛出中断异常，而acquireQueued中只是记录中断。\" class=\"headerlink\" title=\"如果你和AQS的acquireQueued方法做对比会发现doAcquireInterruptibly的一个主要区别就是如果中断则直接抛出中断异常，而acquireQueued中只是记录中断。\"></a>如果你和AQS的acquireQueued方法做对比会发现doAcquireInterruptibly的一个主要区别就是如果中断则直接抛出中断异常，而acquireQueued中只是记录中断。</h5><h3 id=\"tryLock\"><a href=\"#tryLock\" class=\"headerlink\" title=\"tryLock()\"></a>tryLock()</h3><pre><code class=\"lang-java\">public boolean tryLock() {\n    return sync.nonfairTryAcquire(1);\n}\n</code></pre>\n<h5 id=\"如果调用tryLock-，则并不关心是否公平，和非公平的tryAcquire操作相同，不做等待和重试操作\"><a href=\"#如果调用tryLock-，则并不关心是否公平，和非公平的tryAcquire操作相同，不做等待和重试操作\" class=\"headerlink\" title=\"如果调用tryLock()，则并不关心是否公平，和非公平的tryAcquire操作相同，不做等待和重试操作\"></a>如果调用tryLock()，则并不关心是否公平，和非公平的tryAcquire操作相同，不做等待和重试操作</h5><h3 id=\"getHoldCount\"><a href=\"#getHoldCount\" class=\"headerlink\" title=\"getHoldCount()\"></a>getHoldCount()</h3><pre><code class=\"lang-java\">public int getHoldCount() {\n    return sync.getHoldCount();\n}\n</code></pre>\n<h5 id=\"获取ReentrantLock的lock-方法被调用了几次（重入了几次），就是state的当前值\"><a href=\"#获取ReentrantLock的lock-方法被调用了几次（重入了几次），就是state的当前值\" class=\"headerlink\" title=\"获取ReentrantLock的lock()方法被调用了几次（重入了几次），就是state的当前值\"></a>获取<strong>ReentrantLock</strong>的<strong>lock()</strong>方法被调用了几次（重入了几次），就是<strong>state</strong>的当前值</h5><h3 id=\"getOwner\"><a href=\"#getOwner\" class=\"headerlink\" title=\"getOwner()\"></a>getOwner()</h3><pre><code class=\"lang-java\">protected Thread getOwner() {\n    return sync.getOwner();\n}\n</code></pre>\n<pre><code class=\"lang-java\">final Thread getOwner() {\n    return getState() == 0 ? null : getExclusiveOwnerThread();\n}\n</code></pre>\n<h5 id=\"获取当前占有锁的线程，就是AbstractOwnableSynchronizer中exclusiveOwnerThread的值\"><a href=\"#获取当前占有锁的线程，就是AbstractOwnableSynchronizer中exclusiveOwnerThread的值\" class=\"headerlink\" title=\"获取当前占有锁的线程，就是AbstractOwnableSynchronizer中exclusiveOwnerThread的值\"></a>获取当前占有锁的线程，就是<strong>AbstractOwnableSynchronizer</strong>中<strong>exclusiveOwnerThread</strong>的值</h5><h3 id=\"getQueuedThreads\"><a href=\"#getQueuedThreads\" class=\"headerlink\" title=\"getQueuedThreads()\"></a>getQueuedThreads()</h3><pre><code class=\"lang-java\">protected Collection&lt;Thread&gt; getQueuedThreads() {\n    return sync.getQueuedThreads();\n}\n</code></pre>\n<pre><code class=\"lang-java\">public final Collection&lt;Thread&gt; getQueuedThreads() {\n    ArrayList&lt;Thread&gt; list = new ArrayList&lt;Thread&gt;();\n    for (Node p = tail; p != null; p = p.prev) {\n        Thread t = p.thread;\n        if (t != null)\n            list.add(t);\n    }\n    return list;\n}\n</code></pre>\n<h5 id=\"获取等待持有锁的线程集合。队列从后向前遍历\"><a href=\"#获取等待持有锁的线程集合。队列从后向前遍历\" class=\"headerlink\" title=\"获取等待持有锁的线程集合。队列从后向前遍历\"></a>获取等待持有锁的线程集合。队列从后向前遍历</h5><h3 id=\"getQueuedLength\"><a href=\"#getQueuedLength\" class=\"headerlink\" title=\"getQueuedLength()\"></a>getQueuedLength()</h3><pre><code class=\"lang-java\">public final int getQueueLength() {\n    return sync.getQueueLength();\n}\n</code></pre>\n<pre><code class=\"lang-java\">public final int getQueueLength() {\n    int n = 0;\n    for (Node p = tail; p != null; p = p.prev) {\n        if (p.thread != null)\n            ++n;\n    }\n    return n;\n}\n</code></pre>\n<h5 id=\"获取等待持有锁的队列长度，和getQueuedThreads类似，通过遍历计数后返回\"><a href=\"#获取等待持有锁的队列长度，和getQueuedThreads类似，通过遍历计数后返回\" class=\"headerlink\" title=\"获取等待持有锁的队列长度，和getQueuedThreads类似，通过遍历计数后返回\"></a>获取等待持有锁的队列长度，和<strong>getQueuedThreads</strong>类似，通过遍历计数后返回</h5><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><h5 id=\"通过源码分析，发现其实ReentrantLock的实现是非常简单的，只要理解了AQS的实现过程，剩下的就是自定义同步器NonfairSync和FairSync对于AQS的state采用独占方式的获取和释放。锁的特性和概念也正是在这个过程中被实现和赋予其含义的。\"><a href=\"#通过源码分析，发现其实ReentrantLock的实现是非常简单的，只要理解了AQS的实现过程，剩下的就是自定义同步器NonfairSync和FairSync对于AQS的state采用独占方式的获取和释放。锁的特性和概念也正是在这个过程中被实现和赋予其含义的。\" class=\"headerlink\" title=\"通过源码分析，发现其实ReentrantLock的实现是非常简单的，只要理解了AQS的实现过程，剩下的就是自定义同步器NonfairSync和FairSync对于AQS的state采用独占方式的获取和释放。锁的特性和概念也正是在这个过程中被实现和赋予其含义的。\"></a>通过源码分析，发现其实<strong>ReentrantLock</strong>的实现是非常简单的，只要理解了AQS的实现过程，剩下的就是自定义同步器<strong>NonfairSync</strong>和<strong>FairSync</strong>对于<strong>AQS</strong>的<strong>state</strong>采用独占方式的获取和释放。锁的特性和概念也正是在这个过程中被实现和赋予其含义的。</h5>","site":{"data":{}},"excerpt":"<h5 id=\"Java-的ReentrantLock是我们最常用的java锁之一。ReentrantLock实现了我们最常用的一些锁的特性，那么它是如何实现这些过程的呢。其实现的原理是基于AbstractQueuedSynchronizer（AQS）和-自定义同步器-sync-的。关于AQS的实现原理可以去看我的另一篇文章：Java并发之AQS\"><a href=\"#Java-的ReentrantLock是我们最常用的java锁之一。ReentrantLock实现了我们最常用的一些锁的特性，那么它是如何实现这些过程的呢。其实现的原理是基于AbstractQueuedSynchronizer（AQS）和-自定义同步器-sync-的。关于AQS的实现原理可以去看我的另一篇文章：Java并发之AQS\" class=\"headerlink\" title=\"Java 的ReentrantLock是我们最常用的java锁之一。ReentrantLock实现了我们最常用的一些锁的特性，那么它是如何实现这些过程的呢。其实现的原理是基于AbstractQueuedSynchronizer（AQS）和 自定义同步器 sync 的。关于AQS的实现原理可以去看我的另一篇文章：Java并发之AQS\"></a>Java 的<strong>ReentrantLock</strong>是我们最常用的java锁之一。<strong>ReentrantLock</strong>实现了我们最常用的一些锁的特性，那么它是如何实现这些过程的呢。其实现的原理是基于<strong>AbstractQueuedSynchronizer</strong>（AQS）和 自定义同步器 <strong>sync</strong> 的。关于AQS的实现原理可以去看我的另一篇文章：<a href=\"https://winx402.github.io/note/jdk/JavaAQS/\" target=\"_blank\" rel=\"external\">Java并发之AQS</a></h5>","more":"<h2 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h2><h5 id=\"ReentrantLock实现了公平锁和非公平锁，它的实现过程主要是通过对AQS的state状态采取独占的操作方式，我们知道在AQS中state为0表示正常状态（释放中），为1则表示线程占用状态（也就是排他锁的概念，当然还有可能大于1，因为锁可以重入），而这些对于AQS的操作方式又是通过自定义同步器Sync来完成的：\"><a href=\"#ReentrantLock实现了公平锁和非公平锁，它的实现过程主要是通过对AQS的state状态采取独占的操作方式，我们知道在AQS中state为0表示正常状态（释放中），为1则表示线程占用状态（也就是排他锁的概念，当然还有可能大于1，因为锁可以重入），而这些对于AQS的操作方式又是通过自定义同步器Sync来完成的：\" class=\"headerlink\" title=\"ReentrantLock实现了公平锁和非公平锁，它的实现过程主要是通过对AQS的state状态采取独占的操作方式，我们知道在AQS中state为0表示正常状态（释放中），为1则表示线程占用状态（也就是排他锁的概念，当然还有可能大于1，因为锁可以重入），而这些对于AQS的操作方式又是通过自定义同步器Sync来完成的：\"></a><strong>ReentrantLock</strong>实现了公平锁和非公平锁，它的实现过程主要是通过对AQS的<strong>state</strong>状态采取独占的操作方式，我们知道在AQS中state为0表示正常状态（释放中），为1则表示线程占用状态（也就是排他锁的概念，当然还有可能大于1，因为锁可以重入），而这些对于AQS的操作方式又是通过自定义同步器<strong>Sync</strong>来完成的：</h5><pre><code class=\"lang-java\">private final Sync sync;\n</code></pre>\n<h5 id=\"ReentrantLock相对应的实现了两个Sync：\"><a href=\"#ReentrantLock相对应的实现了两个Sync：\" class=\"headerlink\" title=\"ReentrantLock相对应的实现了两个Sync：\"></a><strong>ReentrantLock</strong>相对应的实现了两个<strong>Sync</strong>：</h5><pre><code class=\"lang-java\">//非公平锁的实现\nstatic final class NonfairSync extends Sync\n</code></pre>\n<pre><code class=\"lang-java\">//公平锁的实现\nstatic final class FairSync extends Sync\n</code></pre>\n<h5 id=\"可以看到NonfairSync和NonfairSync都是继承的同一个Sync，而且他们是final类型的，都不能被再次继承。\"><a href=\"#可以看到NonfairSync和NonfairSync都是继承的同一个Sync，而且他们是final类型的，都不能被再次继承。\" class=\"headerlink\" title=\"可以看到NonfairSync和NonfairSync都是继承的同一个Sync，而且他们是final类型的，都不能被再次继承。\"></a>可以看到NonfairSync和NonfairSync都是继承的同一个Sync，而且他们是final类型的，都不能被再次继承。</h5><pre><code class=\"lang-java\">//基类Sync，继承了AQS\nabstract static class Sync extends AbstractQueuedSynchronizer\n</code></pre>\n<h2 id=\"源码详解\"><a href=\"#源码详解\" class=\"headerlink\" title=\"源码详解\"></a>源码详解</h2><h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><pre><code class=\"lang-java\">public ReentrantLock() {\n    sync = new NonfairSync();\n}\n</code></pre>\n<h5 id=\"默认构造函数将使用非公平实现方案\"><a href=\"#默认构造函数将使用非公平实现方案\" class=\"headerlink\" title=\"默认构造函数将使用非公平实现方案\"></a>默认构造函数将使用非公平实现方案</h5><pre><code class=\"lang-java\">public ReentrantLock(boolean fair) {\n    sync = fair ? new FairSync() : new NonfairSync();\n}\n</code></pre>\n<h5 id=\"公平或者非公平主要就体现在使用FairSync或者NonfairSync\"><a href=\"#公平或者非公平主要就体现在使用FairSync或者NonfairSync\" class=\"headerlink\" title=\"公平或者非公平主要就体现在使用FairSync或者NonfairSync\"></a>公平或者非公平主要就体现在使用FairSync或者NonfairSync</h5><h3 id=\"lock\"><a href=\"#lock\" class=\"headerlink\" title=\"lock()\"></a>lock()</h3><pre><code class=\"lang-java\">public void lock() {\n    sync.lock();\n}\n</code></pre>\n<h5 id=\"ReentrantLock的lock操作完全交给同步器Sync去执行，让我们来看下他们是怎么实现的：\"><a href=\"#ReentrantLock的lock操作完全交给同步器Sync去执行，让我们来看下他们是怎么实现的：\" class=\"headerlink\" title=\"ReentrantLock的lock操作完全交给同步器Sync去执行，让我们来看下他们是怎么实现的：\"></a><strong>ReentrantLock</strong>的lock操作完全交给同步器Sync去执行，让我们来看下他们是怎么实现的：</h5><h4 id=\"NonfairSync-的-lock\"><a href=\"#NonfairSync-的-lock\" class=\"headerlink\" title=\"NonfairSync 的 lock()\"></a>NonfairSync 的 lock()</h4><pre><code class=\"lang-java\">final void lock() {\n    if (compareAndSetState(0, 1))\n        setExclusiveOwnerThread(Thread.currentThread());\n    else\n        acquire(1);\n}\n</code></pre>\n<h5 id=\"NonfairSync的lock操作是基于对AQS对state状态的修改，很简单，主要分两步：\"><a href=\"#NonfairSync的lock操作是基于对AQS对state状态的修改，很简单，主要分两步：\" class=\"headerlink\" title=\"NonfairSync的lock操作是基于对AQS对state状态的修改，很简单，主要分两步：\"></a>NonfairSync的lock操作是基于对AQS对state状态的修改，很简单，主要分两步：</h5><ol>\n<li>直接通过CAS操作AQS的状态，如果是0则修改成1（该过程的语义可以理解成：如果没有线程正在占用锁，则占用该锁），修改成功则表示锁获取成功，之后设置AbstractOwnableSynchronizer的thread为当前线程</li>\n<li>如果修改失败，则调用acquire（独占的方式）操作去获取锁。</li>\n</ol>\n<h5 id=\"acquire-int-在AQS中已经详细的说明了，这里简单提一下：\"><a href=\"#acquire-int-在AQS中已经详细的说明了，这里简单提一下：\" class=\"headerlink\" title=\"acquire(int) 在AQS中已经详细的说明了，这里简单提一下：\"></a>acquire(int) 在AQS中已经详细的说明了，这里简单提一下：</h5><pre><code class=\"lang-java\">public final void acquire(int arg) {\n    if (!tryAcquire(arg) &amp;&amp;\n        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        selfInterrupt();\n}\n</code></pre>\n<ol>\n<li>tryAcquire()尝试直接去获取资源，如果成功则直接返回；</li>\n<li>addWaiter()将该线程加入等待队列的尾部，并标记为独占模式；</li>\n<li>acquireQueued()使线程在等待队列中获取资源，一直获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。</li>\n<li>如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。</li>\n</ol>\n<h5 id=\"而我们主要需要实现的就是tryAcquire-int-函数：\"><a href=\"#而我们主要需要实现的就是tryAcquire-int-函数：\" class=\"headerlink\" title=\"而我们主要需要实现的就是tryAcquire(int)函数：\"></a>而我们主要需要实现的就是tryAcquire(int)函数：</h5><pre><code class=\"lang-java\">//NonfairSync\nprotected final boolean tryAcquire(int acquires) {\n    return nonfairTryAcquire(acquires);\n}\n</code></pre>\n<h5 id=\"在非公平实现中主要通过基类Sync的nonfairTryAcquire-int-来实现：\"><a href=\"#在非公平实现中主要通过基类Sync的nonfairTryAcquire-int-来实现：\" class=\"headerlink\" title=\"在非公平实现中主要通过基类Sync的nonfairTryAcquire(int)来实现：\"></a>在非公平实现中主要通过基类Sync的nonfairTryAcquire(int)来实现：</h5><pre><code class=\"lang-java\">final boolean nonfairTryAcquire(int acquires) {\n    //获取当前线程\n    final Thread current = Thread.currentThread();\n    //获取AQS状态（state为volatile变量）\n    int c = getState();\n    if (c == 0) {\n        //这一步和NonfairSync 的 lock()的第一步是一样的，不重复解释了\n        if (compareAndSetState(0, acquires)) {\n            setExclusiveOwnerThread(current);\n            return true;\n        }\n    }\n    //判断当前线程是否已经获取到锁，可重入锁的实现\n    else if (current == getExclusiveOwnerThread()) {\n        int nextc = c + acquires;\n        if (nextc &lt; 0) // overflow\n            throw new Error(&quot;Maximum lock count exceeded&quot;);\n        setState(nextc);\n        return true;\n    }\n    return false;\n}\n</code></pre>\n<h5 id=\"nonfairTryAcquire的过程在上面代码中已经简单说明，可以看到tryAcquire（nonfairTryAcquire）操作只是针对一次性的获取操作，这里并没有重试或者自旋。因为相应的过程都在acquire-int-中实现。\"><a href=\"#nonfairTryAcquire的过程在上面代码中已经简单说明，可以看到tryAcquire（nonfairTryAcquire）操作只是针对一次性的获取操作，这里并没有重试或者自旋。因为相应的过程都在acquire-int-中实现。\" class=\"headerlink\" title=\"nonfairTryAcquire的过程在上面代码中已经简单说明，可以看到tryAcquire（nonfairTryAcquire）操作只是针对一次性的获取操作，这里并没有重试或者自旋。因为相应的过程都在acquire(int)中实现。\"></a>nonfairTryAcquire的过程在上面代码中已经简单说明，可以看到tryAcquire（nonfairTryAcquire）操作只是针对一次性的获取操作，这里并没有重试或者自旋。因为相应的过程都在acquire(int)中实现。</h5><h4 id=\"FairSync-的-lock\"><a href=\"#FairSync-的-lock\" class=\"headerlink\" title=\"FairSync 的 lock()\"></a>FairSync 的 lock()</h4><pre><code class=\"lang-java\">final void lock() {\n    acquire(1);\n}\n</code></pre>\n<h5 id=\"和非公平的实现相比，少了一步cas操作，直接通过AQS的acquire去独占state。这里也是非公平的区别之一，非公平的实现导致新加入的线程不用经过队列而是直接尝试获取锁，这个时候队列中很有可能存在其他的等待线程，这些队列中的线程可能正在唤醒的过程中。而非公平的这种操作对于系统来说性能是更高的，因为线程的唤醒需要时间。\"><a href=\"#和非公平的实现相比，少了一步cas操作，直接通过AQS的acquire去独占state。这里也是非公平的区别之一，非公平的实现导致新加入的线程不用经过队列而是直接尝试获取锁，这个时候队列中很有可能存在其他的等待线程，这些队列中的线程可能正在唤醒的过程中。而非公平的这种操作对于系统来说性能是更高的，因为线程的唤醒需要时间。\" class=\"headerlink\" title=\"和非公平的实现相比，少了一步cas操作，直接通过AQS的acquire去独占state。这里也是非公平的区别之一，非公平的实现导致新加入的线程不用经过队列而是直接尝试获取锁，这个时候队列中很有可能存在其他的等待线程，这些队列中的线程可能正在唤醒的过程中。而非公平的这种操作对于系统来说性能是更高的，因为线程的唤醒需要时间。\"></a>和非公平的实现相比，少了一步cas操作，直接通过AQS的acquire去独占state。这里也是非公平的区别之一，非公平的实现导致新加入的线程不用经过队列而是直接尝试获取锁，这个时候队列中很有可能存在其他的等待线程，这些队列中的线程可能正在唤醒的过程中。而非公平的这种操作对于系统来说性能是更高的，因为线程的唤醒需要时间。</h5><h5 id=\"acquire-int-的操作和非公平一样，我们直接看FairSync的tryAcquire-int\"><a href=\"#acquire-int-的操作和非公平一样，我们直接看FairSync的tryAcquire-int\" class=\"headerlink\" title=\"acquire(int)的操作和非公平一样，我们直接看FairSync的tryAcquire(int):\"></a><strong>acquire(int)</strong>的操作和非公平一样，我们直接看<strong>FairSync</strong>的<strong>tryAcquire(int)</strong>:</h5><pre><code class=\"lang-java\">protected final boolean tryAcquire(int acquires) {\n    //获取当前线程\n    final Thread current = Thread.currentThread();\n    //获取锁的状态\n    int c = getState();\n    if (c == 0) {\n        //如果锁是释放的，并且队列中有其他线程正在前面等待。\n        if (!hasQueuedPredecessors() &amp;&amp;\n            compareAndSetState(0, acquires)) {\n            setExclusiveOwnerThread(current);\n            return true;\n        }\n    }\n    else if (current == getExclusiveOwnerThread()) {\n        int nextc = c + acquires;\n        if (nextc &lt; 0)\n            throw new Error(&quot;Maximum lock count exceeded&quot;);\n        setState(nextc);\n        return true;\n    }\n    return false;\n}\n</code></pre>\n<h5 id=\"这里和非公平的实现nonfairTryAcquire也很像，唯一的区别在于获取锁的时候需要判断一次队列情况，也正是这个操作，导致了公平锁的实现是不能插队的，我们看下hasQueuedPredecessors的实现：\"><a href=\"#这里和非公平的实现nonfairTryAcquire也很像，唯一的区别在于获取锁的时候需要判断一次队列情况，也正是这个操作，导致了公平锁的实现是不能插队的，我们看下hasQueuedPredecessors的实现：\" class=\"headerlink\" title=\"这里和非公平的实现nonfairTryAcquire也很像，唯一的区别在于获取锁的时候需要判断一次队列情况，也正是这个操作，导致了公平锁的实现是不能插队的，我们看下hasQueuedPredecessors的实现：\"></a>这里和非公平的实现<strong>nonfairTryAcquire</strong>也很像，唯一的区别在于获取锁的时候需要判断一次队列情况，也正是这个操作，导致了公平锁的实现是不能插队的，我们看下hasQueuedPredecessors的实现：</h5><pre><code class=\"lang-java\">public final boolean hasQueuedPredecessors() {\n    Node t = tail;\n    Node h = head;\n    Node s;\n    return h != t &amp;&amp;\n        ((s = h.next) == null || s.thread != Thread.currentThread());\n}\n</code></pre>\n<h5 id=\"简单来说hasQueuedPredecessors返回true需要同时满足下面2个条件：\"><a href=\"#简单来说hasQueuedPredecessors返回true需要同时满足下面2个条件：\" class=\"headerlink\" title=\"简单来说hasQueuedPredecessors返回true需要同时满足下面2个条件：\"></a>简单来说hasQueuedPredecessors返回true需要同时满足下面2个条件：</h5><ol>\n<li>操作state的等待队列不为空</li>\n<li>队列的下一个操作线程和当前线程不是同一个线程（这里的语义和acquireQueued中很像，都是判断是否为队列的第二个节点，因为第一个节点为操作state的线程，所以第二个节点很可能是第一个节点唤醒的，所以是有机会的）。</li>\n</ol>\n<h3 id=\"unlock\"><a href=\"#unlock\" class=\"headerlink\" title=\"unlock()\"></a>unlock()</h3><pre><code class=\"lang-java\">public void unlock() {\n    sync.release(1);\n}\n</code></pre>\n<h5 id=\"通过操作AQS的释放操作，完成解锁语义，看下release-int\"><a href=\"#通过操作AQS的释放操作，完成解锁语义，看下release-int\" class=\"headerlink\" title=\"通过操作AQS的释放操作，完成解锁语义，看下release(int):\"></a>通过操作AQS的释放操作，完成解锁语义，看下release(int):</h5><pre><code class=\"lang-java\">public final boolean release(int arg) {\n    if (tryRelease(arg)) {\n        Node h = head;//找到头结点\n        if (h != null &amp;&amp; h.waitStatus != 0)\n            unparkSuccessor(h);//唤醒等待队列里的下一个线程\n        return true;\n    }\n    return false;\n}\n</code></pre>\n<h5 id=\"release操作在AQS文章中也已经说明，不再赘诉，直接看tryRelease-int-实现。\"><a href=\"#release操作在AQS文章中也已经说明，不再赘诉，直接看tryRelease-int-实现。\" class=\"headerlink\" title=\"release操作在AQS文章中也已经说明，不再赘诉，直接看tryRelease(int)实现。\"></a>release操作在AQS文章中也已经说明，不再赘诉，直接看tryRelease(int)实现。</h5><pre><code class=\"lang-java\">protected final boolean tryRelease(int releases) {\n    int c = getState() - releases;\n    if (Thread.currentThread() != getExclusiveOwnerThread())\n        throw new IllegalMonitorStateException();\n    boolean free = false;\n    if (c == 0) {\n        free = true;\n        setExclusiveOwnerThread(null);\n    }\n    setState(c);\n    return free;\n}\n</code></pre>\n<h5 id=\"tryRelease的实现不区分公平非公平，其主要流程如下：\"><a href=\"#tryRelease的实现不区分公平非公平，其主要流程如下：\" class=\"headerlink\" title=\"tryRelease的实现不区分公平非公平，其主要流程如下：\"></a>tryRelease的实现不区分公平非公平，其主要流程如下：</h5><ol>\n<li>计算state释放releases后的值</li>\n<li>查看当前线程是否持有该锁，如果不持有。抛出异常</li>\n<li>如果锁被完全释放(state == 0)，设置持有线程为null</li>\n<li>则设置剩余状态值</li>\n</ol>\n<h3 id=\"lockInterruptibly\"><a href=\"#lockInterruptibly\" class=\"headerlink\" title=\"lockInterruptibly()\"></a>lockInterruptibly()</h3><pre><code class=\"lang-java\">public void lockInterruptibly() throws InterruptedException {\n    sync.acquireInterruptibly(1);\n}\n</code></pre>\n<h5 id=\"直接看AQS的acquireInterruptibly-int-和doAcquireInterruptibly-int\"><a href=\"#直接看AQS的acquireInterruptibly-int-和doAcquireInterruptibly-int\" class=\"headerlink\" title=\"直接看AQS的acquireInterruptibly(int)和doAcquireInterruptibly(int):\"></a>直接看AQS的acquireInterruptibly(int)和doAcquireInterruptibly(int):</h5><pre><code class=\"lang-java\">public final void acquireInterruptibly(int arg)\n        throws InterruptedException {\n    if (Thread.interrupted())\n        throw new InterruptedException();\n    if (!tryAcquire(arg))\n        doAcquireInterruptibly(arg);\n}\n</code></pre>\n<pre><code class=\"lang-java\">private void doAcquireInterruptibly(int arg)\n    throws InterruptedException {\n    final Node node = addWaiter(Node.EXCLUSIVE);\n    boolean failed = true;\n    try {\n        for (;;) {\n            final Node p = node.predecessor();\n            if (p == head &amp;&amp; tryAcquire(arg)) {\n                setHead(node);\n                p.next = null; // help GC\n                failed = false;\n                return;\n            }\n            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;\n                parkAndCheckInterrupt())\n                throw new InterruptedException();\n        }\n    } finally {\n        if (failed)\n            cancelAcquire(node);\n    }\n}\n</code></pre>\n<h5 id=\"如果你和AQS的acquireQueued方法做对比会发现doAcquireInterruptibly的一个主要区别就是如果中断则直接抛出中断异常，而acquireQueued中只是记录中断。\"><a href=\"#如果你和AQS的acquireQueued方法做对比会发现doAcquireInterruptibly的一个主要区别就是如果中断则直接抛出中断异常，而acquireQueued中只是记录中断。\" class=\"headerlink\" title=\"如果你和AQS的acquireQueued方法做对比会发现doAcquireInterruptibly的一个主要区别就是如果中断则直接抛出中断异常，而acquireQueued中只是记录中断。\"></a>如果你和AQS的acquireQueued方法做对比会发现doAcquireInterruptibly的一个主要区别就是如果中断则直接抛出中断异常，而acquireQueued中只是记录中断。</h5><h3 id=\"tryLock\"><a href=\"#tryLock\" class=\"headerlink\" title=\"tryLock()\"></a>tryLock()</h3><pre><code class=\"lang-java\">public boolean tryLock() {\n    return sync.nonfairTryAcquire(1);\n}\n</code></pre>\n<h5 id=\"如果调用tryLock-，则并不关心是否公平，和非公平的tryAcquire操作相同，不做等待和重试操作\"><a href=\"#如果调用tryLock-，则并不关心是否公平，和非公平的tryAcquire操作相同，不做等待和重试操作\" class=\"headerlink\" title=\"如果调用tryLock()，则并不关心是否公平，和非公平的tryAcquire操作相同，不做等待和重试操作\"></a>如果调用tryLock()，则并不关心是否公平，和非公平的tryAcquire操作相同，不做等待和重试操作</h5><h3 id=\"getHoldCount\"><a href=\"#getHoldCount\" class=\"headerlink\" title=\"getHoldCount()\"></a>getHoldCount()</h3><pre><code class=\"lang-java\">public int getHoldCount() {\n    return sync.getHoldCount();\n}\n</code></pre>\n<h5 id=\"获取ReentrantLock的lock-方法被调用了几次（重入了几次），就是state的当前值\"><a href=\"#获取ReentrantLock的lock-方法被调用了几次（重入了几次），就是state的当前值\" class=\"headerlink\" title=\"获取ReentrantLock的lock()方法被调用了几次（重入了几次），就是state的当前值\"></a>获取<strong>ReentrantLock</strong>的<strong>lock()</strong>方法被调用了几次（重入了几次），就是<strong>state</strong>的当前值</h5><h3 id=\"getOwner\"><a href=\"#getOwner\" class=\"headerlink\" title=\"getOwner()\"></a>getOwner()</h3><pre><code class=\"lang-java\">protected Thread getOwner() {\n    return sync.getOwner();\n}\n</code></pre>\n<pre><code class=\"lang-java\">final Thread getOwner() {\n    return getState() == 0 ? null : getExclusiveOwnerThread();\n}\n</code></pre>\n<h5 id=\"获取当前占有锁的线程，就是AbstractOwnableSynchronizer中exclusiveOwnerThread的值\"><a href=\"#获取当前占有锁的线程，就是AbstractOwnableSynchronizer中exclusiveOwnerThread的值\" class=\"headerlink\" title=\"获取当前占有锁的线程，就是AbstractOwnableSynchronizer中exclusiveOwnerThread的值\"></a>获取当前占有锁的线程，就是<strong>AbstractOwnableSynchronizer</strong>中<strong>exclusiveOwnerThread</strong>的值</h5><h3 id=\"getQueuedThreads\"><a href=\"#getQueuedThreads\" class=\"headerlink\" title=\"getQueuedThreads()\"></a>getQueuedThreads()</h3><pre><code class=\"lang-java\">protected Collection&lt;Thread&gt; getQueuedThreads() {\n    return sync.getQueuedThreads();\n}\n</code></pre>\n<pre><code class=\"lang-java\">public final Collection&lt;Thread&gt; getQueuedThreads() {\n    ArrayList&lt;Thread&gt; list = new ArrayList&lt;Thread&gt;();\n    for (Node p = tail; p != null; p = p.prev) {\n        Thread t = p.thread;\n        if (t != null)\n            list.add(t);\n    }\n    return list;\n}\n</code></pre>\n<h5 id=\"获取等待持有锁的线程集合。队列从后向前遍历\"><a href=\"#获取等待持有锁的线程集合。队列从后向前遍历\" class=\"headerlink\" title=\"获取等待持有锁的线程集合。队列从后向前遍历\"></a>获取等待持有锁的线程集合。队列从后向前遍历</h5><h3 id=\"getQueuedLength\"><a href=\"#getQueuedLength\" class=\"headerlink\" title=\"getQueuedLength()\"></a>getQueuedLength()</h3><pre><code class=\"lang-java\">public final int getQueueLength() {\n    return sync.getQueueLength();\n}\n</code></pre>\n<pre><code class=\"lang-java\">public final int getQueueLength() {\n    int n = 0;\n    for (Node p = tail; p != null; p = p.prev) {\n        if (p.thread != null)\n            ++n;\n    }\n    return n;\n}\n</code></pre>\n<h5 id=\"获取等待持有锁的队列长度，和getQueuedThreads类似，通过遍历计数后返回\"><a href=\"#获取等待持有锁的队列长度，和getQueuedThreads类似，通过遍历计数后返回\" class=\"headerlink\" title=\"获取等待持有锁的队列长度，和getQueuedThreads类似，通过遍历计数后返回\"></a>获取等待持有锁的队列长度，和<strong>getQueuedThreads</strong>类似，通过遍历计数后返回</h5><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><h5 id=\"通过源码分析，发现其实ReentrantLock的实现是非常简单的，只要理解了AQS的实现过程，剩下的就是自定义同步器NonfairSync和FairSync对于AQS的state采用独占方式的获取和释放。锁的特性和概念也正是在这个过程中被实现和赋予其含义的。\"><a href=\"#通过源码分析，发现其实ReentrantLock的实现是非常简单的，只要理解了AQS的实现过程，剩下的就是自定义同步器NonfairSync和FairSync对于AQS的state采用独占方式的获取和释放。锁的特性和概念也正是在这个过程中被实现和赋予其含义的。\" class=\"headerlink\" title=\"通过源码分析，发现其实ReentrantLock的实现是非常简单的，只要理解了AQS的实现过程，剩下的就是自定义同步器NonfairSync和FairSync对于AQS的state采用独占方式的获取和释放。锁的特性和概念也正是在这个过程中被实现和赋予其含义的。\"></a>通过源码分析，发现其实<strong>ReentrantLock</strong>的实现是非常简单的，只要理解了AQS的实现过程，剩下的就是自定义同步器<strong>NonfairSync</strong>和<strong>FairSync</strong>对于<strong>AQS</strong>的<strong>state</strong>采用独占方式的获取和释放。锁的特性和概念也正是在这个过程中被实现和赋予其含义的。</h5>"},{"layout":"post","title":"ThreadLocal源码解析","date":"2017-03-08T16:00:00.000Z","original":true,"tag":[["java","java"]],"_content":"\n## ThreadLocal是什么\n##### This class provides thread-local variables.  These variables differ from their normal counterparts in that each thread that accesses one (via its <tt>get</tt> or <tt>set</tt> method) has its own, independently initialized copy of the variable.  <tt>ThreadLocal</tt> instances are typically private static fields in classes that wish to associate state with a thread (e.g., a user ID or Transaction ID).\n<!--more-->\n\n### 这是ThreadLocal源码中一段介绍，翻译过来的大概意思是：\n##### ThreadLocal类用来提供线程内部的局部变量。这种变量在多线程环境下访问(通过get或set方法访问)时能保证各个线程里的变量相对独立于其他线程内的变量。ThreadLocal实例通常来说都是private static类型的，用于关联线程和线程的上下文。\n\n##### 这种解释和网络上所说的解决多线程的并发问题不太一样，当你把一个变量复制成了多份，我觉得这种方式并不叫解决多线程访问资源时的共享问题。本质上来说资源已经变成了多份，没有共享之说，当然这也是一种解决方式，但是如果资源不必线程共享，又何必要用ThreadLocal去实现呢。\n\n#### 总结来说：ThreadLocal的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。\n##### 举一个例子，一个请求需要按照1、2、3这个顺序执行3个函数。但是其中有一个参数是需要函数1提供给函数3使用的，但是这个参数对于函数2来说并没有作用（实际情况可能比这要复杂的多）。同时我们又不希望污染函数2，那么如何将该参数通过函数1传递到函数3呢？ThreadLocal是一个比较合理的解决方法。\n\n## ThreadLocal代码演示\n\n```JAVA\n/**\n * Created BY wangwenxiang on 2017/3/15.\n */\npublic class ThreadLocalTest {\n    private static ThreadLocal<Integer> integerThreadLocal = new ThreadLocal<Integer>();\n\n    /**\n     * 初始化并输出每个线程的ThreadLocal\n     * Runnable\n     * name\n     */\n    private static Thread[] initThread(){\n        Thread[] threads = new Thread[10];\n        for (int i=0;i<10;i++){\n            final int finalI = i;\n            threads[i] = new Thread(new Runnable() {\n                public void run() {\n                    integerThreadLocal.set(finalI);\n                    System.out.println(Thread.currentThread().getName()+\": \"+integerThreadLocal.get());\n                }\n            },\"thread-\" + i);\n        }\n        return threads;\n    }\n\n\n    public static void main(String[] args) {\n        Thread[] threads = initThread();\n        for (Thread thread : threads){\n            thread.start();\n        }\n    }\n}\n```\n\n##### ThreadLocal的操作非常简单，基本上没有太多的过程。\n\n##### 执行结果：\n```\nthread-0: 0\nthread-1: 1\nthread-2: 2\nthread-3: 3\nthread-4: 4\nthread-5: 5\nthread-6: 6\nthread-7: 7\nthread-8: 8\nthread-9: 9\n```\n\n##### 可以看出虽然只创建了一个ThreadLocal对象，但是每个线程的初始化之后，得出来的结果并不一样。各个线程之间的值是相互独立的。\n\n## ThreadLocal源码\n### 构造函数\n```java\n/**\n * Creates a thread local variable.\n */\npublic ThreadLocal() {\n}\n```\n##### 这是ThreadLocal唯一的构造函数，什么也没做\n\n### set方法\n```JAVA\n/**\n * Sets the current thread's copy of this thread-local variable\n * to the specified value.  Most subclasses will have no need to\n * override this method, relying solely on the {@link #initialValue}\n * method to set the values of thread-locals.\n *\n * @param value the value to be stored in the current thread's copy of\n *        this thread-local.\n */\npublic void set(T value) {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null)\n            map.set(this, value);\n        else\n            createMap(t, value);\n    }\n```\n##### 代码比较简单\n\n1. 获取当前线程 `Thread t = Thread.currentThread();`\n2. 获取当前线程的ThreadLocalMap，使得每个线程的本地数据相互隔离的原因也在于这里，因为每个线程都有自己的ThreadLocalMap；\n3. 判断ThreadLocalMap是否为空，直接插入或者创建map并插入；\n\n#### ThreadLocalMap的set方法\n```JAVA\n/**\n * Set the value associated with key.\n * @param value the value to be set\n *\n * @param key the thread local object\n */\nprivate void set(ThreadLocal key, Object value) {\n\n    // We don't use a fast path as with get() because it is at\n    // least as common to use set() to create new entries as\n    // it is to replace existing ones, in which case, a fast\n    // path would fail more often than not.\n\n    Entry[] tab = table;\n    int len = tab.length;\n    int i = key.threadLocalHashCode & (len-1);\n\n    for (Entry e = tab[i];\n         e != null;\n         e = tab[i = nextIndex(i, len)]) {\n        ThreadLocal k = e.get();\n\n        if (k == key) {\n            e.value = value;\n            return;\n        }\n\n        if (k == null) {\n            replaceStaleEntry(key, value, i);\n            return;\n        }\n    }\n\n    tab[i] = new Entry(key, value);\n    int sz = ++size;\n    if (!cleanSomeSlots(i, sz) && sz >= threshold)\n        rehash();\n}\n```\n##### map的key和value分别对应的是ThreadLocal本身和往ThreadLocal中set的值。\n\n1. 首先根据ThreadLocal元素的hashCode计算出其数组下标；由于数组的长度用于等于2<sup>n</sup>个，所以下表的取值范围在0到2<sup>n</sup>-1；\n2. for循环，从数组位置i开始以步长1向后循环遍历，直到找到一个空位，每次循环将该位置的值赋值给e；\n3. 当数组位置不为空时执行方法体：\n    1. 获得该数组位置的ThreadLocal，判断是否与当前ThreadLocal相等，如果相等，则将value更新，set方法结束；\n    2. 如果该ThreadLocal为空，则替换，然后结束方法。\n4. 在位置i插入新值，计数加1\n\n### get方法\n```JAVA\n/**\n  * Returns the value in the current thread's copy of this\n  * thread-local variable.  If the variable has no value for the\n  * current thread, it is first initialized to the value returned\n  * by an invocation of the {@link #initialValue} method.\n  *\n  * @return the current thread's value of this thread-local\n  */\npublic T get() {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null) {\n            ThreadLocalMap.Entry e = map.getEntry(this);\n            if (e != null)\n                return (T)e.value;\n        }\n        return setInitialValue();\n    }\n```\n##### get方法和set方法比较类似，首先获取当前线程，并获取线程的ThreadLocalMap，以当前的ThreadLocal作为key在map中获取value，判断value是否为null，如果为null，则将当前的ThreadLocal中设置初始值，并返回改值。\n#### setInitialValue()\n```JAVA\n/**\n * Variant of set() to establish initialValue. Used instead\n * of set() in case user has overridden the set() method.\n *\n * @return the initial value\n */\nprivate T setInitialValue() {\n    T value = initialValue();\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n    if (map != null)\n        map.set(this, value);\n    else\n        createMap(t, value);\n    return value;\n}\n```\n##### 该方法和set方法基本一样\n#### initialValue()\n```JAVA\n/**\n * Returns the current thread's \"initial value\" for this\n * thread-local variable.  This method will be invoked the first\n * time a thread accesses the variable with the {@link #get}\n * method, unless the thread previously invoked the {@link #set}\n * method, in which case the <tt>initialValue</tt> method will not\n * be invoked for the thread.  Normally, this method is invoked at\n * most once per thread, but it may be invoked again in case of\n * subsequent invocations of {@link #remove} followed by {@link #get}.\n *\n * <p>This implementation simply returns <tt>null</tt>; if the\n * programmer desires thread-local variables to have an initial\n * value other than <tt>null</tt>, <tt>ThreadLocal</tt> must be\n * subclassed, and this method overridden.  Typically, an\n * anonymous inner class will be used.\n *\n * @return the initial value for this thread-local\n */\n protected T initialValue() {\n     return null;\n }\n```\n##### 该方法只在get方法中被调用，当ThreadLocal中没有设置value时。默认返回null，protected的访问权限表示该方法支持被覆盖。\n\n### ThreadLocalMap\n##### ThreadLocalMap是使用ThreadLocal的弱引用作为Key的\n```JAVA\nstatic class ThreadLocalMap {\n        /**\n         * The entries in this hash map extend WeakReference, using\n         * its main ref field as the key (which is always a\n         * ThreadLocal object).  Note that null keys (i.e. entry.get()\n         * == null) mean that the key is no longer referenced, so the\n         * entry can be expunged from table.  Such entries are referred to\n         * as \"stale entries\" in the code that follows.\n         */\n        static class Entry extends WeakReference<ThreadLocal> {\n            /** The value associated with this ThreadLocal. */\n            Object value;\n\n            Entry(ThreadLocal k, Object v) {\n                super(k);\n                value = v;\n            }\n        }\n        ...\n        ...\n}\n```\n\n##### 下图是本文介绍到的一些对象之间的引用关系图，实线表示强引用，虚线表示弱引用：\n![ThreadLocal](/img/note/ThreadLocal.png) <div class='img-note'>ThreadLocal对象引用</div>\n\n##### 如上图，ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用引用他，那么系统gc的时候，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：\n#### Thread Ref -> Thread -> ThreaLocalMap -> Entry -> value\n##### 永远无法回收，造成内存泄露。\n\n##### 其实，在JDK的ThreadLocalMap的设计中已经考虑到这种情况，也加上了一些防护措施，下面是ThreadLocalMap的`getEntry`方法的源码：\n```JAVA\nprivate Entry getEntry(ThreadLocal key) {\n    int i = key.threadLocalHashCode & (table.length - 1);\n    Entry e = table[i];\n    if (e != null && e.get() == key)\n        return e;\n    else\n        return getEntryAfterMiss(key, i, e);\n}\n```\n#### 当Entry为null时，getEntryAfterMiss方法\n```java\nprivate Entry getEntryAfterMiss(ThreadLocal key, int i, Entry e) {\n    Entry[] tab = table;\n    int len = tab.length;\n    while (e != null) {\n        ThreadLocal k = e.get();\n        if (k == key)\n            return e;\n        if (k == null)\n            expungeStaleEntry(i);\n        else\n            i = nextIndex(i, len);\n        e = tab[i];\n    }\n    return null;\n}\n```\n\n#### `expungeStaleEntry`函数的源码：\n```java\nprivate int expungeStaleEntry(int staleSlot) {\n    Entry[] tab = table;\n    int len = tab.length;\n\n    // expunge entry at staleSlot\n    tab[staleSlot].value = null;\n    tab[staleSlot] = null;\n    size--;\n\n    // Rehash until we encounter null\n    Entry e;\n    int i;\n    for (i = nextIndex(staleSlot, len);\n         (e = tab[i]) != null;\n         i = nextIndex(i, len)) {\n        ThreadLocal k = e.get();\n        if (k == null) {\n            e.value = null;\n            tab[i] = null;\n            size--;\n        } else {\n            int h = k.threadLocalHashCode & (len - 1);\n            if (h != i) {\n                tab[i] = null;\n\n                // Unlike Knuth 6.4 Algorithm R, we must scan until\n                // null because multiple entries could have been stale.\n                while (tab[h] != null)\n                    h = nextIndex(h, len);\n                tab[h] = e;\n            }\n        }\n    }\n    return i;\n}\n```\n\n##### 整理一下ThreadLocalMap的`getEntry`函数的流程：\n\n1. 首先从ThreadLocal的直接索引位置(通过ThreadLocal.threadLocalHashCode & (len-1)运算得到)获取Entry e，如果e不为null并且key相同则返回e；\n2. 如果e为null或者key不一致则向下一个位置查询，如果下一个位置的key和当前需要查询的key相等，则返回对应的Entry，否则，如果key值为null，则擦除该位置的Entry，否则继续向下一个位置查询\n\n##### 在这个过程中遇到的key为null的Entry都会被擦除，那么Entry内的value也就没有强引用链，自然会被回收。仔细研究代码可以发现，`set`操作也有类似的思想，将key为null的这些Entry都删除，防止内存泄露。\n##### 但是光这样还是不够的，上面的设计思路依赖一个前提条件： 要调用ThreadLocalMap的`getEntry`函数或者`set`函数。 这当然是不可能任何情况都成立的，所以很多情况下需要使用者手动调用ThreadLocal的`remove`函数，手动删除不再需要的ThreadLocal，防止内存泄露。所以JDK建议将ThreadLocal变量定义成`private static`的，这样的话ThreadLocal的生命周期就更长，由于一直存在ThreadLocal的强引用，所以ThreadLocal也就不会被回收，也就能保证任何时候都能根据ThreadLocal的弱引用访问到Entry的value值，然后remove它，防止内存泄露。","source":"_posts/note/jdk/threadLocal.md","raw":"---\nlayout: post\ntitle: ThreadLocal源码解析\ndate: 2017/03/09\noriginal: true\ntags: [tech, index, java]\ntag: [[java, java]]\n---\n\n## ThreadLocal是什么\n##### This class provides thread-local variables.  These variables differ from their normal counterparts in that each thread that accesses one (via its <tt>get</tt> or <tt>set</tt> method) has its own, independently initialized copy of the variable.  <tt>ThreadLocal</tt> instances are typically private static fields in classes that wish to associate state with a thread (e.g., a user ID or Transaction ID).\n<!--more-->\n\n### 这是ThreadLocal源码中一段介绍，翻译过来的大概意思是：\n##### ThreadLocal类用来提供线程内部的局部变量。这种变量在多线程环境下访问(通过get或set方法访问)时能保证各个线程里的变量相对独立于其他线程内的变量。ThreadLocal实例通常来说都是private static类型的，用于关联线程和线程的上下文。\n\n##### 这种解释和网络上所说的解决多线程的并发问题不太一样，当你把一个变量复制成了多份，我觉得这种方式并不叫解决多线程访问资源时的共享问题。本质上来说资源已经变成了多份，没有共享之说，当然这也是一种解决方式，但是如果资源不必线程共享，又何必要用ThreadLocal去实现呢。\n\n#### 总结来说：ThreadLocal的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。\n##### 举一个例子，一个请求需要按照1、2、3这个顺序执行3个函数。但是其中有一个参数是需要函数1提供给函数3使用的，但是这个参数对于函数2来说并没有作用（实际情况可能比这要复杂的多）。同时我们又不希望污染函数2，那么如何将该参数通过函数1传递到函数3呢？ThreadLocal是一个比较合理的解决方法。\n\n## ThreadLocal代码演示\n\n```JAVA\n/**\n * Created BY wangwenxiang on 2017/3/15.\n */\npublic class ThreadLocalTest {\n    private static ThreadLocal<Integer> integerThreadLocal = new ThreadLocal<Integer>();\n\n    /**\n     * 初始化并输出每个线程的ThreadLocal\n     * Runnable\n     * name\n     */\n    private static Thread[] initThread(){\n        Thread[] threads = new Thread[10];\n        for (int i=0;i<10;i++){\n            final int finalI = i;\n            threads[i] = new Thread(new Runnable() {\n                public void run() {\n                    integerThreadLocal.set(finalI);\n                    System.out.println(Thread.currentThread().getName()+\": \"+integerThreadLocal.get());\n                }\n            },\"thread-\" + i);\n        }\n        return threads;\n    }\n\n\n    public static void main(String[] args) {\n        Thread[] threads = initThread();\n        for (Thread thread : threads){\n            thread.start();\n        }\n    }\n}\n```\n\n##### ThreadLocal的操作非常简单，基本上没有太多的过程。\n\n##### 执行结果：\n```\nthread-0: 0\nthread-1: 1\nthread-2: 2\nthread-3: 3\nthread-4: 4\nthread-5: 5\nthread-6: 6\nthread-7: 7\nthread-8: 8\nthread-9: 9\n```\n\n##### 可以看出虽然只创建了一个ThreadLocal对象，但是每个线程的初始化之后，得出来的结果并不一样。各个线程之间的值是相互独立的。\n\n## ThreadLocal源码\n### 构造函数\n```java\n/**\n * Creates a thread local variable.\n */\npublic ThreadLocal() {\n}\n```\n##### 这是ThreadLocal唯一的构造函数，什么也没做\n\n### set方法\n```JAVA\n/**\n * Sets the current thread's copy of this thread-local variable\n * to the specified value.  Most subclasses will have no need to\n * override this method, relying solely on the {@link #initialValue}\n * method to set the values of thread-locals.\n *\n * @param value the value to be stored in the current thread's copy of\n *        this thread-local.\n */\npublic void set(T value) {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null)\n            map.set(this, value);\n        else\n            createMap(t, value);\n    }\n```\n##### 代码比较简单\n\n1. 获取当前线程 `Thread t = Thread.currentThread();`\n2. 获取当前线程的ThreadLocalMap，使得每个线程的本地数据相互隔离的原因也在于这里，因为每个线程都有自己的ThreadLocalMap；\n3. 判断ThreadLocalMap是否为空，直接插入或者创建map并插入；\n\n#### ThreadLocalMap的set方法\n```JAVA\n/**\n * Set the value associated with key.\n * @param value the value to be set\n *\n * @param key the thread local object\n */\nprivate void set(ThreadLocal key, Object value) {\n\n    // We don't use a fast path as with get() because it is at\n    // least as common to use set() to create new entries as\n    // it is to replace existing ones, in which case, a fast\n    // path would fail more often than not.\n\n    Entry[] tab = table;\n    int len = tab.length;\n    int i = key.threadLocalHashCode & (len-1);\n\n    for (Entry e = tab[i];\n         e != null;\n         e = tab[i = nextIndex(i, len)]) {\n        ThreadLocal k = e.get();\n\n        if (k == key) {\n            e.value = value;\n            return;\n        }\n\n        if (k == null) {\n            replaceStaleEntry(key, value, i);\n            return;\n        }\n    }\n\n    tab[i] = new Entry(key, value);\n    int sz = ++size;\n    if (!cleanSomeSlots(i, sz) && sz >= threshold)\n        rehash();\n}\n```\n##### map的key和value分别对应的是ThreadLocal本身和往ThreadLocal中set的值。\n\n1. 首先根据ThreadLocal元素的hashCode计算出其数组下标；由于数组的长度用于等于2<sup>n</sup>个，所以下表的取值范围在0到2<sup>n</sup>-1；\n2. for循环，从数组位置i开始以步长1向后循环遍历，直到找到一个空位，每次循环将该位置的值赋值给e；\n3. 当数组位置不为空时执行方法体：\n    1. 获得该数组位置的ThreadLocal，判断是否与当前ThreadLocal相等，如果相等，则将value更新，set方法结束；\n    2. 如果该ThreadLocal为空，则替换，然后结束方法。\n4. 在位置i插入新值，计数加1\n\n### get方法\n```JAVA\n/**\n  * Returns the value in the current thread's copy of this\n  * thread-local variable.  If the variable has no value for the\n  * current thread, it is first initialized to the value returned\n  * by an invocation of the {@link #initialValue} method.\n  *\n  * @return the current thread's value of this thread-local\n  */\npublic T get() {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null) {\n            ThreadLocalMap.Entry e = map.getEntry(this);\n            if (e != null)\n                return (T)e.value;\n        }\n        return setInitialValue();\n    }\n```\n##### get方法和set方法比较类似，首先获取当前线程，并获取线程的ThreadLocalMap，以当前的ThreadLocal作为key在map中获取value，判断value是否为null，如果为null，则将当前的ThreadLocal中设置初始值，并返回改值。\n#### setInitialValue()\n```JAVA\n/**\n * Variant of set() to establish initialValue. Used instead\n * of set() in case user has overridden the set() method.\n *\n * @return the initial value\n */\nprivate T setInitialValue() {\n    T value = initialValue();\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n    if (map != null)\n        map.set(this, value);\n    else\n        createMap(t, value);\n    return value;\n}\n```\n##### 该方法和set方法基本一样\n#### initialValue()\n```JAVA\n/**\n * Returns the current thread's \"initial value\" for this\n * thread-local variable.  This method will be invoked the first\n * time a thread accesses the variable with the {@link #get}\n * method, unless the thread previously invoked the {@link #set}\n * method, in which case the <tt>initialValue</tt> method will not\n * be invoked for the thread.  Normally, this method is invoked at\n * most once per thread, but it may be invoked again in case of\n * subsequent invocations of {@link #remove} followed by {@link #get}.\n *\n * <p>This implementation simply returns <tt>null</tt>; if the\n * programmer desires thread-local variables to have an initial\n * value other than <tt>null</tt>, <tt>ThreadLocal</tt> must be\n * subclassed, and this method overridden.  Typically, an\n * anonymous inner class will be used.\n *\n * @return the initial value for this thread-local\n */\n protected T initialValue() {\n     return null;\n }\n```\n##### 该方法只在get方法中被调用，当ThreadLocal中没有设置value时。默认返回null，protected的访问权限表示该方法支持被覆盖。\n\n### ThreadLocalMap\n##### ThreadLocalMap是使用ThreadLocal的弱引用作为Key的\n```JAVA\nstatic class ThreadLocalMap {\n        /**\n         * The entries in this hash map extend WeakReference, using\n         * its main ref field as the key (which is always a\n         * ThreadLocal object).  Note that null keys (i.e. entry.get()\n         * == null) mean that the key is no longer referenced, so the\n         * entry can be expunged from table.  Such entries are referred to\n         * as \"stale entries\" in the code that follows.\n         */\n        static class Entry extends WeakReference<ThreadLocal> {\n            /** The value associated with this ThreadLocal. */\n            Object value;\n\n            Entry(ThreadLocal k, Object v) {\n                super(k);\n                value = v;\n            }\n        }\n        ...\n        ...\n}\n```\n\n##### 下图是本文介绍到的一些对象之间的引用关系图，实线表示强引用，虚线表示弱引用：\n![ThreadLocal](/img/note/ThreadLocal.png) <div class='img-note'>ThreadLocal对象引用</div>\n\n##### 如上图，ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用引用他，那么系统gc的时候，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：\n#### Thread Ref -> Thread -> ThreaLocalMap -> Entry -> value\n##### 永远无法回收，造成内存泄露。\n\n##### 其实，在JDK的ThreadLocalMap的设计中已经考虑到这种情况，也加上了一些防护措施，下面是ThreadLocalMap的`getEntry`方法的源码：\n```JAVA\nprivate Entry getEntry(ThreadLocal key) {\n    int i = key.threadLocalHashCode & (table.length - 1);\n    Entry e = table[i];\n    if (e != null && e.get() == key)\n        return e;\n    else\n        return getEntryAfterMiss(key, i, e);\n}\n```\n#### 当Entry为null时，getEntryAfterMiss方法\n```java\nprivate Entry getEntryAfterMiss(ThreadLocal key, int i, Entry e) {\n    Entry[] tab = table;\n    int len = tab.length;\n    while (e != null) {\n        ThreadLocal k = e.get();\n        if (k == key)\n            return e;\n        if (k == null)\n            expungeStaleEntry(i);\n        else\n            i = nextIndex(i, len);\n        e = tab[i];\n    }\n    return null;\n}\n```\n\n#### `expungeStaleEntry`函数的源码：\n```java\nprivate int expungeStaleEntry(int staleSlot) {\n    Entry[] tab = table;\n    int len = tab.length;\n\n    // expunge entry at staleSlot\n    tab[staleSlot].value = null;\n    tab[staleSlot] = null;\n    size--;\n\n    // Rehash until we encounter null\n    Entry e;\n    int i;\n    for (i = nextIndex(staleSlot, len);\n         (e = tab[i]) != null;\n         i = nextIndex(i, len)) {\n        ThreadLocal k = e.get();\n        if (k == null) {\n            e.value = null;\n            tab[i] = null;\n            size--;\n        } else {\n            int h = k.threadLocalHashCode & (len - 1);\n            if (h != i) {\n                tab[i] = null;\n\n                // Unlike Knuth 6.4 Algorithm R, we must scan until\n                // null because multiple entries could have been stale.\n                while (tab[h] != null)\n                    h = nextIndex(h, len);\n                tab[h] = e;\n            }\n        }\n    }\n    return i;\n}\n```\n\n##### 整理一下ThreadLocalMap的`getEntry`函数的流程：\n\n1. 首先从ThreadLocal的直接索引位置(通过ThreadLocal.threadLocalHashCode & (len-1)运算得到)获取Entry e，如果e不为null并且key相同则返回e；\n2. 如果e为null或者key不一致则向下一个位置查询，如果下一个位置的key和当前需要查询的key相等，则返回对应的Entry，否则，如果key值为null，则擦除该位置的Entry，否则继续向下一个位置查询\n\n##### 在这个过程中遇到的key为null的Entry都会被擦除，那么Entry内的value也就没有强引用链，自然会被回收。仔细研究代码可以发现，`set`操作也有类似的思想，将key为null的这些Entry都删除，防止内存泄露。\n##### 但是光这样还是不够的，上面的设计思路依赖一个前提条件： 要调用ThreadLocalMap的`getEntry`函数或者`set`函数。 这当然是不可能任何情况都成立的，所以很多情况下需要使用者手动调用ThreadLocal的`remove`函数，手动删除不再需要的ThreadLocal，防止内存泄露。所以JDK建议将ThreadLocal变量定义成`private static`的，这样的话ThreadLocal的生命周期就更长，由于一直存在ThreadLocal的强引用，所以ThreadLocal也就不会被回收，也就能保证任何时候都能根据ThreadLocal的弱引用访问到Entry的value值，然后remove它，防止内存泄露。","slug":"note/jdk/threadLocal","published":1,"updated":"2018-05-08T13:00:14.280Z","comments":1,"photos":[],"link":"","_id":"cjgxop3np003sjah1r12pjjbg","content":"<h2 id=\"ThreadLocal是什么\"><a href=\"#ThreadLocal是什么\" class=\"headerlink\" title=\"ThreadLocal是什么\"></a>ThreadLocal是什么</h2><h5 id=\"This-class-provides-thread-local-variables-These-variables-differ-from-their-normal-counterparts-in-that-each-thread-that-accesses-one-via-its-get-or-set-method-has-its-own-independently-initialized-copy-of-the-variable-ThreadLocal-instances-are-typically-private-static-fields-in-classes-that-wish-to-associate-state-with-a-thread-e-g-a-user-ID-or-Transaction-ID\"><a href=\"#This-class-provides-thread-local-variables-These-variables-differ-from-their-normal-counterparts-in-that-each-thread-that-accesses-one-via-its-get-or-set-method-has-its-own-independently-initialized-copy-of-the-variable-ThreadLocal-instances-are-typically-private-static-fields-in-classes-that-wish-to-associate-state-with-a-thread-e-g-a-user-ID-or-Transaction-ID\" class=\"headerlink\" title=\"This class provides thread-local variables.  These variables differ from their normal counterparts in that each thread that accesses one (via its get or set method) has its own, independently initialized copy of the variable.  ThreadLocal instances are typically private static fields in classes that wish to associate state with a thread (e.g., a user ID or Transaction ID).\"></a>This class provides thread-local variables.  These variables differ from their normal counterparts in that each thread that accesses one (via its <tt>get</tt> or <tt>set</tt> method) has its own, independently initialized copy of the variable.  <tt>ThreadLocal</tt> instances are typically private static fields in classes that wish to associate state with a thread (e.g., a user ID or Transaction ID).</h5><a id=\"more\"></a>\n<h3 id=\"这是ThreadLocal源码中一段介绍，翻译过来的大概意思是：\"><a href=\"#这是ThreadLocal源码中一段介绍，翻译过来的大概意思是：\" class=\"headerlink\" title=\"这是ThreadLocal源码中一段介绍，翻译过来的大概意思是：\"></a>这是ThreadLocal源码中一段介绍，翻译过来的大概意思是：</h3><h5 id=\"ThreadLocal类用来提供线程内部的局部变量。这种变量在多线程环境下访问-通过get或set方法访问-时能保证各个线程里的变量相对独立于其他线程内的变量。ThreadLocal实例通常来说都是private-static类型的，用于关联线程和线程的上下文。\"><a href=\"#ThreadLocal类用来提供线程内部的局部变量。这种变量在多线程环境下访问-通过get或set方法访问-时能保证各个线程里的变量相对独立于其他线程内的变量。ThreadLocal实例通常来说都是private-static类型的，用于关联线程和线程的上下文。\" class=\"headerlink\" title=\"ThreadLocal类用来提供线程内部的局部变量。这种变量在多线程环境下访问(通过get或set方法访问)时能保证各个线程里的变量相对独立于其他线程内的变量。ThreadLocal实例通常来说都是private static类型的，用于关联线程和线程的上下文。\"></a>ThreadLocal类用来提供线程内部的局部变量。这种变量在多线程环境下访问(通过get或set方法访问)时能保证各个线程里的变量相对独立于其他线程内的变量。ThreadLocal实例通常来说都是private static类型的，用于关联线程和线程的上下文。</h5><h5 id=\"这种解释和网络上所说的解决多线程的并发问题不太一样，当你把一个变量复制成了多份，我觉得这种方式并不叫解决多线程访问资源时的共享问题。本质上来说资源已经变成了多份，没有共享之说，当然这也是一种解决方式，但是如果资源不必线程共享，又何必要用ThreadLocal去实现呢。\"><a href=\"#这种解释和网络上所说的解决多线程的并发问题不太一样，当你把一个变量复制成了多份，我觉得这种方式并不叫解决多线程访问资源时的共享问题。本质上来说资源已经变成了多份，没有共享之说，当然这也是一种解决方式，但是如果资源不必线程共享，又何必要用ThreadLocal去实现呢。\" class=\"headerlink\" title=\"这种解释和网络上所说的解决多线程的并发问题不太一样，当你把一个变量复制成了多份，我觉得这种方式并不叫解决多线程访问资源时的共享问题。本质上来说资源已经变成了多份，没有共享之说，当然这也是一种解决方式，但是如果资源不必线程共享，又何必要用ThreadLocal去实现呢。\"></a>这种解释和网络上所说的解决多线程的并发问题不太一样，当你把一个变量复制成了多份，我觉得这种方式并不叫解决多线程访问资源时的共享问题。本质上来说资源已经变成了多份，没有共享之说，当然这也是一种解决方式，但是如果资源不必线程共享，又何必要用ThreadLocal去实现呢。</h5><h4 id=\"总结来说：ThreadLocal的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。\"><a href=\"#总结来说：ThreadLocal的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。\" class=\"headerlink\" title=\"总结来说：ThreadLocal的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。\"></a>总结来说：ThreadLocal的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。</h4><h5 id=\"举一个例子，一个请求需要按照1、2、3这个顺序执行3个函数。但是其中有一个参数是需要函数1提供给函数3使用的，但是这个参数对于函数2来说并没有作用（实际情况可能比这要复杂的多）。同时我们又不希望污染函数2，那么如何将该参数通过函数1传递到函数3呢？ThreadLocal是一个比较合理的解决方法。\"><a href=\"#举一个例子，一个请求需要按照1、2、3这个顺序执行3个函数。但是其中有一个参数是需要函数1提供给函数3使用的，但是这个参数对于函数2来说并没有作用（实际情况可能比这要复杂的多）。同时我们又不希望污染函数2，那么如何将该参数通过函数1传递到函数3呢？ThreadLocal是一个比较合理的解决方法。\" class=\"headerlink\" title=\"举一个例子，一个请求需要按照1、2、3这个顺序执行3个函数。但是其中有一个参数是需要函数1提供给函数3使用的，但是这个参数对于函数2来说并没有作用（实际情况可能比这要复杂的多）。同时我们又不希望污染函数2，那么如何将该参数通过函数1传递到函数3呢？ThreadLocal是一个比较合理的解决方法。\"></a>举一个例子，一个请求需要按照1、2、3这个顺序执行3个函数。但是其中有一个参数是需要函数1提供给函数3使用的，但是这个参数对于函数2来说并没有作用（实际情况可能比这要复杂的多）。同时我们又不希望污染函数2，那么如何将该参数通过函数1传递到函数3呢？ThreadLocal是一个比较合理的解决方法。</h5><h2 id=\"ThreadLocal代码演示\"><a href=\"#ThreadLocal代码演示\" class=\"headerlink\" title=\"ThreadLocal代码演示\"></a>ThreadLocal代码演示</h2><pre><code class=\"lang-JAVA\">/**\n * Created BY wangwenxiang on 2017/3/15.\n */\npublic class ThreadLocalTest {\n    private static ThreadLocal&lt;Integer&gt; integerThreadLocal = new ThreadLocal&lt;Integer&gt;();\n\n    /**\n     * 初始化并输出每个线程的ThreadLocal\n     * Runnable\n     * name\n     */\n    private static Thread[] initThread(){\n        Thread[] threads = new Thread[10];\n        for (int i=0;i&lt;10;i++){\n            final int finalI = i;\n            threads[i] = new Thread(new Runnable() {\n                public void run() {\n                    integerThreadLocal.set(finalI);\n                    System.out.println(Thread.currentThread().getName()+&quot;: &quot;+integerThreadLocal.get());\n                }\n            },&quot;thread-&quot; + i);\n        }\n        return threads;\n    }\n\n\n    public static void main(String[] args) {\n        Thread[] threads = initThread();\n        for (Thread thread : threads){\n            thread.start();\n        }\n    }\n}\n</code></pre>\n<h5 id=\"ThreadLocal的操作非常简单，基本上没有太多的过程。\"><a href=\"#ThreadLocal的操作非常简单，基本上没有太多的过程。\" class=\"headerlink\" title=\"ThreadLocal的操作非常简单，基本上没有太多的过程。\"></a>ThreadLocal的操作非常简单，基本上没有太多的过程。</h5><h5 id=\"执行结果：\"><a href=\"#执行结果：\" class=\"headerlink\" title=\"执行结果：\"></a>执行结果：</h5><pre><code>thread-0: 0\nthread-1: 1\nthread-2: 2\nthread-3: 3\nthread-4: 4\nthread-5: 5\nthread-6: 6\nthread-7: 7\nthread-8: 8\nthread-9: 9\n</code></pre><h5 id=\"可以看出虽然只创建了一个ThreadLocal对象，但是每个线程的初始化之后，得出来的结果并不一样。各个线程之间的值是相互独立的。\"><a href=\"#可以看出虽然只创建了一个ThreadLocal对象，但是每个线程的初始化之后，得出来的结果并不一样。各个线程之间的值是相互独立的。\" class=\"headerlink\" title=\"可以看出虽然只创建了一个ThreadLocal对象，但是每个线程的初始化之后，得出来的结果并不一样。各个线程之间的值是相互独立的。\"></a>可以看出虽然只创建了一个ThreadLocal对象，但是每个线程的初始化之后，得出来的结果并不一样。各个线程之间的值是相互独立的。</h5><h2 id=\"ThreadLocal源码\"><a href=\"#ThreadLocal源码\" class=\"headerlink\" title=\"ThreadLocal源码\"></a>ThreadLocal源码</h2><h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><pre><code class=\"lang-java\">/**\n * Creates a thread local variable.\n */\npublic ThreadLocal() {\n}\n</code></pre>\n<h5 id=\"这是ThreadLocal唯一的构造函数，什么也没做\"><a href=\"#这是ThreadLocal唯一的构造函数，什么也没做\" class=\"headerlink\" title=\"这是ThreadLocal唯一的构造函数，什么也没做\"></a>这是ThreadLocal唯一的构造函数，什么也没做</h5><h3 id=\"set方法\"><a href=\"#set方法\" class=\"headerlink\" title=\"set方法\"></a>set方法</h3><pre><code class=\"lang-JAVA\">/**\n * Sets the current thread&#39;s copy of this thread-local variable\n * to the specified value.  Most subclasses will have no need to\n * override this method, relying solely on the {@link #initialValue}\n * method to set the values of thread-locals.\n *\n * @param value the value to be stored in the current thread&#39;s copy of\n *        this thread-local.\n */\npublic void set(T value) {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null)\n            map.set(this, value);\n        else\n            createMap(t, value);\n    }\n</code></pre>\n<h5 id=\"代码比较简单\"><a href=\"#代码比较简单\" class=\"headerlink\" title=\"代码比较简单\"></a>代码比较简单</h5><ol>\n<li>获取当前线程 <code>Thread t = Thread.currentThread();</code></li>\n<li>获取当前线程的ThreadLocalMap，使得每个线程的本地数据相互隔离的原因也在于这里，因为每个线程都有自己的ThreadLocalMap；</li>\n<li>判断ThreadLocalMap是否为空，直接插入或者创建map并插入；</li>\n</ol>\n<h4 id=\"ThreadLocalMap的set方法\"><a href=\"#ThreadLocalMap的set方法\" class=\"headerlink\" title=\"ThreadLocalMap的set方法\"></a>ThreadLocalMap的set方法</h4><pre><code class=\"lang-JAVA\">/**\n * Set the value associated with key.\n * @param value the value to be set\n *\n * @param key the thread local object\n */\nprivate void set(ThreadLocal key, Object value) {\n\n    // We don&#39;t use a fast path as with get() because it is at\n    // least as common to use set() to create new entries as\n    // it is to replace existing ones, in which case, a fast\n    // path would fail more often than not.\n\n    Entry[] tab = table;\n    int len = tab.length;\n    int i = key.threadLocalHashCode &amp; (len-1);\n\n    for (Entry e = tab[i];\n         e != null;\n         e = tab[i = nextIndex(i, len)]) {\n        ThreadLocal k = e.get();\n\n        if (k == key) {\n            e.value = value;\n            return;\n        }\n\n        if (k == null) {\n            replaceStaleEntry(key, value, i);\n            return;\n        }\n    }\n\n    tab[i] = new Entry(key, value);\n    int sz = ++size;\n    if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)\n        rehash();\n}\n</code></pre>\n<h5 id=\"map的key和value分别对应的是ThreadLocal本身和往ThreadLocal中set的值。\"><a href=\"#map的key和value分别对应的是ThreadLocal本身和往ThreadLocal中set的值。\" class=\"headerlink\" title=\"map的key和value分别对应的是ThreadLocal本身和往ThreadLocal中set的值。\"></a>map的key和value分别对应的是ThreadLocal本身和往ThreadLocal中set的值。</h5><ol>\n<li>首先根据ThreadLocal元素的hashCode计算出其数组下标；由于数组的长度用于等于2<sup>n</sup>个，所以下表的取值范围在0到2<sup>n</sup>-1；</li>\n<li>for循环，从数组位置i开始以步长1向后循环遍历，直到找到一个空位，每次循环将该位置的值赋值给e；</li>\n<li>当数组位置不为空时执行方法体：<ol>\n<li>获得该数组位置的ThreadLocal，判断是否与当前ThreadLocal相等，如果相等，则将value更新，set方法结束；</li>\n<li>如果该ThreadLocal为空，则替换，然后结束方法。</li>\n</ol>\n</li>\n<li>在位置i插入新值，计数加1</li>\n</ol>\n<h3 id=\"get方法\"><a href=\"#get方法\" class=\"headerlink\" title=\"get方法\"></a>get方法</h3><pre><code class=\"lang-JAVA\">/**\n  * Returns the value in the current thread&#39;s copy of this\n  * thread-local variable.  If the variable has no value for the\n  * current thread, it is first initialized to the value returned\n  * by an invocation of the {@link #initialValue} method.\n  *\n  * @return the current thread&#39;s value of this thread-local\n  */\npublic T get() {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null) {\n            ThreadLocalMap.Entry e = map.getEntry(this);\n            if (e != null)\n                return (T)e.value;\n        }\n        return setInitialValue();\n    }\n</code></pre>\n<h5 id=\"get方法和set方法比较类似，首先获取当前线程，并获取线程的ThreadLocalMap，以当前的ThreadLocal作为key在map中获取value，判断value是否为null，如果为null，则将当前的ThreadLocal中设置初始值，并返回改值。\"><a href=\"#get方法和set方法比较类似，首先获取当前线程，并获取线程的ThreadLocalMap，以当前的ThreadLocal作为key在map中获取value，判断value是否为null，如果为null，则将当前的ThreadLocal中设置初始值，并返回改值。\" class=\"headerlink\" title=\"get方法和set方法比较类似，首先获取当前线程，并获取线程的ThreadLocalMap，以当前的ThreadLocal作为key在map中获取value，判断value是否为null，如果为null，则将当前的ThreadLocal中设置初始值，并返回改值。\"></a>get方法和set方法比较类似，首先获取当前线程，并获取线程的ThreadLocalMap，以当前的ThreadLocal作为key在map中获取value，判断value是否为null，如果为null，则将当前的ThreadLocal中设置初始值，并返回改值。</h5><h4 id=\"setInitialValue\"><a href=\"#setInitialValue\" class=\"headerlink\" title=\"setInitialValue()\"></a>setInitialValue()</h4><pre><code class=\"lang-JAVA\">/**\n * Variant of set() to establish initialValue. Used instead\n * of set() in case user has overridden the set() method.\n *\n * @return the initial value\n */\nprivate T setInitialValue() {\n    T value = initialValue();\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n    if (map != null)\n        map.set(this, value);\n    else\n        createMap(t, value);\n    return value;\n}\n</code></pre>\n<h5 id=\"该方法和set方法基本一样\"><a href=\"#该方法和set方法基本一样\" class=\"headerlink\" title=\"该方法和set方法基本一样\"></a>该方法和set方法基本一样</h5><h4 id=\"initialValue\"><a href=\"#initialValue\" class=\"headerlink\" title=\"initialValue()\"></a>initialValue()</h4><pre><code class=\"lang-JAVA\">/**\n * Returns the current thread&#39;s &quot;initial value&quot; for this\n * thread-local variable.  This method will be invoked the first\n * time a thread accesses the variable with the {@link #get}\n * method, unless the thread previously invoked the {@link #set}\n * method, in which case the &lt;tt&gt;initialValue&lt;/tt&gt; method will not\n * be invoked for the thread.  Normally, this method is invoked at\n * most once per thread, but it may be invoked again in case of\n * subsequent invocations of {@link #remove} followed by {@link #get}.\n *\n * &lt;p&gt;This implementation simply returns &lt;tt&gt;null&lt;/tt&gt;; if the\n * programmer desires thread-local variables to have an initial\n * value other than &lt;tt&gt;null&lt;/tt&gt;, &lt;tt&gt;ThreadLocal&lt;/tt&gt; must be\n * subclassed, and this method overridden.  Typically, an\n * anonymous inner class will be used.\n *\n * @return the initial value for this thread-local\n */\n protected T initialValue() {\n     return null;\n }\n</code></pre>\n<h5 id=\"该方法只在get方法中被调用，当ThreadLocal中没有设置value时。默认返回null，protected的访问权限表示该方法支持被覆盖。\"><a href=\"#该方法只在get方法中被调用，当ThreadLocal中没有设置value时。默认返回null，protected的访问权限表示该方法支持被覆盖。\" class=\"headerlink\" title=\"该方法只在get方法中被调用，当ThreadLocal中没有设置value时。默认返回null，protected的访问权限表示该方法支持被覆盖。\"></a>该方法只在get方法中被调用，当ThreadLocal中没有设置value时。默认返回null，protected的访问权限表示该方法支持被覆盖。</h5><h3 id=\"ThreadLocalMap\"><a href=\"#ThreadLocalMap\" class=\"headerlink\" title=\"ThreadLocalMap\"></a>ThreadLocalMap</h3><h5 id=\"ThreadLocalMap是使用ThreadLocal的弱引用作为Key的\"><a href=\"#ThreadLocalMap是使用ThreadLocal的弱引用作为Key的\" class=\"headerlink\" title=\"ThreadLocalMap是使用ThreadLocal的弱引用作为Key的\"></a>ThreadLocalMap是使用ThreadLocal的弱引用作为Key的</h5><pre><code class=\"lang-JAVA\">static class ThreadLocalMap {\n        /**\n         * The entries in this hash map extend WeakReference, using\n         * its main ref field as the key (which is always a\n         * ThreadLocal object).  Note that null keys (i.e. entry.get()\n         * == null) mean that the key is no longer referenced, so the\n         * entry can be expunged from table.  Such entries are referred to\n         * as &quot;stale entries&quot; in the code that follows.\n         */\n        static class Entry extends WeakReference&lt;ThreadLocal&gt; {\n            /** The value associated with this ThreadLocal. */\n            Object value;\n\n            Entry(ThreadLocal k, Object v) {\n                super(k);\n                value = v;\n            }\n        }\n        ...\n        ...\n}\n</code></pre>\n<h5 id=\"下图是本文介绍到的一些对象之间的引用关系图，实线表示强引用，虚线表示弱引用：\"><a href=\"#下图是本文介绍到的一些对象之间的引用关系图，实线表示强引用，虚线表示弱引用：\" class=\"headerlink\" title=\"下图是本文介绍到的一些对象之间的引用关系图，实线表示强引用，虚线表示弱引用：\"></a>下图是本文介绍到的一些对象之间的引用关系图，实线表示强引用，虚线表示弱引用：</h5><p><img src=\"/img/note/ThreadLocal.png\" alt=\"ThreadLocal\"> <div class=\"img-note\">ThreadLocal对象引用</div></p>\n<h5 id=\"如上图，ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用引用他，那么系统gc的时候，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：\"><a href=\"#如上图，ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用引用他，那么系统gc的时候，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：\" class=\"headerlink\" title=\"如上图，ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用引用他，那么系统gc的时候，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：\"></a>如上图，ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用引用他，那么系统gc的时候，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：</h5><h4 id=\"Thread-Ref-gt-Thread-gt-ThreaLocalMap-gt-Entry-gt-value\"><a href=\"#Thread-Ref-gt-Thread-gt-ThreaLocalMap-gt-Entry-gt-value\" class=\"headerlink\" title=\"Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value\"></a>Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value</h4><h5 id=\"永远无法回收，造成内存泄露。\"><a href=\"#永远无法回收，造成内存泄露。\" class=\"headerlink\" title=\"永远无法回收，造成内存泄露。\"></a>永远无法回收，造成内存泄露。</h5><h5 id=\"其实，在JDK的ThreadLocalMap的设计中已经考虑到这种情况，也加上了一些防护措施，下面是ThreadLocalMap的getEntry方法的源码：\"><a href=\"#其实，在JDK的ThreadLocalMap的设计中已经考虑到这种情况，也加上了一些防护措施，下面是ThreadLocalMap的getEntry方法的源码：\" class=\"headerlink\" title=\"其实，在JDK的ThreadLocalMap的设计中已经考虑到这种情况，也加上了一些防护措施，下面是ThreadLocalMap的getEntry方法的源码：\"></a>其实，在JDK的ThreadLocalMap的设计中已经考虑到这种情况，也加上了一些防护措施，下面是ThreadLocalMap的<code>getEntry</code>方法的源码：</h5><pre><code class=\"lang-JAVA\">private Entry getEntry(ThreadLocal key) {\n    int i = key.threadLocalHashCode &amp; (table.length - 1);\n    Entry e = table[i];\n    if (e != null &amp;&amp; e.get() == key)\n        return e;\n    else\n        return getEntryAfterMiss(key, i, e);\n}\n</code></pre>\n<h4 id=\"当Entry为null时，getEntryAfterMiss方法\"><a href=\"#当Entry为null时，getEntryAfterMiss方法\" class=\"headerlink\" title=\"当Entry为null时，getEntryAfterMiss方法\"></a>当Entry为null时，getEntryAfterMiss方法</h4><pre><code class=\"lang-java\">private Entry getEntryAfterMiss(ThreadLocal key, int i, Entry e) {\n    Entry[] tab = table;\n    int len = tab.length;\n    while (e != null) {\n        ThreadLocal k = e.get();\n        if (k == key)\n            return e;\n        if (k == null)\n            expungeStaleEntry(i);\n        else\n            i = nextIndex(i, len);\n        e = tab[i];\n    }\n    return null;\n}\n</code></pre>\n<h4 id=\"expungeStaleEntry函数的源码：\"><a href=\"#expungeStaleEntry函数的源码：\" class=\"headerlink\" title=\"expungeStaleEntry函数的源码：\"></a><code>expungeStaleEntry</code>函数的源码：</h4><pre><code class=\"lang-java\">private int expungeStaleEntry(int staleSlot) {\n    Entry[] tab = table;\n    int len = tab.length;\n\n    // expunge entry at staleSlot\n    tab[staleSlot].value = null;\n    tab[staleSlot] = null;\n    size--;\n\n    // Rehash until we encounter null\n    Entry e;\n    int i;\n    for (i = nextIndex(staleSlot, len);\n         (e = tab[i]) != null;\n         i = nextIndex(i, len)) {\n        ThreadLocal k = e.get();\n        if (k == null) {\n            e.value = null;\n            tab[i] = null;\n            size--;\n        } else {\n            int h = k.threadLocalHashCode &amp; (len - 1);\n            if (h != i) {\n                tab[i] = null;\n\n                // Unlike Knuth 6.4 Algorithm R, we must scan until\n                // null because multiple entries could have been stale.\n                while (tab[h] != null)\n                    h = nextIndex(h, len);\n                tab[h] = e;\n            }\n        }\n    }\n    return i;\n}\n</code></pre>\n<h5 id=\"整理一下ThreadLocalMap的getEntry函数的流程：\"><a href=\"#整理一下ThreadLocalMap的getEntry函数的流程：\" class=\"headerlink\" title=\"整理一下ThreadLocalMap的getEntry函数的流程：\"></a>整理一下ThreadLocalMap的<code>getEntry</code>函数的流程：</h5><ol>\n<li>首先从ThreadLocal的直接索引位置(通过ThreadLocal.threadLocalHashCode &amp; (len-1)运算得到)获取Entry e，如果e不为null并且key相同则返回e；</li>\n<li>如果e为null或者key不一致则向下一个位置查询，如果下一个位置的key和当前需要查询的key相等，则返回对应的Entry，否则，如果key值为null，则擦除该位置的Entry，否则继续向下一个位置查询</li>\n</ol>\n<h5 id=\"在这个过程中遇到的key为null的Entry都会被擦除，那么Entry内的value也就没有强引用链，自然会被回收。仔细研究代码可以发现，set操作也有类似的思想，将key为null的这些Entry都删除，防止内存泄露。\"><a href=\"#在这个过程中遇到的key为null的Entry都会被擦除，那么Entry内的value也就没有强引用链，自然会被回收。仔细研究代码可以发现，set操作也有类似的思想，将key为null的这些Entry都删除，防止内存泄露。\" class=\"headerlink\" title=\"在这个过程中遇到的key为null的Entry都会被擦除，那么Entry内的value也就没有强引用链，自然会被回收。仔细研究代码可以发现，set操作也有类似的思想，将key为null的这些Entry都删除，防止内存泄露。\"></a>在这个过程中遇到的key为null的Entry都会被擦除，那么Entry内的value也就没有强引用链，自然会被回收。仔细研究代码可以发现，<code>set</code>操作也有类似的思想，将key为null的这些Entry都删除，防止内存泄露。</h5><h5 id=\"但是光这样还是不够的，上面的设计思路依赖一个前提条件：-要调用ThreadLocalMap的getEntry函数或者set函数。-这当然是不可能任何情况都成立的，所以很多情况下需要使用者手动调用ThreadLocal的remove函数，手动删除不再需要的ThreadLocal，防止内存泄露。所以JDK建议将ThreadLocal变量定义成private-static的，这样的话ThreadLocal的生命周期就更长，由于一直存在ThreadLocal的强引用，所以ThreadLocal也就不会被回收，也就能保证任何时候都能根据ThreadLocal的弱引用访问到Entry的value值，然后remove它，防止内存泄露。\"><a href=\"#但是光这样还是不够的，上面的设计思路依赖一个前提条件：-要调用ThreadLocalMap的getEntry函数或者set函数。-这当然是不可能任何情况都成立的，所以很多情况下需要使用者手动调用ThreadLocal的remove函数，手动删除不再需要的ThreadLocal，防止内存泄露。所以JDK建议将ThreadLocal变量定义成private-static的，这样的话ThreadLocal的生命周期就更长，由于一直存在ThreadLocal的强引用，所以ThreadLocal也就不会被回收，也就能保证任何时候都能根据ThreadLocal的弱引用访问到Entry的value值，然后remove它，防止内存泄露。\" class=\"headerlink\" title=\"但是光这样还是不够的，上面的设计思路依赖一个前提条件： 要调用ThreadLocalMap的getEntry函数或者set函数。 这当然是不可能任何情况都成立的，所以很多情况下需要使用者手动调用ThreadLocal的remove函数，手动删除不再需要的ThreadLocal，防止内存泄露。所以JDK建议将ThreadLocal变量定义成private static的，这样的话ThreadLocal的生命周期就更长，由于一直存在ThreadLocal的强引用，所以ThreadLocal也就不会被回收，也就能保证任何时候都能根据ThreadLocal的弱引用访问到Entry的value值，然后remove它，防止内存泄露。\"></a>但是光这样还是不够的，上面的设计思路依赖一个前提条件： 要调用ThreadLocalMap的<code>getEntry</code>函数或者<code>set</code>函数。 这当然是不可能任何情况都成立的，所以很多情况下需要使用者手动调用ThreadLocal的<code>remove</code>函数，手动删除不再需要的ThreadLocal，防止内存泄露。所以JDK建议将ThreadLocal变量定义成<code>private static</code>的，这样的话ThreadLocal的生命周期就更长，由于一直存在ThreadLocal的强引用，所以ThreadLocal也就不会被回收，也就能保证任何时候都能根据ThreadLocal的弱引用访问到Entry的value值，然后remove它，防止内存泄露。</h5>","site":{"data":{}},"excerpt":"<h2 id=\"ThreadLocal是什么\"><a href=\"#ThreadLocal是什么\" class=\"headerlink\" title=\"ThreadLocal是什么\"></a>ThreadLocal是什么</h2><h5 id=\"This-class-provides-thread-local-variables-These-variables-differ-from-their-normal-counterparts-in-that-each-thread-that-accesses-one-via-its-get-or-set-method-has-its-own-independently-initialized-copy-of-the-variable-ThreadLocal-instances-are-typically-private-static-fields-in-classes-that-wish-to-associate-state-with-a-thread-e-g-a-user-ID-or-Transaction-ID\"><a href=\"#This-class-provides-thread-local-variables-These-variables-differ-from-their-normal-counterparts-in-that-each-thread-that-accesses-one-via-its-get-or-set-method-has-its-own-independently-initialized-copy-of-the-variable-ThreadLocal-instances-are-typically-private-static-fields-in-classes-that-wish-to-associate-state-with-a-thread-e-g-a-user-ID-or-Transaction-ID\" class=\"headerlink\" title=\"This class provides thread-local variables.  These variables differ from their normal counterparts in that each thread that accesses one (via its get or set method) has its own, independently initialized copy of the variable.  ThreadLocal instances are typically private static fields in classes that wish to associate state with a thread (e.g., a user ID or Transaction ID).\"></a>This class provides thread-local variables.  These variables differ from their normal counterparts in that each thread that accesses one (via its <tt>get</tt> or <tt>set</tt> method) has its own, independently initialized copy of the variable.  <tt>ThreadLocal</tt> instances are typically private static fields in classes that wish to associate state with a thread (e.g., a user ID or Transaction ID).</h5>","more":"<h3 id=\"这是ThreadLocal源码中一段介绍，翻译过来的大概意思是：\"><a href=\"#这是ThreadLocal源码中一段介绍，翻译过来的大概意思是：\" class=\"headerlink\" title=\"这是ThreadLocal源码中一段介绍，翻译过来的大概意思是：\"></a>这是ThreadLocal源码中一段介绍，翻译过来的大概意思是：</h3><h5 id=\"ThreadLocal类用来提供线程内部的局部变量。这种变量在多线程环境下访问-通过get或set方法访问-时能保证各个线程里的变量相对独立于其他线程内的变量。ThreadLocal实例通常来说都是private-static类型的，用于关联线程和线程的上下文。\"><a href=\"#ThreadLocal类用来提供线程内部的局部变量。这种变量在多线程环境下访问-通过get或set方法访问-时能保证各个线程里的变量相对独立于其他线程内的变量。ThreadLocal实例通常来说都是private-static类型的，用于关联线程和线程的上下文。\" class=\"headerlink\" title=\"ThreadLocal类用来提供线程内部的局部变量。这种变量在多线程环境下访问(通过get或set方法访问)时能保证各个线程里的变量相对独立于其他线程内的变量。ThreadLocal实例通常来说都是private static类型的，用于关联线程和线程的上下文。\"></a>ThreadLocal类用来提供线程内部的局部变量。这种变量在多线程环境下访问(通过get或set方法访问)时能保证各个线程里的变量相对独立于其他线程内的变量。ThreadLocal实例通常来说都是private static类型的，用于关联线程和线程的上下文。</h5><h5 id=\"这种解释和网络上所说的解决多线程的并发问题不太一样，当你把一个变量复制成了多份，我觉得这种方式并不叫解决多线程访问资源时的共享问题。本质上来说资源已经变成了多份，没有共享之说，当然这也是一种解决方式，但是如果资源不必线程共享，又何必要用ThreadLocal去实现呢。\"><a href=\"#这种解释和网络上所说的解决多线程的并发问题不太一样，当你把一个变量复制成了多份，我觉得这种方式并不叫解决多线程访问资源时的共享问题。本质上来说资源已经变成了多份，没有共享之说，当然这也是一种解决方式，但是如果资源不必线程共享，又何必要用ThreadLocal去实现呢。\" class=\"headerlink\" title=\"这种解释和网络上所说的解决多线程的并发问题不太一样，当你把一个变量复制成了多份，我觉得这种方式并不叫解决多线程访问资源时的共享问题。本质上来说资源已经变成了多份，没有共享之说，当然这也是一种解决方式，但是如果资源不必线程共享，又何必要用ThreadLocal去实现呢。\"></a>这种解释和网络上所说的解决多线程的并发问题不太一样，当你把一个变量复制成了多份，我觉得这种方式并不叫解决多线程访问资源时的共享问题。本质上来说资源已经变成了多份，没有共享之说，当然这也是一种解决方式，但是如果资源不必线程共享，又何必要用ThreadLocal去实现呢。</h5><h4 id=\"总结来说：ThreadLocal的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。\"><a href=\"#总结来说：ThreadLocal的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。\" class=\"headerlink\" title=\"总结来说：ThreadLocal的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。\"></a>总结来说：ThreadLocal的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。</h4><h5 id=\"举一个例子，一个请求需要按照1、2、3这个顺序执行3个函数。但是其中有一个参数是需要函数1提供给函数3使用的，但是这个参数对于函数2来说并没有作用（实际情况可能比这要复杂的多）。同时我们又不希望污染函数2，那么如何将该参数通过函数1传递到函数3呢？ThreadLocal是一个比较合理的解决方法。\"><a href=\"#举一个例子，一个请求需要按照1、2、3这个顺序执行3个函数。但是其中有一个参数是需要函数1提供给函数3使用的，但是这个参数对于函数2来说并没有作用（实际情况可能比这要复杂的多）。同时我们又不希望污染函数2，那么如何将该参数通过函数1传递到函数3呢？ThreadLocal是一个比较合理的解决方法。\" class=\"headerlink\" title=\"举一个例子，一个请求需要按照1、2、3这个顺序执行3个函数。但是其中有一个参数是需要函数1提供给函数3使用的，但是这个参数对于函数2来说并没有作用（实际情况可能比这要复杂的多）。同时我们又不希望污染函数2，那么如何将该参数通过函数1传递到函数3呢？ThreadLocal是一个比较合理的解决方法。\"></a>举一个例子，一个请求需要按照1、2、3这个顺序执行3个函数。但是其中有一个参数是需要函数1提供给函数3使用的，但是这个参数对于函数2来说并没有作用（实际情况可能比这要复杂的多）。同时我们又不希望污染函数2，那么如何将该参数通过函数1传递到函数3呢？ThreadLocal是一个比较合理的解决方法。</h5><h2 id=\"ThreadLocal代码演示\"><a href=\"#ThreadLocal代码演示\" class=\"headerlink\" title=\"ThreadLocal代码演示\"></a>ThreadLocal代码演示</h2><pre><code class=\"lang-JAVA\">/**\n * Created BY wangwenxiang on 2017/3/15.\n */\npublic class ThreadLocalTest {\n    private static ThreadLocal&lt;Integer&gt; integerThreadLocal = new ThreadLocal&lt;Integer&gt;();\n\n    /**\n     * 初始化并输出每个线程的ThreadLocal\n     * Runnable\n     * name\n     */\n    private static Thread[] initThread(){\n        Thread[] threads = new Thread[10];\n        for (int i=0;i&lt;10;i++){\n            final int finalI = i;\n            threads[i] = new Thread(new Runnable() {\n                public void run() {\n                    integerThreadLocal.set(finalI);\n                    System.out.println(Thread.currentThread().getName()+&quot;: &quot;+integerThreadLocal.get());\n                }\n            },&quot;thread-&quot; + i);\n        }\n        return threads;\n    }\n\n\n    public static void main(String[] args) {\n        Thread[] threads = initThread();\n        for (Thread thread : threads){\n            thread.start();\n        }\n    }\n}\n</code></pre>\n<h5 id=\"ThreadLocal的操作非常简单，基本上没有太多的过程。\"><a href=\"#ThreadLocal的操作非常简单，基本上没有太多的过程。\" class=\"headerlink\" title=\"ThreadLocal的操作非常简单，基本上没有太多的过程。\"></a>ThreadLocal的操作非常简单，基本上没有太多的过程。</h5><h5 id=\"执行结果：\"><a href=\"#执行结果：\" class=\"headerlink\" title=\"执行结果：\"></a>执行结果：</h5><pre><code>thread-0: 0\nthread-1: 1\nthread-2: 2\nthread-3: 3\nthread-4: 4\nthread-5: 5\nthread-6: 6\nthread-7: 7\nthread-8: 8\nthread-9: 9\n</code></pre><h5 id=\"可以看出虽然只创建了一个ThreadLocal对象，但是每个线程的初始化之后，得出来的结果并不一样。各个线程之间的值是相互独立的。\"><a href=\"#可以看出虽然只创建了一个ThreadLocal对象，但是每个线程的初始化之后，得出来的结果并不一样。各个线程之间的值是相互独立的。\" class=\"headerlink\" title=\"可以看出虽然只创建了一个ThreadLocal对象，但是每个线程的初始化之后，得出来的结果并不一样。各个线程之间的值是相互独立的。\"></a>可以看出虽然只创建了一个ThreadLocal对象，但是每个线程的初始化之后，得出来的结果并不一样。各个线程之间的值是相互独立的。</h5><h2 id=\"ThreadLocal源码\"><a href=\"#ThreadLocal源码\" class=\"headerlink\" title=\"ThreadLocal源码\"></a>ThreadLocal源码</h2><h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><pre><code class=\"lang-java\">/**\n * Creates a thread local variable.\n */\npublic ThreadLocal() {\n}\n</code></pre>\n<h5 id=\"这是ThreadLocal唯一的构造函数，什么也没做\"><a href=\"#这是ThreadLocal唯一的构造函数，什么也没做\" class=\"headerlink\" title=\"这是ThreadLocal唯一的构造函数，什么也没做\"></a>这是ThreadLocal唯一的构造函数，什么也没做</h5><h3 id=\"set方法\"><a href=\"#set方法\" class=\"headerlink\" title=\"set方法\"></a>set方法</h3><pre><code class=\"lang-JAVA\">/**\n * Sets the current thread&#39;s copy of this thread-local variable\n * to the specified value.  Most subclasses will have no need to\n * override this method, relying solely on the {@link #initialValue}\n * method to set the values of thread-locals.\n *\n * @param value the value to be stored in the current thread&#39;s copy of\n *        this thread-local.\n */\npublic void set(T value) {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null)\n            map.set(this, value);\n        else\n            createMap(t, value);\n    }\n</code></pre>\n<h5 id=\"代码比较简单\"><a href=\"#代码比较简单\" class=\"headerlink\" title=\"代码比较简单\"></a>代码比较简单</h5><ol>\n<li>获取当前线程 <code>Thread t = Thread.currentThread();</code></li>\n<li>获取当前线程的ThreadLocalMap，使得每个线程的本地数据相互隔离的原因也在于这里，因为每个线程都有自己的ThreadLocalMap；</li>\n<li>判断ThreadLocalMap是否为空，直接插入或者创建map并插入；</li>\n</ol>\n<h4 id=\"ThreadLocalMap的set方法\"><a href=\"#ThreadLocalMap的set方法\" class=\"headerlink\" title=\"ThreadLocalMap的set方法\"></a>ThreadLocalMap的set方法</h4><pre><code class=\"lang-JAVA\">/**\n * Set the value associated with key.\n * @param value the value to be set\n *\n * @param key the thread local object\n */\nprivate void set(ThreadLocal key, Object value) {\n\n    // We don&#39;t use a fast path as with get() because it is at\n    // least as common to use set() to create new entries as\n    // it is to replace existing ones, in which case, a fast\n    // path would fail more often than not.\n\n    Entry[] tab = table;\n    int len = tab.length;\n    int i = key.threadLocalHashCode &amp; (len-1);\n\n    for (Entry e = tab[i];\n         e != null;\n         e = tab[i = nextIndex(i, len)]) {\n        ThreadLocal k = e.get();\n\n        if (k == key) {\n            e.value = value;\n            return;\n        }\n\n        if (k == null) {\n            replaceStaleEntry(key, value, i);\n            return;\n        }\n    }\n\n    tab[i] = new Entry(key, value);\n    int sz = ++size;\n    if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)\n        rehash();\n}\n</code></pre>\n<h5 id=\"map的key和value分别对应的是ThreadLocal本身和往ThreadLocal中set的值。\"><a href=\"#map的key和value分别对应的是ThreadLocal本身和往ThreadLocal中set的值。\" class=\"headerlink\" title=\"map的key和value分别对应的是ThreadLocal本身和往ThreadLocal中set的值。\"></a>map的key和value分别对应的是ThreadLocal本身和往ThreadLocal中set的值。</h5><ol>\n<li>首先根据ThreadLocal元素的hashCode计算出其数组下标；由于数组的长度用于等于2<sup>n</sup>个，所以下表的取值范围在0到2<sup>n</sup>-1；</li>\n<li>for循环，从数组位置i开始以步长1向后循环遍历，直到找到一个空位，每次循环将该位置的值赋值给e；</li>\n<li>当数组位置不为空时执行方法体：<ol>\n<li>获得该数组位置的ThreadLocal，判断是否与当前ThreadLocal相等，如果相等，则将value更新，set方法结束；</li>\n<li>如果该ThreadLocal为空，则替换，然后结束方法。</li>\n</ol>\n</li>\n<li>在位置i插入新值，计数加1</li>\n</ol>\n<h3 id=\"get方法\"><a href=\"#get方法\" class=\"headerlink\" title=\"get方法\"></a>get方法</h3><pre><code class=\"lang-JAVA\">/**\n  * Returns the value in the current thread&#39;s copy of this\n  * thread-local variable.  If the variable has no value for the\n  * current thread, it is first initialized to the value returned\n  * by an invocation of the {@link #initialValue} method.\n  *\n  * @return the current thread&#39;s value of this thread-local\n  */\npublic T get() {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null) {\n            ThreadLocalMap.Entry e = map.getEntry(this);\n            if (e != null)\n                return (T)e.value;\n        }\n        return setInitialValue();\n    }\n</code></pre>\n<h5 id=\"get方法和set方法比较类似，首先获取当前线程，并获取线程的ThreadLocalMap，以当前的ThreadLocal作为key在map中获取value，判断value是否为null，如果为null，则将当前的ThreadLocal中设置初始值，并返回改值。\"><a href=\"#get方法和set方法比较类似，首先获取当前线程，并获取线程的ThreadLocalMap，以当前的ThreadLocal作为key在map中获取value，判断value是否为null，如果为null，则将当前的ThreadLocal中设置初始值，并返回改值。\" class=\"headerlink\" title=\"get方法和set方法比较类似，首先获取当前线程，并获取线程的ThreadLocalMap，以当前的ThreadLocal作为key在map中获取value，判断value是否为null，如果为null，则将当前的ThreadLocal中设置初始值，并返回改值。\"></a>get方法和set方法比较类似，首先获取当前线程，并获取线程的ThreadLocalMap，以当前的ThreadLocal作为key在map中获取value，判断value是否为null，如果为null，则将当前的ThreadLocal中设置初始值，并返回改值。</h5><h4 id=\"setInitialValue\"><a href=\"#setInitialValue\" class=\"headerlink\" title=\"setInitialValue()\"></a>setInitialValue()</h4><pre><code class=\"lang-JAVA\">/**\n * Variant of set() to establish initialValue. Used instead\n * of set() in case user has overridden the set() method.\n *\n * @return the initial value\n */\nprivate T setInitialValue() {\n    T value = initialValue();\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n    if (map != null)\n        map.set(this, value);\n    else\n        createMap(t, value);\n    return value;\n}\n</code></pre>\n<h5 id=\"该方法和set方法基本一样\"><a href=\"#该方法和set方法基本一样\" class=\"headerlink\" title=\"该方法和set方法基本一样\"></a>该方法和set方法基本一样</h5><h4 id=\"initialValue\"><a href=\"#initialValue\" class=\"headerlink\" title=\"initialValue()\"></a>initialValue()</h4><pre><code class=\"lang-JAVA\">/**\n * Returns the current thread&#39;s &quot;initial value&quot; for this\n * thread-local variable.  This method will be invoked the first\n * time a thread accesses the variable with the {@link #get}\n * method, unless the thread previously invoked the {@link #set}\n * method, in which case the &lt;tt&gt;initialValue&lt;/tt&gt; method will not\n * be invoked for the thread.  Normally, this method is invoked at\n * most once per thread, but it may be invoked again in case of\n * subsequent invocations of {@link #remove} followed by {@link #get}.\n *\n * &lt;p&gt;This implementation simply returns &lt;tt&gt;null&lt;/tt&gt;; if the\n * programmer desires thread-local variables to have an initial\n * value other than &lt;tt&gt;null&lt;/tt&gt;, &lt;tt&gt;ThreadLocal&lt;/tt&gt; must be\n * subclassed, and this method overridden.  Typically, an\n * anonymous inner class will be used.\n *\n * @return the initial value for this thread-local\n */\n protected T initialValue() {\n     return null;\n }\n</code></pre>\n<h5 id=\"该方法只在get方法中被调用，当ThreadLocal中没有设置value时。默认返回null，protected的访问权限表示该方法支持被覆盖。\"><a href=\"#该方法只在get方法中被调用，当ThreadLocal中没有设置value时。默认返回null，protected的访问权限表示该方法支持被覆盖。\" class=\"headerlink\" title=\"该方法只在get方法中被调用，当ThreadLocal中没有设置value时。默认返回null，protected的访问权限表示该方法支持被覆盖。\"></a>该方法只在get方法中被调用，当ThreadLocal中没有设置value时。默认返回null，protected的访问权限表示该方法支持被覆盖。</h5><h3 id=\"ThreadLocalMap\"><a href=\"#ThreadLocalMap\" class=\"headerlink\" title=\"ThreadLocalMap\"></a>ThreadLocalMap</h3><h5 id=\"ThreadLocalMap是使用ThreadLocal的弱引用作为Key的\"><a href=\"#ThreadLocalMap是使用ThreadLocal的弱引用作为Key的\" class=\"headerlink\" title=\"ThreadLocalMap是使用ThreadLocal的弱引用作为Key的\"></a>ThreadLocalMap是使用ThreadLocal的弱引用作为Key的</h5><pre><code class=\"lang-JAVA\">static class ThreadLocalMap {\n        /**\n         * The entries in this hash map extend WeakReference, using\n         * its main ref field as the key (which is always a\n         * ThreadLocal object).  Note that null keys (i.e. entry.get()\n         * == null) mean that the key is no longer referenced, so the\n         * entry can be expunged from table.  Such entries are referred to\n         * as &quot;stale entries&quot; in the code that follows.\n         */\n        static class Entry extends WeakReference&lt;ThreadLocal&gt; {\n            /** The value associated with this ThreadLocal. */\n            Object value;\n\n            Entry(ThreadLocal k, Object v) {\n                super(k);\n                value = v;\n            }\n        }\n        ...\n        ...\n}\n</code></pre>\n<h5 id=\"下图是本文介绍到的一些对象之间的引用关系图，实线表示强引用，虚线表示弱引用：\"><a href=\"#下图是本文介绍到的一些对象之间的引用关系图，实线表示强引用，虚线表示弱引用：\" class=\"headerlink\" title=\"下图是本文介绍到的一些对象之间的引用关系图，实线表示强引用，虚线表示弱引用：\"></a>下图是本文介绍到的一些对象之间的引用关系图，实线表示强引用，虚线表示弱引用：</h5><p><img src=\"/img/note/ThreadLocal.png\" alt=\"ThreadLocal\"> <div class=\"img-note\">ThreadLocal对象引用</div></p>\n<h5 id=\"如上图，ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用引用他，那么系统gc的时候，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：\"><a href=\"#如上图，ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用引用他，那么系统gc的时候，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：\" class=\"headerlink\" title=\"如上图，ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用引用他，那么系统gc的时候，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：\"></a>如上图，ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用引用他，那么系统gc的时候，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：</h5><h4 id=\"Thread-Ref-gt-Thread-gt-ThreaLocalMap-gt-Entry-gt-value\"><a href=\"#Thread-Ref-gt-Thread-gt-ThreaLocalMap-gt-Entry-gt-value\" class=\"headerlink\" title=\"Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value\"></a>Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value</h4><h5 id=\"永远无法回收，造成内存泄露。\"><a href=\"#永远无法回收，造成内存泄露。\" class=\"headerlink\" title=\"永远无法回收，造成内存泄露。\"></a>永远无法回收，造成内存泄露。</h5><h5 id=\"其实，在JDK的ThreadLocalMap的设计中已经考虑到这种情况，也加上了一些防护措施，下面是ThreadLocalMap的getEntry方法的源码：\"><a href=\"#其实，在JDK的ThreadLocalMap的设计中已经考虑到这种情况，也加上了一些防护措施，下面是ThreadLocalMap的getEntry方法的源码：\" class=\"headerlink\" title=\"其实，在JDK的ThreadLocalMap的设计中已经考虑到这种情况，也加上了一些防护措施，下面是ThreadLocalMap的getEntry方法的源码：\"></a>其实，在JDK的ThreadLocalMap的设计中已经考虑到这种情况，也加上了一些防护措施，下面是ThreadLocalMap的<code>getEntry</code>方法的源码：</h5><pre><code class=\"lang-JAVA\">private Entry getEntry(ThreadLocal key) {\n    int i = key.threadLocalHashCode &amp; (table.length - 1);\n    Entry e = table[i];\n    if (e != null &amp;&amp; e.get() == key)\n        return e;\n    else\n        return getEntryAfterMiss(key, i, e);\n}\n</code></pre>\n<h4 id=\"当Entry为null时，getEntryAfterMiss方法\"><a href=\"#当Entry为null时，getEntryAfterMiss方法\" class=\"headerlink\" title=\"当Entry为null时，getEntryAfterMiss方法\"></a>当Entry为null时，getEntryAfterMiss方法</h4><pre><code class=\"lang-java\">private Entry getEntryAfterMiss(ThreadLocal key, int i, Entry e) {\n    Entry[] tab = table;\n    int len = tab.length;\n    while (e != null) {\n        ThreadLocal k = e.get();\n        if (k == key)\n            return e;\n        if (k == null)\n            expungeStaleEntry(i);\n        else\n            i = nextIndex(i, len);\n        e = tab[i];\n    }\n    return null;\n}\n</code></pre>\n<h4 id=\"expungeStaleEntry函数的源码：\"><a href=\"#expungeStaleEntry函数的源码：\" class=\"headerlink\" title=\"expungeStaleEntry函数的源码：\"></a><code>expungeStaleEntry</code>函数的源码：</h4><pre><code class=\"lang-java\">private int expungeStaleEntry(int staleSlot) {\n    Entry[] tab = table;\n    int len = tab.length;\n\n    // expunge entry at staleSlot\n    tab[staleSlot].value = null;\n    tab[staleSlot] = null;\n    size--;\n\n    // Rehash until we encounter null\n    Entry e;\n    int i;\n    for (i = nextIndex(staleSlot, len);\n         (e = tab[i]) != null;\n         i = nextIndex(i, len)) {\n        ThreadLocal k = e.get();\n        if (k == null) {\n            e.value = null;\n            tab[i] = null;\n            size--;\n        } else {\n            int h = k.threadLocalHashCode &amp; (len - 1);\n            if (h != i) {\n                tab[i] = null;\n\n                // Unlike Knuth 6.4 Algorithm R, we must scan until\n                // null because multiple entries could have been stale.\n                while (tab[h] != null)\n                    h = nextIndex(h, len);\n                tab[h] = e;\n            }\n        }\n    }\n    return i;\n}\n</code></pre>\n<h5 id=\"整理一下ThreadLocalMap的getEntry函数的流程：\"><a href=\"#整理一下ThreadLocalMap的getEntry函数的流程：\" class=\"headerlink\" title=\"整理一下ThreadLocalMap的getEntry函数的流程：\"></a>整理一下ThreadLocalMap的<code>getEntry</code>函数的流程：</h5><ol>\n<li>首先从ThreadLocal的直接索引位置(通过ThreadLocal.threadLocalHashCode &amp; (len-1)运算得到)获取Entry e，如果e不为null并且key相同则返回e；</li>\n<li>如果e为null或者key不一致则向下一个位置查询，如果下一个位置的key和当前需要查询的key相等，则返回对应的Entry，否则，如果key值为null，则擦除该位置的Entry，否则继续向下一个位置查询</li>\n</ol>\n<h5 id=\"在这个过程中遇到的key为null的Entry都会被擦除，那么Entry内的value也就没有强引用链，自然会被回收。仔细研究代码可以发现，set操作也有类似的思想，将key为null的这些Entry都删除，防止内存泄露。\"><a href=\"#在这个过程中遇到的key为null的Entry都会被擦除，那么Entry内的value也就没有强引用链，自然会被回收。仔细研究代码可以发现，set操作也有类似的思想，将key为null的这些Entry都删除，防止内存泄露。\" class=\"headerlink\" title=\"在这个过程中遇到的key为null的Entry都会被擦除，那么Entry内的value也就没有强引用链，自然会被回收。仔细研究代码可以发现，set操作也有类似的思想，将key为null的这些Entry都删除，防止内存泄露。\"></a>在这个过程中遇到的key为null的Entry都会被擦除，那么Entry内的value也就没有强引用链，自然会被回收。仔细研究代码可以发现，<code>set</code>操作也有类似的思想，将key为null的这些Entry都删除，防止内存泄露。</h5><h5 id=\"但是光这样还是不够的，上面的设计思路依赖一个前提条件：-要调用ThreadLocalMap的getEntry函数或者set函数。-这当然是不可能任何情况都成立的，所以很多情况下需要使用者手动调用ThreadLocal的remove函数，手动删除不再需要的ThreadLocal，防止内存泄露。所以JDK建议将ThreadLocal变量定义成private-static的，这样的话ThreadLocal的生命周期就更长，由于一直存在ThreadLocal的强引用，所以ThreadLocal也就不会被回收，也就能保证任何时候都能根据ThreadLocal的弱引用访问到Entry的value值，然后remove它，防止内存泄露。\"><a href=\"#但是光这样还是不够的，上面的设计思路依赖一个前提条件：-要调用ThreadLocalMap的getEntry函数或者set函数。-这当然是不可能任何情况都成立的，所以很多情况下需要使用者手动调用ThreadLocal的remove函数，手动删除不再需要的ThreadLocal，防止内存泄露。所以JDK建议将ThreadLocal变量定义成private-static的，这样的话ThreadLocal的生命周期就更长，由于一直存在ThreadLocal的强引用，所以ThreadLocal也就不会被回收，也就能保证任何时候都能根据ThreadLocal的弱引用访问到Entry的value值，然后remove它，防止内存泄露。\" class=\"headerlink\" title=\"但是光这样还是不够的，上面的设计思路依赖一个前提条件： 要调用ThreadLocalMap的getEntry函数或者set函数。 这当然是不可能任何情况都成立的，所以很多情况下需要使用者手动调用ThreadLocal的remove函数，手动删除不再需要的ThreadLocal，防止内存泄露。所以JDK建议将ThreadLocal变量定义成private static的，这样的话ThreadLocal的生命周期就更长，由于一直存在ThreadLocal的强引用，所以ThreadLocal也就不会被回收，也就能保证任何时候都能根据ThreadLocal的弱引用访问到Entry的value值，然后remove它，防止内存泄露。\"></a>但是光这样还是不够的，上面的设计思路依赖一个前提条件： 要调用ThreadLocalMap的<code>getEntry</code>函数或者<code>set</code>函数。 这当然是不可能任何情况都成立的，所以很多情况下需要使用者手动调用ThreadLocal的<code>remove</code>函数，手动删除不再需要的ThreadLocal，防止内存泄露。所以JDK建议将ThreadLocal变量定义成<code>private static</code>的，这样的话ThreadLocal的生命周期就更长，由于一直存在ThreadLocal的强引用，所以ThreadLocal也就不会被回收，也就能保证任何时候都能根据ThreadLocal的弱引用访问到Entry的value值，然后remove它，防止内存泄露。</h5>"},{"layout":"post","title":"ThreadPoolExecutor源码阅读","date":"2018-01-04T16:00:00.000Z","original":true,"_content":"\n##### 线程的使用在java中占有极其重要的地位，在jdk1.4极其之前的jdk版本中，关于线程池的使用是极其简陋的。在jdk1.5之后这一情况有了很大的改观。Jdk1.5之后加入了java.util.concurrent包，这个包中主要介绍java中线程以及线程池的使用。为我们在开发中处理线程的问题提供了非常大的帮助。\n\n<!--more-->\n\n##### 线程池的作用和优点就不多说，直接上源码：\n\n### ThreadPoolExecutor结构图\n\n```java\npublic class ThreadPoolExecutor extends AbstractExecutorService\n```\n\n|—java.lang.Object\n|——java.util.concurrent.AbstractExecutorService\n|———java.util.concurrent.ThreadPoolExecutor\n\n#### 所有引用的接口：\njava.util.concurrent.Executor\njava.util.concurrent.ExecutorService\n\n### ThreadPoolExecutor代码\n#### 线程安全AtomicInteger变量ctl\n```java\n/**\n     * The main pool control state, ctl, is an atomic integer packing\n     * two conceptual fields\n     *   workerCount, indicating the effective number of threads\n     *   runState,    indicating whether running, shutting down etc\n     *\n     * In order to pack them into one int, we limit workerCount to\n     * (2^29)-1 (about 500 million) threads rather than (2^31)-1 (2\n     * billion) otherwise representable. If this is ever an issue in\n     * the future, the variable can be changed to be an AtomicLong,\n     * and the shift/mask constants below adjusted. But until the need\n     * arises, this code is a bit faster and simpler using an int.\n     *\n     * The workerCount is the number of workers that have been\n     * permitted to start and not permitted to stop.  The value may be\n     * transiently different from the actual number of live threads,\n     * for example when a ThreadFactory fails to create a thread when\n     * asked, and when exiting threads are still performing\n     * bookkeeping before terminating. The user-visible pool size is\n     * reported as the current size of the workers set.\n     */\nprivate final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));\n```\n##### 在该变量属性上已经有较为详细的介绍了。大致的意思是ctl是线程池的主要控制变量，这个变量主要有两个含义：\n1. 工作线程数量，表示实际的线程数量\n2. 线程池状态，线程池的各种状态情况，后面会详细介绍\n\n##### 那么如何用着一个变量来表示两个不同的含义呢。我们都知道，java中的int有32位，其中最高位为状态位，表示正负，因此java中int能够表示的大小范围在-2<sup>31</sup>~2<sup>31</sup>-1。因此，这里将int的32位分为了两部分，其中低29位用来表示工作线程数量，一共2<sup>29</sup>-1 大约5亿。这里的工作线程数表示那些已经被允许开始并且没有被允许停止的线程。而高3位则用来表示线程池的状态，这个将在后面具体介绍。\n\n\n#### 线程池状态\n```java\nprivate static final int COUNT_BITS = Integer.SIZE - 3;\n\n// runState is stored in the high-order bits\nprivate static final int RUNNING    = -1 << COUNT_BITS;\nprivate static final int SHUTDOWN   =  0 << COUNT_BITS;\nprivate static final int STOP       =  1 << COUNT_BITS;\nprivate static final int TIDYING    =  2 << COUNT_BITS;\nprivate static final int TERMINATED =  3 << COUNT_BITS;\n```\n##### `COUNT_BITS`等于29，表示低的29位。\n1. RUNNING：运行状态，高三位都为1时表示(11100000000000000000000000000000), 表示线程池接受新的任务和处理队列中已有的任务；\n2. SHUTDOWN：00000000000000000000000000000000，不接受新的任务，但是处理队列中的任务；\n3. STOP：00100000000000000000000000000000，不接受新任务，也不处理队列任务，并且中断(interrupt)正在处理的任务；\n4. TIDYING：01000000000000000000000000000000，所有的任务都已经终结，工作线程数为0。将要执行terminated()钩子方法；\n5. TERMINATED：01100000000000000000000000000000，terminated()方法执行完成。\n\n#### 用户存放任务的阻塞队列\n```java\nprivate final BlockingQueue<Runnable> workQueue;\n```\n##### final关键字表示其必须在构造函数中进行初始化\n\n\n\n\n### 参考资料\n[ThreadPoolExecutor](https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ThreadPoolExecutor.html)\n[Java线程池使用说明](http://www.oschina.net/question/565065_86540)","source":"_posts/note/jdk/threadPoolExecutor.md","raw":"---\nlayout: post\ntitle: ThreadPoolExecutor源码阅读\ndate: 2018/01/05\noriginal: true\ntag: [[java, java]]\n---\n\n##### 线程的使用在java中占有极其重要的地位，在jdk1.4极其之前的jdk版本中，关于线程池的使用是极其简陋的。在jdk1.5之后这一情况有了很大的改观。Jdk1.5之后加入了java.util.concurrent包，这个包中主要介绍java中线程以及线程池的使用。为我们在开发中处理线程的问题提供了非常大的帮助。\n\n<!--more-->\n\n##### 线程池的作用和优点就不多说，直接上源码：\n\n### ThreadPoolExecutor结构图\n\n```java\npublic class ThreadPoolExecutor extends AbstractExecutorService\n```\n\n|—java.lang.Object\n|——java.util.concurrent.AbstractExecutorService\n|———java.util.concurrent.ThreadPoolExecutor\n\n#### 所有引用的接口：\njava.util.concurrent.Executor\njava.util.concurrent.ExecutorService\n\n### ThreadPoolExecutor代码\n#### 线程安全AtomicInteger变量ctl\n```java\n/**\n     * The main pool control state, ctl, is an atomic integer packing\n     * two conceptual fields\n     *   workerCount, indicating the effective number of threads\n     *   runState,    indicating whether running, shutting down etc\n     *\n     * In order to pack them into one int, we limit workerCount to\n     * (2^29)-1 (about 500 million) threads rather than (2^31)-1 (2\n     * billion) otherwise representable. If this is ever an issue in\n     * the future, the variable can be changed to be an AtomicLong,\n     * and the shift/mask constants below adjusted. But until the need\n     * arises, this code is a bit faster and simpler using an int.\n     *\n     * The workerCount is the number of workers that have been\n     * permitted to start and not permitted to stop.  The value may be\n     * transiently different from the actual number of live threads,\n     * for example when a ThreadFactory fails to create a thread when\n     * asked, and when exiting threads are still performing\n     * bookkeeping before terminating. The user-visible pool size is\n     * reported as the current size of the workers set.\n     */\nprivate final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));\n```\n##### 在该变量属性上已经有较为详细的介绍了。大致的意思是ctl是线程池的主要控制变量，这个变量主要有两个含义：\n1. 工作线程数量，表示实际的线程数量\n2. 线程池状态，线程池的各种状态情况，后面会详细介绍\n\n##### 那么如何用着一个变量来表示两个不同的含义呢。我们都知道，java中的int有32位，其中最高位为状态位，表示正负，因此java中int能够表示的大小范围在-2<sup>31</sup>~2<sup>31</sup>-1。因此，这里将int的32位分为了两部分，其中低29位用来表示工作线程数量，一共2<sup>29</sup>-1 大约5亿。这里的工作线程数表示那些已经被允许开始并且没有被允许停止的线程。而高3位则用来表示线程池的状态，这个将在后面具体介绍。\n\n\n#### 线程池状态\n```java\nprivate static final int COUNT_BITS = Integer.SIZE - 3;\n\n// runState is stored in the high-order bits\nprivate static final int RUNNING    = -1 << COUNT_BITS;\nprivate static final int SHUTDOWN   =  0 << COUNT_BITS;\nprivate static final int STOP       =  1 << COUNT_BITS;\nprivate static final int TIDYING    =  2 << COUNT_BITS;\nprivate static final int TERMINATED =  3 << COUNT_BITS;\n```\n##### `COUNT_BITS`等于29，表示低的29位。\n1. RUNNING：运行状态，高三位都为1时表示(11100000000000000000000000000000), 表示线程池接受新的任务和处理队列中已有的任务；\n2. SHUTDOWN：00000000000000000000000000000000，不接受新的任务，但是处理队列中的任务；\n3. STOP：00100000000000000000000000000000，不接受新任务，也不处理队列任务，并且中断(interrupt)正在处理的任务；\n4. TIDYING：01000000000000000000000000000000，所有的任务都已经终结，工作线程数为0。将要执行terminated()钩子方法；\n5. TERMINATED：01100000000000000000000000000000，terminated()方法执行完成。\n\n#### 用户存放任务的阻塞队列\n```java\nprivate final BlockingQueue<Runnable> workQueue;\n```\n##### final关键字表示其必须在构造函数中进行初始化\n\n\n\n\n### 参考资料\n[ThreadPoolExecutor](https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ThreadPoolExecutor.html)\n[Java线程池使用说明](http://www.oschina.net/question/565065_86540)","slug":"note/jdk/threadPoolExecutor","published":1,"updated":"2018-05-08T14:49:51.937Z","_id":"cjgxop3nq003ujah19kb67n5l","comments":1,"photos":[],"link":"","content":"<h5 id=\"线程的使用在java中占有极其重要的地位，在jdk1-4极其之前的jdk版本中，关于线程池的使用是极其简陋的。在jdk1-5之后这一情况有了很大的改观。Jdk1-5之后加入了java-util-concurrent包，这个包中主要介绍java中线程以及线程池的使用。为我们在开发中处理线程的问题提供了非常大的帮助。\"><a href=\"#线程的使用在java中占有极其重要的地位，在jdk1-4极其之前的jdk版本中，关于线程池的使用是极其简陋的。在jdk1-5之后这一情况有了很大的改观。Jdk1-5之后加入了java-util-concurrent包，这个包中主要介绍java中线程以及线程池的使用。为我们在开发中处理线程的问题提供了非常大的帮助。\" class=\"headerlink\" title=\"线程的使用在java中占有极其重要的地位，在jdk1.4极其之前的jdk版本中，关于线程池的使用是极其简陋的。在jdk1.5之后这一情况有了很大的改观。Jdk1.5之后加入了java.util.concurrent包，这个包中主要介绍java中线程以及线程池的使用。为我们在开发中处理线程的问题提供了非常大的帮助。\"></a>线程的使用在java中占有极其重要的地位，在jdk1.4极其之前的jdk版本中，关于线程池的使用是极其简陋的。在jdk1.5之后这一情况有了很大的改观。Jdk1.5之后加入了java.util.concurrent包，这个包中主要介绍java中线程以及线程池的使用。为我们在开发中处理线程的问题提供了非常大的帮助。</h5><a id=\"more\"></a>\n<h5 id=\"线程池的作用和优点就不多说，直接上源码：\"><a href=\"#线程池的作用和优点就不多说，直接上源码：\" class=\"headerlink\" title=\"线程池的作用和优点就不多说，直接上源码：\"></a>线程池的作用和优点就不多说，直接上源码：</h5><h3 id=\"ThreadPoolExecutor结构图\"><a href=\"#ThreadPoolExecutor结构图\" class=\"headerlink\" title=\"ThreadPoolExecutor结构图\"></a>ThreadPoolExecutor结构图</h3><pre><code class=\"lang-java\">public class ThreadPoolExecutor extends AbstractExecutorService\n</code></pre>\n<p>|—java.lang.Object<br>|——java.util.concurrent.AbstractExecutorService<br>|———java.util.concurrent.ThreadPoolExecutor</p>\n<h4 id=\"所有引用的接口：\"><a href=\"#所有引用的接口：\" class=\"headerlink\" title=\"所有引用的接口：\"></a>所有引用的接口：</h4><p>java.util.concurrent.Executor<br>java.util.concurrent.ExecutorService</p>\n<h3 id=\"ThreadPoolExecutor代码\"><a href=\"#ThreadPoolExecutor代码\" class=\"headerlink\" title=\"ThreadPoolExecutor代码\"></a>ThreadPoolExecutor代码</h3><h4 id=\"线程安全AtomicInteger变量ctl\"><a href=\"#线程安全AtomicInteger变量ctl\" class=\"headerlink\" title=\"线程安全AtomicInteger变量ctl\"></a>线程安全AtomicInteger变量ctl</h4><pre><code class=\"lang-java\">/**\n     * The main pool control state, ctl, is an atomic integer packing\n     * two conceptual fields\n     *   workerCount, indicating the effective number of threads\n     *   runState,    indicating whether running, shutting down etc\n     *\n     * In order to pack them into one int, we limit workerCount to\n     * (2^29)-1 (about 500 million) threads rather than (2^31)-1 (2\n     * billion) otherwise representable. If this is ever an issue in\n     * the future, the variable can be changed to be an AtomicLong,\n     * and the shift/mask constants below adjusted. But until the need\n     * arises, this code is a bit faster and simpler using an int.\n     *\n     * The workerCount is the number of workers that have been\n     * permitted to start and not permitted to stop.  The value may be\n     * transiently different from the actual number of live threads,\n     * for example when a ThreadFactory fails to create a thread when\n     * asked, and when exiting threads are still performing\n     * bookkeeping before terminating. The user-visible pool size is\n     * reported as the current size of the workers set.\n     */\nprivate final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));\n</code></pre>\n<h5 id=\"在该变量属性上已经有较为详细的介绍了。大致的意思是ctl是线程池的主要控制变量，这个变量主要有两个含义：\"><a href=\"#在该变量属性上已经有较为详细的介绍了。大致的意思是ctl是线程池的主要控制变量，这个变量主要有两个含义：\" class=\"headerlink\" title=\"在该变量属性上已经有较为详细的介绍了。大致的意思是ctl是线程池的主要控制变量，这个变量主要有两个含义：\"></a>在该变量属性上已经有较为详细的介绍了。大致的意思是ctl是线程池的主要控制变量，这个变量主要有两个含义：</h5><ol>\n<li>工作线程数量，表示实际的线程数量</li>\n<li>线程池状态，线程池的各种状态情况，后面会详细介绍</li>\n</ol>\n<h5 id=\"那么如何用着一个变量来表示两个不同的含义呢。我们都知道，java中的int有32位，其中最高位为状态位，表示正负，因此java中int能够表示的大小范围在-231-231-1。因此，这里将int的32位分为了两部分，其中低29位用来表示工作线程数量，一共229-1-大约5亿。这里的工作线程数表示那些已经被允许开始并且没有被允许停止的线程。而高3位则用来表示线程池的状态，这个将在后面具体介绍。\"><a href=\"#那么如何用着一个变量来表示两个不同的含义呢。我们都知道，java中的int有32位，其中最高位为状态位，表示正负，因此java中int能够表示的大小范围在-231-231-1。因此，这里将int的32位分为了两部分，其中低29位用来表示工作线程数量，一共229-1-大约5亿。这里的工作线程数表示那些已经被允许开始并且没有被允许停止的线程。而高3位则用来表示线程池的状态，这个将在后面具体介绍。\" class=\"headerlink\" title=\"那么如何用着一个变量来表示两个不同的含义呢。我们都知道，java中的int有32位，其中最高位为状态位，表示正负，因此java中int能够表示的大小范围在-231~231-1。因此，这里将int的32位分为了两部分，其中低29位用来表示工作线程数量，一共229-1 大约5亿。这里的工作线程数表示那些已经被允许开始并且没有被允许停止的线程。而高3位则用来表示线程池的状态，这个将在后面具体介绍。\"></a>那么如何用着一个变量来表示两个不同的含义呢。我们都知道，java中的int有32位，其中最高位为状态位，表示正负，因此java中int能够表示的大小范围在-2<sup>31</sup>~2<sup>31</sup>-1。因此，这里将int的32位分为了两部分，其中低29位用来表示工作线程数量，一共2<sup>29</sup>-1 大约5亿。这里的工作线程数表示那些已经被允许开始并且没有被允许停止的线程。而高3位则用来表示线程池的状态，这个将在后面具体介绍。</h5><h4 id=\"线程池状态\"><a href=\"#线程池状态\" class=\"headerlink\" title=\"线程池状态\"></a>线程池状态</h4><pre><code class=\"lang-java\">private static final int COUNT_BITS = Integer.SIZE - 3;\n\n// runState is stored in the high-order bits\nprivate static final int RUNNING    = -1 &lt;&lt; COUNT_BITS;\nprivate static final int SHUTDOWN   =  0 &lt;&lt; COUNT_BITS;\nprivate static final int STOP       =  1 &lt;&lt; COUNT_BITS;\nprivate static final int TIDYING    =  2 &lt;&lt; COUNT_BITS;\nprivate static final int TERMINATED =  3 &lt;&lt; COUNT_BITS;\n</code></pre>\n<h5 id=\"COUNT-BITS等于29，表示低的29位。\"><a href=\"#COUNT-BITS等于29，表示低的29位。\" class=\"headerlink\" title=\"COUNT_BITS等于29，表示低的29位。\"></a><code>COUNT_BITS</code>等于29，表示低的29位。</h5><ol>\n<li>RUNNING：运行状态，高三位都为1时表示(11100000000000000000000000000000), 表示线程池接受新的任务和处理队列中已有的任务；</li>\n<li>SHUTDOWN：00000000000000000000000000000000，不接受新的任务，但是处理队列中的任务；</li>\n<li>STOP：00100000000000000000000000000000，不接受新任务，也不处理队列任务，并且中断(interrupt)正在处理的任务；</li>\n<li>TIDYING：01000000000000000000000000000000，所有的任务都已经终结，工作线程数为0。将要执行terminated()钩子方法；</li>\n<li>TERMINATED：01100000000000000000000000000000，terminated()方法执行完成。</li>\n</ol>\n<h4 id=\"用户存放任务的阻塞队列\"><a href=\"#用户存放任务的阻塞队列\" class=\"headerlink\" title=\"用户存放任务的阻塞队列\"></a>用户存放任务的阻塞队列</h4><pre><code class=\"lang-java\">private final BlockingQueue&lt;Runnable&gt; workQueue;\n</code></pre>\n<h5 id=\"final关键字表示其必须在构造函数中进行初始化\"><a href=\"#final关键字表示其必须在构造函数中进行初始化\" class=\"headerlink\" title=\"final关键字表示其必须在构造函数中进行初始化\"></a>final关键字表示其必须在构造函数中进行初始化</h5><h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p><a href=\"https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ThreadPoolExecutor.html\" target=\"_blank\" rel=\"external\">ThreadPoolExecutor</a><br><a href=\"http://www.oschina.net/question/565065_86540\" target=\"_blank\" rel=\"external\">Java线程池使用说明</a></p>\n","site":{"data":{}},"excerpt":"<h5 id=\"线程的使用在java中占有极其重要的地位，在jdk1-4极其之前的jdk版本中，关于线程池的使用是极其简陋的。在jdk1-5之后这一情况有了很大的改观。Jdk1-5之后加入了java-util-concurrent包，这个包中主要介绍java中线程以及线程池的使用。为我们在开发中处理线程的问题提供了非常大的帮助。\"><a href=\"#线程的使用在java中占有极其重要的地位，在jdk1-4极其之前的jdk版本中，关于线程池的使用是极其简陋的。在jdk1-5之后这一情况有了很大的改观。Jdk1-5之后加入了java-util-concurrent包，这个包中主要介绍java中线程以及线程池的使用。为我们在开发中处理线程的问题提供了非常大的帮助。\" class=\"headerlink\" title=\"线程的使用在java中占有极其重要的地位，在jdk1.4极其之前的jdk版本中，关于线程池的使用是极其简陋的。在jdk1.5之后这一情况有了很大的改观。Jdk1.5之后加入了java.util.concurrent包，这个包中主要介绍java中线程以及线程池的使用。为我们在开发中处理线程的问题提供了非常大的帮助。\"></a>线程的使用在java中占有极其重要的地位，在jdk1.4极其之前的jdk版本中，关于线程池的使用是极其简陋的。在jdk1.5之后这一情况有了很大的改观。Jdk1.5之后加入了java.util.concurrent包，这个包中主要介绍java中线程以及线程池的使用。为我们在开发中处理线程的问题提供了非常大的帮助。</h5>","more":"<h5 id=\"线程池的作用和优点就不多说，直接上源码：\"><a href=\"#线程池的作用和优点就不多说，直接上源码：\" class=\"headerlink\" title=\"线程池的作用和优点就不多说，直接上源码：\"></a>线程池的作用和优点就不多说，直接上源码：</h5><h3 id=\"ThreadPoolExecutor结构图\"><a href=\"#ThreadPoolExecutor结构图\" class=\"headerlink\" title=\"ThreadPoolExecutor结构图\"></a>ThreadPoolExecutor结构图</h3><pre><code class=\"lang-java\">public class ThreadPoolExecutor extends AbstractExecutorService\n</code></pre>\n<p>|—java.lang.Object<br>|——java.util.concurrent.AbstractExecutorService<br>|———java.util.concurrent.ThreadPoolExecutor</p>\n<h4 id=\"所有引用的接口：\"><a href=\"#所有引用的接口：\" class=\"headerlink\" title=\"所有引用的接口：\"></a>所有引用的接口：</h4><p>java.util.concurrent.Executor<br>java.util.concurrent.ExecutorService</p>\n<h3 id=\"ThreadPoolExecutor代码\"><a href=\"#ThreadPoolExecutor代码\" class=\"headerlink\" title=\"ThreadPoolExecutor代码\"></a>ThreadPoolExecutor代码</h3><h4 id=\"线程安全AtomicInteger变量ctl\"><a href=\"#线程安全AtomicInteger变量ctl\" class=\"headerlink\" title=\"线程安全AtomicInteger变量ctl\"></a>线程安全AtomicInteger变量ctl</h4><pre><code class=\"lang-java\">/**\n     * The main pool control state, ctl, is an atomic integer packing\n     * two conceptual fields\n     *   workerCount, indicating the effective number of threads\n     *   runState,    indicating whether running, shutting down etc\n     *\n     * In order to pack them into one int, we limit workerCount to\n     * (2^29)-1 (about 500 million) threads rather than (2^31)-1 (2\n     * billion) otherwise representable. If this is ever an issue in\n     * the future, the variable can be changed to be an AtomicLong,\n     * and the shift/mask constants below adjusted. But until the need\n     * arises, this code is a bit faster and simpler using an int.\n     *\n     * The workerCount is the number of workers that have been\n     * permitted to start and not permitted to stop.  The value may be\n     * transiently different from the actual number of live threads,\n     * for example when a ThreadFactory fails to create a thread when\n     * asked, and when exiting threads are still performing\n     * bookkeeping before terminating. The user-visible pool size is\n     * reported as the current size of the workers set.\n     */\nprivate final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));\n</code></pre>\n<h5 id=\"在该变量属性上已经有较为详细的介绍了。大致的意思是ctl是线程池的主要控制变量，这个变量主要有两个含义：\"><a href=\"#在该变量属性上已经有较为详细的介绍了。大致的意思是ctl是线程池的主要控制变量，这个变量主要有两个含义：\" class=\"headerlink\" title=\"在该变量属性上已经有较为详细的介绍了。大致的意思是ctl是线程池的主要控制变量，这个变量主要有两个含义：\"></a>在该变量属性上已经有较为详细的介绍了。大致的意思是ctl是线程池的主要控制变量，这个变量主要有两个含义：</h5><ol>\n<li>工作线程数量，表示实际的线程数量</li>\n<li>线程池状态，线程池的各种状态情况，后面会详细介绍</li>\n</ol>\n<h5 id=\"那么如何用着一个变量来表示两个不同的含义呢。我们都知道，java中的int有32位，其中最高位为状态位，表示正负，因此java中int能够表示的大小范围在-231-231-1。因此，这里将int的32位分为了两部分，其中低29位用来表示工作线程数量，一共229-1-大约5亿。这里的工作线程数表示那些已经被允许开始并且没有被允许停止的线程。而高3位则用来表示线程池的状态，这个将在后面具体介绍。\"><a href=\"#那么如何用着一个变量来表示两个不同的含义呢。我们都知道，java中的int有32位，其中最高位为状态位，表示正负，因此java中int能够表示的大小范围在-231-231-1。因此，这里将int的32位分为了两部分，其中低29位用来表示工作线程数量，一共229-1-大约5亿。这里的工作线程数表示那些已经被允许开始并且没有被允许停止的线程。而高3位则用来表示线程池的状态，这个将在后面具体介绍。\" class=\"headerlink\" title=\"那么如何用着一个变量来表示两个不同的含义呢。我们都知道，java中的int有32位，其中最高位为状态位，表示正负，因此java中int能够表示的大小范围在-231~231-1。因此，这里将int的32位分为了两部分，其中低29位用来表示工作线程数量，一共229-1 大约5亿。这里的工作线程数表示那些已经被允许开始并且没有被允许停止的线程。而高3位则用来表示线程池的状态，这个将在后面具体介绍。\"></a>那么如何用着一个变量来表示两个不同的含义呢。我们都知道，java中的int有32位，其中最高位为状态位，表示正负，因此java中int能够表示的大小范围在-2<sup>31</sup>~2<sup>31</sup>-1。因此，这里将int的32位分为了两部分，其中低29位用来表示工作线程数量，一共2<sup>29</sup>-1 大约5亿。这里的工作线程数表示那些已经被允许开始并且没有被允许停止的线程。而高3位则用来表示线程池的状态，这个将在后面具体介绍。</h5><h4 id=\"线程池状态\"><a href=\"#线程池状态\" class=\"headerlink\" title=\"线程池状态\"></a>线程池状态</h4><pre><code class=\"lang-java\">private static final int COUNT_BITS = Integer.SIZE - 3;\n\n// runState is stored in the high-order bits\nprivate static final int RUNNING    = -1 &lt;&lt; COUNT_BITS;\nprivate static final int SHUTDOWN   =  0 &lt;&lt; COUNT_BITS;\nprivate static final int STOP       =  1 &lt;&lt; COUNT_BITS;\nprivate static final int TIDYING    =  2 &lt;&lt; COUNT_BITS;\nprivate static final int TERMINATED =  3 &lt;&lt; COUNT_BITS;\n</code></pre>\n<h5 id=\"COUNT-BITS等于29，表示低的29位。\"><a href=\"#COUNT-BITS等于29，表示低的29位。\" class=\"headerlink\" title=\"COUNT_BITS等于29，表示低的29位。\"></a><code>COUNT_BITS</code>等于29，表示低的29位。</h5><ol>\n<li>RUNNING：运行状态，高三位都为1时表示(11100000000000000000000000000000), 表示线程池接受新的任务和处理队列中已有的任务；</li>\n<li>SHUTDOWN：00000000000000000000000000000000，不接受新的任务，但是处理队列中的任务；</li>\n<li>STOP：00100000000000000000000000000000，不接受新任务，也不处理队列任务，并且中断(interrupt)正在处理的任务；</li>\n<li>TIDYING：01000000000000000000000000000000，所有的任务都已经终结，工作线程数为0。将要执行terminated()钩子方法；</li>\n<li>TERMINATED：01100000000000000000000000000000，terminated()方法执行完成。</li>\n</ol>\n<h4 id=\"用户存放任务的阻塞队列\"><a href=\"#用户存放任务的阻塞队列\" class=\"headerlink\" title=\"用户存放任务的阻塞队列\"></a>用户存放任务的阻塞队列</h4><pre><code class=\"lang-java\">private final BlockingQueue&lt;Runnable&gt; workQueue;\n</code></pre>\n<h5 id=\"final关键字表示其必须在构造函数中进行初始化\"><a href=\"#final关键字表示其必须在构造函数中进行初始化\" class=\"headerlink\" title=\"final关键字表示其必须在构造函数中进行初始化\"></a>final关键字表示其必须在构造函数中进行初始化</h5><h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p><a href=\"https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ThreadPoolExecutor.html\" target=\"_blank\" rel=\"external\">ThreadPoolExecutor</a><br><a href=\"http://www.oschina.net/question/565065_86540\" target=\"_blank\" rel=\"external\">Java线程池使用说明</a></p>"},{"layout":"post","title":"redis持久化","date":"2018-04-04T16:00:00.000Z","tag":[["redis","redis"]],"_content":"\n##### Redis提供了两种不同的持久化方式。一种叫做快照（snapshotting），另一种叫做只追加文件（append-only file，AOF）。这两种方式可以同时使用，也可以单独使用。\n\n## 快照持久化\n##### redis可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。在创建快照之后，用户可以对快照进行备份。\n#### 创建快照的办法有以下几种：\n1. 客户端通过向redis发送**BGSAVE**命令来创建一个快照。redis会调用fork来创建一个子进程，然后子进程负责将快照写入硬盘，而父进程则继续处理命令请求。\n2. 客户端向redis发送**SAVE**命令，接受到该命令的redis服务器在创建快照完毕之前不再响应任何其他命令。SAVE命令并不常用，通常只在没有足够内存去执行BGSAVE命令的情况下，或者可以忍受SAVE命令执行完毕的等待情况下。才使用这个命令\n3. 设置save配置选项，比如save 60 1000。那么redis当\"60秒内有1000次写入\"这个条件满足是，会自动触发BGSAVE。save配置可以有多个，只要触发其中一个就会触发BGSAVE\n4. 当redis收到SHUTDOWN命令关闭服务器时，会执行一个SAVE命令，并且不在处理任何客户端请求。SAVE命令之后关闭服务器。\n5. 当redis服务器连接另一个reids服务器，通过向对方发送SYNC命令来开始复制操作，这时候主服务器会执行BGSAVE命令。\n\n##### 当只使用快照来持久化保存数据时，系统发生崩溃时，将丢失最近一次生成快照之后更改的所有数据。\n\n##### 为了防止reids因为创建子进程而出现停顿，我们可以考虑关闭自动保存，转而通过手动发送BGSAVE或者SAVE来进行持久化。手动BGSAVE一样会引起停顿，唯一不同的是用户可以通过手动控制停顿出现的时间。另外，虽然SAVE会一直阻塞redis直到快照生成完毕，但是因为不需要创建子进程，所以就不会像BGSAVE一样导致reis停顿。没有子进程争抢资源，SAVE操作会比BGSAVE创建快照的速度快一些。\n\n## AOF持久化\n##### AOF持久化将写命令写到文件的末尾，以此来记录数据的变化。所以redis只要从头到尾执行一次AOF文件的命令，就可以恢复数据集。该持久化可以通过设置appendonly yes选项来打开。而appendfsync配置将影响AOF文件的同步频率：\n* **always** 每个redis写命令都要同步些人硬盘，严重降低redis速度\n* **everysec** 每秒执行一次同步，将多个写命令同步到硬盘\n* **no** 让操作系统来决定何时进行同步\n\n##### 如果使用appendfsyne always选项的话，每个写命令都会被写入硬盘，这样可以将系统崩溃时出现的数据丢失减少到最小。但是这种同步策略要对硬盘进行大量的写入，导致redis的处理速度受到限制。\n\n##### 为了兼顾安全和性能，可以考虑使用everysec选项。redis每秒同步一次AOF对redis的性能不会有大的影响。即使系统崩溃，也只是丢失了一秒内的数据。\n\n##### 如果用户使用appendfsync no选项，那么reids不对AOF文件执行显示的同步操作，而是由操作系统来决定什么时候进行同步。一般情况下不建议使用。因为可能导致缓冲区被等待写入数据填满，redis将会阻塞之后的写入请求。\n\n\n","source":"_posts/note/redis/redisPersistence.md","raw":"---\nlayout: post\ntitle: redis持久化\ndate: 2018/04/05\ntags: [tech, index, redis]\ntag: [[redis, redis]]\n---\n\n##### Redis提供了两种不同的持久化方式。一种叫做快照（snapshotting），另一种叫做只追加文件（append-only file，AOF）。这两种方式可以同时使用，也可以单独使用。\n\n## 快照持久化\n##### redis可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。在创建快照之后，用户可以对快照进行备份。\n#### 创建快照的办法有以下几种：\n1. 客户端通过向redis发送**BGSAVE**命令来创建一个快照。redis会调用fork来创建一个子进程，然后子进程负责将快照写入硬盘，而父进程则继续处理命令请求。\n2. 客户端向redis发送**SAVE**命令，接受到该命令的redis服务器在创建快照完毕之前不再响应任何其他命令。SAVE命令并不常用，通常只在没有足够内存去执行BGSAVE命令的情况下，或者可以忍受SAVE命令执行完毕的等待情况下。才使用这个命令\n3. 设置save配置选项，比如save 60 1000。那么redis当\"60秒内有1000次写入\"这个条件满足是，会自动触发BGSAVE。save配置可以有多个，只要触发其中一个就会触发BGSAVE\n4. 当redis收到SHUTDOWN命令关闭服务器时，会执行一个SAVE命令，并且不在处理任何客户端请求。SAVE命令之后关闭服务器。\n5. 当redis服务器连接另一个reids服务器，通过向对方发送SYNC命令来开始复制操作，这时候主服务器会执行BGSAVE命令。\n\n##### 当只使用快照来持久化保存数据时，系统发生崩溃时，将丢失最近一次生成快照之后更改的所有数据。\n\n##### 为了防止reids因为创建子进程而出现停顿，我们可以考虑关闭自动保存，转而通过手动发送BGSAVE或者SAVE来进行持久化。手动BGSAVE一样会引起停顿，唯一不同的是用户可以通过手动控制停顿出现的时间。另外，虽然SAVE会一直阻塞redis直到快照生成完毕，但是因为不需要创建子进程，所以就不会像BGSAVE一样导致reis停顿。没有子进程争抢资源，SAVE操作会比BGSAVE创建快照的速度快一些。\n\n## AOF持久化\n##### AOF持久化将写命令写到文件的末尾，以此来记录数据的变化。所以redis只要从头到尾执行一次AOF文件的命令，就可以恢复数据集。该持久化可以通过设置appendonly yes选项来打开。而appendfsync配置将影响AOF文件的同步频率：\n* **always** 每个redis写命令都要同步些人硬盘，严重降低redis速度\n* **everysec** 每秒执行一次同步，将多个写命令同步到硬盘\n* **no** 让操作系统来决定何时进行同步\n\n##### 如果使用appendfsyne always选项的话，每个写命令都会被写入硬盘，这样可以将系统崩溃时出现的数据丢失减少到最小。但是这种同步策略要对硬盘进行大量的写入，导致redis的处理速度受到限制。\n\n##### 为了兼顾安全和性能，可以考虑使用everysec选项。redis每秒同步一次AOF对redis的性能不会有大的影响。即使系统崩溃，也只是丢失了一秒内的数据。\n\n##### 如果用户使用appendfsync no选项，那么reids不对AOF文件执行显示的同步操作，而是由操作系统来决定什么时候进行同步。一般情况下不建议使用。因为可能导致缓冲区被等待写入数据填满，redis将会阻塞之后的写入请求。\n\n\n","slug":"note/redis/redisPersistence","published":1,"updated":"2018-05-08T13:00:14.281Z","comments":1,"photos":[],"link":"","_id":"cjgxop3nr003xjah1reclq0mr","content":"<h5 id=\"Redis提供了两种不同的持久化方式。一种叫做快照（snapshotting），另一种叫做只追加文件（append-only-file，AOF）。这两种方式可以同时使用，也可以单独使用。\"><a href=\"#Redis提供了两种不同的持久化方式。一种叫做快照（snapshotting），另一种叫做只追加文件（append-only-file，AOF）。这两种方式可以同时使用，也可以单独使用。\" class=\"headerlink\" title=\"Redis提供了两种不同的持久化方式。一种叫做快照（snapshotting），另一种叫做只追加文件（append-only file，AOF）。这两种方式可以同时使用，也可以单独使用。\"></a>Redis提供了两种不同的持久化方式。一种叫做快照（snapshotting），另一种叫做只追加文件（append-only file，AOF）。这两种方式可以同时使用，也可以单独使用。</h5><h2 id=\"快照持久化\"><a href=\"#快照持久化\" class=\"headerlink\" title=\"快照持久化\"></a>快照持久化</h2><h5 id=\"redis可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。在创建快照之后，用户可以对快照进行备份。\"><a href=\"#redis可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。在创建快照之后，用户可以对快照进行备份。\" class=\"headerlink\" title=\"redis可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。在创建快照之后，用户可以对快照进行备份。\"></a>redis可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。在创建快照之后，用户可以对快照进行备份。</h5><h4 id=\"创建快照的办法有以下几种：\"><a href=\"#创建快照的办法有以下几种：\" class=\"headerlink\" title=\"创建快照的办法有以下几种：\"></a>创建快照的办法有以下几种：</h4><ol>\n<li>客户端通过向redis发送<strong>BGSAVE</strong>命令来创建一个快照。redis会调用fork来创建一个子进程，然后子进程负责将快照写入硬盘，而父进程则继续处理命令请求。</li>\n<li>客户端向redis发送<strong>SAVE</strong>命令，接受到该命令的redis服务器在创建快照完毕之前不再响应任何其他命令。SAVE命令并不常用，通常只在没有足够内存去执行BGSAVE命令的情况下，或者可以忍受SAVE命令执行完毕的等待情况下。才使用这个命令</li>\n<li>设置save配置选项，比如save 60 1000。那么redis当”60秒内有1000次写入”这个条件满足是，会自动触发BGSAVE。save配置可以有多个，只要触发其中一个就会触发BGSAVE</li>\n<li>当redis收到SHUTDOWN命令关闭服务器时，会执行一个SAVE命令，并且不在处理任何客户端请求。SAVE命令之后关闭服务器。</li>\n<li>当redis服务器连接另一个reids服务器，通过向对方发送SYNC命令来开始复制操作，这时候主服务器会执行BGSAVE命令。</li>\n</ol>\n<h5 id=\"当只使用快照来持久化保存数据时，系统发生崩溃时，将丢失最近一次生成快照之后更改的所有数据。\"><a href=\"#当只使用快照来持久化保存数据时，系统发生崩溃时，将丢失最近一次生成快照之后更改的所有数据。\" class=\"headerlink\" title=\"当只使用快照来持久化保存数据时，系统发生崩溃时，将丢失最近一次生成快照之后更改的所有数据。\"></a>当只使用快照来持久化保存数据时，系统发生崩溃时，将丢失最近一次生成快照之后更改的所有数据。</h5><h5 id=\"为了防止reids因为创建子进程而出现停顿，我们可以考虑关闭自动保存，转而通过手动发送BGSAVE或者SAVE来进行持久化。手动BGSAVE一样会引起停顿，唯一不同的是用户可以通过手动控制停顿出现的时间。另外，虽然SAVE会一直阻塞redis直到快照生成完毕，但是因为不需要创建子进程，所以就不会像BGSAVE一样导致reis停顿。没有子进程争抢资源，SAVE操作会比BGSAVE创建快照的速度快一些。\"><a href=\"#为了防止reids因为创建子进程而出现停顿，我们可以考虑关闭自动保存，转而通过手动发送BGSAVE或者SAVE来进行持久化。手动BGSAVE一样会引起停顿，唯一不同的是用户可以通过手动控制停顿出现的时间。另外，虽然SAVE会一直阻塞redis直到快照生成完毕，但是因为不需要创建子进程，所以就不会像BGSAVE一样导致reis停顿。没有子进程争抢资源，SAVE操作会比BGSAVE创建快照的速度快一些。\" class=\"headerlink\" title=\"为了防止reids因为创建子进程而出现停顿，我们可以考虑关闭自动保存，转而通过手动发送BGSAVE或者SAVE来进行持久化。手动BGSAVE一样会引起停顿，唯一不同的是用户可以通过手动控制停顿出现的时间。另外，虽然SAVE会一直阻塞redis直到快照生成完毕，但是因为不需要创建子进程，所以就不会像BGSAVE一样导致reis停顿。没有子进程争抢资源，SAVE操作会比BGSAVE创建快照的速度快一些。\"></a>为了防止reids因为创建子进程而出现停顿，我们可以考虑关闭自动保存，转而通过手动发送BGSAVE或者SAVE来进行持久化。手动BGSAVE一样会引起停顿，唯一不同的是用户可以通过手动控制停顿出现的时间。另外，虽然SAVE会一直阻塞redis直到快照生成完毕，但是因为不需要创建子进程，所以就不会像BGSAVE一样导致reis停顿。没有子进程争抢资源，SAVE操作会比BGSAVE创建快照的速度快一些。</h5><h2 id=\"AOF持久化\"><a href=\"#AOF持久化\" class=\"headerlink\" title=\"AOF持久化\"></a>AOF持久化</h2><h5 id=\"AOF持久化将写命令写到文件的末尾，以此来记录数据的变化。所以redis只要从头到尾执行一次AOF文件的命令，就可以恢复数据集。该持久化可以通过设置appendonly-yes选项来打开。而appendfsync配置将影响AOF文件的同步频率：\"><a href=\"#AOF持久化将写命令写到文件的末尾，以此来记录数据的变化。所以redis只要从头到尾执行一次AOF文件的命令，就可以恢复数据集。该持久化可以通过设置appendonly-yes选项来打开。而appendfsync配置将影响AOF文件的同步频率：\" class=\"headerlink\" title=\"AOF持久化将写命令写到文件的末尾，以此来记录数据的变化。所以redis只要从头到尾执行一次AOF文件的命令，就可以恢复数据集。该持久化可以通过设置appendonly yes选项来打开。而appendfsync配置将影响AOF文件的同步频率：\"></a>AOF持久化将写命令写到文件的末尾，以此来记录数据的变化。所以redis只要从头到尾执行一次AOF文件的命令，就可以恢复数据集。该持久化可以通过设置appendonly yes选项来打开。而appendfsync配置将影响AOF文件的同步频率：</h5><ul>\n<li><strong>always</strong> 每个redis写命令都要同步些人硬盘，严重降低redis速度</li>\n<li><strong>everysec</strong> 每秒执行一次同步，将多个写命令同步到硬盘</li>\n<li><strong>no</strong> 让操作系统来决定何时进行同步</li>\n</ul>\n<h5 id=\"如果使用appendfsyne-always选项的话，每个写命令都会被写入硬盘，这样可以将系统崩溃时出现的数据丢失减少到最小。但是这种同步策略要对硬盘进行大量的写入，导致redis的处理速度受到限制。\"><a href=\"#如果使用appendfsyne-always选项的话，每个写命令都会被写入硬盘，这样可以将系统崩溃时出现的数据丢失减少到最小。但是这种同步策略要对硬盘进行大量的写入，导致redis的处理速度受到限制。\" class=\"headerlink\" title=\"如果使用appendfsyne always选项的话，每个写命令都会被写入硬盘，这样可以将系统崩溃时出现的数据丢失减少到最小。但是这种同步策略要对硬盘进行大量的写入，导致redis的处理速度受到限制。\"></a>如果使用appendfsyne always选项的话，每个写命令都会被写入硬盘，这样可以将系统崩溃时出现的数据丢失减少到最小。但是这种同步策略要对硬盘进行大量的写入，导致redis的处理速度受到限制。</h5><h5 id=\"为了兼顾安全和性能，可以考虑使用everysec选项。redis每秒同步一次AOF对redis的性能不会有大的影响。即使系统崩溃，也只是丢失了一秒内的数据。\"><a href=\"#为了兼顾安全和性能，可以考虑使用everysec选项。redis每秒同步一次AOF对redis的性能不会有大的影响。即使系统崩溃，也只是丢失了一秒内的数据。\" class=\"headerlink\" title=\"为了兼顾安全和性能，可以考虑使用everysec选项。redis每秒同步一次AOF对redis的性能不会有大的影响。即使系统崩溃，也只是丢失了一秒内的数据。\"></a>为了兼顾安全和性能，可以考虑使用everysec选项。redis每秒同步一次AOF对redis的性能不会有大的影响。即使系统崩溃，也只是丢失了一秒内的数据。</h5><h5 id=\"如果用户使用appendfsync-no选项，那么reids不对AOF文件执行显示的同步操作，而是由操作系统来决定什么时候进行同步。一般情况下不建议使用。因为可能导致缓冲区被等待写入数据填满，redis将会阻塞之后的写入请求。\"><a href=\"#如果用户使用appendfsync-no选项，那么reids不对AOF文件执行显示的同步操作，而是由操作系统来决定什么时候进行同步。一般情况下不建议使用。因为可能导致缓冲区被等待写入数据填满，redis将会阻塞之后的写入请求。\" class=\"headerlink\" title=\"如果用户使用appendfsync no选项，那么reids不对AOF文件执行显示的同步操作，而是由操作系统来决定什么时候进行同步。一般情况下不建议使用。因为可能导致缓冲区被等待写入数据填满，redis将会阻塞之后的写入请求。\"></a>如果用户使用appendfsync no选项，那么reids不对AOF文件执行显示的同步操作，而是由操作系统来决定什么时候进行同步。一般情况下不建议使用。因为可能导致缓冲区被等待写入数据填满，redis将会阻塞之后的写入请求。</h5>","site":{"data":{}},"excerpt":"","more":"<h5 id=\"Redis提供了两种不同的持久化方式。一种叫做快照（snapshotting），另一种叫做只追加文件（append-only-file，AOF）。这两种方式可以同时使用，也可以单独使用。\"><a href=\"#Redis提供了两种不同的持久化方式。一种叫做快照（snapshotting），另一种叫做只追加文件（append-only-file，AOF）。这两种方式可以同时使用，也可以单独使用。\" class=\"headerlink\" title=\"Redis提供了两种不同的持久化方式。一种叫做快照（snapshotting），另一种叫做只追加文件（append-only file，AOF）。这两种方式可以同时使用，也可以单独使用。\"></a>Redis提供了两种不同的持久化方式。一种叫做快照（snapshotting），另一种叫做只追加文件（append-only file，AOF）。这两种方式可以同时使用，也可以单独使用。</h5><h2 id=\"快照持久化\"><a href=\"#快照持久化\" class=\"headerlink\" title=\"快照持久化\"></a>快照持久化</h2><h5 id=\"redis可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。在创建快照之后，用户可以对快照进行备份。\"><a href=\"#redis可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。在创建快照之后，用户可以对快照进行备份。\" class=\"headerlink\" title=\"redis可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。在创建快照之后，用户可以对快照进行备份。\"></a>redis可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。在创建快照之后，用户可以对快照进行备份。</h5><h4 id=\"创建快照的办法有以下几种：\"><a href=\"#创建快照的办法有以下几种：\" class=\"headerlink\" title=\"创建快照的办法有以下几种：\"></a>创建快照的办法有以下几种：</h4><ol>\n<li>客户端通过向redis发送<strong>BGSAVE</strong>命令来创建一个快照。redis会调用fork来创建一个子进程，然后子进程负责将快照写入硬盘，而父进程则继续处理命令请求。</li>\n<li>客户端向redis发送<strong>SAVE</strong>命令，接受到该命令的redis服务器在创建快照完毕之前不再响应任何其他命令。SAVE命令并不常用，通常只在没有足够内存去执行BGSAVE命令的情况下，或者可以忍受SAVE命令执行完毕的等待情况下。才使用这个命令</li>\n<li>设置save配置选项，比如save 60 1000。那么redis当”60秒内有1000次写入”这个条件满足是，会自动触发BGSAVE。save配置可以有多个，只要触发其中一个就会触发BGSAVE</li>\n<li>当redis收到SHUTDOWN命令关闭服务器时，会执行一个SAVE命令，并且不在处理任何客户端请求。SAVE命令之后关闭服务器。</li>\n<li>当redis服务器连接另一个reids服务器，通过向对方发送SYNC命令来开始复制操作，这时候主服务器会执行BGSAVE命令。</li>\n</ol>\n<h5 id=\"当只使用快照来持久化保存数据时，系统发生崩溃时，将丢失最近一次生成快照之后更改的所有数据。\"><a href=\"#当只使用快照来持久化保存数据时，系统发生崩溃时，将丢失最近一次生成快照之后更改的所有数据。\" class=\"headerlink\" title=\"当只使用快照来持久化保存数据时，系统发生崩溃时，将丢失最近一次生成快照之后更改的所有数据。\"></a>当只使用快照来持久化保存数据时，系统发生崩溃时，将丢失最近一次生成快照之后更改的所有数据。</h5><h5 id=\"为了防止reids因为创建子进程而出现停顿，我们可以考虑关闭自动保存，转而通过手动发送BGSAVE或者SAVE来进行持久化。手动BGSAVE一样会引起停顿，唯一不同的是用户可以通过手动控制停顿出现的时间。另外，虽然SAVE会一直阻塞redis直到快照生成完毕，但是因为不需要创建子进程，所以就不会像BGSAVE一样导致reis停顿。没有子进程争抢资源，SAVE操作会比BGSAVE创建快照的速度快一些。\"><a href=\"#为了防止reids因为创建子进程而出现停顿，我们可以考虑关闭自动保存，转而通过手动发送BGSAVE或者SAVE来进行持久化。手动BGSAVE一样会引起停顿，唯一不同的是用户可以通过手动控制停顿出现的时间。另外，虽然SAVE会一直阻塞redis直到快照生成完毕，但是因为不需要创建子进程，所以就不会像BGSAVE一样导致reis停顿。没有子进程争抢资源，SAVE操作会比BGSAVE创建快照的速度快一些。\" class=\"headerlink\" title=\"为了防止reids因为创建子进程而出现停顿，我们可以考虑关闭自动保存，转而通过手动发送BGSAVE或者SAVE来进行持久化。手动BGSAVE一样会引起停顿，唯一不同的是用户可以通过手动控制停顿出现的时间。另外，虽然SAVE会一直阻塞redis直到快照生成完毕，但是因为不需要创建子进程，所以就不会像BGSAVE一样导致reis停顿。没有子进程争抢资源，SAVE操作会比BGSAVE创建快照的速度快一些。\"></a>为了防止reids因为创建子进程而出现停顿，我们可以考虑关闭自动保存，转而通过手动发送BGSAVE或者SAVE来进行持久化。手动BGSAVE一样会引起停顿，唯一不同的是用户可以通过手动控制停顿出现的时间。另外，虽然SAVE会一直阻塞redis直到快照生成完毕，但是因为不需要创建子进程，所以就不会像BGSAVE一样导致reis停顿。没有子进程争抢资源，SAVE操作会比BGSAVE创建快照的速度快一些。</h5><h2 id=\"AOF持久化\"><a href=\"#AOF持久化\" class=\"headerlink\" title=\"AOF持久化\"></a>AOF持久化</h2><h5 id=\"AOF持久化将写命令写到文件的末尾，以此来记录数据的变化。所以redis只要从头到尾执行一次AOF文件的命令，就可以恢复数据集。该持久化可以通过设置appendonly-yes选项来打开。而appendfsync配置将影响AOF文件的同步频率：\"><a href=\"#AOF持久化将写命令写到文件的末尾，以此来记录数据的变化。所以redis只要从头到尾执行一次AOF文件的命令，就可以恢复数据集。该持久化可以通过设置appendonly-yes选项来打开。而appendfsync配置将影响AOF文件的同步频率：\" class=\"headerlink\" title=\"AOF持久化将写命令写到文件的末尾，以此来记录数据的变化。所以redis只要从头到尾执行一次AOF文件的命令，就可以恢复数据集。该持久化可以通过设置appendonly yes选项来打开。而appendfsync配置将影响AOF文件的同步频率：\"></a>AOF持久化将写命令写到文件的末尾，以此来记录数据的变化。所以redis只要从头到尾执行一次AOF文件的命令，就可以恢复数据集。该持久化可以通过设置appendonly yes选项来打开。而appendfsync配置将影响AOF文件的同步频率：</h5><ul>\n<li><strong>always</strong> 每个redis写命令都要同步些人硬盘，严重降低redis速度</li>\n<li><strong>everysec</strong> 每秒执行一次同步，将多个写命令同步到硬盘</li>\n<li><strong>no</strong> 让操作系统来决定何时进行同步</li>\n</ul>\n<h5 id=\"如果使用appendfsyne-always选项的话，每个写命令都会被写入硬盘，这样可以将系统崩溃时出现的数据丢失减少到最小。但是这种同步策略要对硬盘进行大量的写入，导致redis的处理速度受到限制。\"><a href=\"#如果使用appendfsyne-always选项的话，每个写命令都会被写入硬盘，这样可以将系统崩溃时出现的数据丢失减少到最小。但是这种同步策略要对硬盘进行大量的写入，导致redis的处理速度受到限制。\" class=\"headerlink\" title=\"如果使用appendfsyne always选项的话，每个写命令都会被写入硬盘，这样可以将系统崩溃时出现的数据丢失减少到最小。但是这种同步策略要对硬盘进行大量的写入，导致redis的处理速度受到限制。\"></a>如果使用appendfsyne always选项的话，每个写命令都会被写入硬盘，这样可以将系统崩溃时出现的数据丢失减少到最小。但是这种同步策略要对硬盘进行大量的写入，导致redis的处理速度受到限制。</h5><h5 id=\"为了兼顾安全和性能，可以考虑使用everysec选项。redis每秒同步一次AOF对redis的性能不会有大的影响。即使系统崩溃，也只是丢失了一秒内的数据。\"><a href=\"#为了兼顾安全和性能，可以考虑使用everysec选项。redis每秒同步一次AOF对redis的性能不会有大的影响。即使系统崩溃，也只是丢失了一秒内的数据。\" class=\"headerlink\" title=\"为了兼顾安全和性能，可以考虑使用everysec选项。redis每秒同步一次AOF对redis的性能不会有大的影响。即使系统崩溃，也只是丢失了一秒内的数据。\"></a>为了兼顾安全和性能，可以考虑使用everysec选项。redis每秒同步一次AOF对redis的性能不会有大的影响。即使系统崩溃，也只是丢失了一秒内的数据。</h5><h5 id=\"如果用户使用appendfsync-no选项，那么reids不对AOF文件执行显示的同步操作，而是由操作系统来决定什么时候进行同步。一般情况下不建议使用。因为可能导致缓冲区被等待写入数据填满，redis将会阻塞之后的写入请求。\"><a href=\"#如果用户使用appendfsync-no选项，那么reids不对AOF文件执行显示的同步操作，而是由操作系统来决定什么时候进行同步。一般情况下不建议使用。因为可能导致缓冲区被等待写入数据填满，redis将会阻塞之后的写入请求。\" class=\"headerlink\" title=\"如果用户使用appendfsync no选项，那么reids不对AOF文件执行显示的同步操作，而是由操作系统来决定什么时候进行同步。一般情况下不建议使用。因为可能导致缓冲区被等待写入数据填满，redis将会阻塞之后的写入请求。\"></a>如果用户使用appendfsync no选项，那么reids不对AOF文件执行显示的同步操作，而是由操作系统来决定什么时候进行同步。一般情况下不建议使用。因为可能导致缓冲区被等待写入数据填满，redis将会阻塞之后的写入请求。</h5>"},{"layout":"post","title":"redis字符串数据结构","date":"2017-07-04T16:00:00.000Z","tag":[["redis","redis"]],"_content":"\n##### redis是基于C语言的，但是redis没有直接使用C语言的传统字符串，而是自己构建了一种简单动态字符串的抽象类型。简称SDS；\n<!--more-->\n### SDS数据结构\n##### 每个sds.h/sdshdr结构表示一个SDS值：\n```C\nstruct sdshdr{\n\n    //记录buf数组汇总已使用字节的数量，等于SDS所保存字符串的长度\n    int len;\n\n    //记录buf数组中未使用字节的数量\n    int free;\n\n    //字节数组，用于保存字符串\n    char buf[];\n}\n```\n##### SDS结构实例：\n![SDS实例](/img/note/redisString.png) <div class='img-note'>SDS实例</div>\n\n1. free属性的值为0，表示SDS没有未使用空间。\n2. len的属性值为5，表示这个SDS保存了一个5字节长的字符串。\n3. buf属性是一个char数组，保存了redis五个字符\n\n##### SDS遵循C字符串以空字符结尾的惯例，该空字符的1字节空间不计算在SDS的len属性里面。并且添加空字符到字符串末尾的操作，是由SDS函数自动完成的。之所以保留这空字符结尾的好处是，SDS可以重用一部分C字符串函数库里面的函数。\n\n### SDS与C字符串的区别\n#### 常数复杂度获取字符串长度\n##### 因为C字符串不记录自身的长度，所以获取一个C字符串的长度，需要遍历整个字符串，直到遇到空字符为止，复杂度为O(N)。而redis的SDS只需要读取len字段就可以知道其字符串长度，复杂度为O(1)。更新和设置SDS的长度是API自动完成的。\n##### 虽然这种操作SDS的数据结构能够很好的提高效率，但是作为代价，SDS维护这些信息的时候也是需要成本的。只是这种代价所带来的好处是值得的。\n\n","source":"_posts/note/redis/redisString.md","raw":"---\nlayout: post\ntitle: redis字符串数据结构\ndate: 2017/07/05\ntags: [tech, index, redis]\ntag: [[redis, redis]]\n---\n\n##### redis是基于C语言的，但是redis没有直接使用C语言的传统字符串，而是自己构建了一种简单动态字符串的抽象类型。简称SDS；\n<!--more-->\n### SDS数据结构\n##### 每个sds.h/sdshdr结构表示一个SDS值：\n```C\nstruct sdshdr{\n\n    //记录buf数组汇总已使用字节的数量，等于SDS所保存字符串的长度\n    int len;\n\n    //记录buf数组中未使用字节的数量\n    int free;\n\n    //字节数组，用于保存字符串\n    char buf[];\n}\n```\n##### SDS结构实例：\n![SDS实例](/img/note/redisString.png) <div class='img-note'>SDS实例</div>\n\n1. free属性的值为0，表示SDS没有未使用空间。\n2. len的属性值为5，表示这个SDS保存了一个5字节长的字符串。\n3. buf属性是一个char数组，保存了redis五个字符\n\n##### SDS遵循C字符串以空字符结尾的惯例，该空字符的1字节空间不计算在SDS的len属性里面。并且添加空字符到字符串末尾的操作，是由SDS函数自动完成的。之所以保留这空字符结尾的好处是，SDS可以重用一部分C字符串函数库里面的函数。\n\n### SDS与C字符串的区别\n#### 常数复杂度获取字符串长度\n##### 因为C字符串不记录自身的长度，所以获取一个C字符串的长度，需要遍历整个字符串，直到遇到空字符为止，复杂度为O(N)。而redis的SDS只需要读取len字段就可以知道其字符串长度，复杂度为O(1)。更新和设置SDS的长度是API自动完成的。\n##### 虽然这种操作SDS的数据结构能够很好的提高效率，但是作为代价，SDS维护这些信息的时候也是需要成本的。只是这种代价所带来的好处是值得的。\n\n","slug":"note/redis/redisString","published":1,"updated":"2018-05-08T13:00:14.281Z","comments":1,"photos":[],"link":"","_id":"cjgxop3ns003zjah16xz95wa6","content":"<h5 id=\"redis是基于C语言的，但是redis没有直接使用C语言的传统字符串，而是自己构建了一种简单动态字符串的抽象类型。简称SDS；\"><a href=\"#redis是基于C语言的，但是redis没有直接使用C语言的传统字符串，而是自己构建了一种简单动态字符串的抽象类型。简称SDS；\" class=\"headerlink\" title=\"redis是基于C语言的，但是redis没有直接使用C语言的传统字符串，而是自己构建了一种简单动态字符串的抽象类型。简称SDS；\"></a>redis是基于C语言的，但是redis没有直接使用C语言的传统字符串，而是自己构建了一种简单动态字符串的抽象类型。简称SDS；</h5><a id=\"more\"></a>\n<h3 id=\"SDS数据结构\"><a href=\"#SDS数据结构\" class=\"headerlink\" title=\"SDS数据结构\"></a>SDS数据结构</h3><h5 id=\"每个sds-h-sdshdr结构表示一个SDS值：\"><a href=\"#每个sds-h-sdshdr结构表示一个SDS值：\" class=\"headerlink\" title=\"每个sds.h/sdshdr结构表示一个SDS值：\"></a>每个sds.h/sdshdr结构表示一个SDS值：</h5><pre><code class=\"lang-C\">struct sdshdr{\n\n    //记录buf数组汇总已使用字节的数量，等于SDS所保存字符串的长度\n    int len;\n\n    //记录buf数组中未使用字节的数量\n    int free;\n\n    //字节数组，用于保存字符串\n    char buf[];\n}\n</code></pre>\n<h5 id=\"SDS结构实例：\"><a href=\"#SDS结构实例：\" class=\"headerlink\" title=\"SDS结构实例：\"></a>SDS结构实例：</h5><p><img src=\"/img/note/redisString.png\" alt=\"SDS实例\"> <div class=\"img-note\">SDS实例</div></p>\n<ol>\n<li>free属性的值为0，表示SDS没有未使用空间。</li>\n<li>len的属性值为5，表示这个SDS保存了一个5字节长的字符串。</li>\n<li>buf属性是一个char数组，保存了redis五个字符</li>\n</ol>\n<h5 id=\"SDS遵循C字符串以空字符结尾的惯例，该空字符的1字节空间不计算在SDS的len属性里面。并且添加空字符到字符串末尾的操作，是由SDS函数自动完成的。之所以保留这空字符结尾的好处是，SDS可以重用一部分C字符串函数库里面的函数。\"><a href=\"#SDS遵循C字符串以空字符结尾的惯例，该空字符的1字节空间不计算在SDS的len属性里面。并且添加空字符到字符串末尾的操作，是由SDS函数自动完成的。之所以保留这空字符结尾的好处是，SDS可以重用一部分C字符串函数库里面的函数。\" class=\"headerlink\" title=\"SDS遵循C字符串以空字符结尾的惯例，该空字符的1字节空间不计算在SDS的len属性里面。并且添加空字符到字符串末尾的操作，是由SDS函数自动完成的。之所以保留这空字符结尾的好处是，SDS可以重用一部分C字符串函数库里面的函数。\"></a>SDS遵循C字符串以空字符结尾的惯例，该空字符的1字节空间不计算在SDS的len属性里面。并且添加空字符到字符串末尾的操作，是由SDS函数自动完成的。之所以保留这空字符结尾的好处是，SDS可以重用一部分C字符串函数库里面的函数。</h5><h3 id=\"SDS与C字符串的区别\"><a href=\"#SDS与C字符串的区别\" class=\"headerlink\" title=\"SDS与C字符串的区别\"></a>SDS与C字符串的区别</h3><h4 id=\"常数复杂度获取字符串长度\"><a href=\"#常数复杂度获取字符串长度\" class=\"headerlink\" title=\"常数复杂度获取字符串长度\"></a>常数复杂度获取字符串长度</h4><h5 id=\"因为C字符串不记录自身的长度，所以获取一个C字符串的长度，需要遍历整个字符串，直到遇到空字符为止，复杂度为O-N-。而redis的SDS只需要读取len字段就可以知道其字符串长度，复杂度为O-1-。更新和设置SDS的长度是API自动完成的。\"><a href=\"#因为C字符串不记录自身的长度，所以获取一个C字符串的长度，需要遍历整个字符串，直到遇到空字符为止，复杂度为O-N-。而redis的SDS只需要读取len字段就可以知道其字符串长度，复杂度为O-1-。更新和设置SDS的长度是API自动完成的。\" class=\"headerlink\" title=\"因为C字符串不记录自身的长度，所以获取一个C字符串的长度，需要遍历整个字符串，直到遇到空字符为止，复杂度为O(N)。而redis的SDS只需要读取len字段就可以知道其字符串长度，复杂度为O(1)。更新和设置SDS的长度是API自动完成的。\"></a>因为C字符串不记录自身的长度，所以获取一个C字符串的长度，需要遍历整个字符串，直到遇到空字符为止，复杂度为O(N)。而redis的SDS只需要读取len字段就可以知道其字符串长度，复杂度为O(1)。更新和设置SDS的长度是API自动完成的。</h5><h5 id=\"虽然这种操作SDS的数据结构能够很好的提高效率，但是作为代价，SDS维护这些信息的时候也是需要成本的。只是这种代价所带来的好处是值得的。\"><a href=\"#虽然这种操作SDS的数据结构能够很好的提高效率，但是作为代价，SDS维护这些信息的时候也是需要成本的。只是这种代价所带来的好处是值得的。\" class=\"headerlink\" title=\"虽然这种操作SDS的数据结构能够很好的提高效率，但是作为代价，SDS维护这些信息的时候也是需要成本的。只是这种代价所带来的好处是值得的。\"></a>虽然这种操作SDS的数据结构能够很好的提高效率，但是作为代价，SDS维护这些信息的时候也是需要成本的。只是这种代价所带来的好处是值得的。</h5>","site":{"data":{}},"excerpt":"<h5 id=\"redis是基于C语言的，但是redis没有直接使用C语言的传统字符串，而是自己构建了一种简单动态字符串的抽象类型。简称SDS；\"><a href=\"#redis是基于C语言的，但是redis没有直接使用C语言的传统字符串，而是自己构建了一种简单动态字符串的抽象类型。简称SDS；\" class=\"headerlink\" title=\"redis是基于C语言的，但是redis没有直接使用C语言的传统字符串，而是自己构建了一种简单动态字符串的抽象类型。简称SDS；\"></a>redis是基于C语言的，但是redis没有直接使用C语言的传统字符串，而是自己构建了一种简单动态字符串的抽象类型。简称SDS；</h5>","more":"<h3 id=\"SDS数据结构\"><a href=\"#SDS数据结构\" class=\"headerlink\" title=\"SDS数据结构\"></a>SDS数据结构</h3><h5 id=\"每个sds-h-sdshdr结构表示一个SDS值：\"><a href=\"#每个sds-h-sdshdr结构表示一个SDS值：\" class=\"headerlink\" title=\"每个sds.h/sdshdr结构表示一个SDS值：\"></a>每个sds.h/sdshdr结构表示一个SDS值：</h5><pre><code class=\"lang-C\">struct sdshdr{\n\n    //记录buf数组汇总已使用字节的数量，等于SDS所保存字符串的长度\n    int len;\n\n    //记录buf数组中未使用字节的数量\n    int free;\n\n    //字节数组，用于保存字符串\n    char buf[];\n}\n</code></pre>\n<h5 id=\"SDS结构实例：\"><a href=\"#SDS结构实例：\" class=\"headerlink\" title=\"SDS结构实例：\"></a>SDS结构实例：</h5><p><img src=\"/img/note/redisString.png\" alt=\"SDS实例\"> <div class=\"img-note\">SDS实例</div></p>\n<ol>\n<li>free属性的值为0，表示SDS没有未使用空间。</li>\n<li>len的属性值为5，表示这个SDS保存了一个5字节长的字符串。</li>\n<li>buf属性是一个char数组，保存了redis五个字符</li>\n</ol>\n<h5 id=\"SDS遵循C字符串以空字符结尾的惯例，该空字符的1字节空间不计算在SDS的len属性里面。并且添加空字符到字符串末尾的操作，是由SDS函数自动完成的。之所以保留这空字符结尾的好处是，SDS可以重用一部分C字符串函数库里面的函数。\"><a href=\"#SDS遵循C字符串以空字符结尾的惯例，该空字符的1字节空间不计算在SDS的len属性里面。并且添加空字符到字符串末尾的操作，是由SDS函数自动完成的。之所以保留这空字符结尾的好处是，SDS可以重用一部分C字符串函数库里面的函数。\" class=\"headerlink\" title=\"SDS遵循C字符串以空字符结尾的惯例，该空字符的1字节空间不计算在SDS的len属性里面。并且添加空字符到字符串末尾的操作，是由SDS函数自动完成的。之所以保留这空字符结尾的好处是，SDS可以重用一部分C字符串函数库里面的函数。\"></a>SDS遵循C字符串以空字符结尾的惯例，该空字符的1字节空间不计算在SDS的len属性里面。并且添加空字符到字符串末尾的操作，是由SDS函数自动完成的。之所以保留这空字符结尾的好处是，SDS可以重用一部分C字符串函数库里面的函数。</h5><h3 id=\"SDS与C字符串的区别\"><a href=\"#SDS与C字符串的区别\" class=\"headerlink\" title=\"SDS与C字符串的区别\"></a>SDS与C字符串的区别</h3><h4 id=\"常数复杂度获取字符串长度\"><a href=\"#常数复杂度获取字符串长度\" class=\"headerlink\" title=\"常数复杂度获取字符串长度\"></a>常数复杂度获取字符串长度</h4><h5 id=\"因为C字符串不记录自身的长度，所以获取一个C字符串的长度，需要遍历整个字符串，直到遇到空字符为止，复杂度为O-N-。而redis的SDS只需要读取len字段就可以知道其字符串长度，复杂度为O-1-。更新和设置SDS的长度是API自动完成的。\"><a href=\"#因为C字符串不记录自身的长度，所以获取一个C字符串的长度，需要遍历整个字符串，直到遇到空字符为止，复杂度为O-N-。而redis的SDS只需要读取len字段就可以知道其字符串长度，复杂度为O-1-。更新和设置SDS的长度是API自动完成的。\" class=\"headerlink\" title=\"因为C字符串不记录自身的长度，所以获取一个C字符串的长度，需要遍历整个字符串，直到遇到空字符为止，复杂度为O(N)。而redis的SDS只需要读取len字段就可以知道其字符串长度，复杂度为O(1)。更新和设置SDS的长度是API自动完成的。\"></a>因为C字符串不记录自身的长度，所以获取一个C字符串的长度，需要遍历整个字符串，直到遇到空字符为止，复杂度为O(N)。而redis的SDS只需要读取len字段就可以知道其字符串长度，复杂度为O(1)。更新和设置SDS的长度是API自动完成的。</h5><h5 id=\"虽然这种操作SDS的数据结构能够很好的提高效率，但是作为代价，SDS维护这些信息的时候也是需要成本的。只是这种代价所带来的好处是值得的。\"><a href=\"#虽然这种操作SDS的数据结构能够很好的提高效率，但是作为代价，SDS维护这些信息的时候也是需要成本的。只是这种代价所带来的好处是值得的。\" class=\"headerlink\" title=\"虽然这种操作SDS的数据结构能够很好的提高效率，但是作为代价，SDS维护这些信息的时候也是需要成本的。只是这种代价所带来的好处是值得的。\"></a>虽然这种操作SDS的数据结构能够很好的提高效率，但是作为代价，SDS维护这些信息的时候也是需要成本的。只是这种代价所带来的好处是值得的。</h5>"},{"layout":"post","title":"redis事务","date":"2018-04-07T16:00:00.000Z","tag":[["redis","redis"]],"_content":"\n##### MULTI 、 EXEC 、 DISCARD 和 WATCH 是 Redis 事务相关的命令。事务可以一次执行多个命令， 并且带有以下两个重要的保证：\n* 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。\n* 事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。\n<!--more-->\n\n## 相关命令\n### MULTI\n##### 用于标记事务块的开始。Redis会将后续的命令逐个放入队列中，然后才能使用EXEC命令原子化地执行这个命令序列。\n```redis\n127.0.0.1:6379> multi\nOK\n```\n\n### EXEC\n##### 当客户端处于事务状态时，所有传入的命令都会返回一个内容为 QUEUED 的状态回复（status reply）， 这些被入队的命令将在 EXEC 命令被调用时执行。然后恢复正常的连接状态。\n##### 当使用WATCH命令时，只有当受监控的键没有被修改时，EXEC命令才会执行事务中的命令，这种方式利用了检查再设置（CAS）的机制。\n```redis\n127.0.0.1:6379> multi\nOK\n127.0.0.1:6379> set name winx\nQUEUED\n127.0.0.1:6379> get name\nQUEUED\n127.0.0.1:6379> exec\n1) OK\n2) \"winx\"\n```\n\n### DISCARD\n##### 清除所有先前在一个事务中放入队列的命令，然后恢复正常的连接状态。\n##### 如果使用了WATCH命令，那么DISCARD命令就会将当前连接监控的所有键取消监控。\n```redis\n127.0.0.1:6379> multi\nOK\n127.0.0.1:6379> set name winx1\nQUEUED\n127.0.0.1:6379> DISCARD\nOK\n127.0.0.1:6379> get name\n\"winx\"\n```\n### WATCH\n##### WATCH 使得 EXEC 命令需要有条件地执行：事务只能在所有被监视键都没有被修改的前提下执行， 如果这个前提不能满足的话，事务就不会被执行。\n#### 客户端1\n```redis\n127.0.0.1:6379> watch name\nOK\n127.0.0.1:6379> set name winx1\nOK\n127.0.0.1:6379> multi\nOK\n127.0.0.1:6379> set name winx\nQUEUED\n```\n\n#### 客户端2\n```redis\n127.0.0.1:6379> get name\n\"winx1\"\n127.0.0.1:6379> set name winx2\nOK\n```\n\n#### 客户端1\n```redis\n127.0.0.1:6379> get name\nQUEUED\n127.0.0.1:6379> exec\n(nil)\n```\n##### 可以看到客户端1监听了name，然后执行事务，在事务提交之前客户端2修改了name值，结果客户端1提交事务后返回`(nil)`结果。\n\n### UNWATCH\n##### 清除所有先前为一个事务监控的键。如果你调用了EXEC或DISCARD命令，那么就不需要手动调用UNWATCH命令。\n\n##### 如果客户端在使用 MULTI 开启了一个事务之后，却因为断线而没有成功执行 EXEC ，那么事务中的所有命令都不会被执行。另一方面，如果客户端成功在开启事务之后执行 EXEC ，那么事务中的所有命令都会被执行。当使用 AOF 方式做持久化的时候， Redis 会使用单个 write(2) 命令将事务写入到磁盘中。然而，如果 Redis 服务器因为某些原因被管理员杀死，或者遇上某种硬件故障，那么可能只有部分事务命令会被成功写入到磁盘中。如果 Redis 在重新启动时发现 AOF 文件出了这样的问题，那么它会退出，并汇报一个错误。使用redis-check-aof程序可以修复这一问题：它会移除 AOF 文件中不完整事务的信息，确保服务器可以顺利启动。\n\n## 事务中的错误\n##### 使用事务时可能会遇上以下两种错误：\n* 事务在执行 EXEC 之前，入队的命令可能会出错。比如说，命令可能会产生语法错误（参数数量错误，参数名错误，等等），或者其他更严重的错误，比如内存不足（如果服务器使用 maxmemory 设置了最大内存限制的话）。\n* 命令可能在 EXEC 调用之后失败。举个例子，事务中的命令可能处理了错误类型的键，比如将列表命令用在了字符串键上面，诸如此类。\n对于发生在 EXEC 执行之前的错误，客户端以前的做法是检查命令入队所得的返回值：如果命令入队时返回 QUEUED ，那么入队成功；否则，就是入队失败。如果有命令在入队时失败，那么大部分客户端都会停止并取消这个事务。\n\n##### 从 Redis 2.6.5 开始，服务器会对命令入队失败的情况进行记录，并在客户端调用 EXEC 命令时，拒绝执行并自动放弃这个事务。\n##### 在 Redis 2.6.5 以前， Redis 只执行事务中那些入队成功的命令，而忽略那些入队失败的命令。 而新的处理方式则使得在流水线（pipeline）中包含事务变得简单，因为发送事务和读取事务的回复都只需要和服务器进行一次通讯。\n##### 至于那些在 EXEC 命令执行之后所产生的错误， 并没有对它们进行特别处理： 即使事务中有某个/某些命令在执行时产生了错误， 事务中的其他命令仍然会继续执行。\n\n##### 从协议的角度来看这个问题，会更容易理解一些。 以下例子中， LPOP 命令的执行将出错， 尽管调用它的语法是正确的：\n```redis\n127.0.0.1:6379> multi\nOK\n127.0.0.1:6379> set name winx\nQUEUED\n127.0.0.1:6379> lpop name\nQUEUED\n127.0.0.1:6379> exec\n1) OK\n2) (error) WRONGTYPE Operation against a key holding the wrong kind of value\n```\n##### 最重要的是记住这样一条， 即使事务中有某条/某些命令执行失败了， 事务队列中的其他命令仍然会继续执行 —— Redis 不会停止执行事务中的命令。\n\n##### 以下例子展示的是另一种情况， 当命令在入队时产生错误， 错误会立即被返回给客户端：\n```reids\n127.0.0.1:6379> multi\nOK\n127.0.0.1:6379> INCR name name1\n(error) ERR wrong number of arguments for 'incr' command\n127.0.0.1:6379> get name\nQUEUED\n127.0.0.1:6379> exec\n(error) EXECABORT Transaction discarded because of previous errors.\n```\n##### 因为调用 INCR 命令的参数格式不正确， 所以这个 INCR 命令入队失败。\n\n### 为什么 Redis 不支持回滚（roll back）\n##### 如果你有使用关系式数据库的经验， 那么 “Redis 在事务失败时不进行回滚，而是继续执行余下的命令”这种做法可能会让你觉得有点奇怪。\n\n#### 以下是这种做法的优点：\n1. Redis 命令只会因为错误的语法而失败（并且这些问题不能在入队时发现），或是命令用在了错误类型的键上面：这也就是说，从实用性的角度来说，失败的命令是由编程错误造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中。\n2. 因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。\n\n## 使用 check-and-set(cas)操作实现乐观锁\n##### WATCH 命令可以为 Redis 事务提供 check-and-set （CAS）行为。\n##### 被 WATCH 的键会被监视，并会发觉这些键是否被改动过了。 如果有至少一个被监视的键在 EXEC 执行之前被修改了， 那么整个事务都会被取消， EXEC 返回nil-reply来表示事务已经失败。\n\n##### 举个例子， 假设我们需要原子性地为某个值进行增 1 操作（假设 INCR 不存在）。\n\n#### 首先我们可能会这样做：\n```\nval = GET mykey\nval = val + 1\nSET mykey $val\n```\n##### 上面的这个实现在只有一个客户端的时候可以执行得很好。但是，当多个客户端同时对同一个键进行这样的操作时，就会产生竞争条件。举个例子， 如果客户端 A 和 B 都读取了键原来的值，比如10，那么两个客户端都会将键的值设为11，但正确的结果应该是12才对。\n\n#### 有了 WATCH ， 我们就可以轻松地解决这类问题了：\n```\nWATCH mykey\nval = GET mykey\nval = val + 1\nMULTI\nSET mykey $val\nEXEC\n```\n##### 使用上面的代码， 如果在 WATCH 执行之后， EXEC 执行之前， 有其他客户端修改了 mykey 的值， 那么当前客户端的事务就会失败。 程序需要做的， 就是不断重试这个操作， 直到没有发生碰撞为止。\n##### 这种形式的锁被称作乐观锁， 它是一种非常强大的锁机制。并且因为大多数情况下，不同的客户端会访问不同的键，碰撞的情况一般都很少， 所以通常并不需要进行重试。\n\n### 了解 WATCH\n##### WATCH 命令可以被调用多次。 对键的监视从 WATCH 执行之后开始生效， 直到调用 EXEC 为止。\n\n##### 用户还可以在单个 WATCH 命令中监视任意多个键， 就像这样：\n```redis\n127.0.0.1:6379> WATCH key1 key2 key3\nOK\n```\n##### 当 EXEC 被调用时， 不管事务是否成功执行， 对所有键的监视都会被取消。\n\n##### 另外， 当客户端断开连接时， 该客户端对键的监视也会被取消。\n\n##### 使用无参数的 UNWATCH 命令可以手动取消对所有键的监视。 对于一些需要改动多个键的事务， 有时候程序需要同时对多个键进行加锁， 然后检查这些键的当前值是否符合程序的要求。 当值达不到要求时， 就可以使用 UNWATCH 命令来取消目前对键的监视， 中途放弃这个事务， 并等待事务的下次尝试。\n\n## Redis 脚本和事务\n##### 从定义上来说， Redis 中的脚本本身就是一种事务， 所以任何在事务里可以完成的事， 在脚本里面也能完成。 并且一般来说， 使用脚本要来得更简单，并且速度更快。\n\n","source":"_posts/note/redis/redisTransaction.md","raw":"---\nlayout: post\ntitle: redis事务\ndate: 2018/04/08\ntags: [tech, index, redis]\ntag: [[redis, redis]]\n---\n\n##### MULTI 、 EXEC 、 DISCARD 和 WATCH 是 Redis 事务相关的命令。事务可以一次执行多个命令， 并且带有以下两个重要的保证：\n* 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。\n* 事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。\n<!--more-->\n\n## 相关命令\n### MULTI\n##### 用于标记事务块的开始。Redis会将后续的命令逐个放入队列中，然后才能使用EXEC命令原子化地执行这个命令序列。\n```redis\n127.0.0.1:6379> multi\nOK\n```\n\n### EXEC\n##### 当客户端处于事务状态时，所有传入的命令都会返回一个内容为 QUEUED 的状态回复（status reply）， 这些被入队的命令将在 EXEC 命令被调用时执行。然后恢复正常的连接状态。\n##### 当使用WATCH命令时，只有当受监控的键没有被修改时，EXEC命令才会执行事务中的命令，这种方式利用了检查再设置（CAS）的机制。\n```redis\n127.0.0.1:6379> multi\nOK\n127.0.0.1:6379> set name winx\nQUEUED\n127.0.0.1:6379> get name\nQUEUED\n127.0.0.1:6379> exec\n1) OK\n2) \"winx\"\n```\n\n### DISCARD\n##### 清除所有先前在一个事务中放入队列的命令，然后恢复正常的连接状态。\n##### 如果使用了WATCH命令，那么DISCARD命令就会将当前连接监控的所有键取消监控。\n```redis\n127.0.0.1:6379> multi\nOK\n127.0.0.1:6379> set name winx1\nQUEUED\n127.0.0.1:6379> DISCARD\nOK\n127.0.0.1:6379> get name\n\"winx\"\n```\n### WATCH\n##### WATCH 使得 EXEC 命令需要有条件地执行：事务只能在所有被监视键都没有被修改的前提下执行， 如果这个前提不能满足的话，事务就不会被执行。\n#### 客户端1\n```redis\n127.0.0.1:6379> watch name\nOK\n127.0.0.1:6379> set name winx1\nOK\n127.0.0.1:6379> multi\nOK\n127.0.0.1:6379> set name winx\nQUEUED\n```\n\n#### 客户端2\n```redis\n127.0.0.1:6379> get name\n\"winx1\"\n127.0.0.1:6379> set name winx2\nOK\n```\n\n#### 客户端1\n```redis\n127.0.0.1:6379> get name\nQUEUED\n127.0.0.1:6379> exec\n(nil)\n```\n##### 可以看到客户端1监听了name，然后执行事务，在事务提交之前客户端2修改了name值，结果客户端1提交事务后返回`(nil)`结果。\n\n### UNWATCH\n##### 清除所有先前为一个事务监控的键。如果你调用了EXEC或DISCARD命令，那么就不需要手动调用UNWATCH命令。\n\n##### 如果客户端在使用 MULTI 开启了一个事务之后，却因为断线而没有成功执行 EXEC ，那么事务中的所有命令都不会被执行。另一方面，如果客户端成功在开启事务之后执行 EXEC ，那么事务中的所有命令都会被执行。当使用 AOF 方式做持久化的时候， Redis 会使用单个 write(2) 命令将事务写入到磁盘中。然而，如果 Redis 服务器因为某些原因被管理员杀死，或者遇上某种硬件故障，那么可能只有部分事务命令会被成功写入到磁盘中。如果 Redis 在重新启动时发现 AOF 文件出了这样的问题，那么它会退出，并汇报一个错误。使用redis-check-aof程序可以修复这一问题：它会移除 AOF 文件中不完整事务的信息，确保服务器可以顺利启动。\n\n## 事务中的错误\n##### 使用事务时可能会遇上以下两种错误：\n* 事务在执行 EXEC 之前，入队的命令可能会出错。比如说，命令可能会产生语法错误（参数数量错误，参数名错误，等等），或者其他更严重的错误，比如内存不足（如果服务器使用 maxmemory 设置了最大内存限制的话）。\n* 命令可能在 EXEC 调用之后失败。举个例子，事务中的命令可能处理了错误类型的键，比如将列表命令用在了字符串键上面，诸如此类。\n对于发生在 EXEC 执行之前的错误，客户端以前的做法是检查命令入队所得的返回值：如果命令入队时返回 QUEUED ，那么入队成功；否则，就是入队失败。如果有命令在入队时失败，那么大部分客户端都会停止并取消这个事务。\n\n##### 从 Redis 2.6.5 开始，服务器会对命令入队失败的情况进行记录，并在客户端调用 EXEC 命令时，拒绝执行并自动放弃这个事务。\n##### 在 Redis 2.6.5 以前， Redis 只执行事务中那些入队成功的命令，而忽略那些入队失败的命令。 而新的处理方式则使得在流水线（pipeline）中包含事务变得简单，因为发送事务和读取事务的回复都只需要和服务器进行一次通讯。\n##### 至于那些在 EXEC 命令执行之后所产生的错误， 并没有对它们进行特别处理： 即使事务中有某个/某些命令在执行时产生了错误， 事务中的其他命令仍然会继续执行。\n\n##### 从协议的角度来看这个问题，会更容易理解一些。 以下例子中， LPOP 命令的执行将出错， 尽管调用它的语法是正确的：\n```redis\n127.0.0.1:6379> multi\nOK\n127.0.0.1:6379> set name winx\nQUEUED\n127.0.0.1:6379> lpop name\nQUEUED\n127.0.0.1:6379> exec\n1) OK\n2) (error) WRONGTYPE Operation against a key holding the wrong kind of value\n```\n##### 最重要的是记住这样一条， 即使事务中有某条/某些命令执行失败了， 事务队列中的其他命令仍然会继续执行 —— Redis 不会停止执行事务中的命令。\n\n##### 以下例子展示的是另一种情况， 当命令在入队时产生错误， 错误会立即被返回给客户端：\n```reids\n127.0.0.1:6379> multi\nOK\n127.0.0.1:6379> INCR name name1\n(error) ERR wrong number of arguments for 'incr' command\n127.0.0.1:6379> get name\nQUEUED\n127.0.0.1:6379> exec\n(error) EXECABORT Transaction discarded because of previous errors.\n```\n##### 因为调用 INCR 命令的参数格式不正确， 所以这个 INCR 命令入队失败。\n\n### 为什么 Redis 不支持回滚（roll back）\n##### 如果你有使用关系式数据库的经验， 那么 “Redis 在事务失败时不进行回滚，而是继续执行余下的命令”这种做法可能会让你觉得有点奇怪。\n\n#### 以下是这种做法的优点：\n1. Redis 命令只会因为错误的语法而失败（并且这些问题不能在入队时发现），或是命令用在了错误类型的键上面：这也就是说，从实用性的角度来说，失败的命令是由编程错误造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中。\n2. 因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。\n\n## 使用 check-and-set(cas)操作实现乐观锁\n##### WATCH 命令可以为 Redis 事务提供 check-and-set （CAS）行为。\n##### 被 WATCH 的键会被监视，并会发觉这些键是否被改动过了。 如果有至少一个被监视的键在 EXEC 执行之前被修改了， 那么整个事务都会被取消， EXEC 返回nil-reply来表示事务已经失败。\n\n##### 举个例子， 假设我们需要原子性地为某个值进行增 1 操作（假设 INCR 不存在）。\n\n#### 首先我们可能会这样做：\n```\nval = GET mykey\nval = val + 1\nSET mykey $val\n```\n##### 上面的这个实现在只有一个客户端的时候可以执行得很好。但是，当多个客户端同时对同一个键进行这样的操作时，就会产生竞争条件。举个例子， 如果客户端 A 和 B 都读取了键原来的值，比如10，那么两个客户端都会将键的值设为11，但正确的结果应该是12才对。\n\n#### 有了 WATCH ， 我们就可以轻松地解决这类问题了：\n```\nWATCH mykey\nval = GET mykey\nval = val + 1\nMULTI\nSET mykey $val\nEXEC\n```\n##### 使用上面的代码， 如果在 WATCH 执行之后， EXEC 执行之前， 有其他客户端修改了 mykey 的值， 那么当前客户端的事务就会失败。 程序需要做的， 就是不断重试这个操作， 直到没有发生碰撞为止。\n##### 这种形式的锁被称作乐观锁， 它是一种非常强大的锁机制。并且因为大多数情况下，不同的客户端会访问不同的键，碰撞的情况一般都很少， 所以通常并不需要进行重试。\n\n### 了解 WATCH\n##### WATCH 命令可以被调用多次。 对键的监视从 WATCH 执行之后开始生效， 直到调用 EXEC 为止。\n\n##### 用户还可以在单个 WATCH 命令中监视任意多个键， 就像这样：\n```redis\n127.0.0.1:6379> WATCH key1 key2 key3\nOK\n```\n##### 当 EXEC 被调用时， 不管事务是否成功执行， 对所有键的监视都会被取消。\n\n##### 另外， 当客户端断开连接时， 该客户端对键的监视也会被取消。\n\n##### 使用无参数的 UNWATCH 命令可以手动取消对所有键的监视。 对于一些需要改动多个键的事务， 有时候程序需要同时对多个键进行加锁， 然后检查这些键的当前值是否符合程序的要求。 当值达不到要求时， 就可以使用 UNWATCH 命令来取消目前对键的监视， 中途放弃这个事务， 并等待事务的下次尝试。\n\n## Redis 脚本和事务\n##### 从定义上来说， Redis 中的脚本本身就是一种事务， 所以任何在事务里可以完成的事， 在脚本里面也能完成。 并且一般来说， 使用脚本要来得更简单，并且速度更快。\n\n","slug":"note/redis/redisTransaction","published":1,"updated":"2018-05-08T13:00:14.281Z","comments":1,"photos":[],"link":"","_id":"cjgxop3nt0041jah123sn7c85","content":"<h5 id=\"MULTI-、-EXEC-、-DISCARD-和-WATCH-是-Redis-事务相关的命令。事务可以一次执行多个命令，-并且带有以下两个重要的保证：\"><a href=\"#MULTI-、-EXEC-、-DISCARD-和-WATCH-是-Redis-事务相关的命令。事务可以一次执行多个命令，-并且带有以下两个重要的保证：\" class=\"headerlink\" title=\"MULTI 、 EXEC 、 DISCARD 和 WATCH 是 Redis 事务相关的命令。事务可以一次执行多个命令， 并且带有以下两个重要的保证：\"></a>MULTI 、 EXEC 、 DISCARD 和 WATCH 是 Redis 事务相关的命令。事务可以一次执行多个命令， 并且带有以下两个重要的保证：</h5><ul>\n<li>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</li>\n<li>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。<a id=\"more\"></a>\n</li>\n</ul>\n<h2 id=\"相关命令\"><a href=\"#相关命令\" class=\"headerlink\" title=\"相关命令\"></a>相关命令</h2><h3 id=\"MULTI\"><a href=\"#MULTI\" class=\"headerlink\" title=\"MULTI\"></a>MULTI</h3><h5 id=\"用于标记事务块的开始。Redis会将后续的命令逐个放入队列中，然后才能使用EXEC命令原子化地执行这个命令序列。\"><a href=\"#用于标记事务块的开始。Redis会将后续的命令逐个放入队列中，然后才能使用EXEC命令原子化地执行这个命令序列。\" class=\"headerlink\" title=\"用于标记事务块的开始。Redis会将后续的命令逐个放入队列中，然后才能使用EXEC命令原子化地执行这个命令序列。\"></a>用于标记事务块的开始。Redis会将后续的命令逐个放入队列中，然后才能使用EXEC命令原子化地执行这个命令序列。</h5><pre><code class=\"lang-redis\">127.0.0.1:6379&gt; multi\nOK\n</code></pre>\n<h3 id=\"EXEC\"><a href=\"#EXEC\" class=\"headerlink\" title=\"EXEC\"></a>EXEC</h3><h5 id=\"当客户端处于事务状态时，所有传入的命令都会返回一个内容为-QUEUED-的状态回复（status-reply），-这些被入队的命令将在-EXEC-命令被调用时执行。然后恢复正常的连接状态。\"><a href=\"#当客户端处于事务状态时，所有传入的命令都会返回一个内容为-QUEUED-的状态回复（status-reply），-这些被入队的命令将在-EXEC-命令被调用时执行。然后恢复正常的连接状态。\" class=\"headerlink\" title=\"当客户端处于事务状态时，所有传入的命令都会返回一个内容为 QUEUED 的状态回复（status reply）， 这些被入队的命令将在 EXEC 命令被调用时执行。然后恢复正常的连接状态。\"></a>当客户端处于事务状态时，所有传入的命令都会返回一个内容为 QUEUED 的状态回复（status reply）， 这些被入队的命令将在 EXEC 命令被调用时执行。然后恢复正常的连接状态。</h5><h5 id=\"当使用WATCH命令时，只有当受监控的键没有被修改时，EXEC命令才会执行事务中的命令，这种方式利用了检查再设置（CAS）的机制。\"><a href=\"#当使用WATCH命令时，只有当受监控的键没有被修改时，EXEC命令才会执行事务中的命令，这种方式利用了检查再设置（CAS）的机制。\" class=\"headerlink\" title=\"当使用WATCH命令时，只有当受监控的键没有被修改时，EXEC命令才会执行事务中的命令，这种方式利用了检查再设置（CAS）的机制。\"></a>当使用WATCH命令时，只有当受监控的键没有被修改时，EXEC命令才会执行事务中的命令，这种方式利用了检查再设置（CAS）的机制。</h5><pre><code class=\"lang-redis\">127.0.0.1:6379&gt; multi\nOK\n127.0.0.1:6379&gt; set name winx\nQUEUED\n127.0.0.1:6379&gt; get name\nQUEUED\n127.0.0.1:6379&gt; exec\n1) OK\n2) &quot;winx&quot;\n</code></pre>\n<h3 id=\"DISCARD\"><a href=\"#DISCARD\" class=\"headerlink\" title=\"DISCARD\"></a>DISCARD</h3><h5 id=\"清除所有先前在一个事务中放入队列的命令，然后恢复正常的连接状态。\"><a href=\"#清除所有先前在一个事务中放入队列的命令，然后恢复正常的连接状态。\" class=\"headerlink\" title=\"清除所有先前在一个事务中放入队列的命令，然后恢复正常的连接状态。\"></a>清除所有先前在一个事务中放入队列的命令，然后恢复正常的连接状态。</h5><h5 id=\"如果使用了WATCH命令，那么DISCARD命令就会将当前连接监控的所有键取消监控。\"><a href=\"#如果使用了WATCH命令，那么DISCARD命令就会将当前连接监控的所有键取消监控。\" class=\"headerlink\" title=\"如果使用了WATCH命令，那么DISCARD命令就会将当前连接监控的所有键取消监控。\"></a>如果使用了WATCH命令，那么DISCARD命令就会将当前连接监控的所有键取消监控。</h5><pre><code class=\"lang-redis\">127.0.0.1:6379&gt; multi\nOK\n127.0.0.1:6379&gt; set name winx1\nQUEUED\n127.0.0.1:6379&gt; DISCARD\nOK\n127.0.0.1:6379&gt; get name\n&quot;winx&quot;\n</code></pre>\n<h3 id=\"WATCH\"><a href=\"#WATCH\" class=\"headerlink\" title=\"WATCH\"></a>WATCH</h3><h5 id=\"WATCH-使得-EXEC-命令需要有条件地执行：事务只能在所有被监视键都没有被修改的前提下执行，-如果这个前提不能满足的话，事务就不会被执行。\"><a href=\"#WATCH-使得-EXEC-命令需要有条件地执行：事务只能在所有被监视键都没有被修改的前提下执行，-如果这个前提不能满足的话，事务就不会被执行。\" class=\"headerlink\" title=\"WATCH 使得 EXEC 命令需要有条件地执行：事务只能在所有被监视键都没有被修改的前提下执行， 如果这个前提不能满足的话，事务就不会被执行。\"></a>WATCH 使得 EXEC 命令需要有条件地执行：事务只能在所有被监视键都没有被修改的前提下执行， 如果这个前提不能满足的话，事务就不会被执行。</h5><h4 id=\"客户端1\"><a href=\"#客户端1\" class=\"headerlink\" title=\"客户端1\"></a>客户端1</h4><pre><code class=\"lang-redis\">127.0.0.1:6379&gt; watch name\nOK\n127.0.0.1:6379&gt; set name winx1\nOK\n127.0.0.1:6379&gt; multi\nOK\n127.0.0.1:6379&gt; set name winx\nQUEUED\n</code></pre>\n<h4 id=\"客户端2\"><a href=\"#客户端2\" class=\"headerlink\" title=\"客户端2\"></a>客户端2</h4><pre><code class=\"lang-redis\">127.0.0.1:6379&gt; get name\n&quot;winx1&quot;\n127.0.0.1:6379&gt; set name winx2\nOK\n</code></pre>\n<h4 id=\"客户端1-1\"><a href=\"#客户端1-1\" class=\"headerlink\" title=\"客户端1\"></a>客户端1</h4><pre><code class=\"lang-redis\">127.0.0.1:6379&gt; get name\nQUEUED\n127.0.0.1:6379&gt; exec\n(nil)\n</code></pre>\n<h5 id=\"可以看到客户端1监听了name，然后执行事务，在事务提交之前客户端2修改了name值，结果客户端1提交事务后返回-nil-结果。\"><a href=\"#可以看到客户端1监听了name，然后执行事务，在事务提交之前客户端2修改了name值，结果客户端1提交事务后返回-nil-结果。\" class=\"headerlink\" title=\"可以看到客户端1监听了name，然后执行事务，在事务提交之前客户端2修改了name值，结果客户端1提交事务后返回(nil)结果。\"></a>可以看到客户端1监听了name，然后执行事务，在事务提交之前客户端2修改了name值，结果客户端1提交事务后返回<code>(nil)</code>结果。</h5><h3 id=\"UNWATCH\"><a href=\"#UNWATCH\" class=\"headerlink\" title=\"UNWATCH\"></a>UNWATCH</h3><h5 id=\"清除所有先前为一个事务监控的键。如果你调用了EXEC或DISCARD命令，那么就不需要手动调用UNWATCH命令。\"><a href=\"#清除所有先前为一个事务监控的键。如果你调用了EXEC或DISCARD命令，那么就不需要手动调用UNWATCH命令。\" class=\"headerlink\" title=\"清除所有先前为一个事务监控的键。如果你调用了EXEC或DISCARD命令，那么就不需要手动调用UNWATCH命令。\"></a>清除所有先前为一个事务监控的键。如果你调用了EXEC或DISCARD命令，那么就不需要手动调用UNWATCH命令。</h5><h5 id=\"如果客户端在使用-MULTI-开启了一个事务之后，却因为断线而没有成功执行-EXEC-，那么事务中的所有命令都不会被执行。另一方面，如果客户端成功在开启事务之后执行-EXEC-，那么事务中的所有命令都会被执行。当使用-AOF-方式做持久化的时候，-Redis-会使用单个-write-2-命令将事务写入到磁盘中。然而，如果-Redis-服务器因为某些原因被管理员杀死，或者遇上某种硬件故障，那么可能只有部分事务命令会被成功写入到磁盘中。如果-Redis-在重新启动时发现-AOF-文件出了这样的问题，那么它会退出，并汇报一个错误。使用redis-check-aof程序可以修复这一问题：它会移除-AOF-文件中不完整事务的信息，确保服务器可以顺利启动。\"><a href=\"#如果客户端在使用-MULTI-开启了一个事务之后，却因为断线而没有成功执行-EXEC-，那么事务中的所有命令都不会被执行。另一方面，如果客户端成功在开启事务之后执行-EXEC-，那么事务中的所有命令都会被执行。当使用-AOF-方式做持久化的时候，-Redis-会使用单个-write-2-命令将事务写入到磁盘中。然而，如果-Redis-服务器因为某些原因被管理员杀死，或者遇上某种硬件故障，那么可能只有部分事务命令会被成功写入到磁盘中。如果-Redis-在重新启动时发现-AOF-文件出了这样的问题，那么它会退出，并汇报一个错误。使用redis-check-aof程序可以修复这一问题：它会移除-AOF-文件中不完整事务的信息，确保服务器可以顺利启动。\" class=\"headerlink\" title=\"如果客户端在使用 MULTI 开启了一个事务之后，却因为断线而没有成功执行 EXEC ，那么事务中的所有命令都不会被执行。另一方面，如果客户端成功在开启事务之后执行 EXEC ，那么事务中的所有命令都会被执行。当使用 AOF 方式做持久化的时候， Redis 会使用单个 write(2) 命令将事务写入到磁盘中。然而，如果 Redis 服务器因为某些原因被管理员杀死，或者遇上某种硬件故障，那么可能只有部分事务命令会被成功写入到磁盘中。如果 Redis 在重新启动时发现 AOF 文件出了这样的问题，那么它会退出，并汇报一个错误。使用redis-check-aof程序可以修复这一问题：它会移除 AOF 文件中不完整事务的信息，确保服务器可以顺利启动。\"></a>如果客户端在使用 MULTI 开启了一个事务之后，却因为断线而没有成功执行 EXEC ，那么事务中的所有命令都不会被执行。另一方面，如果客户端成功在开启事务之后执行 EXEC ，那么事务中的所有命令都会被执行。当使用 AOF 方式做持久化的时候， Redis 会使用单个 write(2) 命令将事务写入到磁盘中。然而，如果 Redis 服务器因为某些原因被管理员杀死，或者遇上某种硬件故障，那么可能只有部分事务命令会被成功写入到磁盘中。如果 Redis 在重新启动时发现 AOF 文件出了这样的问题，那么它会退出，并汇报一个错误。使用redis-check-aof程序可以修复这一问题：它会移除 AOF 文件中不完整事务的信息，确保服务器可以顺利启动。</h5><h2 id=\"事务中的错误\"><a href=\"#事务中的错误\" class=\"headerlink\" title=\"事务中的错误\"></a>事务中的错误</h2><h5 id=\"使用事务时可能会遇上以下两种错误：\"><a href=\"#使用事务时可能会遇上以下两种错误：\" class=\"headerlink\" title=\"使用事务时可能会遇上以下两种错误：\"></a>使用事务时可能会遇上以下两种错误：</h5><ul>\n<li>事务在执行 EXEC 之前，入队的命令可能会出错。比如说，命令可能会产生语法错误（参数数量错误，参数名错误，等等），或者其他更严重的错误，比如内存不足（如果服务器使用 maxmemory 设置了最大内存限制的话）。</li>\n<li>命令可能在 EXEC 调用之后失败。举个例子，事务中的命令可能处理了错误类型的键，比如将列表命令用在了字符串键上面，诸如此类。<br>对于发生在 EXEC 执行之前的错误，客户端以前的做法是检查命令入队所得的返回值：如果命令入队时返回 QUEUED ，那么入队成功；否则，就是入队失败。如果有命令在入队时失败，那么大部分客户端都会停止并取消这个事务。</li>\n</ul>\n<h5 id=\"从-Redis-2-6-5-开始，服务器会对命令入队失败的情况进行记录，并在客户端调用-EXEC-命令时，拒绝执行并自动放弃这个事务。\"><a href=\"#从-Redis-2-6-5-开始，服务器会对命令入队失败的情况进行记录，并在客户端调用-EXEC-命令时，拒绝执行并自动放弃这个事务。\" class=\"headerlink\" title=\"从 Redis 2.6.5 开始，服务器会对命令入队失败的情况进行记录，并在客户端调用 EXEC 命令时，拒绝执行并自动放弃这个事务。\"></a>从 Redis 2.6.5 开始，服务器会对命令入队失败的情况进行记录，并在客户端调用 EXEC 命令时，拒绝执行并自动放弃这个事务。</h5><h5 id=\"在-Redis-2-6-5-以前，-Redis-只执行事务中那些入队成功的命令，而忽略那些入队失败的命令。-而新的处理方式则使得在流水线（pipeline）中包含事务变得简单，因为发送事务和读取事务的回复都只需要和服务器进行一次通讯。\"><a href=\"#在-Redis-2-6-5-以前，-Redis-只执行事务中那些入队成功的命令，而忽略那些入队失败的命令。-而新的处理方式则使得在流水线（pipeline）中包含事务变得简单，因为发送事务和读取事务的回复都只需要和服务器进行一次通讯。\" class=\"headerlink\" title=\"在 Redis 2.6.5 以前， Redis 只执行事务中那些入队成功的命令，而忽略那些入队失败的命令。 而新的处理方式则使得在流水线（pipeline）中包含事务变得简单，因为发送事务和读取事务的回复都只需要和服务器进行一次通讯。\"></a>在 Redis 2.6.5 以前， Redis 只执行事务中那些入队成功的命令，而忽略那些入队失败的命令。 而新的处理方式则使得在流水线（pipeline）中包含事务变得简单，因为发送事务和读取事务的回复都只需要和服务器进行一次通讯。</h5><h5 id=\"至于那些在-EXEC-命令执行之后所产生的错误，-并没有对它们进行特别处理：-即使事务中有某个-某些命令在执行时产生了错误，-事务中的其他命令仍然会继续执行。\"><a href=\"#至于那些在-EXEC-命令执行之后所产生的错误，-并没有对它们进行特别处理：-即使事务中有某个-某些命令在执行时产生了错误，-事务中的其他命令仍然会继续执行。\" class=\"headerlink\" title=\"至于那些在 EXEC 命令执行之后所产生的错误， 并没有对它们进行特别处理： 即使事务中有某个/某些命令在执行时产生了错误， 事务中的其他命令仍然会继续执行。\"></a>至于那些在 EXEC 命令执行之后所产生的错误， 并没有对它们进行特别处理： 即使事务中有某个/某些命令在执行时产生了错误， 事务中的其他命令仍然会继续执行。</h5><h5 id=\"从协议的角度来看这个问题，会更容易理解一些。-以下例子中，-LPOP-命令的执行将出错，-尽管调用它的语法是正确的：\"><a href=\"#从协议的角度来看这个问题，会更容易理解一些。-以下例子中，-LPOP-命令的执行将出错，-尽管调用它的语法是正确的：\" class=\"headerlink\" title=\"从协议的角度来看这个问题，会更容易理解一些。 以下例子中， LPOP 命令的执行将出错， 尽管调用它的语法是正确的：\"></a>从协议的角度来看这个问题，会更容易理解一些。 以下例子中， LPOP 命令的执行将出错， 尽管调用它的语法是正确的：</h5><pre><code class=\"lang-redis\">127.0.0.1:6379&gt; multi\nOK\n127.0.0.1:6379&gt; set name winx\nQUEUED\n127.0.0.1:6379&gt; lpop name\nQUEUED\n127.0.0.1:6379&gt; exec\n1) OK\n2) (error) WRONGTYPE Operation against a key holding the wrong kind of value\n</code></pre>\n<h5 id=\"最重要的是记住这样一条，-即使事务中有某条-某些命令执行失败了，-事务队列中的其他命令仍然会继续执行-——-Redis-不会停止执行事务中的命令。\"><a href=\"#最重要的是记住这样一条，-即使事务中有某条-某些命令执行失败了，-事务队列中的其他命令仍然会继续执行-——-Redis-不会停止执行事务中的命令。\" class=\"headerlink\" title=\"最重要的是记住这样一条， 即使事务中有某条/某些命令执行失败了， 事务队列中的其他命令仍然会继续执行 —— Redis 不会停止执行事务中的命令。\"></a>最重要的是记住这样一条， 即使事务中有某条/某些命令执行失败了， 事务队列中的其他命令仍然会继续执行 —— Redis 不会停止执行事务中的命令。</h5><h5 id=\"以下例子展示的是另一种情况，-当命令在入队时产生错误，-错误会立即被返回给客户端：\"><a href=\"#以下例子展示的是另一种情况，-当命令在入队时产生错误，-错误会立即被返回给客户端：\" class=\"headerlink\" title=\"以下例子展示的是另一种情况， 当命令在入队时产生错误， 错误会立即被返回给客户端：\"></a>以下例子展示的是另一种情况， 当命令在入队时产生错误， 错误会立即被返回给客户端：</h5><pre><code class=\"lang-reids\">127.0.0.1:6379&gt; multi\nOK\n127.0.0.1:6379&gt; INCR name name1\n(error) ERR wrong number of arguments for &#39;incr&#39; command\n127.0.0.1:6379&gt; get name\nQUEUED\n127.0.0.1:6379&gt; exec\n(error) EXECABORT Transaction discarded because of previous errors.\n</code></pre>\n<h5 id=\"因为调用-INCR-命令的参数格式不正确，-所以这个-INCR-命令入队失败。\"><a href=\"#因为调用-INCR-命令的参数格式不正确，-所以这个-INCR-命令入队失败。\" class=\"headerlink\" title=\"因为调用 INCR 命令的参数格式不正确， 所以这个 INCR 命令入队失败。\"></a>因为调用 INCR 命令的参数格式不正确， 所以这个 INCR 命令入队失败。</h5><h3 id=\"为什么-Redis-不支持回滚（roll-back）\"><a href=\"#为什么-Redis-不支持回滚（roll-back）\" class=\"headerlink\" title=\"为什么 Redis 不支持回滚（roll back）\"></a>为什么 Redis 不支持回滚（roll back）</h3><h5 id=\"如果你有使用关系式数据库的经验，-那么-“Redis-在事务失败时不进行回滚，而是继续执行余下的命令”这种做法可能会让你觉得有点奇怪。\"><a href=\"#如果你有使用关系式数据库的经验，-那么-“Redis-在事务失败时不进行回滚，而是继续执行余下的命令”这种做法可能会让你觉得有点奇怪。\" class=\"headerlink\" title=\"如果你有使用关系式数据库的经验， 那么 “Redis 在事务失败时不进行回滚，而是继续执行余下的命令”这种做法可能会让你觉得有点奇怪。\"></a>如果你有使用关系式数据库的经验， 那么 “Redis 在事务失败时不进行回滚，而是继续执行余下的命令”这种做法可能会让你觉得有点奇怪。</h5><h4 id=\"以下是这种做法的优点：\"><a href=\"#以下是这种做法的优点：\" class=\"headerlink\" title=\"以下是这种做法的优点：\"></a>以下是这种做法的优点：</h4><ol>\n<li>Redis 命令只会因为错误的语法而失败（并且这些问题不能在入队时发现），或是命令用在了错误类型的键上面：这也就是说，从实用性的角度来说，失败的命令是由编程错误造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中。</li>\n<li>因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。</li>\n</ol>\n<h2 id=\"使用-check-and-set-cas-操作实现乐观锁\"><a href=\"#使用-check-and-set-cas-操作实现乐观锁\" class=\"headerlink\" title=\"使用 check-and-set(cas)操作实现乐观锁\"></a>使用 check-and-set(cas)操作实现乐观锁</h2><h5 id=\"WATCH-命令可以为-Redis-事务提供-check-and-set-（CAS）行为。\"><a href=\"#WATCH-命令可以为-Redis-事务提供-check-and-set-（CAS）行为。\" class=\"headerlink\" title=\"WATCH 命令可以为 Redis 事务提供 check-and-set （CAS）行为。\"></a>WATCH 命令可以为 Redis 事务提供 check-and-set （CAS）行为。</h5><h5 id=\"被-WATCH-的键会被监视，并会发觉这些键是否被改动过了。-如果有至少一个被监视的键在-EXEC-执行之前被修改了，-那么整个事务都会被取消，-EXEC-返回nil-reply来表示事务已经失败。\"><a href=\"#被-WATCH-的键会被监视，并会发觉这些键是否被改动过了。-如果有至少一个被监视的键在-EXEC-执行之前被修改了，-那么整个事务都会被取消，-EXEC-返回nil-reply来表示事务已经失败。\" class=\"headerlink\" title=\"被 WATCH 的键会被监视，并会发觉这些键是否被改动过了。 如果有至少一个被监视的键在 EXEC 执行之前被修改了， 那么整个事务都会被取消， EXEC 返回nil-reply来表示事务已经失败。\"></a>被 WATCH 的键会被监视，并会发觉这些键是否被改动过了。 如果有至少一个被监视的键在 EXEC 执行之前被修改了， 那么整个事务都会被取消， EXEC 返回nil-reply来表示事务已经失败。</h5><h5 id=\"举个例子，-假设我们需要原子性地为某个值进行增-1-操作（假设-INCR-不存在）。\"><a href=\"#举个例子，-假设我们需要原子性地为某个值进行增-1-操作（假设-INCR-不存在）。\" class=\"headerlink\" title=\"举个例子， 假设我们需要原子性地为某个值进行增 1 操作（假设 INCR 不存在）。\"></a>举个例子， 假设我们需要原子性地为某个值进行增 1 操作（假设 INCR 不存在）。</h5><h4 id=\"首先我们可能会这样做：\"><a href=\"#首先我们可能会这样做：\" class=\"headerlink\" title=\"首先我们可能会这样做：\"></a>首先我们可能会这样做：</h4><pre><code>val = GET mykey\nval = val + 1\nSET mykey $val\n</code></pre><h5 id=\"上面的这个实现在只有一个客户端的时候可以执行得很好。但是，当多个客户端同时对同一个键进行这样的操作时，就会产生竞争条件。举个例子，-如果客户端-A-和-B-都读取了键原来的值，比如10，那么两个客户端都会将键的值设为11，但正确的结果应该是12才对。\"><a href=\"#上面的这个实现在只有一个客户端的时候可以执行得很好。但是，当多个客户端同时对同一个键进行这样的操作时，就会产生竞争条件。举个例子，-如果客户端-A-和-B-都读取了键原来的值，比如10，那么两个客户端都会将键的值设为11，但正确的结果应该是12才对。\" class=\"headerlink\" title=\"上面的这个实现在只有一个客户端的时候可以执行得很好。但是，当多个客户端同时对同一个键进行这样的操作时，就会产生竞争条件。举个例子， 如果客户端 A 和 B 都读取了键原来的值，比如10，那么两个客户端都会将键的值设为11，但正确的结果应该是12才对。\"></a>上面的这个实现在只有一个客户端的时候可以执行得很好。但是，当多个客户端同时对同一个键进行这样的操作时，就会产生竞争条件。举个例子， 如果客户端 A 和 B 都读取了键原来的值，比如10，那么两个客户端都会将键的值设为11，但正确的结果应该是12才对。</h5><h4 id=\"有了-WATCH-，-我们就可以轻松地解决这类问题了：\"><a href=\"#有了-WATCH-，-我们就可以轻松地解决这类问题了：\" class=\"headerlink\" title=\"有了 WATCH ， 我们就可以轻松地解决这类问题了：\"></a>有了 WATCH ， 我们就可以轻松地解决这类问题了：</h4><pre><code>WATCH mykey\nval = GET mykey\nval = val + 1\nMULTI\nSET mykey $val\nEXEC\n</code></pre><h5 id=\"使用上面的代码，-如果在-WATCH-执行之后，-EXEC-执行之前，-有其他客户端修改了-mykey-的值，-那么当前客户端的事务就会失败。-程序需要做的，-就是不断重试这个操作，-直到没有发生碰撞为止。\"><a href=\"#使用上面的代码，-如果在-WATCH-执行之后，-EXEC-执行之前，-有其他客户端修改了-mykey-的值，-那么当前客户端的事务就会失败。-程序需要做的，-就是不断重试这个操作，-直到没有发生碰撞为止。\" class=\"headerlink\" title=\"使用上面的代码， 如果在 WATCH 执行之后， EXEC 执行之前， 有其他客户端修改了 mykey 的值， 那么当前客户端的事务就会失败。 程序需要做的， 就是不断重试这个操作， 直到没有发生碰撞为止。\"></a>使用上面的代码， 如果在 WATCH 执行之后， EXEC 执行之前， 有其他客户端修改了 mykey 的值， 那么当前客户端的事务就会失败。 程序需要做的， 就是不断重试这个操作， 直到没有发生碰撞为止。</h5><h5 id=\"这种形式的锁被称作乐观锁，-它是一种非常强大的锁机制。并且因为大多数情况下，不同的客户端会访问不同的键，碰撞的情况一般都很少，-所以通常并不需要进行重试。\"><a href=\"#这种形式的锁被称作乐观锁，-它是一种非常强大的锁机制。并且因为大多数情况下，不同的客户端会访问不同的键，碰撞的情况一般都很少，-所以通常并不需要进行重试。\" class=\"headerlink\" title=\"这种形式的锁被称作乐观锁， 它是一种非常强大的锁机制。并且因为大多数情况下，不同的客户端会访问不同的键，碰撞的情况一般都很少， 所以通常并不需要进行重试。\"></a>这种形式的锁被称作乐观锁， 它是一种非常强大的锁机制。并且因为大多数情况下，不同的客户端会访问不同的键，碰撞的情况一般都很少， 所以通常并不需要进行重试。</h5><h3 id=\"了解-WATCH\"><a href=\"#了解-WATCH\" class=\"headerlink\" title=\"了解 WATCH\"></a>了解 WATCH</h3><h5 id=\"WATCH-命令可以被调用多次。-对键的监视从-WATCH-执行之后开始生效，-直到调用-EXEC-为止。\"><a href=\"#WATCH-命令可以被调用多次。-对键的监视从-WATCH-执行之后开始生效，-直到调用-EXEC-为止。\" class=\"headerlink\" title=\"WATCH 命令可以被调用多次。 对键的监视从 WATCH 执行之后开始生效， 直到调用 EXEC 为止。\"></a>WATCH 命令可以被调用多次。 对键的监视从 WATCH 执行之后开始生效， 直到调用 EXEC 为止。</h5><h5 id=\"用户还可以在单个-WATCH-命令中监视任意多个键，-就像这样：\"><a href=\"#用户还可以在单个-WATCH-命令中监视任意多个键，-就像这样：\" class=\"headerlink\" title=\"用户还可以在单个 WATCH 命令中监视任意多个键， 就像这样：\"></a>用户还可以在单个 WATCH 命令中监视任意多个键， 就像这样：</h5><pre><code class=\"lang-redis\">127.0.0.1:6379&gt; WATCH key1 key2 key3\nOK\n</code></pre>\n<h5 id=\"当-EXEC-被调用时，-不管事务是否成功执行，-对所有键的监视都会被取消。\"><a href=\"#当-EXEC-被调用时，-不管事务是否成功执行，-对所有键的监视都会被取消。\" class=\"headerlink\" title=\"当 EXEC 被调用时， 不管事务是否成功执行， 对所有键的监视都会被取消。\"></a>当 EXEC 被调用时， 不管事务是否成功执行， 对所有键的监视都会被取消。</h5><h5 id=\"另外，-当客户端断开连接时，-该客户端对键的监视也会被取消。\"><a href=\"#另外，-当客户端断开连接时，-该客户端对键的监视也会被取消。\" class=\"headerlink\" title=\"另外， 当客户端断开连接时， 该客户端对键的监视也会被取消。\"></a>另外， 当客户端断开连接时， 该客户端对键的监视也会被取消。</h5><h5 id=\"使用无参数的-UNWATCH-命令可以手动取消对所有键的监视。-对于一些需要改动多个键的事务，-有时候程序需要同时对多个键进行加锁，-然后检查这些键的当前值是否符合程序的要求。-当值达不到要求时，-就可以使用-UNWATCH-命令来取消目前对键的监视，-中途放弃这个事务，-并等待事务的下次尝试。\"><a href=\"#使用无参数的-UNWATCH-命令可以手动取消对所有键的监视。-对于一些需要改动多个键的事务，-有时候程序需要同时对多个键进行加锁，-然后检查这些键的当前值是否符合程序的要求。-当值达不到要求时，-就可以使用-UNWATCH-命令来取消目前对键的监视，-中途放弃这个事务，-并等待事务的下次尝试。\" class=\"headerlink\" title=\"使用无参数的 UNWATCH 命令可以手动取消对所有键的监视。 对于一些需要改动多个键的事务， 有时候程序需要同时对多个键进行加锁， 然后检查这些键的当前值是否符合程序的要求。 当值达不到要求时， 就可以使用 UNWATCH 命令来取消目前对键的监视， 中途放弃这个事务， 并等待事务的下次尝试。\"></a>使用无参数的 UNWATCH 命令可以手动取消对所有键的监视。 对于一些需要改动多个键的事务， 有时候程序需要同时对多个键进行加锁， 然后检查这些键的当前值是否符合程序的要求。 当值达不到要求时， 就可以使用 UNWATCH 命令来取消目前对键的监视， 中途放弃这个事务， 并等待事务的下次尝试。</h5><h2 id=\"Redis-脚本和事务\"><a href=\"#Redis-脚本和事务\" class=\"headerlink\" title=\"Redis 脚本和事务\"></a>Redis 脚本和事务</h2><h5 id=\"从定义上来说，-Redis-中的脚本本身就是一种事务，-所以任何在事务里可以完成的事，-在脚本里面也能完成。-并且一般来说，-使用脚本要来得更简单，并且速度更快。\"><a href=\"#从定义上来说，-Redis-中的脚本本身就是一种事务，-所以任何在事务里可以完成的事，-在脚本里面也能完成。-并且一般来说，-使用脚本要来得更简单，并且速度更快。\" class=\"headerlink\" title=\"从定义上来说， Redis 中的脚本本身就是一种事务， 所以任何在事务里可以完成的事， 在脚本里面也能完成。 并且一般来说， 使用脚本要来得更简单，并且速度更快。\"></a>从定义上来说， Redis 中的脚本本身就是一种事务， 所以任何在事务里可以完成的事， 在脚本里面也能完成。 并且一般来说， 使用脚本要来得更简单，并且速度更快。</h5>","site":{"data":{}},"excerpt":"<h5 id=\"MULTI-、-EXEC-、-DISCARD-和-WATCH-是-Redis-事务相关的命令。事务可以一次执行多个命令，-并且带有以下两个重要的保证：\"><a href=\"#MULTI-、-EXEC-、-DISCARD-和-WATCH-是-Redis-事务相关的命令。事务可以一次执行多个命令，-并且带有以下两个重要的保证：\" class=\"headerlink\" title=\"MULTI 、 EXEC 、 DISCARD 和 WATCH 是 Redis 事务相关的命令。事务可以一次执行多个命令， 并且带有以下两个重要的保证：\"></a>MULTI 、 EXEC 、 DISCARD 和 WATCH 是 Redis 事务相关的命令。事务可以一次执行多个命令， 并且带有以下两个重要的保证：</h5><ul>\n<li>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</li>\n<li>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。","more":"</li>\n</ul>\n<h2 id=\"相关命令\"><a href=\"#相关命令\" class=\"headerlink\" title=\"相关命令\"></a>相关命令</h2><h3 id=\"MULTI\"><a href=\"#MULTI\" class=\"headerlink\" title=\"MULTI\"></a>MULTI</h3><h5 id=\"用于标记事务块的开始。Redis会将后续的命令逐个放入队列中，然后才能使用EXEC命令原子化地执行这个命令序列。\"><a href=\"#用于标记事务块的开始。Redis会将后续的命令逐个放入队列中，然后才能使用EXEC命令原子化地执行这个命令序列。\" class=\"headerlink\" title=\"用于标记事务块的开始。Redis会将后续的命令逐个放入队列中，然后才能使用EXEC命令原子化地执行这个命令序列。\"></a>用于标记事务块的开始。Redis会将后续的命令逐个放入队列中，然后才能使用EXEC命令原子化地执行这个命令序列。</h5><pre><code class=\"lang-redis\">127.0.0.1:6379&gt; multi\nOK\n</code></pre>\n<h3 id=\"EXEC\"><a href=\"#EXEC\" class=\"headerlink\" title=\"EXEC\"></a>EXEC</h3><h5 id=\"当客户端处于事务状态时，所有传入的命令都会返回一个内容为-QUEUED-的状态回复（status-reply），-这些被入队的命令将在-EXEC-命令被调用时执行。然后恢复正常的连接状态。\"><a href=\"#当客户端处于事务状态时，所有传入的命令都会返回一个内容为-QUEUED-的状态回复（status-reply），-这些被入队的命令将在-EXEC-命令被调用时执行。然后恢复正常的连接状态。\" class=\"headerlink\" title=\"当客户端处于事务状态时，所有传入的命令都会返回一个内容为 QUEUED 的状态回复（status reply）， 这些被入队的命令将在 EXEC 命令被调用时执行。然后恢复正常的连接状态。\"></a>当客户端处于事务状态时，所有传入的命令都会返回一个内容为 QUEUED 的状态回复（status reply）， 这些被入队的命令将在 EXEC 命令被调用时执行。然后恢复正常的连接状态。</h5><h5 id=\"当使用WATCH命令时，只有当受监控的键没有被修改时，EXEC命令才会执行事务中的命令，这种方式利用了检查再设置（CAS）的机制。\"><a href=\"#当使用WATCH命令时，只有当受监控的键没有被修改时，EXEC命令才会执行事务中的命令，这种方式利用了检查再设置（CAS）的机制。\" class=\"headerlink\" title=\"当使用WATCH命令时，只有当受监控的键没有被修改时，EXEC命令才会执行事务中的命令，这种方式利用了检查再设置（CAS）的机制。\"></a>当使用WATCH命令时，只有当受监控的键没有被修改时，EXEC命令才会执行事务中的命令，这种方式利用了检查再设置（CAS）的机制。</h5><pre><code class=\"lang-redis\">127.0.0.1:6379&gt; multi\nOK\n127.0.0.1:6379&gt; set name winx\nQUEUED\n127.0.0.1:6379&gt; get name\nQUEUED\n127.0.0.1:6379&gt; exec\n1) OK\n2) &quot;winx&quot;\n</code></pre>\n<h3 id=\"DISCARD\"><a href=\"#DISCARD\" class=\"headerlink\" title=\"DISCARD\"></a>DISCARD</h3><h5 id=\"清除所有先前在一个事务中放入队列的命令，然后恢复正常的连接状态。\"><a href=\"#清除所有先前在一个事务中放入队列的命令，然后恢复正常的连接状态。\" class=\"headerlink\" title=\"清除所有先前在一个事务中放入队列的命令，然后恢复正常的连接状态。\"></a>清除所有先前在一个事务中放入队列的命令，然后恢复正常的连接状态。</h5><h5 id=\"如果使用了WATCH命令，那么DISCARD命令就会将当前连接监控的所有键取消监控。\"><a href=\"#如果使用了WATCH命令，那么DISCARD命令就会将当前连接监控的所有键取消监控。\" class=\"headerlink\" title=\"如果使用了WATCH命令，那么DISCARD命令就会将当前连接监控的所有键取消监控。\"></a>如果使用了WATCH命令，那么DISCARD命令就会将当前连接监控的所有键取消监控。</h5><pre><code class=\"lang-redis\">127.0.0.1:6379&gt; multi\nOK\n127.0.0.1:6379&gt; set name winx1\nQUEUED\n127.0.0.1:6379&gt; DISCARD\nOK\n127.0.0.1:6379&gt; get name\n&quot;winx&quot;\n</code></pre>\n<h3 id=\"WATCH\"><a href=\"#WATCH\" class=\"headerlink\" title=\"WATCH\"></a>WATCH</h3><h5 id=\"WATCH-使得-EXEC-命令需要有条件地执行：事务只能在所有被监视键都没有被修改的前提下执行，-如果这个前提不能满足的话，事务就不会被执行。\"><a href=\"#WATCH-使得-EXEC-命令需要有条件地执行：事务只能在所有被监视键都没有被修改的前提下执行，-如果这个前提不能满足的话，事务就不会被执行。\" class=\"headerlink\" title=\"WATCH 使得 EXEC 命令需要有条件地执行：事务只能在所有被监视键都没有被修改的前提下执行， 如果这个前提不能满足的话，事务就不会被执行。\"></a>WATCH 使得 EXEC 命令需要有条件地执行：事务只能在所有被监视键都没有被修改的前提下执行， 如果这个前提不能满足的话，事务就不会被执行。</h5><h4 id=\"客户端1\"><a href=\"#客户端1\" class=\"headerlink\" title=\"客户端1\"></a>客户端1</h4><pre><code class=\"lang-redis\">127.0.0.1:6379&gt; watch name\nOK\n127.0.0.1:6379&gt; set name winx1\nOK\n127.0.0.1:6379&gt; multi\nOK\n127.0.0.1:6379&gt; set name winx\nQUEUED\n</code></pre>\n<h4 id=\"客户端2\"><a href=\"#客户端2\" class=\"headerlink\" title=\"客户端2\"></a>客户端2</h4><pre><code class=\"lang-redis\">127.0.0.1:6379&gt; get name\n&quot;winx1&quot;\n127.0.0.1:6379&gt; set name winx2\nOK\n</code></pre>\n<h4 id=\"客户端1-1\"><a href=\"#客户端1-1\" class=\"headerlink\" title=\"客户端1\"></a>客户端1</h4><pre><code class=\"lang-redis\">127.0.0.1:6379&gt; get name\nQUEUED\n127.0.0.1:6379&gt; exec\n(nil)\n</code></pre>\n<h5 id=\"可以看到客户端1监听了name，然后执行事务，在事务提交之前客户端2修改了name值，结果客户端1提交事务后返回-nil-结果。\"><a href=\"#可以看到客户端1监听了name，然后执行事务，在事务提交之前客户端2修改了name值，结果客户端1提交事务后返回-nil-结果。\" class=\"headerlink\" title=\"可以看到客户端1监听了name，然后执行事务，在事务提交之前客户端2修改了name值，结果客户端1提交事务后返回(nil)结果。\"></a>可以看到客户端1监听了name，然后执行事务，在事务提交之前客户端2修改了name值，结果客户端1提交事务后返回<code>(nil)</code>结果。</h5><h3 id=\"UNWATCH\"><a href=\"#UNWATCH\" class=\"headerlink\" title=\"UNWATCH\"></a>UNWATCH</h3><h5 id=\"清除所有先前为一个事务监控的键。如果你调用了EXEC或DISCARD命令，那么就不需要手动调用UNWATCH命令。\"><a href=\"#清除所有先前为一个事务监控的键。如果你调用了EXEC或DISCARD命令，那么就不需要手动调用UNWATCH命令。\" class=\"headerlink\" title=\"清除所有先前为一个事务监控的键。如果你调用了EXEC或DISCARD命令，那么就不需要手动调用UNWATCH命令。\"></a>清除所有先前为一个事务监控的键。如果你调用了EXEC或DISCARD命令，那么就不需要手动调用UNWATCH命令。</h5><h5 id=\"如果客户端在使用-MULTI-开启了一个事务之后，却因为断线而没有成功执行-EXEC-，那么事务中的所有命令都不会被执行。另一方面，如果客户端成功在开启事务之后执行-EXEC-，那么事务中的所有命令都会被执行。当使用-AOF-方式做持久化的时候，-Redis-会使用单个-write-2-命令将事务写入到磁盘中。然而，如果-Redis-服务器因为某些原因被管理员杀死，或者遇上某种硬件故障，那么可能只有部分事务命令会被成功写入到磁盘中。如果-Redis-在重新启动时发现-AOF-文件出了这样的问题，那么它会退出，并汇报一个错误。使用redis-check-aof程序可以修复这一问题：它会移除-AOF-文件中不完整事务的信息，确保服务器可以顺利启动。\"><a href=\"#如果客户端在使用-MULTI-开启了一个事务之后，却因为断线而没有成功执行-EXEC-，那么事务中的所有命令都不会被执行。另一方面，如果客户端成功在开启事务之后执行-EXEC-，那么事务中的所有命令都会被执行。当使用-AOF-方式做持久化的时候，-Redis-会使用单个-write-2-命令将事务写入到磁盘中。然而，如果-Redis-服务器因为某些原因被管理员杀死，或者遇上某种硬件故障，那么可能只有部分事务命令会被成功写入到磁盘中。如果-Redis-在重新启动时发现-AOF-文件出了这样的问题，那么它会退出，并汇报一个错误。使用redis-check-aof程序可以修复这一问题：它会移除-AOF-文件中不完整事务的信息，确保服务器可以顺利启动。\" class=\"headerlink\" title=\"如果客户端在使用 MULTI 开启了一个事务之后，却因为断线而没有成功执行 EXEC ，那么事务中的所有命令都不会被执行。另一方面，如果客户端成功在开启事务之后执行 EXEC ，那么事务中的所有命令都会被执行。当使用 AOF 方式做持久化的时候， Redis 会使用单个 write(2) 命令将事务写入到磁盘中。然而，如果 Redis 服务器因为某些原因被管理员杀死，或者遇上某种硬件故障，那么可能只有部分事务命令会被成功写入到磁盘中。如果 Redis 在重新启动时发现 AOF 文件出了这样的问题，那么它会退出，并汇报一个错误。使用redis-check-aof程序可以修复这一问题：它会移除 AOF 文件中不完整事务的信息，确保服务器可以顺利启动。\"></a>如果客户端在使用 MULTI 开启了一个事务之后，却因为断线而没有成功执行 EXEC ，那么事务中的所有命令都不会被执行。另一方面，如果客户端成功在开启事务之后执行 EXEC ，那么事务中的所有命令都会被执行。当使用 AOF 方式做持久化的时候， Redis 会使用单个 write(2) 命令将事务写入到磁盘中。然而，如果 Redis 服务器因为某些原因被管理员杀死，或者遇上某种硬件故障，那么可能只有部分事务命令会被成功写入到磁盘中。如果 Redis 在重新启动时发现 AOF 文件出了这样的问题，那么它会退出，并汇报一个错误。使用redis-check-aof程序可以修复这一问题：它会移除 AOF 文件中不完整事务的信息，确保服务器可以顺利启动。</h5><h2 id=\"事务中的错误\"><a href=\"#事务中的错误\" class=\"headerlink\" title=\"事务中的错误\"></a>事务中的错误</h2><h5 id=\"使用事务时可能会遇上以下两种错误：\"><a href=\"#使用事务时可能会遇上以下两种错误：\" class=\"headerlink\" title=\"使用事务时可能会遇上以下两种错误：\"></a>使用事务时可能会遇上以下两种错误：</h5><ul>\n<li>事务在执行 EXEC 之前，入队的命令可能会出错。比如说，命令可能会产生语法错误（参数数量错误，参数名错误，等等），或者其他更严重的错误，比如内存不足（如果服务器使用 maxmemory 设置了最大内存限制的话）。</li>\n<li>命令可能在 EXEC 调用之后失败。举个例子，事务中的命令可能处理了错误类型的键，比如将列表命令用在了字符串键上面，诸如此类。<br>对于发生在 EXEC 执行之前的错误，客户端以前的做法是检查命令入队所得的返回值：如果命令入队时返回 QUEUED ，那么入队成功；否则，就是入队失败。如果有命令在入队时失败，那么大部分客户端都会停止并取消这个事务。</li>\n</ul>\n<h5 id=\"从-Redis-2-6-5-开始，服务器会对命令入队失败的情况进行记录，并在客户端调用-EXEC-命令时，拒绝执行并自动放弃这个事务。\"><a href=\"#从-Redis-2-6-5-开始，服务器会对命令入队失败的情况进行记录，并在客户端调用-EXEC-命令时，拒绝执行并自动放弃这个事务。\" class=\"headerlink\" title=\"从 Redis 2.6.5 开始，服务器会对命令入队失败的情况进行记录，并在客户端调用 EXEC 命令时，拒绝执行并自动放弃这个事务。\"></a>从 Redis 2.6.5 开始，服务器会对命令入队失败的情况进行记录，并在客户端调用 EXEC 命令时，拒绝执行并自动放弃这个事务。</h5><h5 id=\"在-Redis-2-6-5-以前，-Redis-只执行事务中那些入队成功的命令，而忽略那些入队失败的命令。-而新的处理方式则使得在流水线（pipeline）中包含事务变得简单，因为发送事务和读取事务的回复都只需要和服务器进行一次通讯。\"><a href=\"#在-Redis-2-6-5-以前，-Redis-只执行事务中那些入队成功的命令，而忽略那些入队失败的命令。-而新的处理方式则使得在流水线（pipeline）中包含事务变得简单，因为发送事务和读取事务的回复都只需要和服务器进行一次通讯。\" class=\"headerlink\" title=\"在 Redis 2.6.5 以前， Redis 只执行事务中那些入队成功的命令，而忽略那些入队失败的命令。 而新的处理方式则使得在流水线（pipeline）中包含事务变得简单，因为发送事务和读取事务的回复都只需要和服务器进行一次通讯。\"></a>在 Redis 2.6.5 以前， Redis 只执行事务中那些入队成功的命令，而忽略那些入队失败的命令。 而新的处理方式则使得在流水线（pipeline）中包含事务变得简单，因为发送事务和读取事务的回复都只需要和服务器进行一次通讯。</h5><h5 id=\"至于那些在-EXEC-命令执行之后所产生的错误，-并没有对它们进行特别处理：-即使事务中有某个-某些命令在执行时产生了错误，-事务中的其他命令仍然会继续执行。\"><a href=\"#至于那些在-EXEC-命令执行之后所产生的错误，-并没有对它们进行特别处理：-即使事务中有某个-某些命令在执行时产生了错误，-事务中的其他命令仍然会继续执行。\" class=\"headerlink\" title=\"至于那些在 EXEC 命令执行之后所产生的错误， 并没有对它们进行特别处理： 即使事务中有某个/某些命令在执行时产生了错误， 事务中的其他命令仍然会继续执行。\"></a>至于那些在 EXEC 命令执行之后所产生的错误， 并没有对它们进行特别处理： 即使事务中有某个/某些命令在执行时产生了错误， 事务中的其他命令仍然会继续执行。</h5><h5 id=\"从协议的角度来看这个问题，会更容易理解一些。-以下例子中，-LPOP-命令的执行将出错，-尽管调用它的语法是正确的：\"><a href=\"#从协议的角度来看这个问题，会更容易理解一些。-以下例子中，-LPOP-命令的执行将出错，-尽管调用它的语法是正确的：\" class=\"headerlink\" title=\"从协议的角度来看这个问题，会更容易理解一些。 以下例子中， LPOP 命令的执行将出错， 尽管调用它的语法是正确的：\"></a>从协议的角度来看这个问题，会更容易理解一些。 以下例子中， LPOP 命令的执行将出错， 尽管调用它的语法是正确的：</h5><pre><code class=\"lang-redis\">127.0.0.1:6379&gt; multi\nOK\n127.0.0.1:6379&gt; set name winx\nQUEUED\n127.0.0.1:6379&gt; lpop name\nQUEUED\n127.0.0.1:6379&gt; exec\n1) OK\n2) (error) WRONGTYPE Operation against a key holding the wrong kind of value\n</code></pre>\n<h5 id=\"最重要的是记住这样一条，-即使事务中有某条-某些命令执行失败了，-事务队列中的其他命令仍然会继续执行-——-Redis-不会停止执行事务中的命令。\"><a href=\"#最重要的是记住这样一条，-即使事务中有某条-某些命令执行失败了，-事务队列中的其他命令仍然会继续执行-——-Redis-不会停止执行事务中的命令。\" class=\"headerlink\" title=\"最重要的是记住这样一条， 即使事务中有某条/某些命令执行失败了， 事务队列中的其他命令仍然会继续执行 —— Redis 不会停止执行事务中的命令。\"></a>最重要的是记住这样一条， 即使事务中有某条/某些命令执行失败了， 事务队列中的其他命令仍然会继续执行 —— Redis 不会停止执行事务中的命令。</h5><h5 id=\"以下例子展示的是另一种情况，-当命令在入队时产生错误，-错误会立即被返回给客户端：\"><a href=\"#以下例子展示的是另一种情况，-当命令在入队时产生错误，-错误会立即被返回给客户端：\" class=\"headerlink\" title=\"以下例子展示的是另一种情况， 当命令在入队时产生错误， 错误会立即被返回给客户端：\"></a>以下例子展示的是另一种情况， 当命令在入队时产生错误， 错误会立即被返回给客户端：</h5><pre><code class=\"lang-reids\">127.0.0.1:6379&gt; multi\nOK\n127.0.0.1:6379&gt; INCR name name1\n(error) ERR wrong number of arguments for &#39;incr&#39; command\n127.0.0.1:6379&gt; get name\nQUEUED\n127.0.0.1:6379&gt; exec\n(error) EXECABORT Transaction discarded because of previous errors.\n</code></pre>\n<h5 id=\"因为调用-INCR-命令的参数格式不正确，-所以这个-INCR-命令入队失败。\"><a href=\"#因为调用-INCR-命令的参数格式不正确，-所以这个-INCR-命令入队失败。\" class=\"headerlink\" title=\"因为调用 INCR 命令的参数格式不正确， 所以这个 INCR 命令入队失败。\"></a>因为调用 INCR 命令的参数格式不正确， 所以这个 INCR 命令入队失败。</h5><h3 id=\"为什么-Redis-不支持回滚（roll-back）\"><a href=\"#为什么-Redis-不支持回滚（roll-back）\" class=\"headerlink\" title=\"为什么 Redis 不支持回滚（roll back）\"></a>为什么 Redis 不支持回滚（roll back）</h3><h5 id=\"如果你有使用关系式数据库的经验，-那么-“Redis-在事务失败时不进行回滚，而是继续执行余下的命令”这种做法可能会让你觉得有点奇怪。\"><a href=\"#如果你有使用关系式数据库的经验，-那么-“Redis-在事务失败时不进行回滚，而是继续执行余下的命令”这种做法可能会让你觉得有点奇怪。\" class=\"headerlink\" title=\"如果你有使用关系式数据库的经验， 那么 “Redis 在事务失败时不进行回滚，而是继续执行余下的命令”这种做法可能会让你觉得有点奇怪。\"></a>如果你有使用关系式数据库的经验， 那么 “Redis 在事务失败时不进行回滚，而是继续执行余下的命令”这种做法可能会让你觉得有点奇怪。</h5><h4 id=\"以下是这种做法的优点：\"><a href=\"#以下是这种做法的优点：\" class=\"headerlink\" title=\"以下是这种做法的优点：\"></a>以下是这种做法的优点：</h4><ol>\n<li>Redis 命令只会因为错误的语法而失败（并且这些问题不能在入队时发现），或是命令用在了错误类型的键上面：这也就是说，从实用性的角度来说，失败的命令是由编程错误造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中。</li>\n<li>因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。</li>\n</ol>\n<h2 id=\"使用-check-and-set-cas-操作实现乐观锁\"><a href=\"#使用-check-and-set-cas-操作实现乐观锁\" class=\"headerlink\" title=\"使用 check-and-set(cas)操作实现乐观锁\"></a>使用 check-and-set(cas)操作实现乐观锁</h2><h5 id=\"WATCH-命令可以为-Redis-事务提供-check-and-set-（CAS）行为。\"><a href=\"#WATCH-命令可以为-Redis-事务提供-check-and-set-（CAS）行为。\" class=\"headerlink\" title=\"WATCH 命令可以为 Redis 事务提供 check-and-set （CAS）行为。\"></a>WATCH 命令可以为 Redis 事务提供 check-and-set （CAS）行为。</h5><h5 id=\"被-WATCH-的键会被监视，并会发觉这些键是否被改动过了。-如果有至少一个被监视的键在-EXEC-执行之前被修改了，-那么整个事务都会被取消，-EXEC-返回nil-reply来表示事务已经失败。\"><a href=\"#被-WATCH-的键会被监视，并会发觉这些键是否被改动过了。-如果有至少一个被监视的键在-EXEC-执行之前被修改了，-那么整个事务都会被取消，-EXEC-返回nil-reply来表示事务已经失败。\" class=\"headerlink\" title=\"被 WATCH 的键会被监视，并会发觉这些键是否被改动过了。 如果有至少一个被监视的键在 EXEC 执行之前被修改了， 那么整个事务都会被取消， EXEC 返回nil-reply来表示事务已经失败。\"></a>被 WATCH 的键会被监视，并会发觉这些键是否被改动过了。 如果有至少一个被监视的键在 EXEC 执行之前被修改了， 那么整个事务都会被取消， EXEC 返回nil-reply来表示事务已经失败。</h5><h5 id=\"举个例子，-假设我们需要原子性地为某个值进行增-1-操作（假设-INCR-不存在）。\"><a href=\"#举个例子，-假设我们需要原子性地为某个值进行增-1-操作（假设-INCR-不存在）。\" class=\"headerlink\" title=\"举个例子， 假设我们需要原子性地为某个值进行增 1 操作（假设 INCR 不存在）。\"></a>举个例子， 假设我们需要原子性地为某个值进行增 1 操作（假设 INCR 不存在）。</h5><h4 id=\"首先我们可能会这样做：\"><a href=\"#首先我们可能会这样做：\" class=\"headerlink\" title=\"首先我们可能会这样做：\"></a>首先我们可能会这样做：</h4><pre><code>val = GET mykey\nval = val + 1\nSET mykey $val\n</code></pre><h5 id=\"上面的这个实现在只有一个客户端的时候可以执行得很好。但是，当多个客户端同时对同一个键进行这样的操作时，就会产生竞争条件。举个例子，-如果客户端-A-和-B-都读取了键原来的值，比如10，那么两个客户端都会将键的值设为11，但正确的结果应该是12才对。\"><a href=\"#上面的这个实现在只有一个客户端的时候可以执行得很好。但是，当多个客户端同时对同一个键进行这样的操作时，就会产生竞争条件。举个例子，-如果客户端-A-和-B-都读取了键原来的值，比如10，那么两个客户端都会将键的值设为11，但正确的结果应该是12才对。\" class=\"headerlink\" title=\"上面的这个实现在只有一个客户端的时候可以执行得很好。但是，当多个客户端同时对同一个键进行这样的操作时，就会产生竞争条件。举个例子， 如果客户端 A 和 B 都读取了键原来的值，比如10，那么两个客户端都会将键的值设为11，但正确的结果应该是12才对。\"></a>上面的这个实现在只有一个客户端的时候可以执行得很好。但是，当多个客户端同时对同一个键进行这样的操作时，就会产生竞争条件。举个例子， 如果客户端 A 和 B 都读取了键原来的值，比如10，那么两个客户端都会将键的值设为11，但正确的结果应该是12才对。</h5><h4 id=\"有了-WATCH-，-我们就可以轻松地解决这类问题了：\"><a href=\"#有了-WATCH-，-我们就可以轻松地解决这类问题了：\" class=\"headerlink\" title=\"有了 WATCH ， 我们就可以轻松地解决这类问题了：\"></a>有了 WATCH ， 我们就可以轻松地解决这类问题了：</h4><pre><code>WATCH mykey\nval = GET mykey\nval = val + 1\nMULTI\nSET mykey $val\nEXEC\n</code></pre><h5 id=\"使用上面的代码，-如果在-WATCH-执行之后，-EXEC-执行之前，-有其他客户端修改了-mykey-的值，-那么当前客户端的事务就会失败。-程序需要做的，-就是不断重试这个操作，-直到没有发生碰撞为止。\"><a href=\"#使用上面的代码，-如果在-WATCH-执行之后，-EXEC-执行之前，-有其他客户端修改了-mykey-的值，-那么当前客户端的事务就会失败。-程序需要做的，-就是不断重试这个操作，-直到没有发生碰撞为止。\" class=\"headerlink\" title=\"使用上面的代码， 如果在 WATCH 执行之后， EXEC 执行之前， 有其他客户端修改了 mykey 的值， 那么当前客户端的事务就会失败。 程序需要做的， 就是不断重试这个操作， 直到没有发生碰撞为止。\"></a>使用上面的代码， 如果在 WATCH 执行之后， EXEC 执行之前， 有其他客户端修改了 mykey 的值， 那么当前客户端的事务就会失败。 程序需要做的， 就是不断重试这个操作， 直到没有发生碰撞为止。</h5><h5 id=\"这种形式的锁被称作乐观锁，-它是一种非常强大的锁机制。并且因为大多数情况下，不同的客户端会访问不同的键，碰撞的情况一般都很少，-所以通常并不需要进行重试。\"><a href=\"#这种形式的锁被称作乐观锁，-它是一种非常强大的锁机制。并且因为大多数情况下，不同的客户端会访问不同的键，碰撞的情况一般都很少，-所以通常并不需要进行重试。\" class=\"headerlink\" title=\"这种形式的锁被称作乐观锁， 它是一种非常强大的锁机制。并且因为大多数情况下，不同的客户端会访问不同的键，碰撞的情况一般都很少， 所以通常并不需要进行重试。\"></a>这种形式的锁被称作乐观锁， 它是一种非常强大的锁机制。并且因为大多数情况下，不同的客户端会访问不同的键，碰撞的情况一般都很少， 所以通常并不需要进行重试。</h5><h3 id=\"了解-WATCH\"><a href=\"#了解-WATCH\" class=\"headerlink\" title=\"了解 WATCH\"></a>了解 WATCH</h3><h5 id=\"WATCH-命令可以被调用多次。-对键的监视从-WATCH-执行之后开始生效，-直到调用-EXEC-为止。\"><a href=\"#WATCH-命令可以被调用多次。-对键的监视从-WATCH-执行之后开始生效，-直到调用-EXEC-为止。\" class=\"headerlink\" title=\"WATCH 命令可以被调用多次。 对键的监视从 WATCH 执行之后开始生效， 直到调用 EXEC 为止。\"></a>WATCH 命令可以被调用多次。 对键的监视从 WATCH 执行之后开始生效， 直到调用 EXEC 为止。</h5><h5 id=\"用户还可以在单个-WATCH-命令中监视任意多个键，-就像这样：\"><a href=\"#用户还可以在单个-WATCH-命令中监视任意多个键，-就像这样：\" class=\"headerlink\" title=\"用户还可以在单个 WATCH 命令中监视任意多个键， 就像这样：\"></a>用户还可以在单个 WATCH 命令中监视任意多个键， 就像这样：</h5><pre><code class=\"lang-redis\">127.0.0.1:6379&gt; WATCH key1 key2 key3\nOK\n</code></pre>\n<h5 id=\"当-EXEC-被调用时，-不管事务是否成功执行，-对所有键的监视都会被取消。\"><a href=\"#当-EXEC-被调用时，-不管事务是否成功执行，-对所有键的监视都会被取消。\" class=\"headerlink\" title=\"当 EXEC 被调用时， 不管事务是否成功执行， 对所有键的监视都会被取消。\"></a>当 EXEC 被调用时， 不管事务是否成功执行， 对所有键的监视都会被取消。</h5><h5 id=\"另外，-当客户端断开连接时，-该客户端对键的监视也会被取消。\"><a href=\"#另外，-当客户端断开连接时，-该客户端对键的监视也会被取消。\" class=\"headerlink\" title=\"另外， 当客户端断开连接时， 该客户端对键的监视也会被取消。\"></a>另外， 当客户端断开连接时， 该客户端对键的监视也会被取消。</h5><h5 id=\"使用无参数的-UNWATCH-命令可以手动取消对所有键的监视。-对于一些需要改动多个键的事务，-有时候程序需要同时对多个键进行加锁，-然后检查这些键的当前值是否符合程序的要求。-当值达不到要求时，-就可以使用-UNWATCH-命令来取消目前对键的监视，-中途放弃这个事务，-并等待事务的下次尝试。\"><a href=\"#使用无参数的-UNWATCH-命令可以手动取消对所有键的监视。-对于一些需要改动多个键的事务，-有时候程序需要同时对多个键进行加锁，-然后检查这些键的当前值是否符合程序的要求。-当值达不到要求时，-就可以使用-UNWATCH-命令来取消目前对键的监视，-中途放弃这个事务，-并等待事务的下次尝试。\" class=\"headerlink\" title=\"使用无参数的 UNWATCH 命令可以手动取消对所有键的监视。 对于一些需要改动多个键的事务， 有时候程序需要同时对多个键进行加锁， 然后检查这些键的当前值是否符合程序的要求。 当值达不到要求时， 就可以使用 UNWATCH 命令来取消目前对键的监视， 中途放弃这个事务， 并等待事务的下次尝试。\"></a>使用无参数的 UNWATCH 命令可以手动取消对所有键的监视。 对于一些需要改动多个键的事务， 有时候程序需要同时对多个键进行加锁， 然后检查这些键的当前值是否符合程序的要求。 当值达不到要求时， 就可以使用 UNWATCH 命令来取消目前对键的监视， 中途放弃这个事务， 并等待事务的下次尝试。</h5><h2 id=\"Redis-脚本和事务\"><a href=\"#Redis-脚本和事务\" class=\"headerlink\" title=\"Redis 脚本和事务\"></a>Redis 脚本和事务</h2><h5 id=\"从定义上来说，-Redis-中的脚本本身就是一种事务，-所以任何在事务里可以完成的事，-在脚本里面也能完成。-并且一般来说，-使用脚本要来得更简单，并且速度更快。\"><a href=\"#从定义上来说，-Redis-中的脚本本身就是一种事务，-所以任何在事务里可以完成的事，-在脚本里面也能完成。-并且一般来说，-使用脚本要来得更简单，并且速度更快。\" class=\"headerlink\" title=\"从定义上来说， Redis 中的脚本本身就是一种事务， 所以任何在事务里可以完成的事， 在脚本里面也能完成。 并且一般来说， 使用脚本要来得更简单，并且速度更快。\"></a>从定义上来说， Redis 中的脚本本身就是一种事务， 所以任何在事务里可以完成的事， 在脚本里面也能完成。 并且一般来说， 使用脚本要来得更简单，并且速度更快。</h5>"},{"layout":"post","title":"river工具介绍","date":"2017-06-01T16:00:00.000Z","original":true,"tag":[["river","river"]],"_content":"\n##### river是一个java工具包，是对java的method的增强。在原有的method调用流程不变的情况下，尽可能用注解去增强目标方法的灵活性。river希望做的是解耦java method 之间的调用关系。实现代码无侵入或者少侵入的流程控制。\n<!--more-->\n\n#### github地址：[river](https://github.com/winx402/river)\n\n## river基础\n##### river是基于cglib动态代理以及guava作为基础来实现的，这里并没有使用jdk自带的代理方式实现。部分功能的实现是依靠guava或者在guava之上封装来完成的。\n\n## river现有功能\n### aop\n##### aop是一个比较典型的例子，aop实现在目标方法之前、之后、异常等情况下的代码插入。这些插入的代码可以做类似于日志记录，流量统计等工作。也可以在before代码中修改目标方法参数，在after中修改目标方法返回值。但是没有办法控制目标方法是否继续（除非抛出异常）。\n\n### 缓存\n##### cache显而易见，是对目标方法结果的缓存，在缓存结果有效期内，新的调用并不会去执行目标方法，而是直接拿缓存结果。并且用户可以自定义缓存的key（从入参中选取一部分参数，或者是某个对象中的某些属性来作为缓存的key）。\n### 限流\n##### rate limit是对目标方法每秒的调用频率的限制。在限制的流量内，调用会非常顺畅。在超出的流量之外，调用会阻塞，直到新的调用机会。此外，也可以设置超时时间，如果有超时时间设置，在调用之前会先检查在超时时间内能否拿到调用的机会，如果不能，直接返回超时异常。\n### 线程池\n##### 目标方法会用新的线程去执行。可以理解成方法之间的异步执行，如果返回值是void或者是指定的类型。其他的返回值类型，虽然启用的新的线程去执行，但是会等待线程执行完成后拿到返回值再返回。\n### around\n##### around是最灵活的，around是现在river的功能的核心，around可以在A方法调用B方法之间插入C方法。C方法就叫做对B的around，C可以拿到B的入参、返回、method对象等，也可以控制调用B方法的时机，甚至是不调用。实际上，上面的各种功能的实现都可以用around自己实现，但是实现以上功能的成本对于普通使用者来说成本太高也没有必要。因此一些核心且重要的功能都已经单独实现，只需要使用相应的注解就可以了","source":"_posts/note/river/RiverIntroduce.md","raw":"---\nlayout: post\ntitle: river工具介绍\ndate: 2017/06/02\noriginal: true\ntags: [tech, river, index, java]\ntag: [[river, river]]\n---\n\n##### river是一个java工具包，是对java的method的增强。在原有的method调用流程不变的情况下，尽可能用注解去增强目标方法的灵活性。river希望做的是解耦java method 之间的调用关系。实现代码无侵入或者少侵入的流程控制。\n<!--more-->\n\n#### github地址：[river](https://github.com/winx402/river)\n\n## river基础\n##### river是基于cglib动态代理以及guava作为基础来实现的，这里并没有使用jdk自带的代理方式实现。部分功能的实现是依靠guava或者在guava之上封装来完成的。\n\n## river现有功能\n### aop\n##### aop是一个比较典型的例子，aop实现在目标方法之前、之后、异常等情况下的代码插入。这些插入的代码可以做类似于日志记录，流量统计等工作。也可以在before代码中修改目标方法参数，在after中修改目标方法返回值。但是没有办法控制目标方法是否继续（除非抛出异常）。\n\n### 缓存\n##### cache显而易见，是对目标方法结果的缓存，在缓存结果有效期内，新的调用并不会去执行目标方法，而是直接拿缓存结果。并且用户可以自定义缓存的key（从入参中选取一部分参数，或者是某个对象中的某些属性来作为缓存的key）。\n### 限流\n##### rate limit是对目标方法每秒的调用频率的限制。在限制的流量内，调用会非常顺畅。在超出的流量之外，调用会阻塞，直到新的调用机会。此外，也可以设置超时时间，如果有超时时间设置，在调用之前会先检查在超时时间内能否拿到调用的机会，如果不能，直接返回超时异常。\n### 线程池\n##### 目标方法会用新的线程去执行。可以理解成方法之间的异步执行，如果返回值是void或者是指定的类型。其他的返回值类型，虽然启用的新的线程去执行，但是会等待线程执行完成后拿到返回值再返回。\n### around\n##### around是最灵活的，around是现在river的功能的核心，around可以在A方法调用B方法之间插入C方法。C方法就叫做对B的around，C可以拿到B的入参、返回、method对象等，也可以控制调用B方法的时机，甚至是不调用。实际上，上面的各种功能的实现都可以用around自己实现，但是实现以上功能的成本对于普通使用者来说成本太高也没有必要。因此一些核心且重要的功能都已经单独实现，只需要使用相应的注解就可以了","slug":"note/river/RiverIntroduce","published":1,"updated":"2018-05-08T14:51:18.356Z","_id":"cjgxop3nu0044jah10epobnll","comments":1,"photos":[],"link":"","content":"<h5 id=\"river是一个java工具包，是对java的method的增强。在原有的method调用流程不变的情况下，尽可能用注解去增强目标方法的灵活性。river希望做的是解耦java-method-之间的调用关系。实现代码无侵入或者少侵入的流程控制。\"><a href=\"#river是一个java工具包，是对java的method的增强。在原有的method调用流程不变的情况下，尽可能用注解去增强目标方法的灵活性。river希望做的是解耦java-method-之间的调用关系。实现代码无侵入或者少侵入的流程控制。\" class=\"headerlink\" title=\"river是一个java工具包，是对java的method的增强。在原有的method调用流程不变的情况下，尽可能用注解去增强目标方法的灵活性。river希望做的是解耦java method 之间的调用关系。实现代码无侵入或者少侵入的流程控制。\"></a>river是一个java工具包，是对java的method的增强。在原有的method调用流程不变的情况下，尽可能用注解去增强目标方法的灵活性。river希望做的是解耦java method 之间的调用关系。实现代码无侵入或者少侵入的流程控制。</h5><a id=\"more\"></a>\n<h4 id=\"github地址：river\"><a href=\"#github地址：river\" class=\"headerlink\" title=\"github地址：river\"></a>github地址：<a href=\"https://github.com/winx402/river\">river</a></h4><h2 id=\"river基础\"><a href=\"#river基础\" class=\"headerlink\" title=\"river基础\"></a>river基础</h2><h5 id=\"river是基于cglib动态代理以及guava作为基础来实现的，这里并没有使用jdk自带的代理方式实现。部分功能的实现是依靠guava或者在guava之上封装来完成的。\"><a href=\"#river是基于cglib动态代理以及guava作为基础来实现的，这里并没有使用jdk自带的代理方式实现。部分功能的实现是依靠guava或者在guava之上封装来完成的。\" class=\"headerlink\" title=\"river是基于cglib动态代理以及guava作为基础来实现的，这里并没有使用jdk自带的代理方式实现。部分功能的实现是依靠guava或者在guava之上封装来完成的。\"></a>river是基于cglib动态代理以及guava作为基础来实现的，这里并没有使用jdk自带的代理方式实现。部分功能的实现是依靠guava或者在guava之上封装来完成的。</h5><h2 id=\"river现有功能\"><a href=\"#river现有功能\" class=\"headerlink\" title=\"river现有功能\"></a>river现有功能</h2><h3 id=\"aop\"><a href=\"#aop\" class=\"headerlink\" title=\"aop\"></a>aop</h3><h5 id=\"aop是一个比较典型的例子，aop实现在目标方法之前、之后、异常等情况下的代码插入。这些插入的代码可以做类似于日志记录，流量统计等工作。也可以在before代码中修改目标方法参数，在after中修改目标方法返回值。但是没有办法控制目标方法是否继续（除非抛出异常）。\"><a href=\"#aop是一个比较典型的例子，aop实现在目标方法之前、之后、异常等情况下的代码插入。这些插入的代码可以做类似于日志记录，流量统计等工作。也可以在before代码中修改目标方法参数，在after中修改目标方法返回值。但是没有办法控制目标方法是否继续（除非抛出异常）。\" class=\"headerlink\" title=\"aop是一个比较典型的例子，aop实现在目标方法之前、之后、异常等情况下的代码插入。这些插入的代码可以做类似于日志记录，流量统计等工作。也可以在before代码中修改目标方法参数，在after中修改目标方法返回值。但是没有办法控制目标方法是否继续（除非抛出异常）。\"></a>aop是一个比较典型的例子，aop实现在目标方法之前、之后、异常等情况下的代码插入。这些插入的代码可以做类似于日志记录，流量统计等工作。也可以在before代码中修改目标方法参数，在after中修改目标方法返回值。但是没有办法控制目标方法是否继续（除非抛出异常）。</h5><h3 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h3><h5 id=\"cache显而易见，是对目标方法结果的缓存，在缓存结果有效期内，新的调用并不会去执行目标方法，而是直接拿缓存结果。并且用户可以自定义缓存的key（从入参中选取一部分参数，或者是某个对象中的某些属性来作为缓存的key）。\"><a href=\"#cache显而易见，是对目标方法结果的缓存，在缓存结果有效期内，新的调用并不会去执行目标方法，而是直接拿缓存结果。并且用户可以自定义缓存的key（从入参中选取一部分参数，或者是某个对象中的某些属性来作为缓存的key）。\" class=\"headerlink\" title=\"cache显而易见，是对目标方法结果的缓存，在缓存结果有效期内，新的调用并不会去执行目标方法，而是直接拿缓存结果。并且用户可以自定义缓存的key（从入参中选取一部分参数，或者是某个对象中的某些属性来作为缓存的key）。\"></a>cache显而易见，是对目标方法结果的缓存，在缓存结果有效期内，新的调用并不会去执行目标方法，而是直接拿缓存结果。并且用户可以自定义缓存的key（从入参中选取一部分参数，或者是某个对象中的某些属性来作为缓存的key）。</h5><h3 id=\"限流\"><a href=\"#限流\" class=\"headerlink\" title=\"限流\"></a>限流</h3><h5 id=\"rate-limit是对目标方法每秒的调用频率的限制。在限制的流量内，调用会非常顺畅。在超出的流量之外，调用会阻塞，直到新的调用机会。此外，也可以设置超时时间，如果有超时时间设置，在调用之前会先检查在超时时间内能否拿到调用的机会，如果不能，直接返回超时异常。\"><a href=\"#rate-limit是对目标方法每秒的调用频率的限制。在限制的流量内，调用会非常顺畅。在超出的流量之外，调用会阻塞，直到新的调用机会。此外，也可以设置超时时间，如果有超时时间设置，在调用之前会先检查在超时时间内能否拿到调用的机会，如果不能，直接返回超时异常。\" class=\"headerlink\" title=\"rate limit是对目标方法每秒的调用频率的限制。在限制的流量内，调用会非常顺畅。在超出的流量之外，调用会阻塞，直到新的调用机会。此外，也可以设置超时时间，如果有超时时间设置，在调用之前会先检查在超时时间内能否拿到调用的机会，如果不能，直接返回超时异常。\"></a>rate limit是对目标方法每秒的调用频率的限制。在限制的流量内，调用会非常顺畅。在超出的流量之外，调用会阻塞，直到新的调用机会。此外，也可以设置超时时间，如果有超时时间设置，在调用之前会先检查在超时时间内能否拿到调用的机会，如果不能，直接返回超时异常。</h5><h3 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h3><h5 id=\"目标方法会用新的线程去执行。可以理解成方法之间的异步执行，如果返回值是void或者是指定的类型。其他的返回值类型，虽然启用的新的线程去执行，但是会等待线程执行完成后拿到返回值再返回。\"><a href=\"#目标方法会用新的线程去执行。可以理解成方法之间的异步执行，如果返回值是void或者是指定的类型。其他的返回值类型，虽然启用的新的线程去执行，但是会等待线程执行完成后拿到返回值再返回。\" class=\"headerlink\" title=\"目标方法会用新的线程去执行。可以理解成方法之间的异步执行，如果返回值是void或者是指定的类型。其他的返回值类型，虽然启用的新的线程去执行，但是会等待线程执行完成后拿到返回值再返回。\"></a>目标方法会用新的线程去执行。可以理解成方法之间的异步执行，如果返回值是void或者是指定的类型。其他的返回值类型，虽然启用的新的线程去执行，但是会等待线程执行完成后拿到返回值再返回。</h5><h3 id=\"around\"><a href=\"#around\" class=\"headerlink\" title=\"around\"></a>around</h3><h5 id=\"around是最灵活的，around是现在river的功能的核心，around可以在A方法调用B方法之间插入C方法。C方法就叫做对B的around，C可以拿到B的入参、返回、method对象等，也可以控制调用B方法的时机，甚至是不调用。实际上，上面的各种功能的实现都可以用around自己实现，但是实现以上功能的成本对于普通使用者来说成本太高也没有必要。因此一些核心且重要的功能都已经单独实现，只需要使用相应的注解就可以了\"><a href=\"#around是最灵活的，around是现在river的功能的核心，around可以在A方法调用B方法之间插入C方法。C方法就叫做对B的around，C可以拿到B的入参、返回、method对象等，也可以控制调用B方法的时机，甚至是不调用。实际上，上面的各种功能的实现都可以用around自己实现，但是实现以上功能的成本对于普通使用者来说成本太高也没有必要。因此一些核心且重要的功能都已经单独实现，只需要使用相应的注解就可以了\" class=\"headerlink\" title=\"around是最灵活的，around是现在river的功能的核心，around可以在A方法调用B方法之间插入C方法。C方法就叫做对B的around，C可以拿到B的入参、返回、method对象等，也可以控制调用B方法的时机，甚至是不调用。实际上，上面的各种功能的实现都可以用around自己实现，但是实现以上功能的成本对于普通使用者来说成本太高也没有必要。因此一些核心且重要的功能都已经单独实现，只需要使用相应的注解就可以了\"></a>around是最灵活的，around是现在river的功能的核心，around可以在A方法调用B方法之间插入C方法。C方法就叫做对B的around，C可以拿到B的入参、返回、method对象等，也可以控制调用B方法的时机，甚至是不调用。实际上，上面的各种功能的实现都可以用around自己实现，但是实现以上功能的成本对于普通使用者来说成本太高也没有必要。因此一些核心且重要的功能都已经单独实现，只需要使用相应的注解就可以了</h5>","site":{"data":{}},"excerpt":"<h5 id=\"river是一个java工具包，是对java的method的增强。在原有的method调用流程不变的情况下，尽可能用注解去增强目标方法的灵活性。river希望做的是解耦java-method-之间的调用关系。实现代码无侵入或者少侵入的流程控制。\"><a href=\"#river是一个java工具包，是对java的method的增强。在原有的method调用流程不变的情况下，尽可能用注解去增强目标方法的灵活性。river希望做的是解耦java-method-之间的调用关系。实现代码无侵入或者少侵入的流程控制。\" class=\"headerlink\" title=\"river是一个java工具包，是对java的method的增强。在原有的method调用流程不变的情况下，尽可能用注解去增强目标方法的灵活性。river希望做的是解耦java method 之间的调用关系。实现代码无侵入或者少侵入的流程控制。\"></a>river是一个java工具包，是对java的method的增强。在原有的method调用流程不变的情况下，尽可能用注解去增强目标方法的灵活性。river希望做的是解耦java method 之间的调用关系。实现代码无侵入或者少侵入的流程控制。</h5>","more":"<h4 id=\"github地址：river\"><a href=\"#github地址：river\" class=\"headerlink\" title=\"github地址：river\"></a>github地址：<a href=\"https://github.com/winx402/river\">river</a></h4><h2 id=\"river基础\"><a href=\"#river基础\" class=\"headerlink\" title=\"river基础\"></a>river基础</h2><h5 id=\"river是基于cglib动态代理以及guava作为基础来实现的，这里并没有使用jdk自带的代理方式实现。部分功能的实现是依靠guava或者在guava之上封装来完成的。\"><a href=\"#river是基于cglib动态代理以及guava作为基础来实现的，这里并没有使用jdk自带的代理方式实现。部分功能的实现是依靠guava或者在guava之上封装来完成的。\" class=\"headerlink\" title=\"river是基于cglib动态代理以及guava作为基础来实现的，这里并没有使用jdk自带的代理方式实现。部分功能的实现是依靠guava或者在guava之上封装来完成的。\"></a>river是基于cglib动态代理以及guava作为基础来实现的，这里并没有使用jdk自带的代理方式实现。部分功能的实现是依靠guava或者在guava之上封装来完成的。</h5><h2 id=\"river现有功能\"><a href=\"#river现有功能\" class=\"headerlink\" title=\"river现有功能\"></a>river现有功能</h2><h3 id=\"aop\"><a href=\"#aop\" class=\"headerlink\" title=\"aop\"></a>aop</h3><h5 id=\"aop是一个比较典型的例子，aop实现在目标方法之前、之后、异常等情况下的代码插入。这些插入的代码可以做类似于日志记录，流量统计等工作。也可以在before代码中修改目标方法参数，在after中修改目标方法返回值。但是没有办法控制目标方法是否继续（除非抛出异常）。\"><a href=\"#aop是一个比较典型的例子，aop实现在目标方法之前、之后、异常等情况下的代码插入。这些插入的代码可以做类似于日志记录，流量统计等工作。也可以在before代码中修改目标方法参数，在after中修改目标方法返回值。但是没有办法控制目标方法是否继续（除非抛出异常）。\" class=\"headerlink\" title=\"aop是一个比较典型的例子，aop实现在目标方法之前、之后、异常等情况下的代码插入。这些插入的代码可以做类似于日志记录，流量统计等工作。也可以在before代码中修改目标方法参数，在after中修改目标方法返回值。但是没有办法控制目标方法是否继续（除非抛出异常）。\"></a>aop是一个比较典型的例子，aop实现在目标方法之前、之后、异常等情况下的代码插入。这些插入的代码可以做类似于日志记录，流量统计等工作。也可以在before代码中修改目标方法参数，在after中修改目标方法返回值。但是没有办法控制目标方法是否继续（除非抛出异常）。</h5><h3 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h3><h5 id=\"cache显而易见，是对目标方法结果的缓存，在缓存结果有效期内，新的调用并不会去执行目标方法，而是直接拿缓存结果。并且用户可以自定义缓存的key（从入参中选取一部分参数，或者是某个对象中的某些属性来作为缓存的key）。\"><a href=\"#cache显而易见，是对目标方法结果的缓存，在缓存结果有效期内，新的调用并不会去执行目标方法，而是直接拿缓存结果。并且用户可以自定义缓存的key（从入参中选取一部分参数，或者是某个对象中的某些属性来作为缓存的key）。\" class=\"headerlink\" title=\"cache显而易见，是对目标方法结果的缓存，在缓存结果有效期内，新的调用并不会去执行目标方法，而是直接拿缓存结果。并且用户可以自定义缓存的key（从入参中选取一部分参数，或者是某个对象中的某些属性来作为缓存的key）。\"></a>cache显而易见，是对目标方法结果的缓存，在缓存结果有效期内，新的调用并不会去执行目标方法，而是直接拿缓存结果。并且用户可以自定义缓存的key（从入参中选取一部分参数，或者是某个对象中的某些属性来作为缓存的key）。</h5><h3 id=\"限流\"><a href=\"#限流\" class=\"headerlink\" title=\"限流\"></a>限流</h3><h5 id=\"rate-limit是对目标方法每秒的调用频率的限制。在限制的流量内，调用会非常顺畅。在超出的流量之外，调用会阻塞，直到新的调用机会。此外，也可以设置超时时间，如果有超时时间设置，在调用之前会先检查在超时时间内能否拿到调用的机会，如果不能，直接返回超时异常。\"><a href=\"#rate-limit是对目标方法每秒的调用频率的限制。在限制的流量内，调用会非常顺畅。在超出的流量之外，调用会阻塞，直到新的调用机会。此外，也可以设置超时时间，如果有超时时间设置，在调用之前会先检查在超时时间内能否拿到调用的机会，如果不能，直接返回超时异常。\" class=\"headerlink\" title=\"rate limit是对目标方法每秒的调用频率的限制。在限制的流量内，调用会非常顺畅。在超出的流量之外，调用会阻塞，直到新的调用机会。此外，也可以设置超时时间，如果有超时时间设置，在调用之前会先检查在超时时间内能否拿到调用的机会，如果不能，直接返回超时异常。\"></a>rate limit是对目标方法每秒的调用频率的限制。在限制的流量内，调用会非常顺畅。在超出的流量之外，调用会阻塞，直到新的调用机会。此外，也可以设置超时时间，如果有超时时间设置，在调用之前会先检查在超时时间内能否拿到调用的机会，如果不能，直接返回超时异常。</h5><h3 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h3><h5 id=\"目标方法会用新的线程去执行。可以理解成方法之间的异步执行，如果返回值是void或者是指定的类型。其他的返回值类型，虽然启用的新的线程去执行，但是会等待线程执行完成后拿到返回值再返回。\"><a href=\"#目标方法会用新的线程去执行。可以理解成方法之间的异步执行，如果返回值是void或者是指定的类型。其他的返回值类型，虽然启用的新的线程去执行，但是会等待线程执行完成后拿到返回值再返回。\" class=\"headerlink\" title=\"目标方法会用新的线程去执行。可以理解成方法之间的异步执行，如果返回值是void或者是指定的类型。其他的返回值类型，虽然启用的新的线程去执行，但是会等待线程执行完成后拿到返回值再返回。\"></a>目标方法会用新的线程去执行。可以理解成方法之间的异步执行，如果返回值是void或者是指定的类型。其他的返回值类型，虽然启用的新的线程去执行，但是会等待线程执行完成后拿到返回值再返回。</h5><h3 id=\"around\"><a href=\"#around\" class=\"headerlink\" title=\"around\"></a>around</h3><h5 id=\"around是最灵活的，around是现在river的功能的核心，around可以在A方法调用B方法之间插入C方法。C方法就叫做对B的around，C可以拿到B的入参、返回、method对象等，也可以控制调用B方法的时机，甚至是不调用。实际上，上面的各种功能的实现都可以用around自己实现，但是实现以上功能的成本对于普通使用者来说成本太高也没有必要。因此一些核心且重要的功能都已经单独实现，只需要使用相应的注解就可以了\"><a href=\"#around是最灵活的，around是现在river的功能的核心，around可以在A方法调用B方法之间插入C方法。C方法就叫做对B的around，C可以拿到B的入参、返回、method对象等，也可以控制调用B方法的时机，甚至是不调用。实际上，上面的各种功能的实现都可以用around自己实现，但是实现以上功能的成本对于普通使用者来说成本太高也没有必要。因此一些核心且重要的功能都已经单独实现，只需要使用相应的注解就可以了\" class=\"headerlink\" title=\"around是最灵活的，around是现在river的功能的核心，around可以在A方法调用B方法之间插入C方法。C方法就叫做对B的around，C可以拿到B的入参、返回、method对象等，也可以控制调用B方法的时机，甚至是不调用。实际上，上面的各种功能的实现都可以用around自己实现，但是实现以上功能的成本对于普通使用者来说成本太高也没有必要。因此一些核心且重要的功能都已经单独实现，只需要使用相应的注解就可以了\"></a>around是最灵活的，around是现在river的功能的核心，around可以在A方法调用B方法之间插入C方法。C方法就叫做对B的around，C可以拿到B的入参、返回、method对象等，也可以控制调用B方法的时机，甚至是不调用。实际上，上面的各种功能的实现都可以用around自己实现，但是实现以上功能的成本对于普通使用者来说成本太高也没有必要。因此一些核心且重要的功能都已经单独实现，只需要使用相应的注解就可以了</h5>"},{"layout":"post","title":"Aop","date":"2017-06-03T16:00:00.000Z","original":true,"color":"#E30D23","tag":[["river","river"]],"_content":"\n##### aop是一个比较典型的例子，aop实现在目标方法之前、之后、异常等情况下的代码插入。这些插入的代码可以做类似于日志记录，流量统计等工作。也可以在before代码中修改目标方法参数，在after中修改目标方法返回值。但是没有办法控制目标方法是否继续（除非抛出异常）。\n<!--more-->\n\n### 实例代码\n#### 首先需要实现一个继承自`AopPoint`的类。\n```java\npublic class AopTest extends AopPoint {\n\n    public void before() {\n        System.out.println(\"before....params:\" + Arrays.toString(getParams()));\n        setParams(new Object[]{\"change params\"});\n    }\n\n    public void after() {\n        System.out.println(\"after...result:\" + getResult());\n    }\n\n    public void afterReturing() {\n    }\n\n    public void afterThrowing() {\n    }\n}\n```\n#### 在目标方法中加入`Aop`注解,在Aop注解中设置自己实现的`AopPoint`类Class\n```java\n@Aop(AopTest.class)\npublic String aop(String param){\n    System.out.println(\"aop param : \" + param);\n    return param + \" success\";\n}\n```\n#### 获取目标方法类的代理实例，然后执行\n```java\nCrudServiceImpl proxy = ProxyFactory.getSingleProxy(CrudServiceImpl.class);\nproxy.aop(\"test\");\n```\n#### 执行结果\n```none\nbefore....params:[test]\naop param : change params\nafter...result:change params success\n```\n\n### 代码分析\n#### 继承自`AopPoint`的类,需要实现4个方法：\n##### `before`：在目标方法之前执行；\n##### `after`：在目标方法之后执行，无论目标执行是否成功；\n##### `afterReturing`：在目标方法执行之后执行；\n##### `afterThrowing`：在目标方法抛出异常后调用执行。\n#### 在`AopPoint`的子类中，设置了一些对目标方法的操作：\n```java\n/**\n * 获取目标方法Method对象\n */\nprotected Method getMethod() {}\n\n/**\n * 获取入参\n */\nprotected Object[] getParams() {}\n\n/**\n * 修改入参\n */\nprotected void setParams(Object[] objects) {}\n\n/**\n * 获取返回结果\n * 在before中调用这个方法将返回null\n */\nprotected Object getResult() {}\n\n/**\n * 修改返回结果\n * 在before中设置的返回结果将被正真的结果覆盖\n */\nprotected void setResult(Object result) {}\n```\n#### `AopPoint`的实现类会使用单例模式，所以当你Aop多个方法的时候，调用的都是将是同一个实例。因此下面这种代码将会出现线程安全问题\n```java\npublic class AopTest extends AopPoint {\n\n    private int i = 0;\n\n    public void before() {\n        System.out.println(++i);\n    }\n\n    ...\n}\n```\n##### 这种线程安全问题只能自己保证共享对象的安全。现在还不能通过参数改变aop的实例类是否单例。\n```java\npublic class AopTest extends AopPoint {\n\n    private AtomicInteger i = new AtomicInteger(0);\n\n    public void before() {\n        System.out.println(i.incrementAndGet());\n    }\n\n    ...\n}\n```\n\n#### aop大法好，但是也有一些局限性，说一说还能实现的一些细节点：\n1. 目前代理对象还是需要手动的去获取，这个在后期接入spring逻辑后，可以使用spring注入。\n2. 没有办法做到流程控制，是否可以在`AopPoint`中加入流程控制，当发现参数不对时，阻止流程的继续。\n3. 当目标方法比较多时，需要添加注解的地方比较多，这点Spring使用的是切面的解决方法，个人认为这种方法会使得使用的学习成本变高，因为每次我想要使用的时候需要翻看笔记。是否可以使得`Aop`支持类的注解，以减轻这种现象。\n4. 是否应该控制`AopPoint`实现类的单例与否。","source":"_posts/note/river/aop.md","raw":"---\nlayout: post\ntitle: Aop\ndate: 2017/06/04\noriginal: true\ntags: [tech, river, index, java]\ncolor: '#E30D23'\ntag: [[river, river]]\n---\n\n##### aop是一个比较典型的例子，aop实现在目标方法之前、之后、异常等情况下的代码插入。这些插入的代码可以做类似于日志记录，流量统计等工作。也可以在before代码中修改目标方法参数，在after中修改目标方法返回值。但是没有办法控制目标方法是否继续（除非抛出异常）。\n<!--more-->\n\n### 实例代码\n#### 首先需要实现一个继承自`AopPoint`的类。\n```java\npublic class AopTest extends AopPoint {\n\n    public void before() {\n        System.out.println(\"before....params:\" + Arrays.toString(getParams()));\n        setParams(new Object[]{\"change params\"});\n    }\n\n    public void after() {\n        System.out.println(\"after...result:\" + getResult());\n    }\n\n    public void afterReturing() {\n    }\n\n    public void afterThrowing() {\n    }\n}\n```\n#### 在目标方法中加入`Aop`注解,在Aop注解中设置自己实现的`AopPoint`类Class\n```java\n@Aop(AopTest.class)\npublic String aop(String param){\n    System.out.println(\"aop param : \" + param);\n    return param + \" success\";\n}\n```\n#### 获取目标方法类的代理实例，然后执行\n```java\nCrudServiceImpl proxy = ProxyFactory.getSingleProxy(CrudServiceImpl.class);\nproxy.aop(\"test\");\n```\n#### 执行结果\n```none\nbefore....params:[test]\naop param : change params\nafter...result:change params success\n```\n\n### 代码分析\n#### 继承自`AopPoint`的类,需要实现4个方法：\n##### `before`：在目标方法之前执行；\n##### `after`：在目标方法之后执行，无论目标执行是否成功；\n##### `afterReturing`：在目标方法执行之后执行；\n##### `afterThrowing`：在目标方法抛出异常后调用执行。\n#### 在`AopPoint`的子类中，设置了一些对目标方法的操作：\n```java\n/**\n * 获取目标方法Method对象\n */\nprotected Method getMethod() {}\n\n/**\n * 获取入参\n */\nprotected Object[] getParams() {}\n\n/**\n * 修改入参\n */\nprotected void setParams(Object[] objects) {}\n\n/**\n * 获取返回结果\n * 在before中调用这个方法将返回null\n */\nprotected Object getResult() {}\n\n/**\n * 修改返回结果\n * 在before中设置的返回结果将被正真的结果覆盖\n */\nprotected void setResult(Object result) {}\n```\n#### `AopPoint`的实现类会使用单例模式，所以当你Aop多个方法的时候，调用的都是将是同一个实例。因此下面这种代码将会出现线程安全问题\n```java\npublic class AopTest extends AopPoint {\n\n    private int i = 0;\n\n    public void before() {\n        System.out.println(++i);\n    }\n\n    ...\n}\n```\n##### 这种线程安全问题只能自己保证共享对象的安全。现在还不能通过参数改变aop的实例类是否单例。\n```java\npublic class AopTest extends AopPoint {\n\n    private AtomicInteger i = new AtomicInteger(0);\n\n    public void before() {\n        System.out.println(i.incrementAndGet());\n    }\n\n    ...\n}\n```\n\n#### aop大法好，但是也有一些局限性，说一说还能实现的一些细节点：\n1. 目前代理对象还是需要手动的去获取，这个在后期接入spring逻辑后，可以使用spring注入。\n2. 没有办法做到流程控制，是否可以在`AopPoint`中加入流程控制，当发现参数不对时，阻止流程的继续。\n3. 当目标方法比较多时，需要添加注解的地方比较多，这点Spring使用的是切面的解决方法，个人认为这种方法会使得使用的学习成本变高，因为每次我想要使用的时候需要翻看笔记。是否可以使得`Aop`支持类的注解，以减轻这种现象。\n4. 是否应该控制`AopPoint`实现类的单例与否。","slug":"note/river/aop","published":1,"updated":"2018-05-08T14:51:18.345Z","_id":"cjgxop3nv0046jah183ik7ufr","comments":1,"photos":[],"link":"","content":"<h5 id=\"aop是一个比较典型的例子，aop实现在目标方法之前、之后、异常等情况下的代码插入。这些插入的代码可以做类似于日志记录，流量统计等工作。也可以在before代码中修改目标方法参数，在after中修改目标方法返回值。但是没有办法控制目标方法是否继续（除非抛出异常）。\"><a href=\"#aop是一个比较典型的例子，aop实现在目标方法之前、之后、异常等情况下的代码插入。这些插入的代码可以做类似于日志记录，流量统计等工作。也可以在before代码中修改目标方法参数，在after中修改目标方法返回值。但是没有办法控制目标方法是否继续（除非抛出异常）。\" class=\"headerlink\" title=\"aop是一个比较典型的例子，aop实现在目标方法之前、之后、异常等情况下的代码插入。这些插入的代码可以做类似于日志记录，流量统计等工作。也可以在before代码中修改目标方法参数，在after中修改目标方法返回值。但是没有办法控制目标方法是否继续（除非抛出异常）。\"></a>aop是一个比较典型的例子，aop实现在目标方法之前、之后、异常等情况下的代码插入。这些插入的代码可以做类似于日志记录，流量统计等工作。也可以在before代码中修改目标方法参数，在after中修改目标方法返回值。但是没有办法控制目标方法是否继续（除非抛出异常）。</h5><a id=\"more\"></a>\n<h3 id=\"实例代码\"><a href=\"#实例代码\" class=\"headerlink\" title=\"实例代码\"></a>实例代码</h3><h4 id=\"首先需要实现一个继承自AopPoint的类。\"><a href=\"#首先需要实现一个继承自AopPoint的类。\" class=\"headerlink\" title=\"首先需要实现一个继承自AopPoint的类。\"></a>首先需要实现一个继承自<code>AopPoint</code>的类。</h4><pre><code class=\"lang-java\">public class AopTest extends AopPoint {\n\n    public void before() {\n        System.out.println(&quot;before....params:&quot; + Arrays.toString(getParams()));\n        setParams(new Object[]{&quot;change params&quot;});\n    }\n\n    public void after() {\n        System.out.println(&quot;after...result:&quot; + getResult());\n    }\n\n    public void afterReturing() {\n    }\n\n    public void afterThrowing() {\n    }\n}\n</code></pre>\n<h4 id=\"在目标方法中加入Aop注解-在Aop注解中设置自己实现的AopPoint类Class\"><a href=\"#在目标方法中加入Aop注解-在Aop注解中设置自己实现的AopPoint类Class\" class=\"headerlink\" title=\"在目标方法中加入Aop注解,在Aop注解中设置自己实现的AopPoint类Class\"></a>在目标方法中加入<code>Aop</code>注解,在Aop注解中设置自己实现的<code>AopPoint</code>类Class</h4><pre><code class=\"lang-java\">@Aop(AopTest.class)\npublic String aop(String param){\n    System.out.println(&quot;aop param : &quot; + param);\n    return param + &quot; success&quot;;\n}\n</code></pre>\n<h4 id=\"获取目标方法类的代理实例，然后执行\"><a href=\"#获取目标方法类的代理实例，然后执行\" class=\"headerlink\" title=\"获取目标方法类的代理实例，然后执行\"></a>获取目标方法类的代理实例，然后执行</h4><pre><code class=\"lang-java\">CrudServiceImpl proxy = ProxyFactory.getSingleProxy(CrudServiceImpl.class);\nproxy.aop(&quot;test&quot;);\n</code></pre>\n<h4 id=\"执行结果\"><a href=\"#执行结果\" class=\"headerlink\" title=\"执行结果\"></a>执行结果</h4><pre><code class=\"lang-none\">before....params:[test]\naop param : change params\nafter...result:change params success\n</code></pre>\n<h3 id=\"代码分析\"><a href=\"#代码分析\" class=\"headerlink\" title=\"代码分析\"></a>代码分析</h3><h4 id=\"继承自AopPoint的类-需要实现4个方法：\"><a href=\"#继承自AopPoint的类-需要实现4个方法：\" class=\"headerlink\" title=\"继承自AopPoint的类,需要实现4个方法：\"></a>继承自<code>AopPoint</code>的类,需要实现4个方法：</h4><h5 id=\"before：在目标方法之前执行；\"><a href=\"#before：在目标方法之前执行；\" class=\"headerlink\" title=\"before：在目标方法之前执行；\"></a><code>before</code>：在目标方法之前执行；</h5><h5 id=\"after：在目标方法之后执行，无论目标执行是否成功；\"><a href=\"#after：在目标方法之后执行，无论目标执行是否成功；\" class=\"headerlink\" title=\"after：在目标方法之后执行，无论目标执行是否成功；\"></a><code>after</code>：在目标方法之后执行，无论目标执行是否成功；</h5><h5 id=\"afterReturing：在目标方法执行之后执行；\"><a href=\"#afterReturing：在目标方法执行之后执行；\" class=\"headerlink\" title=\"afterReturing：在目标方法执行之后执行；\"></a><code>afterReturing</code>：在目标方法执行之后执行；</h5><h5 id=\"afterThrowing：在目标方法抛出异常后调用执行。\"><a href=\"#afterThrowing：在目标方法抛出异常后调用执行。\" class=\"headerlink\" title=\"afterThrowing：在目标方法抛出异常后调用执行。\"></a><code>afterThrowing</code>：在目标方法抛出异常后调用执行。</h5><h4 id=\"在AopPoint的子类中，设置了一些对目标方法的操作：\"><a href=\"#在AopPoint的子类中，设置了一些对目标方法的操作：\" class=\"headerlink\" title=\"在AopPoint的子类中，设置了一些对目标方法的操作：\"></a>在<code>AopPoint</code>的子类中，设置了一些对目标方法的操作：</h4><pre><code class=\"lang-java\">/**\n * 获取目标方法Method对象\n */\nprotected Method getMethod() {}\n\n/**\n * 获取入参\n */\nprotected Object[] getParams() {}\n\n/**\n * 修改入参\n */\nprotected void setParams(Object[] objects) {}\n\n/**\n * 获取返回结果\n * 在before中调用这个方法将返回null\n */\nprotected Object getResult() {}\n\n/**\n * 修改返回结果\n * 在before中设置的返回结果将被正真的结果覆盖\n */\nprotected void setResult(Object result) {}\n</code></pre>\n<h4 id=\"AopPoint的实现类会使用单例模式，所以当你Aop多个方法的时候，调用的都是将是同一个实例。因此下面这种代码将会出现线程安全问题\"><a href=\"#AopPoint的实现类会使用单例模式，所以当你Aop多个方法的时候，调用的都是将是同一个实例。因此下面这种代码将会出现线程安全问题\" class=\"headerlink\" title=\"AopPoint的实现类会使用单例模式，所以当你Aop多个方法的时候，调用的都是将是同一个实例。因此下面这种代码将会出现线程安全问题\"></a><code>AopPoint</code>的实现类会使用单例模式，所以当你Aop多个方法的时候，调用的都是将是同一个实例。因此下面这种代码将会出现线程安全问题</h4><pre><code class=\"lang-java\">public class AopTest extends AopPoint {\n\n    private int i = 0;\n\n    public void before() {\n        System.out.println(++i);\n    }\n\n    ...\n}\n</code></pre>\n<h5 id=\"这种线程安全问题只能自己保证共享对象的安全。现在还不能通过参数改变aop的实例类是否单例。\"><a href=\"#这种线程安全问题只能自己保证共享对象的安全。现在还不能通过参数改变aop的实例类是否单例。\" class=\"headerlink\" title=\"这种线程安全问题只能自己保证共享对象的安全。现在还不能通过参数改变aop的实例类是否单例。\"></a>这种线程安全问题只能自己保证共享对象的安全。现在还不能通过参数改变aop的实例类是否单例。</h5><pre><code class=\"lang-java\">public class AopTest extends AopPoint {\n\n    private AtomicInteger i = new AtomicInteger(0);\n\n    public void before() {\n        System.out.println(i.incrementAndGet());\n    }\n\n    ...\n}\n</code></pre>\n<h4 id=\"aop大法好，但是也有一些局限性，说一说还能实现的一些细节点：\"><a href=\"#aop大法好，但是也有一些局限性，说一说还能实现的一些细节点：\" class=\"headerlink\" title=\"aop大法好，但是也有一些局限性，说一说还能实现的一些细节点：\"></a>aop大法好，但是也有一些局限性，说一说还能实现的一些细节点：</h4><ol>\n<li>目前代理对象还是需要手动的去获取，这个在后期接入spring逻辑后，可以使用spring注入。</li>\n<li>没有办法做到流程控制，是否可以在<code>AopPoint</code>中加入流程控制，当发现参数不对时，阻止流程的继续。</li>\n<li>当目标方法比较多时，需要添加注解的地方比较多，这点Spring使用的是切面的解决方法，个人认为这种方法会使得使用的学习成本变高，因为每次我想要使用的时候需要翻看笔记。是否可以使得<code>Aop</code>支持类的注解，以减轻这种现象。</li>\n<li>是否应该控制<code>AopPoint</code>实现类的单例与否。</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h5 id=\"aop是一个比较典型的例子，aop实现在目标方法之前、之后、异常等情况下的代码插入。这些插入的代码可以做类似于日志记录，流量统计等工作。也可以在before代码中修改目标方法参数，在after中修改目标方法返回值。但是没有办法控制目标方法是否继续（除非抛出异常）。\"><a href=\"#aop是一个比较典型的例子，aop实现在目标方法之前、之后、异常等情况下的代码插入。这些插入的代码可以做类似于日志记录，流量统计等工作。也可以在before代码中修改目标方法参数，在after中修改目标方法返回值。但是没有办法控制目标方法是否继续（除非抛出异常）。\" class=\"headerlink\" title=\"aop是一个比较典型的例子，aop实现在目标方法之前、之后、异常等情况下的代码插入。这些插入的代码可以做类似于日志记录，流量统计等工作。也可以在before代码中修改目标方法参数，在after中修改目标方法返回值。但是没有办法控制目标方法是否继续（除非抛出异常）。\"></a>aop是一个比较典型的例子，aop实现在目标方法之前、之后、异常等情况下的代码插入。这些插入的代码可以做类似于日志记录，流量统计等工作。也可以在before代码中修改目标方法参数，在after中修改目标方法返回值。但是没有办法控制目标方法是否继续（除非抛出异常）。</h5>","more":"<h3 id=\"实例代码\"><a href=\"#实例代码\" class=\"headerlink\" title=\"实例代码\"></a>实例代码</h3><h4 id=\"首先需要实现一个继承自AopPoint的类。\"><a href=\"#首先需要实现一个继承自AopPoint的类。\" class=\"headerlink\" title=\"首先需要实现一个继承自AopPoint的类。\"></a>首先需要实现一个继承自<code>AopPoint</code>的类。</h4><pre><code class=\"lang-java\">public class AopTest extends AopPoint {\n\n    public void before() {\n        System.out.println(&quot;before....params:&quot; + Arrays.toString(getParams()));\n        setParams(new Object[]{&quot;change params&quot;});\n    }\n\n    public void after() {\n        System.out.println(&quot;after...result:&quot; + getResult());\n    }\n\n    public void afterReturing() {\n    }\n\n    public void afterThrowing() {\n    }\n}\n</code></pre>\n<h4 id=\"在目标方法中加入Aop注解-在Aop注解中设置自己实现的AopPoint类Class\"><a href=\"#在目标方法中加入Aop注解-在Aop注解中设置自己实现的AopPoint类Class\" class=\"headerlink\" title=\"在目标方法中加入Aop注解,在Aop注解中设置自己实现的AopPoint类Class\"></a>在目标方法中加入<code>Aop</code>注解,在Aop注解中设置自己实现的<code>AopPoint</code>类Class</h4><pre><code class=\"lang-java\">@Aop(AopTest.class)\npublic String aop(String param){\n    System.out.println(&quot;aop param : &quot; + param);\n    return param + &quot; success&quot;;\n}\n</code></pre>\n<h4 id=\"获取目标方法类的代理实例，然后执行\"><a href=\"#获取目标方法类的代理实例，然后执行\" class=\"headerlink\" title=\"获取目标方法类的代理实例，然后执行\"></a>获取目标方法类的代理实例，然后执行</h4><pre><code class=\"lang-java\">CrudServiceImpl proxy = ProxyFactory.getSingleProxy(CrudServiceImpl.class);\nproxy.aop(&quot;test&quot;);\n</code></pre>\n<h4 id=\"执行结果\"><a href=\"#执行结果\" class=\"headerlink\" title=\"执行结果\"></a>执行结果</h4><pre><code class=\"lang-none\">before....params:[test]\naop param : change params\nafter...result:change params success\n</code></pre>\n<h3 id=\"代码分析\"><a href=\"#代码分析\" class=\"headerlink\" title=\"代码分析\"></a>代码分析</h3><h4 id=\"继承自AopPoint的类-需要实现4个方法：\"><a href=\"#继承自AopPoint的类-需要实现4个方法：\" class=\"headerlink\" title=\"继承自AopPoint的类,需要实现4个方法：\"></a>继承自<code>AopPoint</code>的类,需要实现4个方法：</h4><h5 id=\"before：在目标方法之前执行；\"><a href=\"#before：在目标方法之前执行；\" class=\"headerlink\" title=\"before：在目标方法之前执行；\"></a><code>before</code>：在目标方法之前执行；</h5><h5 id=\"after：在目标方法之后执行，无论目标执行是否成功；\"><a href=\"#after：在目标方法之后执行，无论目标执行是否成功；\" class=\"headerlink\" title=\"after：在目标方法之后执行，无论目标执行是否成功；\"></a><code>after</code>：在目标方法之后执行，无论目标执行是否成功；</h5><h5 id=\"afterReturing：在目标方法执行之后执行；\"><a href=\"#afterReturing：在目标方法执行之后执行；\" class=\"headerlink\" title=\"afterReturing：在目标方法执行之后执行；\"></a><code>afterReturing</code>：在目标方法执行之后执行；</h5><h5 id=\"afterThrowing：在目标方法抛出异常后调用执行。\"><a href=\"#afterThrowing：在目标方法抛出异常后调用执行。\" class=\"headerlink\" title=\"afterThrowing：在目标方法抛出异常后调用执行。\"></a><code>afterThrowing</code>：在目标方法抛出异常后调用执行。</h5><h4 id=\"在AopPoint的子类中，设置了一些对目标方法的操作：\"><a href=\"#在AopPoint的子类中，设置了一些对目标方法的操作：\" class=\"headerlink\" title=\"在AopPoint的子类中，设置了一些对目标方法的操作：\"></a>在<code>AopPoint</code>的子类中，设置了一些对目标方法的操作：</h4><pre><code class=\"lang-java\">/**\n * 获取目标方法Method对象\n */\nprotected Method getMethod() {}\n\n/**\n * 获取入参\n */\nprotected Object[] getParams() {}\n\n/**\n * 修改入参\n */\nprotected void setParams(Object[] objects) {}\n\n/**\n * 获取返回结果\n * 在before中调用这个方法将返回null\n */\nprotected Object getResult() {}\n\n/**\n * 修改返回结果\n * 在before中设置的返回结果将被正真的结果覆盖\n */\nprotected void setResult(Object result) {}\n</code></pre>\n<h4 id=\"AopPoint的实现类会使用单例模式，所以当你Aop多个方法的时候，调用的都是将是同一个实例。因此下面这种代码将会出现线程安全问题\"><a href=\"#AopPoint的实现类会使用单例模式，所以当你Aop多个方法的时候，调用的都是将是同一个实例。因此下面这种代码将会出现线程安全问题\" class=\"headerlink\" title=\"AopPoint的实现类会使用单例模式，所以当你Aop多个方法的时候，调用的都是将是同一个实例。因此下面这种代码将会出现线程安全问题\"></a><code>AopPoint</code>的实现类会使用单例模式，所以当你Aop多个方法的时候，调用的都是将是同一个实例。因此下面这种代码将会出现线程安全问题</h4><pre><code class=\"lang-java\">public class AopTest extends AopPoint {\n\n    private int i = 0;\n\n    public void before() {\n        System.out.println(++i);\n    }\n\n    ...\n}\n</code></pre>\n<h5 id=\"这种线程安全问题只能自己保证共享对象的安全。现在还不能通过参数改变aop的实例类是否单例。\"><a href=\"#这种线程安全问题只能自己保证共享对象的安全。现在还不能通过参数改变aop的实例类是否单例。\" class=\"headerlink\" title=\"这种线程安全问题只能自己保证共享对象的安全。现在还不能通过参数改变aop的实例类是否单例。\"></a>这种线程安全问题只能自己保证共享对象的安全。现在还不能通过参数改变aop的实例类是否单例。</h5><pre><code class=\"lang-java\">public class AopTest extends AopPoint {\n\n    private AtomicInteger i = new AtomicInteger(0);\n\n    public void before() {\n        System.out.println(i.incrementAndGet());\n    }\n\n    ...\n}\n</code></pre>\n<h4 id=\"aop大法好，但是也有一些局限性，说一说还能实现的一些细节点：\"><a href=\"#aop大法好，但是也有一些局限性，说一说还能实现的一些细节点：\" class=\"headerlink\" title=\"aop大法好，但是也有一些局限性，说一说还能实现的一些细节点：\"></a>aop大法好，但是也有一些局限性，说一说还能实现的一些细节点：</h4><ol>\n<li>目前代理对象还是需要手动的去获取，这个在后期接入spring逻辑后，可以使用spring注入。</li>\n<li>没有办法做到流程控制，是否可以在<code>AopPoint</code>中加入流程控制，当发现参数不对时，阻止流程的继续。</li>\n<li>当目标方法比较多时，需要添加注解的地方比较多，这点Spring使用的是切面的解决方法，个人认为这种方法会使得使用的学习成本变高，因为每次我想要使用的时候需要翻看笔记。是否可以使得<code>Aop</code>支持类的注解，以减轻这种现象。</li>\n<li>是否应该控制<code>AopPoint</code>实现类的单例与否。</li>\n</ol>"},{"layout":"post","title":"缓存","date":"2017-06-04T16:00:00.000Z","original":true,"tag":[["river","river"]],"_content":"\n##### cache的功能显而易见，是对目标方法结果的缓存，在缓存结果有效期内，新的调用并不会去执行目标方法，而是直接拿缓存结果。并且用户可以自定义缓存的key（从入参中选取一部分参数，或者是某个对象中的某些属性来作为缓存的key）。\n<!--more-->\n\n### 实例代码\n#### 目标方法添加`cache`注解\n```java\n@Cache(maxSize = 2, timeOut = 1, timeUnit = TimeUnit.MINUTES)\npublic String cache(String param){\n    System.out.println(\"cache param : \" + param);\n    return param + \" success\";\n}\n```\n#### 获取代理对象实例，调用目标方法\n```java\nfinal CrudServiceImpl proxy = ProxyFactory.getSingleProxy(CrudServiceImpl.class);\nfor (int i = 0; i < 10; i ++){\n    System.out.println(proxy.cache(\"cache key\"));\n}\n```\n#### 执行结果\n```none\ncache param : cache key\ncache key success\ncache key success\ncache key success\ncache key success\ncache key success\ncache key success\ncache key success\ncache key success\ncache key success\ncache key success\n```\n\n### 代码分析\n\n#### 缓存大法好，但是也有一些局限性，说一说还能实现的一些细节点：\n1. 目前代理对象还是需要手动的去获取，这个在后期接入spring逻辑后，可以使用spring注入。","source":"_posts/note/river/cache.md","raw":"---\nlayout: post\ntitle: 缓存\ndate: 2017/06/05\noriginal: true\ntags: [tech, river, index, java]\ntag: [[river, river]]\n---\n\n##### cache的功能显而易见，是对目标方法结果的缓存，在缓存结果有效期内，新的调用并不会去执行目标方法，而是直接拿缓存结果。并且用户可以自定义缓存的key（从入参中选取一部分参数，或者是某个对象中的某些属性来作为缓存的key）。\n<!--more-->\n\n### 实例代码\n#### 目标方法添加`cache`注解\n```java\n@Cache(maxSize = 2, timeOut = 1, timeUnit = TimeUnit.MINUTES)\npublic String cache(String param){\n    System.out.println(\"cache param : \" + param);\n    return param + \" success\";\n}\n```\n#### 获取代理对象实例，调用目标方法\n```java\nfinal CrudServiceImpl proxy = ProxyFactory.getSingleProxy(CrudServiceImpl.class);\nfor (int i = 0; i < 10; i ++){\n    System.out.println(proxy.cache(\"cache key\"));\n}\n```\n#### 执行结果\n```none\ncache param : cache key\ncache key success\ncache key success\ncache key success\ncache key success\ncache key success\ncache key success\ncache key success\ncache key success\ncache key success\ncache key success\n```\n\n### 代码分析\n\n#### 缓存大法好，但是也有一些局限性，说一说还能实现的一些细节点：\n1. 目前代理对象还是需要手动的去获取，这个在后期接入spring逻辑后，可以使用spring注入。","slug":"note/river/cache","published":1,"updated":"2018-05-08T14:51:18.349Z","_id":"cjgxop3nx0049jah1xkzal9ni","comments":1,"photos":[],"link":"","content":"<h5 id=\"cache的功能显而易见，是对目标方法结果的缓存，在缓存结果有效期内，新的调用并不会去执行目标方法，而是直接拿缓存结果。并且用户可以自定义缓存的key（从入参中选取一部分参数，或者是某个对象中的某些属性来作为缓存的key）。\"><a href=\"#cache的功能显而易见，是对目标方法结果的缓存，在缓存结果有效期内，新的调用并不会去执行目标方法，而是直接拿缓存结果。并且用户可以自定义缓存的key（从入参中选取一部分参数，或者是某个对象中的某些属性来作为缓存的key）。\" class=\"headerlink\" title=\"cache的功能显而易见，是对目标方法结果的缓存，在缓存结果有效期内，新的调用并不会去执行目标方法，而是直接拿缓存结果。并且用户可以自定义缓存的key（从入参中选取一部分参数，或者是某个对象中的某些属性来作为缓存的key）。\"></a>cache的功能显而易见，是对目标方法结果的缓存，在缓存结果有效期内，新的调用并不会去执行目标方法，而是直接拿缓存结果。并且用户可以自定义缓存的key（从入参中选取一部分参数，或者是某个对象中的某些属性来作为缓存的key）。</h5><a id=\"more\"></a>\n<h3 id=\"实例代码\"><a href=\"#实例代码\" class=\"headerlink\" title=\"实例代码\"></a>实例代码</h3><h4 id=\"目标方法添加cache注解\"><a href=\"#目标方法添加cache注解\" class=\"headerlink\" title=\"目标方法添加cache注解\"></a>目标方法添加<code>cache</code>注解</h4><pre><code class=\"lang-java\">@Cache(maxSize = 2, timeOut = 1, timeUnit = TimeUnit.MINUTES)\npublic String cache(String param){\n    System.out.println(&quot;cache param : &quot; + param);\n    return param + &quot; success&quot;;\n}\n</code></pre>\n<h4 id=\"获取代理对象实例，调用目标方法\"><a href=\"#获取代理对象实例，调用目标方法\" class=\"headerlink\" title=\"获取代理对象实例，调用目标方法\"></a>获取代理对象实例，调用目标方法</h4><pre><code class=\"lang-java\">final CrudServiceImpl proxy = ProxyFactory.getSingleProxy(CrudServiceImpl.class);\nfor (int i = 0; i &lt; 10; i ++){\n    System.out.println(proxy.cache(&quot;cache key&quot;));\n}\n</code></pre>\n<h4 id=\"执行结果\"><a href=\"#执行结果\" class=\"headerlink\" title=\"执行结果\"></a>执行结果</h4><pre><code class=\"lang-none\">cache param : cache key\ncache key success\ncache key success\ncache key success\ncache key success\ncache key success\ncache key success\ncache key success\ncache key success\ncache key success\ncache key success\n</code></pre>\n<h3 id=\"代码分析\"><a href=\"#代码分析\" class=\"headerlink\" title=\"代码分析\"></a>代码分析</h3><h4 id=\"缓存大法好，但是也有一些局限性，说一说还能实现的一些细节点：\"><a href=\"#缓存大法好，但是也有一些局限性，说一说还能实现的一些细节点：\" class=\"headerlink\" title=\"缓存大法好，但是也有一些局限性，说一说还能实现的一些细节点：\"></a>缓存大法好，但是也有一些局限性，说一说还能实现的一些细节点：</h4><ol>\n<li>目前代理对象还是需要手动的去获取，这个在后期接入spring逻辑后，可以使用spring注入。</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h5 id=\"cache的功能显而易见，是对目标方法结果的缓存，在缓存结果有效期内，新的调用并不会去执行目标方法，而是直接拿缓存结果。并且用户可以自定义缓存的key（从入参中选取一部分参数，或者是某个对象中的某些属性来作为缓存的key）。\"><a href=\"#cache的功能显而易见，是对目标方法结果的缓存，在缓存结果有效期内，新的调用并不会去执行目标方法，而是直接拿缓存结果。并且用户可以自定义缓存的key（从入参中选取一部分参数，或者是某个对象中的某些属性来作为缓存的key）。\" class=\"headerlink\" title=\"cache的功能显而易见，是对目标方法结果的缓存，在缓存结果有效期内，新的调用并不会去执行目标方法，而是直接拿缓存结果。并且用户可以自定义缓存的key（从入参中选取一部分参数，或者是某个对象中的某些属性来作为缓存的key）。\"></a>cache的功能显而易见，是对目标方法结果的缓存，在缓存结果有效期内，新的调用并不会去执行目标方法，而是直接拿缓存结果。并且用户可以自定义缓存的key（从入参中选取一部分参数，或者是某个对象中的某些属性来作为缓存的key）。</h5>","more":"<h3 id=\"实例代码\"><a href=\"#实例代码\" class=\"headerlink\" title=\"实例代码\"></a>实例代码</h3><h4 id=\"目标方法添加cache注解\"><a href=\"#目标方法添加cache注解\" class=\"headerlink\" title=\"目标方法添加cache注解\"></a>目标方法添加<code>cache</code>注解</h4><pre><code class=\"lang-java\">@Cache(maxSize = 2, timeOut = 1, timeUnit = TimeUnit.MINUTES)\npublic String cache(String param){\n    System.out.println(&quot;cache param : &quot; + param);\n    return param + &quot; success&quot;;\n}\n</code></pre>\n<h4 id=\"获取代理对象实例，调用目标方法\"><a href=\"#获取代理对象实例，调用目标方法\" class=\"headerlink\" title=\"获取代理对象实例，调用目标方法\"></a>获取代理对象实例，调用目标方法</h4><pre><code class=\"lang-java\">final CrudServiceImpl proxy = ProxyFactory.getSingleProxy(CrudServiceImpl.class);\nfor (int i = 0; i &lt; 10; i ++){\n    System.out.println(proxy.cache(&quot;cache key&quot;));\n}\n</code></pre>\n<h4 id=\"执行结果\"><a href=\"#执行结果\" class=\"headerlink\" title=\"执行结果\"></a>执行结果</h4><pre><code class=\"lang-none\">cache param : cache key\ncache key success\ncache key success\ncache key success\ncache key success\ncache key success\ncache key success\ncache key success\ncache key success\ncache key success\ncache key success\n</code></pre>\n<h3 id=\"代码分析\"><a href=\"#代码分析\" class=\"headerlink\" title=\"代码分析\"></a>代码分析</h3><h4 id=\"缓存大法好，但是也有一些局限性，说一说还能实现的一些细节点：\"><a href=\"#缓存大法好，但是也有一些局限性，说一说还能实现的一些细节点：\" class=\"headerlink\" title=\"缓存大法好，但是也有一些局限性，说一说还能实现的一些细节点：\"></a>缓存大法好，但是也有一些局限性，说一说还能实现的一些细节点：</h4><ol>\n<li>目前代理对象还是需要手动的去获取，这个在后期接入spring逻辑后，可以使用spring注入。</li>\n</ol>"},{"layout":"post","title":"spring ioc容器初始化流程","date":"2018-04-14T16:00:00.000Z","original":true,"tag":[["spring","spring"],["java","java"]],"_content":"\n##### IOC容器是Spring的核心之一，就是具有依赖注入功能的容器，IOC容器负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。应用程序无需在代码中new相关的对象，应用程序由IOC容器进行组装。具体的Spring和IOC的功能要点这里不做详细介绍，本文的重点将是围绕IOC的创建流程去发现和学习Spring的核心原理。\n<!--more-->\n\n## 介绍\n##### Ioc容器的初始化是由refresh（）方法来启动的，这个方法标志着Ioc容器的正式启动。具体来说这个启动过程包括三个基本过程：\n1. BeanDifinition的Resource定位\n2. BeanDifinition的载入与解析\n3. BeanDifinition在Ioc容器中的注册\n\n##### 需要注意的是，Spring把这三个过程分开，并使用不同的模块来完成，如使用相应的ResourceLoader、BeanDifinitionReader等模块，通过这样的实际方式，可以让用户更加灵活的对这三个过程进行剪裁和扩展。\n##### 这些过程都是在AbstractApplicationContext中的refresh()方法中完成的\n```java\npublic void refresh() throws BeansException, IllegalStateException {\n\t\tsynchronized (this.startupShutdownMonitor) {\n\t\t\t// 准备工作\n\t\t\tprepareRefresh();\n\n\t\t\t// 通过子类创建beanFactory\n\t\t\tConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();\n\n\t\t\t// beanFactory的准备工作\n\t\t\tprepareBeanFactory(beanFactory);\n\n\t\t\ttry {\n\t\t\t\t// 设置beanFactory的后置处理\n\t\t\t\tpostProcessBeanFactory(beanFactory);\n\n\t\t\t\t// 调用beanFactory的后处理器，这些后处理器是在Bean定义中向容器注册的\n\t\t\t\tinvokeBeanFactoryPostProcessors(beanFactory);\n\n\t\t\t\t// 注册Bean的后处理器，在Bean创建过程中调用\n\t\t\t\tregisterBeanPostProcessors(beanFactory);\n\n\t\t\t\t// 初始化上下文中的消息源\n\t\t\t\tinitMessageSource();\n\n\t\t\t\t// 初始化时间机制\n\t\t\t\tinitApplicationEventMulticaster();\n\n\t\t\t\t// 初始化其他特殊Bean\n\t\t\t\tonRefresh();\n\n\t\t\t\t// 检查监听Bean并且将这些Bean向容器注册\n\t\t\t\tregisterListeners();\n\n\t\t\t\t// 实例化所有non-lazy-init组件\n\t\t\t\tfinishBeanFactoryInitialization(beanFactory);\n\n\t\t\t\t// 发布容器事件，结束初始化流程\n\t\t\t\tfinishRefresh();\n\t\t\t}\n\n\t\t\tcatch (BeansException ex) {\n\t\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\t\tlogger.warn(\"Exception encountered during context initialization - \" +\n\t\t\t\t\t\t\t\"cancelling refresh attempt: \" + ex);\n\t\t\t\t}\n\n\t\t\t\t// 为防止Bean资源占用，如果出现异常，销毁已经在前面过程中生成的单元Bean\n\t\t\t\tdestroyBeans();\n\n\t\t\t\t// 重置 'active' 标志.\n\t\t\t\tcancelRefresh(ex);\n\n\t\t\t\tthrow ex;\n\t\t\t}\n\n\t\t\tfinally {\n\t\t\t\tresetCommonCaches();\n\t\t\t}\n\t\t}\n\t}\n```\n\n## 源码解析\n##### 首先来看下BeanFactory的创建\n\n### 创建beanFactory：obtainFreshBeanFactory()\n```java\nprotected ConfigurableListableBeanFactory obtainFreshBeanFactory() {\n\trefreshBeanFactory();\n\tConfigurableListableBeanFactory beanFactory = getBeanFactory();\n\tif (logger.isDebugEnabled()) {\n\t\tlogger.debug(\"Bean factory for \" + getDisplayName() + \": \" + beanFactory);\n\t}\n\treturn beanFactory;\n}\n```\n\n##### obtainFreshBeanFactory()方法获取的是ConfigurableListableBeanFactory，这里的操作很简单，refreshBeanFactory创建BeanFactory，然后获取并返回。让我们继续看下refreshBeanFactory():\n```java\nprotected abstract void refreshBeanFactory() throws BeansException, IllegalStateException;\n```\n##### 抽象方法，看下AbstractRefreshableApplicationContext中的实现：\n```java\nprotected final void refreshBeanFactory() throws BeansException {\n\tif (hasBeanFactory()) {\n\t    //如果BeanFactory已经被创建，则销毁并关闭它\n\t\tdestroyBeans();\n\t\tcloseBeanFactory();\n\t}\n\ttry {\n\t    //创建DefaultListableBeanFactory\n\t\tDefaultListableBeanFactory beanFactory = createBeanFactory(); \n\t\tbeanFactory.setSerializationId(getId());\n\t\t//属性继承\n\t\tcustomizeBeanFactory(beanFactory);\n\t\t//载入BeanDefinitions\n\t\tloadBeanDefinitions(beanFactory);\n\t\tsynchronized (this.beanFactoryMonitor) {\n\t\t\tthis.beanFactory = beanFactory;\n\t\t}\n\t}\n\tcatch (IOException ex) {\n\t\tthrow new ApplicationContextException(\"I/O error parsing bean definition source for \" + getDisplayName(), ex);\n\t}\n}\n```\n#### createBeanFactory():\n```java\nprotected DefaultListableBeanFactory createBeanFactory() {\n\treturn new DefaultListableBeanFactory(getInternalParentBeanFactory());\n}\n``` \n##### 实例化一个DefaultListableBeanFactory并设置其父BeanFactory，看下getInternalParentBeanFactory():\n```java\nprotected BeanFactory getInternalParentBeanFactory() {\n\treturn (getParent() instanceof ConfigurableApplicationContext) ?\n\t\t\t((ConfigurableApplicationContext) getParent()).getBeanFactory() : getParent();\n}\n```\n\n#### customizeBeanFactory(beanFactory)\n```java\nprotected void customizeBeanFactory(DefaultListableBeanFactory beanFactory) {\n\tif (this.allowBeanDefinitionOverriding != null) {\n\t\tbeanFactory.setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);\n\t}\n\tif (this.allowCircularReferences != null) {\n\t\tbeanFactory.setAllowCircularReferences(this.allowCircularReferences);\n\t}\n}\n```\n##### 继承容器的属性设置：\n1. allowBeanDefinitionOverriding：当不同文件中配置了相同id或者name的同一类型的两个bean时，是否允许覆盖\n2. allowCircularReferences：是否允许循环引用\n\n#### loadBeanDefinitions(DefaultListableBeanFactory):\n```java\nprotected abstract void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException;\n```\n\n##### 抽象方法，我们以XmlWebApplicationContext作为例子看下实现的过程\n```java\nprotected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException {\n\t// 根据beanFactory创建新的XmlBeanDefinitionReader\n\tXmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);\n\tbeanDefinitionReader.setEnvironment(this.getEnvironment());\n\tbeanDefinitionReader.setResourceLoader(this);\n\tbeanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));\n\tinitBeanDefinitionReader(beanDefinitionReader);\n\tloadBeanDefinitions(beanDefinitionReader);\n}\n```\n\n##### 直接看最后的loadBeanDefinitions(XmlBeanDefinitionReader):\n```java\nprotected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws IOException {\n    //加载配置地址\n\tString[] configLocations = getConfigLocations();\n\tif (configLocations != null) {\n\t\tfor (String configLocation : configLocations) {\n\t\t\treader.loadBeanDefinitions(configLocation);\n\t\t}\n\t}\n}\n```\n\n##### 根据地址循环载入BeanDefinition：\n```java\npublic int loadBeanDefinitions(String location) throws BeanDefinitionStoreException {\n\treturn loadBeanDefinitions(location, null);\n}\n```\n##### 真正的执行过程：\n```java\npublic int loadBeanDefinitions(String location, Set<Resource> actualResources) throws BeanDefinitionStoreException {\n    //获取resourceLoader\n\tResourceLoader resourceLoader = getResourceLoader();\n\tif (resourceLoader == null) {\n\t\tthrow new BeanDefinitionStoreException(\n\t\t\t\t\"Cannot import bean definitions from location [\" + location + \"]: no ResourceLoader available\");\n\t}\n\tif (resourceLoader instanceof ResourcePatternResolver) {\n\t\t// Resource pattern matching available.\n\t\ttry {\n\t\t    //定位资源\n\t\t\tResource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);\n\t\t\tint loadCount = loadBeanDefinitions(resources);\n\t\t\tif (actualResources != null) {\n\t\t\t\tfor (Resource resource : resources) {\n\t\t\t\t\tactualResources.add(resource);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Loaded \" + loadCount + \" bean definitions from location pattern [\" + location + \"]\");\n\t\t\t}\n\t\t\treturn loadCount;\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new BeanDefinitionStoreException(\n\t\t\t\t\t\"Could not resolve bean definition resource pattern [\" + location + \"]\", ex);\n\t\t}\n\t}\n\telse {\n\t\t// Can only load single resources by absolute URL.\n\t\tResource resource = resourceLoader.getResource(location);\n\t\tint loadCount = loadBeanDefinitions(resource);\n\t\tif (actualResources != null) {\n\t\t\tactualResources.add(resource);\n\t\t}\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Loaded \" + loadCount + \" bean definitions from location [\" + location + \"]\");\n\t\t}\n\t\treturn loadCount;\n\t}\n}\n```\n##### 具体的执行流程这里不做结束，总之Spring在加载BeanFactory之后，通过factory去载入了BeanDefinition\n\n##\n\n","source":"_posts/note/spring/springIoc.md","raw":"---\nlayout: post\ntitle: spring ioc容器初始化流程\ndate: 2018/04/15\ntags: [hide]\noriginal: true\ntag: [[spring, spring],[java, java]]\n---\n\n##### IOC容器是Spring的核心之一，就是具有依赖注入功能的容器，IOC容器负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。应用程序无需在代码中new相关的对象，应用程序由IOC容器进行组装。具体的Spring和IOC的功能要点这里不做详细介绍，本文的重点将是围绕IOC的创建流程去发现和学习Spring的核心原理。\n<!--more-->\n\n## 介绍\n##### Ioc容器的初始化是由refresh（）方法来启动的，这个方法标志着Ioc容器的正式启动。具体来说这个启动过程包括三个基本过程：\n1. BeanDifinition的Resource定位\n2. BeanDifinition的载入与解析\n3. BeanDifinition在Ioc容器中的注册\n\n##### 需要注意的是，Spring把这三个过程分开，并使用不同的模块来完成，如使用相应的ResourceLoader、BeanDifinitionReader等模块，通过这样的实际方式，可以让用户更加灵活的对这三个过程进行剪裁和扩展。\n##### 这些过程都是在AbstractApplicationContext中的refresh()方法中完成的\n```java\npublic void refresh() throws BeansException, IllegalStateException {\n\t\tsynchronized (this.startupShutdownMonitor) {\n\t\t\t// 准备工作\n\t\t\tprepareRefresh();\n\n\t\t\t// 通过子类创建beanFactory\n\t\t\tConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();\n\n\t\t\t// beanFactory的准备工作\n\t\t\tprepareBeanFactory(beanFactory);\n\n\t\t\ttry {\n\t\t\t\t// 设置beanFactory的后置处理\n\t\t\t\tpostProcessBeanFactory(beanFactory);\n\n\t\t\t\t// 调用beanFactory的后处理器，这些后处理器是在Bean定义中向容器注册的\n\t\t\t\tinvokeBeanFactoryPostProcessors(beanFactory);\n\n\t\t\t\t// 注册Bean的后处理器，在Bean创建过程中调用\n\t\t\t\tregisterBeanPostProcessors(beanFactory);\n\n\t\t\t\t// 初始化上下文中的消息源\n\t\t\t\tinitMessageSource();\n\n\t\t\t\t// 初始化时间机制\n\t\t\t\tinitApplicationEventMulticaster();\n\n\t\t\t\t// 初始化其他特殊Bean\n\t\t\t\tonRefresh();\n\n\t\t\t\t// 检查监听Bean并且将这些Bean向容器注册\n\t\t\t\tregisterListeners();\n\n\t\t\t\t// 实例化所有non-lazy-init组件\n\t\t\t\tfinishBeanFactoryInitialization(beanFactory);\n\n\t\t\t\t// 发布容器事件，结束初始化流程\n\t\t\t\tfinishRefresh();\n\t\t\t}\n\n\t\t\tcatch (BeansException ex) {\n\t\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\t\tlogger.warn(\"Exception encountered during context initialization - \" +\n\t\t\t\t\t\t\t\"cancelling refresh attempt: \" + ex);\n\t\t\t\t}\n\n\t\t\t\t// 为防止Bean资源占用，如果出现异常，销毁已经在前面过程中生成的单元Bean\n\t\t\t\tdestroyBeans();\n\n\t\t\t\t// 重置 'active' 标志.\n\t\t\t\tcancelRefresh(ex);\n\n\t\t\t\tthrow ex;\n\t\t\t}\n\n\t\t\tfinally {\n\t\t\t\tresetCommonCaches();\n\t\t\t}\n\t\t}\n\t}\n```\n\n## 源码解析\n##### 首先来看下BeanFactory的创建\n\n### 创建beanFactory：obtainFreshBeanFactory()\n```java\nprotected ConfigurableListableBeanFactory obtainFreshBeanFactory() {\n\trefreshBeanFactory();\n\tConfigurableListableBeanFactory beanFactory = getBeanFactory();\n\tif (logger.isDebugEnabled()) {\n\t\tlogger.debug(\"Bean factory for \" + getDisplayName() + \": \" + beanFactory);\n\t}\n\treturn beanFactory;\n}\n```\n\n##### obtainFreshBeanFactory()方法获取的是ConfigurableListableBeanFactory，这里的操作很简单，refreshBeanFactory创建BeanFactory，然后获取并返回。让我们继续看下refreshBeanFactory():\n```java\nprotected abstract void refreshBeanFactory() throws BeansException, IllegalStateException;\n```\n##### 抽象方法，看下AbstractRefreshableApplicationContext中的实现：\n```java\nprotected final void refreshBeanFactory() throws BeansException {\n\tif (hasBeanFactory()) {\n\t    //如果BeanFactory已经被创建，则销毁并关闭它\n\t\tdestroyBeans();\n\t\tcloseBeanFactory();\n\t}\n\ttry {\n\t    //创建DefaultListableBeanFactory\n\t\tDefaultListableBeanFactory beanFactory = createBeanFactory(); \n\t\tbeanFactory.setSerializationId(getId());\n\t\t//属性继承\n\t\tcustomizeBeanFactory(beanFactory);\n\t\t//载入BeanDefinitions\n\t\tloadBeanDefinitions(beanFactory);\n\t\tsynchronized (this.beanFactoryMonitor) {\n\t\t\tthis.beanFactory = beanFactory;\n\t\t}\n\t}\n\tcatch (IOException ex) {\n\t\tthrow new ApplicationContextException(\"I/O error parsing bean definition source for \" + getDisplayName(), ex);\n\t}\n}\n```\n#### createBeanFactory():\n```java\nprotected DefaultListableBeanFactory createBeanFactory() {\n\treturn new DefaultListableBeanFactory(getInternalParentBeanFactory());\n}\n``` \n##### 实例化一个DefaultListableBeanFactory并设置其父BeanFactory，看下getInternalParentBeanFactory():\n```java\nprotected BeanFactory getInternalParentBeanFactory() {\n\treturn (getParent() instanceof ConfigurableApplicationContext) ?\n\t\t\t((ConfigurableApplicationContext) getParent()).getBeanFactory() : getParent();\n}\n```\n\n#### customizeBeanFactory(beanFactory)\n```java\nprotected void customizeBeanFactory(DefaultListableBeanFactory beanFactory) {\n\tif (this.allowBeanDefinitionOverriding != null) {\n\t\tbeanFactory.setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);\n\t}\n\tif (this.allowCircularReferences != null) {\n\t\tbeanFactory.setAllowCircularReferences(this.allowCircularReferences);\n\t}\n}\n```\n##### 继承容器的属性设置：\n1. allowBeanDefinitionOverriding：当不同文件中配置了相同id或者name的同一类型的两个bean时，是否允许覆盖\n2. allowCircularReferences：是否允许循环引用\n\n#### loadBeanDefinitions(DefaultListableBeanFactory):\n```java\nprotected abstract void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException;\n```\n\n##### 抽象方法，我们以XmlWebApplicationContext作为例子看下实现的过程\n```java\nprotected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException {\n\t// 根据beanFactory创建新的XmlBeanDefinitionReader\n\tXmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);\n\tbeanDefinitionReader.setEnvironment(this.getEnvironment());\n\tbeanDefinitionReader.setResourceLoader(this);\n\tbeanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));\n\tinitBeanDefinitionReader(beanDefinitionReader);\n\tloadBeanDefinitions(beanDefinitionReader);\n}\n```\n\n##### 直接看最后的loadBeanDefinitions(XmlBeanDefinitionReader):\n```java\nprotected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws IOException {\n    //加载配置地址\n\tString[] configLocations = getConfigLocations();\n\tif (configLocations != null) {\n\t\tfor (String configLocation : configLocations) {\n\t\t\treader.loadBeanDefinitions(configLocation);\n\t\t}\n\t}\n}\n```\n\n##### 根据地址循环载入BeanDefinition：\n```java\npublic int loadBeanDefinitions(String location) throws BeanDefinitionStoreException {\n\treturn loadBeanDefinitions(location, null);\n}\n```\n##### 真正的执行过程：\n```java\npublic int loadBeanDefinitions(String location, Set<Resource> actualResources) throws BeanDefinitionStoreException {\n    //获取resourceLoader\n\tResourceLoader resourceLoader = getResourceLoader();\n\tif (resourceLoader == null) {\n\t\tthrow new BeanDefinitionStoreException(\n\t\t\t\t\"Cannot import bean definitions from location [\" + location + \"]: no ResourceLoader available\");\n\t}\n\tif (resourceLoader instanceof ResourcePatternResolver) {\n\t\t// Resource pattern matching available.\n\t\ttry {\n\t\t    //定位资源\n\t\t\tResource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);\n\t\t\tint loadCount = loadBeanDefinitions(resources);\n\t\t\tif (actualResources != null) {\n\t\t\t\tfor (Resource resource : resources) {\n\t\t\t\t\tactualResources.add(resource);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Loaded \" + loadCount + \" bean definitions from location pattern [\" + location + \"]\");\n\t\t\t}\n\t\t\treturn loadCount;\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new BeanDefinitionStoreException(\n\t\t\t\t\t\"Could not resolve bean definition resource pattern [\" + location + \"]\", ex);\n\t\t}\n\t}\n\telse {\n\t\t// Can only load single resources by absolute URL.\n\t\tResource resource = resourceLoader.getResource(location);\n\t\tint loadCount = loadBeanDefinitions(resource);\n\t\tif (actualResources != null) {\n\t\t\tactualResources.add(resource);\n\t\t}\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Loaded \" + loadCount + \" bean definitions from location [\" + location + \"]\");\n\t\t}\n\t\treturn loadCount;\n\t}\n}\n```\n##### 具体的执行流程这里不做结束，总之Spring在加载BeanFactory之后，通过factory去载入了BeanDefinition\n\n##\n\n","slug":"note/spring/springIoc","published":1,"updated":"2018-05-08T13:00:14.283Z","comments":1,"photos":[],"link":"","_id":"cjgxop3nz004bjah1mr9yy84u","content":"<h5 id=\"IOC容器是Spring的核心之一，就是具有依赖注入功能的容器，IOC容器负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。应用程序无需在代码中new相关的对象，应用程序由IOC容器进行组装。具体的Spring和IOC的功能要点这里不做详细介绍，本文的重点将是围绕IOC的创建流程去发现和学习Spring的核心原理。\"><a href=\"#IOC容器是Spring的核心之一，就是具有依赖注入功能的容器，IOC容器负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。应用程序无需在代码中new相关的对象，应用程序由IOC容器进行组装。具体的Spring和IOC的功能要点这里不做详细介绍，本文的重点将是围绕IOC的创建流程去发现和学习Spring的核心原理。\" class=\"headerlink\" title=\"IOC容器是Spring的核心之一，就是具有依赖注入功能的容器，IOC容器负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。应用程序无需在代码中new相关的对象，应用程序由IOC容器进行组装。具体的Spring和IOC的功能要点这里不做详细介绍，本文的重点将是围绕IOC的创建流程去发现和学习Spring的核心原理。\"></a>IOC容器是Spring的核心之一，就是具有依赖注入功能的容器，IOC容器负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。应用程序无需在代码中new相关的对象，应用程序由IOC容器进行组装。具体的Spring和IOC的功能要点这里不做详细介绍，本文的重点将是围绕IOC的创建流程去发现和学习Spring的核心原理。</h5><a id=\"more\"></a>\n<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><h5 id=\"Ioc容器的初始化是由refresh（）方法来启动的，这个方法标志着Ioc容器的正式启动。具体来说这个启动过程包括三个基本过程：\"><a href=\"#Ioc容器的初始化是由refresh（）方法来启动的，这个方法标志着Ioc容器的正式启动。具体来说这个启动过程包括三个基本过程：\" class=\"headerlink\" title=\"Ioc容器的初始化是由refresh（）方法来启动的，这个方法标志着Ioc容器的正式启动。具体来说这个启动过程包括三个基本过程：\"></a>Ioc容器的初始化是由refresh（）方法来启动的，这个方法标志着Ioc容器的正式启动。具体来说这个启动过程包括三个基本过程：</h5><ol>\n<li>BeanDifinition的Resource定位</li>\n<li>BeanDifinition的载入与解析</li>\n<li>BeanDifinition在Ioc容器中的注册</li>\n</ol>\n<h5 id=\"需要注意的是，Spring把这三个过程分开，并使用不同的模块来完成，如使用相应的ResourceLoader、BeanDifinitionReader等模块，通过这样的实际方式，可以让用户更加灵活的对这三个过程进行剪裁和扩展。\"><a href=\"#需要注意的是，Spring把这三个过程分开，并使用不同的模块来完成，如使用相应的ResourceLoader、BeanDifinitionReader等模块，通过这样的实际方式，可以让用户更加灵活的对这三个过程进行剪裁和扩展。\" class=\"headerlink\" title=\"需要注意的是，Spring把这三个过程分开，并使用不同的模块来完成，如使用相应的ResourceLoader、BeanDifinitionReader等模块，通过这样的实际方式，可以让用户更加灵活的对这三个过程进行剪裁和扩展。\"></a>需要注意的是，Spring把这三个过程分开，并使用不同的模块来完成，如使用相应的ResourceLoader、BeanDifinitionReader等模块，通过这样的实际方式，可以让用户更加灵活的对这三个过程进行剪裁和扩展。</h5><h5 id=\"这些过程都是在AbstractApplicationContext中的refresh-方法中完成的\"><a href=\"#这些过程都是在AbstractApplicationContext中的refresh-方法中完成的\" class=\"headerlink\" title=\"这些过程都是在AbstractApplicationContext中的refresh()方法中完成的\"></a>这些过程都是在AbstractApplicationContext中的refresh()方法中完成的</h5><pre><code class=\"lang-java\">public void refresh() throws BeansException, IllegalStateException {\n        synchronized (this.startupShutdownMonitor) {\n            // 准备工作\n            prepareRefresh();\n\n            // 通过子类创建beanFactory\n            ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();\n\n            // beanFactory的准备工作\n            prepareBeanFactory(beanFactory);\n\n            try {\n                // 设置beanFactory的后置处理\n                postProcessBeanFactory(beanFactory);\n\n                // 调用beanFactory的后处理器，这些后处理器是在Bean定义中向容器注册的\n                invokeBeanFactoryPostProcessors(beanFactory);\n\n                // 注册Bean的后处理器，在Bean创建过程中调用\n                registerBeanPostProcessors(beanFactory);\n\n                // 初始化上下文中的消息源\n                initMessageSource();\n\n                // 初始化时间机制\n                initApplicationEventMulticaster();\n\n                // 初始化其他特殊Bean\n                onRefresh();\n\n                // 检查监听Bean并且将这些Bean向容器注册\n                registerListeners();\n\n                // 实例化所有non-lazy-init组件\n                finishBeanFactoryInitialization(beanFactory);\n\n                // 发布容器事件，结束初始化流程\n                finishRefresh();\n            }\n\n            catch (BeansException ex) {\n                if (logger.isWarnEnabled()) {\n                    logger.warn(&quot;Exception encountered during context initialization - &quot; +\n                            &quot;cancelling refresh attempt: &quot; + ex);\n                }\n\n                // 为防止Bean资源占用，如果出现异常，销毁已经在前面过程中生成的单元Bean\n                destroyBeans();\n\n                // 重置 &#39;active&#39; 标志.\n                cancelRefresh(ex);\n\n                throw ex;\n            }\n\n            finally {\n                resetCommonCaches();\n            }\n        }\n    }\n</code></pre>\n<h2 id=\"源码解析\"><a href=\"#源码解析\" class=\"headerlink\" title=\"源码解析\"></a>源码解析</h2><h5 id=\"首先来看下BeanFactory的创建\"><a href=\"#首先来看下BeanFactory的创建\" class=\"headerlink\" title=\"首先来看下BeanFactory的创建\"></a>首先来看下BeanFactory的创建</h5><h3 id=\"创建beanFactory：obtainFreshBeanFactory\"><a href=\"#创建beanFactory：obtainFreshBeanFactory\" class=\"headerlink\" title=\"创建beanFactory：obtainFreshBeanFactory()\"></a>创建beanFactory：obtainFreshBeanFactory()</h3><pre><code class=\"lang-java\">protected ConfigurableListableBeanFactory obtainFreshBeanFactory() {\n    refreshBeanFactory();\n    ConfigurableListableBeanFactory beanFactory = getBeanFactory();\n    if (logger.isDebugEnabled()) {\n        logger.debug(&quot;Bean factory for &quot; + getDisplayName() + &quot;: &quot; + beanFactory);\n    }\n    return beanFactory;\n}\n</code></pre>\n<h5 id=\"obtainFreshBeanFactory-方法获取的是ConfigurableListableBeanFactory，这里的操作很简单，refreshBeanFactory创建BeanFactory，然后获取并返回。让我们继续看下refreshBeanFactory\"><a href=\"#obtainFreshBeanFactory-方法获取的是ConfigurableListableBeanFactory，这里的操作很简单，refreshBeanFactory创建BeanFactory，然后获取并返回。让我们继续看下refreshBeanFactory\" class=\"headerlink\" title=\"obtainFreshBeanFactory()方法获取的是ConfigurableListableBeanFactory，这里的操作很简单，refreshBeanFactory创建BeanFactory，然后获取并返回。让我们继续看下refreshBeanFactory():\"></a>obtainFreshBeanFactory()方法获取的是ConfigurableListableBeanFactory，这里的操作很简单，refreshBeanFactory创建BeanFactory，然后获取并返回。让我们继续看下refreshBeanFactory():</h5><pre><code class=\"lang-java\">protected abstract void refreshBeanFactory() throws BeansException, IllegalStateException;\n</code></pre>\n<h5 id=\"抽象方法，看下AbstractRefreshableApplicationContext中的实现：\"><a href=\"#抽象方法，看下AbstractRefreshableApplicationContext中的实现：\" class=\"headerlink\" title=\"抽象方法，看下AbstractRefreshableApplicationContext中的实现：\"></a>抽象方法，看下AbstractRefreshableApplicationContext中的实现：</h5><pre><code class=\"lang-java\">protected final void refreshBeanFactory() throws BeansException {\n    if (hasBeanFactory()) {\n        //如果BeanFactory已经被创建，则销毁并关闭它\n        destroyBeans();\n        closeBeanFactory();\n    }\n    try {\n        //创建DefaultListableBeanFactory\n        DefaultListableBeanFactory beanFactory = createBeanFactory(); \n        beanFactory.setSerializationId(getId());\n        //属性继承\n        customizeBeanFactory(beanFactory);\n        //载入BeanDefinitions\n        loadBeanDefinitions(beanFactory);\n        synchronized (this.beanFactoryMonitor) {\n            this.beanFactory = beanFactory;\n        }\n    }\n    catch (IOException ex) {\n        throw new ApplicationContextException(&quot;I/O error parsing bean definition source for &quot; + getDisplayName(), ex);\n    }\n}\n</code></pre>\n<h4 id=\"createBeanFactory\"><a href=\"#createBeanFactory\" class=\"headerlink\" title=\"createBeanFactory():\"></a>createBeanFactory():</h4><pre><code class=\"lang-java\">protected DefaultListableBeanFactory createBeanFactory() {\n    return new DefaultListableBeanFactory(getInternalParentBeanFactory());\n}\n</code></pre>\n<h5 id=\"实例化一个DefaultListableBeanFactory并设置其父BeanFactory，看下getInternalParentBeanFactory\"><a href=\"#实例化一个DefaultListableBeanFactory并设置其父BeanFactory，看下getInternalParentBeanFactory\" class=\"headerlink\" title=\"实例化一个DefaultListableBeanFactory并设置其父BeanFactory，看下getInternalParentBeanFactory():\"></a>实例化一个DefaultListableBeanFactory并设置其父BeanFactory，看下getInternalParentBeanFactory():</h5><pre><code class=\"lang-java\">protected BeanFactory getInternalParentBeanFactory() {\n    return (getParent() instanceof ConfigurableApplicationContext) ?\n            ((ConfigurableApplicationContext) getParent()).getBeanFactory() : getParent();\n}\n</code></pre>\n<h4 id=\"customizeBeanFactory-beanFactory\"><a href=\"#customizeBeanFactory-beanFactory\" class=\"headerlink\" title=\"customizeBeanFactory(beanFactory)\"></a>customizeBeanFactory(beanFactory)</h4><pre><code class=\"lang-java\">protected void customizeBeanFactory(DefaultListableBeanFactory beanFactory) {\n    if (this.allowBeanDefinitionOverriding != null) {\n        beanFactory.setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);\n    }\n    if (this.allowCircularReferences != null) {\n        beanFactory.setAllowCircularReferences(this.allowCircularReferences);\n    }\n}\n</code></pre>\n<h5 id=\"继承容器的属性设置：\"><a href=\"#继承容器的属性设置：\" class=\"headerlink\" title=\"继承容器的属性设置：\"></a>继承容器的属性设置：</h5><ol>\n<li>allowBeanDefinitionOverriding：当不同文件中配置了相同id或者name的同一类型的两个bean时，是否允许覆盖</li>\n<li>allowCircularReferences：是否允许循环引用</li>\n</ol>\n<h4 id=\"loadBeanDefinitions-DefaultListableBeanFactory\"><a href=\"#loadBeanDefinitions-DefaultListableBeanFactory\" class=\"headerlink\" title=\"loadBeanDefinitions(DefaultListableBeanFactory):\"></a>loadBeanDefinitions(DefaultListableBeanFactory):</h4><pre><code class=\"lang-java\">protected abstract void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException;\n</code></pre>\n<h5 id=\"抽象方法，我们以XmlWebApplicationContext作为例子看下实现的过程\"><a href=\"#抽象方法，我们以XmlWebApplicationContext作为例子看下实现的过程\" class=\"headerlink\" title=\"抽象方法，我们以XmlWebApplicationContext作为例子看下实现的过程\"></a>抽象方法，我们以XmlWebApplicationContext作为例子看下实现的过程</h5><pre><code class=\"lang-java\">protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException {\n    // 根据beanFactory创建新的XmlBeanDefinitionReader\n    XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);\n    beanDefinitionReader.setEnvironment(this.getEnvironment());\n    beanDefinitionReader.setResourceLoader(this);\n    beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));\n    initBeanDefinitionReader(beanDefinitionReader);\n    loadBeanDefinitions(beanDefinitionReader);\n}\n</code></pre>\n<h5 id=\"直接看最后的loadBeanDefinitions-XmlBeanDefinitionReader\"><a href=\"#直接看最后的loadBeanDefinitions-XmlBeanDefinitionReader\" class=\"headerlink\" title=\"直接看最后的loadBeanDefinitions(XmlBeanDefinitionReader):\"></a>直接看最后的loadBeanDefinitions(XmlBeanDefinitionReader):</h5><pre><code class=\"lang-java\">protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws IOException {\n    //加载配置地址\n    String[] configLocations = getConfigLocations();\n    if (configLocations != null) {\n        for (String configLocation : configLocations) {\n            reader.loadBeanDefinitions(configLocation);\n        }\n    }\n}\n</code></pre>\n<h5 id=\"根据地址循环载入BeanDefinition：\"><a href=\"#根据地址循环载入BeanDefinition：\" class=\"headerlink\" title=\"根据地址循环载入BeanDefinition：\"></a>根据地址循环载入BeanDefinition：</h5><pre><code class=\"lang-java\">public int loadBeanDefinitions(String location) throws BeanDefinitionStoreException {\n    return loadBeanDefinitions(location, null);\n}\n</code></pre>\n<h5 id=\"真正的执行过程：\"><a href=\"#真正的执行过程：\" class=\"headerlink\" title=\"真正的执行过程：\"></a>真正的执行过程：</h5><pre><code class=\"lang-java\">public int loadBeanDefinitions(String location, Set&lt;Resource&gt; actualResources) throws BeanDefinitionStoreException {\n    //获取resourceLoader\n    ResourceLoader resourceLoader = getResourceLoader();\n    if (resourceLoader == null) {\n        throw new BeanDefinitionStoreException(\n                &quot;Cannot import bean definitions from location [&quot; + location + &quot;]: no ResourceLoader available&quot;);\n    }\n    if (resourceLoader instanceof ResourcePatternResolver) {\n        // Resource pattern matching available.\n        try {\n            //定位资源\n            Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);\n            int loadCount = loadBeanDefinitions(resources);\n            if (actualResources != null) {\n                for (Resource resource : resources) {\n                    actualResources.add(resource);\n                }\n            }\n            if (logger.isDebugEnabled()) {\n                logger.debug(&quot;Loaded &quot; + loadCount + &quot; bean definitions from location pattern [&quot; + location + &quot;]&quot;);\n            }\n            return loadCount;\n        }\n        catch (IOException ex) {\n            throw new BeanDefinitionStoreException(\n                    &quot;Could not resolve bean definition resource pattern [&quot; + location + &quot;]&quot;, ex);\n        }\n    }\n    else {\n        // Can only load single resources by absolute URL.\n        Resource resource = resourceLoader.getResource(location);\n        int loadCount = loadBeanDefinitions(resource);\n        if (actualResources != null) {\n            actualResources.add(resource);\n        }\n        if (logger.isDebugEnabled()) {\n            logger.debug(&quot;Loaded &quot; + loadCount + &quot; bean definitions from location [&quot; + location + &quot;]&quot;);\n        }\n        return loadCount;\n    }\n}\n</code></pre>\n<h5 id=\"具体的执行流程这里不做结束，总之Spring在加载BeanFactory之后，通过factory去载入了BeanDefinition\"><a href=\"#具体的执行流程这里不做结束，总之Spring在加载BeanFactory之后，通过factory去载入了BeanDefinition\" class=\"headerlink\" title=\"具体的执行流程这里不做结束，总之Spring在加载BeanFactory之后，通过factory去载入了BeanDefinition\"></a>具体的执行流程这里不做结束，总之Spring在加载BeanFactory之后，通过factory去载入了BeanDefinition</h5><h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"#\"></a>#</h1>","site":{"data":{}},"excerpt":"<h5 id=\"IOC容器是Spring的核心之一，就是具有依赖注入功能的容器，IOC容器负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。应用程序无需在代码中new相关的对象，应用程序由IOC容器进行组装。具体的Spring和IOC的功能要点这里不做详细介绍，本文的重点将是围绕IOC的创建流程去发现和学习Spring的核心原理。\"><a href=\"#IOC容器是Spring的核心之一，就是具有依赖注入功能的容器，IOC容器负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。应用程序无需在代码中new相关的对象，应用程序由IOC容器进行组装。具体的Spring和IOC的功能要点这里不做详细介绍，本文的重点将是围绕IOC的创建流程去发现和学习Spring的核心原理。\" class=\"headerlink\" title=\"IOC容器是Spring的核心之一，就是具有依赖注入功能的容器，IOC容器负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。应用程序无需在代码中new相关的对象，应用程序由IOC容器进行组装。具体的Spring和IOC的功能要点这里不做详细介绍，本文的重点将是围绕IOC的创建流程去发现和学习Spring的核心原理。\"></a>IOC容器是Spring的核心之一，就是具有依赖注入功能的容器，IOC容器负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。应用程序无需在代码中new相关的对象，应用程序由IOC容器进行组装。具体的Spring和IOC的功能要点这里不做详细介绍，本文的重点将是围绕IOC的创建流程去发现和学习Spring的核心原理。</h5>","more":"<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><h5 id=\"Ioc容器的初始化是由refresh（）方法来启动的，这个方法标志着Ioc容器的正式启动。具体来说这个启动过程包括三个基本过程：\"><a href=\"#Ioc容器的初始化是由refresh（）方法来启动的，这个方法标志着Ioc容器的正式启动。具体来说这个启动过程包括三个基本过程：\" class=\"headerlink\" title=\"Ioc容器的初始化是由refresh（）方法来启动的，这个方法标志着Ioc容器的正式启动。具体来说这个启动过程包括三个基本过程：\"></a>Ioc容器的初始化是由refresh（）方法来启动的，这个方法标志着Ioc容器的正式启动。具体来说这个启动过程包括三个基本过程：</h5><ol>\n<li>BeanDifinition的Resource定位</li>\n<li>BeanDifinition的载入与解析</li>\n<li>BeanDifinition在Ioc容器中的注册</li>\n</ol>\n<h5 id=\"需要注意的是，Spring把这三个过程分开，并使用不同的模块来完成，如使用相应的ResourceLoader、BeanDifinitionReader等模块，通过这样的实际方式，可以让用户更加灵活的对这三个过程进行剪裁和扩展。\"><a href=\"#需要注意的是，Spring把这三个过程分开，并使用不同的模块来完成，如使用相应的ResourceLoader、BeanDifinitionReader等模块，通过这样的实际方式，可以让用户更加灵活的对这三个过程进行剪裁和扩展。\" class=\"headerlink\" title=\"需要注意的是，Spring把这三个过程分开，并使用不同的模块来完成，如使用相应的ResourceLoader、BeanDifinitionReader等模块，通过这样的实际方式，可以让用户更加灵活的对这三个过程进行剪裁和扩展。\"></a>需要注意的是，Spring把这三个过程分开，并使用不同的模块来完成，如使用相应的ResourceLoader、BeanDifinitionReader等模块，通过这样的实际方式，可以让用户更加灵活的对这三个过程进行剪裁和扩展。</h5><h5 id=\"这些过程都是在AbstractApplicationContext中的refresh-方法中完成的\"><a href=\"#这些过程都是在AbstractApplicationContext中的refresh-方法中完成的\" class=\"headerlink\" title=\"这些过程都是在AbstractApplicationContext中的refresh()方法中完成的\"></a>这些过程都是在AbstractApplicationContext中的refresh()方法中完成的</h5><pre><code class=\"lang-java\">public void refresh() throws BeansException, IllegalStateException {\n        synchronized (this.startupShutdownMonitor) {\n            // 准备工作\n            prepareRefresh();\n\n            // 通过子类创建beanFactory\n            ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();\n\n            // beanFactory的准备工作\n            prepareBeanFactory(beanFactory);\n\n            try {\n                // 设置beanFactory的后置处理\n                postProcessBeanFactory(beanFactory);\n\n                // 调用beanFactory的后处理器，这些后处理器是在Bean定义中向容器注册的\n                invokeBeanFactoryPostProcessors(beanFactory);\n\n                // 注册Bean的后处理器，在Bean创建过程中调用\n                registerBeanPostProcessors(beanFactory);\n\n                // 初始化上下文中的消息源\n                initMessageSource();\n\n                // 初始化时间机制\n                initApplicationEventMulticaster();\n\n                // 初始化其他特殊Bean\n                onRefresh();\n\n                // 检查监听Bean并且将这些Bean向容器注册\n                registerListeners();\n\n                // 实例化所有non-lazy-init组件\n                finishBeanFactoryInitialization(beanFactory);\n\n                // 发布容器事件，结束初始化流程\n                finishRefresh();\n            }\n\n            catch (BeansException ex) {\n                if (logger.isWarnEnabled()) {\n                    logger.warn(&quot;Exception encountered during context initialization - &quot; +\n                            &quot;cancelling refresh attempt: &quot; + ex);\n                }\n\n                // 为防止Bean资源占用，如果出现异常，销毁已经在前面过程中生成的单元Bean\n                destroyBeans();\n\n                // 重置 &#39;active&#39; 标志.\n                cancelRefresh(ex);\n\n                throw ex;\n            }\n\n            finally {\n                resetCommonCaches();\n            }\n        }\n    }\n</code></pre>\n<h2 id=\"源码解析\"><a href=\"#源码解析\" class=\"headerlink\" title=\"源码解析\"></a>源码解析</h2><h5 id=\"首先来看下BeanFactory的创建\"><a href=\"#首先来看下BeanFactory的创建\" class=\"headerlink\" title=\"首先来看下BeanFactory的创建\"></a>首先来看下BeanFactory的创建</h5><h3 id=\"创建beanFactory：obtainFreshBeanFactory\"><a href=\"#创建beanFactory：obtainFreshBeanFactory\" class=\"headerlink\" title=\"创建beanFactory：obtainFreshBeanFactory()\"></a>创建beanFactory：obtainFreshBeanFactory()</h3><pre><code class=\"lang-java\">protected ConfigurableListableBeanFactory obtainFreshBeanFactory() {\n    refreshBeanFactory();\n    ConfigurableListableBeanFactory beanFactory = getBeanFactory();\n    if (logger.isDebugEnabled()) {\n        logger.debug(&quot;Bean factory for &quot; + getDisplayName() + &quot;: &quot; + beanFactory);\n    }\n    return beanFactory;\n}\n</code></pre>\n<h5 id=\"obtainFreshBeanFactory-方法获取的是ConfigurableListableBeanFactory，这里的操作很简单，refreshBeanFactory创建BeanFactory，然后获取并返回。让我们继续看下refreshBeanFactory\"><a href=\"#obtainFreshBeanFactory-方法获取的是ConfigurableListableBeanFactory，这里的操作很简单，refreshBeanFactory创建BeanFactory，然后获取并返回。让我们继续看下refreshBeanFactory\" class=\"headerlink\" title=\"obtainFreshBeanFactory()方法获取的是ConfigurableListableBeanFactory，这里的操作很简单，refreshBeanFactory创建BeanFactory，然后获取并返回。让我们继续看下refreshBeanFactory():\"></a>obtainFreshBeanFactory()方法获取的是ConfigurableListableBeanFactory，这里的操作很简单，refreshBeanFactory创建BeanFactory，然后获取并返回。让我们继续看下refreshBeanFactory():</h5><pre><code class=\"lang-java\">protected abstract void refreshBeanFactory() throws BeansException, IllegalStateException;\n</code></pre>\n<h5 id=\"抽象方法，看下AbstractRefreshableApplicationContext中的实现：\"><a href=\"#抽象方法，看下AbstractRefreshableApplicationContext中的实现：\" class=\"headerlink\" title=\"抽象方法，看下AbstractRefreshableApplicationContext中的实现：\"></a>抽象方法，看下AbstractRefreshableApplicationContext中的实现：</h5><pre><code class=\"lang-java\">protected final void refreshBeanFactory() throws BeansException {\n    if (hasBeanFactory()) {\n        //如果BeanFactory已经被创建，则销毁并关闭它\n        destroyBeans();\n        closeBeanFactory();\n    }\n    try {\n        //创建DefaultListableBeanFactory\n        DefaultListableBeanFactory beanFactory = createBeanFactory(); \n        beanFactory.setSerializationId(getId());\n        //属性继承\n        customizeBeanFactory(beanFactory);\n        //载入BeanDefinitions\n        loadBeanDefinitions(beanFactory);\n        synchronized (this.beanFactoryMonitor) {\n            this.beanFactory = beanFactory;\n        }\n    }\n    catch (IOException ex) {\n        throw new ApplicationContextException(&quot;I/O error parsing bean definition source for &quot; + getDisplayName(), ex);\n    }\n}\n</code></pre>\n<h4 id=\"createBeanFactory\"><a href=\"#createBeanFactory\" class=\"headerlink\" title=\"createBeanFactory():\"></a>createBeanFactory():</h4><pre><code class=\"lang-java\">protected DefaultListableBeanFactory createBeanFactory() {\n    return new DefaultListableBeanFactory(getInternalParentBeanFactory());\n}\n</code></pre>\n<h5 id=\"实例化一个DefaultListableBeanFactory并设置其父BeanFactory，看下getInternalParentBeanFactory\"><a href=\"#实例化一个DefaultListableBeanFactory并设置其父BeanFactory，看下getInternalParentBeanFactory\" class=\"headerlink\" title=\"实例化一个DefaultListableBeanFactory并设置其父BeanFactory，看下getInternalParentBeanFactory():\"></a>实例化一个DefaultListableBeanFactory并设置其父BeanFactory，看下getInternalParentBeanFactory():</h5><pre><code class=\"lang-java\">protected BeanFactory getInternalParentBeanFactory() {\n    return (getParent() instanceof ConfigurableApplicationContext) ?\n            ((ConfigurableApplicationContext) getParent()).getBeanFactory() : getParent();\n}\n</code></pre>\n<h4 id=\"customizeBeanFactory-beanFactory\"><a href=\"#customizeBeanFactory-beanFactory\" class=\"headerlink\" title=\"customizeBeanFactory(beanFactory)\"></a>customizeBeanFactory(beanFactory)</h4><pre><code class=\"lang-java\">protected void customizeBeanFactory(DefaultListableBeanFactory beanFactory) {\n    if (this.allowBeanDefinitionOverriding != null) {\n        beanFactory.setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);\n    }\n    if (this.allowCircularReferences != null) {\n        beanFactory.setAllowCircularReferences(this.allowCircularReferences);\n    }\n}\n</code></pre>\n<h5 id=\"继承容器的属性设置：\"><a href=\"#继承容器的属性设置：\" class=\"headerlink\" title=\"继承容器的属性设置：\"></a>继承容器的属性设置：</h5><ol>\n<li>allowBeanDefinitionOverriding：当不同文件中配置了相同id或者name的同一类型的两个bean时，是否允许覆盖</li>\n<li>allowCircularReferences：是否允许循环引用</li>\n</ol>\n<h4 id=\"loadBeanDefinitions-DefaultListableBeanFactory\"><a href=\"#loadBeanDefinitions-DefaultListableBeanFactory\" class=\"headerlink\" title=\"loadBeanDefinitions(DefaultListableBeanFactory):\"></a>loadBeanDefinitions(DefaultListableBeanFactory):</h4><pre><code class=\"lang-java\">protected abstract void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException;\n</code></pre>\n<h5 id=\"抽象方法，我们以XmlWebApplicationContext作为例子看下实现的过程\"><a href=\"#抽象方法，我们以XmlWebApplicationContext作为例子看下实现的过程\" class=\"headerlink\" title=\"抽象方法，我们以XmlWebApplicationContext作为例子看下实现的过程\"></a>抽象方法，我们以XmlWebApplicationContext作为例子看下实现的过程</h5><pre><code class=\"lang-java\">protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException {\n    // 根据beanFactory创建新的XmlBeanDefinitionReader\n    XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);\n    beanDefinitionReader.setEnvironment(this.getEnvironment());\n    beanDefinitionReader.setResourceLoader(this);\n    beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));\n    initBeanDefinitionReader(beanDefinitionReader);\n    loadBeanDefinitions(beanDefinitionReader);\n}\n</code></pre>\n<h5 id=\"直接看最后的loadBeanDefinitions-XmlBeanDefinitionReader\"><a href=\"#直接看最后的loadBeanDefinitions-XmlBeanDefinitionReader\" class=\"headerlink\" title=\"直接看最后的loadBeanDefinitions(XmlBeanDefinitionReader):\"></a>直接看最后的loadBeanDefinitions(XmlBeanDefinitionReader):</h5><pre><code class=\"lang-java\">protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws IOException {\n    //加载配置地址\n    String[] configLocations = getConfigLocations();\n    if (configLocations != null) {\n        for (String configLocation : configLocations) {\n            reader.loadBeanDefinitions(configLocation);\n        }\n    }\n}\n</code></pre>\n<h5 id=\"根据地址循环载入BeanDefinition：\"><a href=\"#根据地址循环载入BeanDefinition：\" class=\"headerlink\" title=\"根据地址循环载入BeanDefinition：\"></a>根据地址循环载入BeanDefinition：</h5><pre><code class=\"lang-java\">public int loadBeanDefinitions(String location) throws BeanDefinitionStoreException {\n    return loadBeanDefinitions(location, null);\n}\n</code></pre>\n<h5 id=\"真正的执行过程：\"><a href=\"#真正的执行过程：\" class=\"headerlink\" title=\"真正的执行过程：\"></a>真正的执行过程：</h5><pre><code class=\"lang-java\">public int loadBeanDefinitions(String location, Set&lt;Resource&gt; actualResources) throws BeanDefinitionStoreException {\n    //获取resourceLoader\n    ResourceLoader resourceLoader = getResourceLoader();\n    if (resourceLoader == null) {\n        throw new BeanDefinitionStoreException(\n                &quot;Cannot import bean definitions from location [&quot; + location + &quot;]: no ResourceLoader available&quot;);\n    }\n    if (resourceLoader instanceof ResourcePatternResolver) {\n        // Resource pattern matching available.\n        try {\n            //定位资源\n            Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);\n            int loadCount = loadBeanDefinitions(resources);\n            if (actualResources != null) {\n                for (Resource resource : resources) {\n                    actualResources.add(resource);\n                }\n            }\n            if (logger.isDebugEnabled()) {\n                logger.debug(&quot;Loaded &quot; + loadCount + &quot; bean definitions from location pattern [&quot; + location + &quot;]&quot;);\n            }\n            return loadCount;\n        }\n        catch (IOException ex) {\n            throw new BeanDefinitionStoreException(\n                    &quot;Could not resolve bean definition resource pattern [&quot; + location + &quot;]&quot;, ex);\n        }\n    }\n    else {\n        // Can only load single resources by absolute URL.\n        Resource resource = resourceLoader.getResource(location);\n        int loadCount = loadBeanDefinitions(resource);\n        if (actualResources != null) {\n            actualResources.add(resource);\n        }\n        if (logger.isDebugEnabled()) {\n            logger.debug(&quot;Loaded &quot; + loadCount + &quot; bean definitions from location [&quot; + location + &quot;]&quot;);\n        }\n        return loadCount;\n    }\n}\n</code></pre>\n<h5 id=\"具体的执行流程这里不做结束，总之Spring在加载BeanFactory之后，通过factory去载入了BeanDefinition\"><a href=\"#具体的执行流程这里不做结束，总之Spring在加载BeanFactory之后，通过factory去载入了BeanDefinition\" class=\"headerlink\" title=\"具体的执行流程这里不做结束，总之Spring在加载BeanFactory之后，通过factory去载入了BeanDefinition\"></a>具体的执行流程这里不做结束，总之Spring在加载BeanFactory之后，通过factory去载入了BeanDefinition</h5><h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"#\"></a>#</h1>"},{"layout":"post","title":"spring boot 动态启动与加载","date":"2017-08-30T16:00:00.000Z","original":true,"tag":[["spring","spring"],["java","java"]],"top":1,"topTag":["index"],"_content":"\n##### 通常情况下，我们通过XML或者Annotation两种方式配置Bean Definition。从Spring 3.0开始，增加了一种新的途径来配置Bean Definition，这就是通过Java Code配置Bean Definition。\n<!--more-->\n\n#### Java Code配置与XML和Annotation两种配置方式不同点在于：\n##### 前两种方式XML和Annotation的配置方式为预定义方式，即开发人员通过XML文件或者Annotation预定义配置Bean的各种属性后，启动Spring容器，Spring容器会首先解析这些配置属性，生成对应的Bean Definition,装入到`DefaultListtableBeanFactory`对象的属性容器中，以此同时，Spring框架也会定义内部使用的Bean定义，如Bean名为：`org.springframework.context.annotation.internalConfigurationAnnotationProcessor`的 `ConfigurationClassPostProcessor` 定义。而后此刻不会做任何Bean Definition的解析动作，Spring框架会根据前两种配置，过滤出`BeanDefinitionRegistryPostProcessor` 类型的Bean定义，并通过Spring框架生成对应的Bean对象（如 `ConfigurationClassPostProcessor` 实例）。结合 Spring 上下文源码可知这个对象是一个 processor 类型工具类，<u>Spring容器会在实例化开发人员所定义的 Bean 前先调用该 processor 的 postProcessBeanDefinitionRegistry(…) 方法。此处实现基于 Java Code 配置Bean Definition的处理</u>。\n\n##### 基于 Java Code 的配置方式，其执行原理不同于前两种。它是在 Spring 框架已经解析了基于 XML 和 Annotation 配置后，通过加入 BeanDefinitionRegistryPostProcessor 类型的 processor 来处理配置信息，让开发人员通过 Java 编程方式定义一个 Java 对象。其优点在于可以将配置信息集中在一定数量的 Java 对象中，同时通过 Java 编程方式，比基于 Annotation 方式具有更高的灵活性。并且该配置方式给开发人员提供了一种非常好的范例来增加用户自定义的解析工具类。其主要缺点在于与 Java 代码结合紧密，配置信息的改变需要重新编译 Java 代码，另外这是一种新引入的解析方式，需要一定的学习成本。\n\n<br/>\n\n#### 提及一点的就是，Spring框架有3个主要的Hook类，分别是：\n`org.springframework.context.ApplicationContextAware`\n##### 它的setApplicationContext 方法将在Spring启动之前第一个被调用。\n`org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor`\n##### 它的postProcessBeanDefinitionRegistry 和 postProcessBeanFactory 方法是第二和第三被调用，它们在Bean初始化创建之前启动，如果Spring的bean需要的其他第三方中的组件，我们在这里将其注入给Spring。\n`org.springframework.context.ApplicationListener`\n用于在初始化完成后做一些事情，当Spring所有XML或元注解的Bean都启动被创建成功了，这时会调用它的唯一方法onApplicationEvent。\n<br/>\n#### 通过 BeanDefinitionRegistryPostProcessor 加载自己的bean的demo：\n```java\nimport org.springframework.beans.BeansException;\nimport org.springframework.beans.MutablePropertyValues;\nimport org.springframework.beans.factory.annotation.AnnotatedBeanDefinition;\nimport org.springframework.beans.factory.annotation.AnnotatedGenericBeanDefinition;\nimport org.springframework.beans.factory.config.BeanDefinition;\nimport org.springframework.beans.factory.config.BeanDefinitionHolder;\nimport org.springframework.beans.factory.config.ConfigurableListableBeanFactory;\nimport org.springframework.beans.factory.support.BeanDefinitionReaderUtils;\nimport org.springframework.beans.factory.support.BeanDefinitionRegistry;\nimport org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor;\n\n/**\n * @author winx\n * @create 2017-09-01.\n */\n@Configuration\npublic class MyBeanDefinitionRegistryPostProcessor implements BeanDefinitionRegistryPostProcessor {\n\n    /**\n     * 先执行：postProcessBeanDefinitionRegistry()方法\n     * 通过Class对象，注册自己的 BeanDefinition\n     */\n    @Override\n    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException {\n        try {\n            AnnotatedBeanDefinition annotatedBeanDefinition = new AnnotatedGenericBeanDefinition(Class.forName(\"\"));\n            BeanDefinitionHolder beanDefinitionHolder = new BeanDefinitionHolder(annotatedBeanDefinition, \"beanName\");\n            BeanDefinitionReaderUtils.registerBeanDefinition(beanDefinitionHolder, registry);\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * 再执行：postProcessBeanFactory()方法。\n     * 通过 beanName 拿到注册后的 BeanDefinition\n     * 然后加入自定义属性，BeanDefinition 会在初始化bean时，将 Property 键值对插入到之前的Class对象属性中。\n     */\n    @Override\n    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {\n        BeanDefinition beanDefinition = beanFactory.getBeanDefinition(\"beanName\");\n        MutablePropertyValues mutablePropertyValues = beanDefinition.getPropertyValues();\n        //加入属性.\n        mutablePropertyValues.addPropertyValue(\"username\", \"root\");\n    }\n}\n```\n\n##### `@Configuration`注解提示spring boot通过该类加载bean\n##### `postProcessBeanDefinitionRegistry()` 通过Class对象，注册自己的 BeanDefinition\n##### `postProcessBeanFactory()`方法会在`postProcessBeanDefinitionRegistry()`之后执行， 通过beanFactory拿到 BeanDefinition 后加入属性，这一步可以跳过。\n\n### 实际项目需求\n##### 目前项目分为线上环境和dev环境，项目本身只支持http服务，因为线上环境有nginx做反向代理，所以用http和https均能正常访问线上服务。但是本地环境相对简单，不能支持https服务。先在需要根据环境的不同。动态的扩张spring boot的多连接器设置。当环境为dev时，即加载多连接器，分别用两个端口提供http和https服务。当环境不为dev时，只加载默认http即可。\n##### 根据这些需求，通过xml或者annotation去定义bean都不太合适。只能是通过java code去判断环境并动态加载。\n\n##### 省去spring boot支持https以及多连接器的配置，相关的代码网络上很多。直接说遇到的主要问题吧。上面的demo通过`mutablePropertyValues.addPropertyValue(\"key\", \"root\");`的方式为目标class定义属性，但是要求属性key必须有相应的set方法。\n\n```java\n@Configuration\npublic class HttpsBeanDefinitionRegistryPostProcessor implements BeanDefinitionRegistryPostProcessor, EnvironmentAware {\n\n    private String profile;\n\n    @Override\n    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry beanDefinitionRegistry) throws BeansException {\n        if (\"dev\".equals(profile)){\n            AnnotatedBeanDefinition annotatedBeanDefinition = new AnnotatedGenericBeanDefinition(TomcatEmbeddedServletContainerFactory.class);\n            BeanDefinitionHolder beanDefinitionHolder = new BeanDefinitionHolder(annotatedBeanDefinition, \"tomcatEmbeddedServletContainerFactory\");\n            BeanDefinitionReaderUtils.registerBeanDefinition(beanDefinitionHolder, beanDefinitionRegistry);\n        }\n    }\n\n    @Override\n    public void postProcessBeanFactory(ConfigurableListableBeanFactory configurableListableBeanFactory) throws BeansException {\n        MutablePropertyValues tomcatEmbeddedServletContainerFactory = configurableListableBeanFactory.getBeanDefinition(\"tomcatEmbeddedServletContainerFactory\").getPropertyValues();\n        tomcatEmbeddedServletContainerFactory.addPropertyValue(\"additionalTomcatConnectors\", getConnector());\n    }\n\n    public Connector getConnector(){\n        Connector connector = new Connector(\"org.apache.coyote.http11.Http11NioProtocol\");\n        Http11NioProtocol protocol = (Http11NioProtocol) connector.getProtocolHandler();\n        connector.setScheme(\"https\");\n        connector.setSecure(true);\n        connector.setPort(8443);\n        protocol.setSSLEnabled(true);\n        protocol.setKeystoreFile(\"/Users/winx/.keystore\");\n        protocol.setKeystorePass(\"123456\");\n        protocol.setTruststoreFile(\"/Users/winx/.keystore\");\n        protocol.setTruststorePass(\"123456\");\n        protocol.setKeyAlias(\"tomcat\");\n        return connector;\n    }\n\n    @Override\n    public void setEnvironment(Environment environment) {\n        profile = environment.getProperty(\"profile\");\n    }\n}\n```\n\n##### 在拿到`MutablePropertyValues`之后，想要给`TomcatEmbeddedServletContainerFactory`对象设置`additionalTomcatConnectors`属性，Connector中包含了https关键信息的设置。之后报错如下：\n```\norg.springframework.context.ApplicationContextException: Unable to start embedded container; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'tomcatEmbeddedServletContainerFactory': Error setting property values; nested exception is org.springframework.beans.NotWritablePropertyException: Invalid property 'additionalTomcatConnectors' of bean class [org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedServletContainerFactory]: Bean property 'additionalTomcatConnectors' is not writable or has an invalid setter method. Does the parameter type of the setter match the return type of the getter?\n\tat org.springframework.boot.context.embedded.EmbeddedWebApplicationContext.onRefresh(EmbeddedWebApplicationContext.java:133) ~[spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n\tat org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:532) ~[spring-context-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n\tat org.springframework.boot.context.embedded.EmbeddedWebApplicationContext.refresh(EmbeddedWebApplicationContext.java:118) ~[spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n\tat org.springframework.boot.SpringApplication.refresh(SpringApplication.java:760) [spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n\tat org.springframework.boot.SpringApplication.createAndRefreshContext(SpringApplication.java:360) [spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n\tat org.springframework.boot.SpringApplication.run(SpringApplication.java:306) [spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n\tat org.springframework.boot.SpringApplication.run(SpringApplication.java:1185) [spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n\tat org.springframework.boot.SpringApplication.run(SpringApplication.java:1174) [spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n\tat com.winx.es.metis.RunMetis.main(RunMetis.java:47) [classes/:na]\nCaused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'tomcatEmbeddedServletContainerFactory': Error setting property values; nested exception is org.springframework.beans.NotWritablePropertyException: Invalid property 'additionalTomcatConnectors' of bean class [org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedServletContainerFactory]: Bean property 'additionalTomcatConnectors' is not writable or has an invalid setter method. Does the parameter type of the setter match the return type of the getter?\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyPropertyValues(AbstractAutowireCapableBeanFactory.java:1518) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1226) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:543) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:482) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n\tat org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:306) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n\tat org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:302) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n\tat org.springframework.boot.context.embedded.EmbeddedWebApplicationContext.getEmbeddedServletContainerFactory(EmbeddedWebApplicationContext.java:195) ~[spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n\tat org.springframework.boot.context.embedded.EmbeddedWebApplicationContext.createEmbeddedServletContainer(EmbeddedWebApplicationContext.java:158) ~[spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n\tat org.springframework.boot.context.embedded.EmbeddedWebApplicationContext.onRefresh(EmbeddedWebApplicationContext.java:130) ~[spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n\t... 8 common frames omitted\nCaused by: org.springframework.beans.NotWritablePropertyException: Invalid property 'additionalTomcatConnectors' of bean class [org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedServletContainerFactory]: Bean property 'additionalTomcatConnectors' is not writable or has an invalid setter method. Does the parameter type of the setter match the return type of the getter?\n\tat org.springframework.beans.BeanWrapperImpl.createNotWritablePropertyException(BeanWrapperImpl.java:230) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n\tat org.springframework.beans.AbstractNestablePropertyAccessor.setPropertyValue(AbstractNestablePropertyAccessor.java:423) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n\tat org.springframework.beans.AbstractNestablePropertyAccessor.setPropertyValue(AbstractNestablePropertyAccessor.java:280) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n\tat org.springframework.beans.AbstractPropertyAccessor.setPropertyValues(AbstractPropertyAccessor.java:95) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n\tat org.springframework.beans.AbstractPropertyAccessor.setPropertyValues(AbstractPropertyAccessor.java:75) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyPropertyValues(AbstractAutowireCapableBeanFactory.java:1514) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n\t... 18 common frames omitted\n```\n\n##### **关键错误信息**：`Bean property 'additionalTomcatConnectors' is not writable or has an invalid setter method. Does the parameter type of the setter match the return type of the getter?`，没有权限写入以及没有找到相应的个体方法。\n\n##### 查看`TomcatEmbeddedServletContainerFactory`源码后发现其相应的设置方法如下：\n```java\npublic void addAdditionalTomcatConnectors(Connector... connectors) {\n    Assert.notNull(connectors, \"Connectors must not be null\");\n    this.additionalTomcatConnectors.addAll(Arrays.asList(connectors));\n}\n```\n\n##### 顿时觉得坑爹的add啊，之后在Bean Definition的私有属性设置，以及通过方法设置属性值的方向去尝试解决问题，没有任何效果。几乎快要绝望的时候，突然灵机一动，为什么我不能自己定义一个不需要后置设置属性的`TomcatEmbeddedServletContainerFactory`呢，于是有了下面的代码：\n\n```java\n@Configuration\npublic class HttpsBeanDefinitionRegistryPostProcessor implements BeanDefinitionRegistryPostProcessor, EnvironmentAware {\n\n    private String profile;\n\n    @Override\n    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry beanDefinitionRegistry) throws BeansException {\n        if (\"dev\".equals(profile)){\n            AnnotatedBeanDefinition annotatedBeanDefinition = new AnnotatedGenericBeanDefinition(HttpsTomcatEmbeddedServletContainerFactory.class);\n            BeanDefinitionHolder beanDefinitionHolder = new BeanDefinitionHolder(annotatedBeanDefinition, \"tomcatEmbeddedServletContainerFactory\");\n            BeanDefinitionReaderUtils.registerBeanDefinition(beanDefinitionHolder, beanDefinitionRegistry);\n        }\n    }\n\n    @Override\n    public void postProcessBeanFactory(ConfigurableListableBeanFactory configurableListableBeanFactory) throws BeansException {}\n\n\n    @Override\n    public void setEnvironment(Environment environment) {\n        profile = environment.getProperty(\"profile\");\n    }\n}\n```\n\n##### 注意上面的注入对象是`HttpsTomcatEmbeddedServletContainerFactory`，不是之前的`TomcatEmbeddedServletContainerFactory`，贴上`HttpsTomcatEmbeddedServletContainerFactory`代码：\n\n```java\nimport org.apache.catalina.connector.Connector;\nimport org.apache.coyote.http11.Http11NioProtocol;\nimport org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedServletContainerFactory;\n\n/**\n * @author winx\n * @create 2017-09-01.\n */\npublic class HttpsTomcatEmbeddedServletContainerFactory extends TomcatEmbeddedServletContainerFactory {\n\n    public HttpsTomcatEmbeddedServletContainerFactory() {\n        super();\n        Connector connector = new Connector(\"org.apache.coyote.http11.Http11NioProtocol\");\n        Http11NioProtocol protocol = (Http11NioProtocol) connector.getProtocolHandler();\n        connector.setScheme(\"https\");\n        connector.setSecure(true);\n        connector.setPort(8443);\n        protocol.setSSLEnabled(true);\n        protocol.setKeystoreFile(\"/Users/winx/.keystore\");\n        protocol.setKeystorePass(\"123456\");\n        protocol.setTruststoreFile(\"/Users/winx/.keystore\");\n        protocol.setTruststorePass(\"123456\");\n        protocol.setKeyAlias(\"tomcat\");\n        addAdditionalTomcatConnectors(connector);\n    }\n}\n```\n\n##### 成功的解决了之前属性设置问题。","source":"_posts/note/spring/springbootDynamic.md","raw":"---\nlayout: post\ntitle: spring boot 动态启动与加载\ndate: 2017/08/31\ntags: [tech, index, spring, java]\noriginal: true\ntag: [[spring, spring],[java, java]]\ntop: 1\ntopTag: [index]\n---\n\n##### 通常情况下，我们通过XML或者Annotation两种方式配置Bean Definition。从Spring 3.0开始，增加了一种新的途径来配置Bean Definition，这就是通过Java Code配置Bean Definition。\n<!--more-->\n\n#### Java Code配置与XML和Annotation两种配置方式不同点在于：\n##### 前两种方式XML和Annotation的配置方式为预定义方式，即开发人员通过XML文件或者Annotation预定义配置Bean的各种属性后，启动Spring容器，Spring容器会首先解析这些配置属性，生成对应的Bean Definition,装入到`DefaultListtableBeanFactory`对象的属性容器中，以此同时，Spring框架也会定义内部使用的Bean定义，如Bean名为：`org.springframework.context.annotation.internalConfigurationAnnotationProcessor`的 `ConfigurationClassPostProcessor` 定义。而后此刻不会做任何Bean Definition的解析动作，Spring框架会根据前两种配置，过滤出`BeanDefinitionRegistryPostProcessor` 类型的Bean定义，并通过Spring框架生成对应的Bean对象（如 `ConfigurationClassPostProcessor` 实例）。结合 Spring 上下文源码可知这个对象是一个 processor 类型工具类，<u>Spring容器会在实例化开发人员所定义的 Bean 前先调用该 processor 的 postProcessBeanDefinitionRegistry(…) 方法。此处实现基于 Java Code 配置Bean Definition的处理</u>。\n\n##### 基于 Java Code 的配置方式，其执行原理不同于前两种。它是在 Spring 框架已经解析了基于 XML 和 Annotation 配置后，通过加入 BeanDefinitionRegistryPostProcessor 类型的 processor 来处理配置信息，让开发人员通过 Java 编程方式定义一个 Java 对象。其优点在于可以将配置信息集中在一定数量的 Java 对象中，同时通过 Java 编程方式，比基于 Annotation 方式具有更高的灵活性。并且该配置方式给开发人员提供了一种非常好的范例来增加用户自定义的解析工具类。其主要缺点在于与 Java 代码结合紧密，配置信息的改变需要重新编译 Java 代码，另外这是一种新引入的解析方式，需要一定的学习成本。\n\n<br/>\n\n#### 提及一点的就是，Spring框架有3个主要的Hook类，分别是：\n`org.springframework.context.ApplicationContextAware`\n##### 它的setApplicationContext 方法将在Spring启动之前第一个被调用。\n`org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor`\n##### 它的postProcessBeanDefinitionRegistry 和 postProcessBeanFactory 方法是第二和第三被调用，它们在Bean初始化创建之前启动，如果Spring的bean需要的其他第三方中的组件，我们在这里将其注入给Spring。\n`org.springframework.context.ApplicationListener`\n用于在初始化完成后做一些事情，当Spring所有XML或元注解的Bean都启动被创建成功了，这时会调用它的唯一方法onApplicationEvent。\n<br/>\n#### 通过 BeanDefinitionRegistryPostProcessor 加载自己的bean的demo：\n```java\nimport org.springframework.beans.BeansException;\nimport org.springframework.beans.MutablePropertyValues;\nimport org.springframework.beans.factory.annotation.AnnotatedBeanDefinition;\nimport org.springframework.beans.factory.annotation.AnnotatedGenericBeanDefinition;\nimport org.springframework.beans.factory.config.BeanDefinition;\nimport org.springframework.beans.factory.config.BeanDefinitionHolder;\nimport org.springframework.beans.factory.config.ConfigurableListableBeanFactory;\nimport org.springframework.beans.factory.support.BeanDefinitionReaderUtils;\nimport org.springframework.beans.factory.support.BeanDefinitionRegistry;\nimport org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor;\n\n/**\n * @author winx\n * @create 2017-09-01.\n */\n@Configuration\npublic class MyBeanDefinitionRegistryPostProcessor implements BeanDefinitionRegistryPostProcessor {\n\n    /**\n     * 先执行：postProcessBeanDefinitionRegistry()方法\n     * 通过Class对象，注册自己的 BeanDefinition\n     */\n    @Override\n    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException {\n        try {\n            AnnotatedBeanDefinition annotatedBeanDefinition = new AnnotatedGenericBeanDefinition(Class.forName(\"\"));\n            BeanDefinitionHolder beanDefinitionHolder = new BeanDefinitionHolder(annotatedBeanDefinition, \"beanName\");\n            BeanDefinitionReaderUtils.registerBeanDefinition(beanDefinitionHolder, registry);\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * 再执行：postProcessBeanFactory()方法。\n     * 通过 beanName 拿到注册后的 BeanDefinition\n     * 然后加入自定义属性，BeanDefinition 会在初始化bean时，将 Property 键值对插入到之前的Class对象属性中。\n     */\n    @Override\n    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {\n        BeanDefinition beanDefinition = beanFactory.getBeanDefinition(\"beanName\");\n        MutablePropertyValues mutablePropertyValues = beanDefinition.getPropertyValues();\n        //加入属性.\n        mutablePropertyValues.addPropertyValue(\"username\", \"root\");\n    }\n}\n```\n\n##### `@Configuration`注解提示spring boot通过该类加载bean\n##### `postProcessBeanDefinitionRegistry()` 通过Class对象，注册自己的 BeanDefinition\n##### `postProcessBeanFactory()`方法会在`postProcessBeanDefinitionRegistry()`之后执行， 通过beanFactory拿到 BeanDefinition 后加入属性，这一步可以跳过。\n\n### 实际项目需求\n##### 目前项目分为线上环境和dev环境，项目本身只支持http服务，因为线上环境有nginx做反向代理，所以用http和https均能正常访问线上服务。但是本地环境相对简单，不能支持https服务。先在需要根据环境的不同。动态的扩张spring boot的多连接器设置。当环境为dev时，即加载多连接器，分别用两个端口提供http和https服务。当环境不为dev时，只加载默认http即可。\n##### 根据这些需求，通过xml或者annotation去定义bean都不太合适。只能是通过java code去判断环境并动态加载。\n\n##### 省去spring boot支持https以及多连接器的配置，相关的代码网络上很多。直接说遇到的主要问题吧。上面的demo通过`mutablePropertyValues.addPropertyValue(\"key\", \"root\");`的方式为目标class定义属性，但是要求属性key必须有相应的set方法。\n\n```java\n@Configuration\npublic class HttpsBeanDefinitionRegistryPostProcessor implements BeanDefinitionRegistryPostProcessor, EnvironmentAware {\n\n    private String profile;\n\n    @Override\n    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry beanDefinitionRegistry) throws BeansException {\n        if (\"dev\".equals(profile)){\n            AnnotatedBeanDefinition annotatedBeanDefinition = new AnnotatedGenericBeanDefinition(TomcatEmbeddedServletContainerFactory.class);\n            BeanDefinitionHolder beanDefinitionHolder = new BeanDefinitionHolder(annotatedBeanDefinition, \"tomcatEmbeddedServletContainerFactory\");\n            BeanDefinitionReaderUtils.registerBeanDefinition(beanDefinitionHolder, beanDefinitionRegistry);\n        }\n    }\n\n    @Override\n    public void postProcessBeanFactory(ConfigurableListableBeanFactory configurableListableBeanFactory) throws BeansException {\n        MutablePropertyValues tomcatEmbeddedServletContainerFactory = configurableListableBeanFactory.getBeanDefinition(\"tomcatEmbeddedServletContainerFactory\").getPropertyValues();\n        tomcatEmbeddedServletContainerFactory.addPropertyValue(\"additionalTomcatConnectors\", getConnector());\n    }\n\n    public Connector getConnector(){\n        Connector connector = new Connector(\"org.apache.coyote.http11.Http11NioProtocol\");\n        Http11NioProtocol protocol = (Http11NioProtocol) connector.getProtocolHandler();\n        connector.setScheme(\"https\");\n        connector.setSecure(true);\n        connector.setPort(8443);\n        protocol.setSSLEnabled(true);\n        protocol.setKeystoreFile(\"/Users/winx/.keystore\");\n        protocol.setKeystorePass(\"123456\");\n        protocol.setTruststoreFile(\"/Users/winx/.keystore\");\n        protocol.setTruststorePass(\"123456\");\n        protocol.setKeyAlias(\"tomcat\");\n        return connector;\n    }\n\n    @Override\n    public void setEnvironment(Environment environment) {\n        profile = environment.getProperty(\"profile\");\n    }\n}\n```\n\n##### 在拿到`MutablePropertyValues`之后，想要给`TomcatEmbeddedServletContainerFactory`对象设置`additionalTomcatConnectors`属性，Connector中包含了https关键信息的设置。之后报错如下：\n```\norg.springframework.context.ApplicationContextException: Unable to start embedded container; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'tomcatEmbeddedServletContainerFactory': Error setting property values; nested exception is org.springframework.beans.NotWritablePropertyException: Invalid property 'additionalTomcatConnectors' of bean class [org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedServletContainerFactory]: Bean property 'additionalTomcatConnectors' is not writable or has an invalid setter method. Does the parameter type of the setter match the return type of the getter?\n\tat org.springframework.boot.context.embedded.EmbeddedWebApplicationContext.onRefresh(EmbeddedWebApplicationContext.java:133) ~[spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n\tat org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:532) ~[spring-context-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n\tat org.springframework.boot.context.embedded.EmbeddedWebApplicationContext.refresh(EmbeddedWebApplicationContext.java:118) ~[spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n\tat org.springframework.boot.SpringApplication.refresh(SpringApplication.java:760) [spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n\tat org.springframework.boot.SpringApplication.createAndRefreshContext(SpringApplication.java:360) [spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n\tat org.springframework.boot.SpringApplication.run(SpringApplication.java:306) [spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n\tat org.springframework.boot.SpringApplication.run(SpringApplication.java:1185) [spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n\tat org.springframework.boot.SpringApplication.run(SpringApplication.java:1174) [spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n\tat com.winx.es.metis.RunMetis.main(RunMetis.java:47) [classes/:na]\nCaused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'tomcatEmbeddedServletContainerFactory': Error setting property values; nested exception is org.springframework.beans.NotWritablePropertyException: Invalid property 'additionalTomcatConnectors' of bean class [org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedServletContainerFactory]: Bean property 'additionalTomcatConnectors' is not writable or has an invalid setter method. Does the parameter type of the setter match the return type of the getter?\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyPropertyValues(AbstractAutowireCapableBeanFactory.java:1518) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1226) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:543) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:482) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n\tat org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:306) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n\tat org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:302) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n\tat org.springframework.boot.context.embedded.EmbeddedWebApplicationContext.getEmbeddedServletContainerFactory(EmbeddedWebApplicationContext.java:195) ~[spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n\tat org.springframework.boot.context.embedded.EmbeddedWebApplicationContext.createEmbeddedServletContainer(EmbeddedWebApplicationContext.java:158) ~[spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n\tat org.springframework.boot.context.embedded.EmbeddedWebApplicationContext.onRefresh(EmbeddedWebApplicationContext.java:130) ~[spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n\t... 8 common frames omitted\nCaused by: org.springframework.beans.NotWritablePropertyException: Invalid property 'additionalTomcatConnectors' of bean class [org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedServletContainerFactory]: Bean property 'additionalTomcatConnectors' is not writable or has an invalid setter method. Does the parameter type of the setter match the return type of the getter?\n\tat org.springframework.beans.BeanWrapperImpl.createNotWritablePropertyException(BeanWrapperImpl.java:230) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n\tat org.springframework.beans.AbstractNestablePropertyAccessor.setPropertyValue(AbstractNestablePropertyAccessor.java:423) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n\tat org.springframework.beans.AbstractNestablePropertyAccessor.setPropertyValue(AbstractNestablePropertyAccessor.java:280) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n\tat org.springframework.beans.AbstractPropertyAccessor.setPropertyValues(AbstractPropertyAccessor.java:95) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n\tat org.springframework.beans.AbstractPropertyAccessor.setPropertyValues(AbstractPropertyAccessor.java:75) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyPropertyValues(AbstractAutowireCapableBeanFactory.java:1514) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n\t... 18 common frames omitted\n```\n\n##### **关键错误信息**：`Bean property 'additionalTomcatConnectors' is not writable or has an invalid setter method. Does the parameter type of the setter match the return type of the getter?`，没有权限写入以及没有找到相应的个体方法。\n\n##### 查看`TomcatEmbeddedServletContainerFactory`源码后发现其相应的设置方法如下：\n```java\npublic void addAdditionalTomcatConnectors(Connector... connectors) {\n    Assert.notNull(connectors, \"Connectors must not be null\");\n    this.additionalTomcatConnectors.addAll(Arrays.asList(connectors));\n}\n```\n\n##### 顿时觉得坑爹的add啊，之后在Bean Definition的私有属性设置，以及通过方法设置属性值的方向去尝试解决问题，没有任何效果。几乎快要绝望的时候，突然灵机一动，为什么我不能自己定义一个不需要后置设置属性的`TomcatEmbeddedServletContainerFactory`呢，于是有了下面的代码：\n\n```java\n@Configuration\npublic class HttpsBeanDefinitionRegistryPostProcessor implements BeanDefinitionRegistryPostProcessor, EnvironmentAware {\n\n    private String profile;\n\n    @Override\n    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry beanDefinitionRegistry) throws BeansException {\n        if (\"dev\".equals(profile)){\n            AnnotatedBeanDefinition annotatedBeanDefinition = new AnnotatedGenericBeanDefinition(HttpsTomcatEmbeddedServletContainerFactory.class);\n            BeanDefinitionHolder beanDefinitionHolder = new BeanDefinitionHolder(annotatedBeanDefinition, \"tomcatEmbeddedServletContainerFactory\");\n            BeanDefinitionReaderUtils.registerBeanDefinition(beanDefinitionHolder, beanDefinitionRegistry);\n        }\n    }\n\n    @Override\n    public void postProcessBeanFactory(ConfigurableListableBeanFactory configurableListableBeanFactory) throws BeansException {}\n\n\n    @Override\n    public void setEnvironment(Environment environment) {\n        profile = environment.getProperty(\"profile\");\n    }\n}\n```\n\n##### 注意上面的注入对象是`HttpsTomcatEmbeddedServletContainerFactory`，不是之前的`TomcatEmbeddedServletContainerFactory`，贴上`HttpsTomcatEmbeddedServletContainerFactory`代码：\n\n```java\nimport org.apache.catalina.connector.Connector;\nimport org.apache.coyote.http11.Http11NioProtocol;\nimport org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedServletContainerFactory;\n\n/**\n * @author winx\n * @create 2017-09-01.\n */\npublic class HttpsTomcatEmbeddedServletContainerFactory extends TomcatEmbeddedServletContainerFactory {\n\n    public HttpsTomcatEmbeddedServletContainerFactory() {\n        super();\n        Connector connector = new Connector(\"org.apache.coyote.http11.Http11NioProtocol\");\n        Http11NioProtocol protocol = (Http11NioProtocol) connector.getProtocolHandler();\n        connector.setScheme(\"https\");\n        connector.setSecure(true);\n        connector.setPort(8443);\n        protocol.setSSLEnabled(true);\n        protocol.setKeystoreFile(\"/Users/winx/.keystore\");\n        protocol.setKeystorePass(\"123456\");\n        protocol.setTruststoreFile(\"/Users/winx/.keystore\");\n        protocol.setTruststorePass(\"123456\");\n        protocol.setKeyAlias(\"tomcat\");\n        addAdditionalTomcatConnectors(connector);\n    }\n}\n```\n\n##### 成功的解决了之前属性设置问题。","slug":"note/spring/springbootDynamic","published":1,"updated":"2018-05-08T14:51:18.342Z","_id":"cjgxop3o1004ejah1eb513vqk","comments":1,"photos":[],"link":"","content":"<h5 id=\"通常情况下，我们通过XML或者Annotation两种方式配置Bean-Definition。从Spring-3-0开始，增加了一种新的途径来配置Bean-Definition，这就是通过Java-Code配置Bean-Definition。\"><a href=\"#通常情况下，我们通过XML或者Annotation两种方式配置Bean-Definition。从Spring-3-0开始，增加了一种新的途径来配置Bean-Definition，这就是通过Java-Code配置Bean-Definition。\" class=\"headerlink\" title=\"通常情况下，我们通过XML或者Annotation两种方式配置Bean Definition。从Spring 3.0开始，增加了一种新的途径来配置Bean Definition，这就是通过Java Code配置Bean Definition。\"></a>通常情况下，我们通过XML或者Annotation两种方式配置Bean Definition。从Spring 3.0开始，增加了一种新的途径来配置Bean Definition，这就是通过Java Code配置Bean Definition。</h5><a id=\"more\"></a>\n<h4 id=\"Java-Code配置与XML和Annotation两种配置方式不同点在于：\"><a href=\"#Java-Code配置与XML和Annotation两种配置方式不同点在于：\" class=\"headerlink\" title=\"Java Code配置与XML和Annotation两种配置方式不同点在于：\"></a>Java Code配置与XML和Annotation两种配置方式不同点在于：</h4><h5 id=\"前两种方式XML和Annotation的配置方式为预定义方式，即开发人员通过XML文件或者Annotation预定义配置Bean的各种属性后，启动Spring容器，Spring容器会首先解析这些配置属性，生成对应的Bean-Definition-装入到DefaultListtableBeanFactory对象的属性容器中，以此同时，Spring框架也会定义内部使用的Bean定义，如Bean名为：org-springframework-context-annotation-internalConfigurationAnnotationProcessor的-ConfigurationClassPostProcessor-定义。而后此刻不会做任何Bean-Definition的解析动作，Spring框架会根据前两种配置，过滤出BeanDefinitionRegistryPostProcessor-类型的Bean定义，并通过Spring框架生成对应的Bean对象（如-ConfigurationClassPostProcessor-实例）。结合-Spring-上下文源码可知这个对象是一个-processor-类型工具类，Spring容器会在实例化开发人员所定义的-Bean-前先调用该-processor-的-postProcessBeanDefinitionRegistry-…-方法。此处实现基于-Java-Code-配置Bean-Definition的处理。\"><a href=\"#前两种方式XML和Annotation的配置方式为预定义方式，即开发人员通过XML文件或者Annotation预定义配置Bean的各种属性后，启动Spring容器，Spring容器会首先解析这些配置属性，生成对应的Bean-Definition-装入到DefaultListtableBeanFactory对象的属性容器中，以此同时，Spring框架也会定义内部使用的Bean定义，如Bean名为：org-springframework-context-annotation-internalConfigurationAnnotationProcessor的-ConfigurationClassPostProcessor-定义。而后此刻不会做任何Bean-Definition的解析动作，Spring框架会根据前两种配置，过滤出BeanDefinitionRegistryPostProcessor-类型的Bean定义，并通过Spring框架生成对应的Bean对象（如-ConfigurationClassPostProcessor-实例）。结合-Spring-上下文源码可知这个对象是一个-processor-类型工具类，Spring容器会在实例化开发人员所定义的-Bean-前先调用该-processor-的-postProcessBeanDefinitionRegistry-…-方法。此处实现基于-Java-Code-配置Bean-Definition的处理。\" class=\"headerlink\" title=\"前两种方式XML和Annotation的配置方式为预定义方式，即开发人员通过XML文件或者Annotation预定义配置Bean的各种属性后，启动Spring容器，Spring容器会首先解析这些配置属性，生成对应的Bean Definition,装入到DefaultListtableBeanFactory对象的属性容器中，以此同时，Spring框架也会定义内部使用的Bean定义，如Bean名为：org.springframework.context.annotation.internalConfigurationAnnotationProcessor的 ConfigurationClassPostProcessor 定义。而后此刻不会做任何Bean Definition的解析动作，Spring框架会根据前两种配置，过滤出BeanDefinitionRegistryPostProcessor 类型的Bean定义，并通过Spring框架生成对应的Bean对象（如 ConfigurationClassPostProcessor 实例）。结合 Spring 上下文源码可知这个对象是一个 processor 类型工具类，Spring容器会在实例化开发人员所定义的 Bean 前先调用该 processor 的 postProcessBeanDefinitionRegistry(…) 方法。此处实现基于 Java Code 配置Bean Definition的处理。\"></a>前两种方式XML和Annotation的配置方式为预定义方式，即开发人员通过XML文件或者Annotation预定义配置Bean的各种属性后，启动Spring容器，Spring容器会首先解析这些配置属性，生成对应的Bean Definition,装入到<code>DefaultListtableBeanFactory</code>对象的属性容器中，以此同时，Spring框架也会定义内部使用的Bean定义，如Bean名为：<code>org.springframework.context.annotation.internalConfigurationAnnotationProcessor</code>的 <code>ConfigurationClassPostProcessor</code> 定义。而后此刻不会做任何Bean Definition的解析动作，Spring框架会根据前两种配置，过滤出<code>BeanDefinitionRegistryPostProcessor</code> 类型的Bean定义，并通过Spring框架生成对应的Bean对象（如 <code>ConfigurationClassPostProcessor</code> 实例）。结合 Spring 上下文源码可知这个对象是一个 processor 类型工具类，<u>Spring容器会在实例化开发人员所定义的 Bean 前先调用该 processor 的 postProcessBeanDefinitionRegistry(…) 方法。此处实现基于 Java Code 配置Bean Definition的处理</u>。</h5><h5 id=\"基于-Java-Code-的配置方式，其执行原理不同于前两种。它是在-Spring-框架已经解析了基于-XML-和-Annotation-配置后，通过加入-BeanDefinitionRegistryPostProcessor-类型的-processor-来处理配置信息，让开发人员通过-Java-编程方式定义一个-Java-对象。其优点在于可以将配置信息集中在一定数量的-Java-对象中，同时通过-Java-编程方式，比基于-Annotation-方式具有更高的灵活性。并且该配置方式给开发人员提供了一种非常好的范例来增加用户自定义的解析工具类。其主要缺点在于与-Java-代码结合紧密，配置信息的改变需要重新编译-Java-代码，另外这是一种新引入的解析方式，需要一定的学习成本。\"><a href=\"#基于-Java-Code-的配置方式，其执行原理不同于前两种。它是在-Spring-框架已经解析了基于-XML-和-Annotation-配置后，通过加入-BeanDefinitionRegistryPostProcessor-类型的-processor-来处理配置信息，让开发人员通过-Java-编程方式定义一个-Java-对象。其优点在于可以将配置信息集中在一定数量的-Java-对象中，同时通过-Java-编程方式，比基于-Annotation-方式具有更高的灵活性。并且该配置方式给开发人员提供了一种非常好的范例来增加用户自定义的解析工具类。其主要缺点在于与-Java-代码结合紧密，配置信息的改变需要重新编译-Java-代码，另外这是一种新引入的解析方式，需要一定的学习成本。\" class=\"headerlink\" title=\"基于 Java Code 的配置方式，其执行原理不同于前两种。它是在 Spring 框架已经解析了基于 XML 和 Annotation 配置后，通过加入 BeanDefinitionRegistryPostProcessor 类型的 processor 来处理配置信息，让开发人员通过 Java 编程方式定义一个 Java 对象。其优点在于可以将配置信息集中在一定数量的 Java 对象中，同时通过 Java 编程方式，比基于 Annotation 方式具有更高的灵活性。并且该配置方式给开发人员提供了一种非常好的范例来增加用户自定义的解析工具类。其主要缺点在于与 Java 代码结合紧密，配置信息的改变需要重新编译 Java 代码，另外这是一种新引入的解析方式，需要一定的学习成本。\"></a>基于 Java Code 的配置方式，其执行原理不同于前两种。它是在 Spring 框架已经解析了基于 XML 和 Annotation 配置后，通过加入 BeanDefinitionRegistryPostProcessor 类型的 processor 来处理配置信息，让开发人员通过 Java 编程方式定义一个 Java 对象。其优点在于可以将配置信息集中在一定数量的 Java 对象中，同时通过 Java 编程方式，比基于 Annotation 方式具有更高的灵活性。并且该配置方式给开发人员提供了一种非常好的范例来增加用户自定义的解析工具类。其主要缺点在于与 Java 代码结合紧密，配置信息的改变需要重新编译 Java 代码，另外这是一种新引入的解析方式，需要一定的学习成本。</h5><p><br></p>\n<h4 id=\"提及一点的就是，Spring框架有3个主要的Hook类，分别是：\"><a href=\"#提及一点的就是，Spring框架有3个主要的Hook类，分别是：\" class=\"headerlink\" title=\"提及一点的就是，Spring框架有3个主要的Hook类，分别是：\"></a>提及一点的就是，Spring框架有3个主要的Hook类，分别是：</h4><p><code>org.springframework.context.ApplicationContextAware</code></p>\n<h5 id=\"它的setApplicationContext-方法将在Spring启动之前第一个被调用。\"><a href=\"#它的setApplicationContext-方法将在Spring启动之前第一个被调用。\" class=\"headerlink\" title=\"它的setApplicationContext 方法将在Spring启动之前第一个被调用。\"></a>它的setApplicationContext 方法将在Spring启动之前第一个被调用。</h5><p><code>org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor</code></p>\n<h5 id=\"它的postProcessBeanDefinitionRegistry-和-postProcessBeanFactory-方法是第二和第三被调用，它们在Bean初始化创建之前启动，如果Spring的bean需要的其他第三方中的组件，我们在这里将其注入给Spring。\"><a href=\"#它的postProcessBeanDefinitionRegistry-和-postProcessBeanFactory-方法是第二和第三被调用，它们在Bean初始化创建之前启动，如果Spring的bean需要的其他第三方中的组件，我们在这里将其注入给Spring。\" class=\"headerlink\" title=\"它的postProcessBeanDefinitionRegistry 和 postProcessBeanFactory 方法是第二和第三被调用，它们在Bean初始化创建之前启动，如果Spring的bean需要的其他第三方中的组件，我们在这里将其注入给Spring。\"></a>它的postProcessBeanDefinitionRegistry 和 postProcessBeanFactory 方法是第二和第三被调用，它们在Bean初始化创建之前启动，如果Spring的bean需要的其他第三方中的组件，我们在这里将其注入给Spring。</h5><p><code>org.springframework.context.ApplicationListener</code><br>用于在初始化完成后做一些事情，当Spring所有XML或元注解的Bean都启动被创建成功了，这时会调用它的唯一方法onApplicationEvent。<br><br></p>\n<h4 id=\"通过-BeanDefinitionRegistryPostProcessor-加载自己的bean的demo：\"><a href=\"#通过-BeanDefinitionRegistryPostProcessor-加载自己的bean的demo：\" class=\"headerlink\" title=\"通过 BeanDefinitionRegistryPostProcessor 加载自己的bean的demo：\"></a>通过 BeanDefinitionRegistryPostProcessor 加载自己的bean的demo：</h4><pre><code class=\"lang-java\">import org.springframework.beans.BeansException;\nimport org.springframework.beans.MutablePropertyValues;\nimport org.springframework.beans.factory.annotation.AnnotatedBeanDefinition;\nimport org.springframework.beans.factory.annotation.AnnotatedGenericBeanDefinition;\nimport org.springframework.beans.factory.config.BeanDefinition;\nimport org.springframework.beans.factory.config.BeanDefinitionHolder;\nimport org.springframework.beans.factory.config.ConfigurableListableBeanFactory;\nimport org.springframework.beans.factory.support.BeanDefinitionReaderUtils;\nimport org.springframework.beans.factory.support.BeanDefinitionRegistry;\nimport org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor;\n\n/**\n * @author winx\n * @create 2017-09-01.\n */\n@Configuration\npublic class MyBeanDefinitionRegistryPostProcessor implements BeanDefinitionRegistryPostProcessor {\n\n    /**\n     * 先执行：postProcessBeanDefinitionRegistry()方法\n     * 通过Class对象，注册自己的 BeanDefinition\n     */\n    @Override\n    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException {\n        try {\n            AnnotatedBeanDefinition annotatedBeanDefinition = new AnnotatedGenericBeanDefinition(Class.forName(&quot;&quot;));\n            BeanDefinitionHolder beanDefinitionHolder = new BeanDefinitionHolder(annotatedBeanDefinition, &quot;beanName&quot;);\n            BeanDefinitionReaderUtils.registerBeanDefinition(beanDefinitionHolder, registry);\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * 再执行：postProcessBeanFactory()方法。\n     * 通过 beanName 拿到注册后的 BeanDefinition\n     * 然后加入自定义属性，BeanDefinition 会在初始化bean时，将 Property 键值对插入到之前的Class对象属性中。\n     */\n    @Override\n    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {\n        BeanDefinition beanDefinition = beanFactory.getBeanDefinition(&quot;beanName&quot;);\n        MutablePropertyValues mutablePropertyValues = beanDefinition.getPropertyValues();\n        //加入属性.\n        mutablePropertyValues.addPropertyValue(&quot;username&quot;, &quot;root&quot;);\n    }\n}\n</code></pre>\n<h5 id=\"Configuration注解提示spring-boot通过该类加载bean\"><a href=\"#Configuration注解提示spring-boot通过该类加载bean\" class=\"headerlink\" title=\"@Configuration注解提示spring boot通过该类加载bean\"></a><code>@Configuration</code>注解提示spring boot通过该类加载bean</h5><h5 id=\"postProcessBeanDefinitionRegistry-通过Class对象，注册自己的-BeanDefinition\"><a href=\"#postProcessBeanDefinitionRegistry-通过Class对象，注册自己的-BeanDefinition\" class=\"headerlink\" title=\"postProcessBeanDefinitionRegistry() 通过Class对象，注册自己的 BeanDefinition\"></a><code>postProcessBeanDefinitionRegistry()</code> 通过Class对象，注册自己的 BeanDefinition</h5><h5 id=\"postProcessBeanFactory-方法会在postProcessBeanDefinitionRegistry-之后执行，-通过beanFactory拿到-BeanDefinition-后加入属性，这一步可以跳过。\"><a href=\"#postProcessBeanFactory-方法会在postProcessBeanDefinitionRegistry-之后执行，-通过beanFactory拿到-BeanDefinition-后加入属性，这一步可以跳过。\" class=\"headerlink\" title=\"postProcessBeanFactory()方法会在postProcessBeanDefinitionRegistry()之后执行， 通过beanFactory拿到 BeanDefinition 后加入属性，这一步可以跳过。\"></a><code>postProcessBeanFactory()</code>方法会在<code>postProcessBeanDefinitionRegistry()</code>之后执行， 通过beanFactory拿到 BeanDefinition 后加入属性，这一步可以跳过。</h5><h3 id=\"实际项目需求\"><a href=\"#实际项目需求\" class=\"headerlink\" title=\"实际项目需求\"></a>实际项目需求</h3><h5 id=\"目前项目分为线上环境和dev环境，项目本身只支持http服务，因为线上环境有nginx做反向代理，所以用http和https均能正常访问线上服务。但是本地环境相对简单，不能支持https服务。先在需要根据环境的不同。动态的扩张spring-boot的多连接器设置。当环境为dev时，即加载多连接器，分别用两个端口提供http和https服务。当环境不为dev时，只加载默认http即可。\"><a href=\"#目前项目分为线上环境和dev环境，项目本身只支持http服务，因为线上环境有nginx做反向代理，所以用http和https均能正常访问线上服务。但是本地环境相对简单，不能支持https服务。先在需要根据环境的不同。动态的扩张spring-boot的多连接器设置。当环境为dev时，即加载多连接器，分别用两个端口提供http和https服务。当环境不为dev时，只加载默认http即可。\" class=\"headerlink\" title=\"目前项目分为线上环境和dev环境，项目本身只支持http服务，因为线上环境有nginx做反向代理，所以用http和https均能正常访问线上服务。但是本地环境相对简单，不能支持https服务。先在需要根据环境的不同。动态的扩张spring boot的多连接器设置。当环境为dev时，即加载多连接器，分别用两个端口提供http和https服务。当环境不为dev时，只加载默认http即可。\"></a>目前项目分为线上环境和dev环境，项目本身只支持http服务，因为线上环境有nginx做反向代理，所以用http和https均能正常访问线上服务。但是本地环境相对简单，不能支持https服务。先在需要根据环境的不同。动态的扩张spring boot的多连接器设置。当环境为dev时，即加载多连接器，分别用两个端口提供http和https服务。当环境不为dev时，只加载默认http即可。</h5><h5 id=\"根据这些需求，通过xml或者annotation去定义bean都不太合适。只能是通过java-code去判断环境并动态加载。\"><a href=\"#根据这些需求，通过xml或者annotation去定义bean都不太合适。只能是通过java-code去判断环境并动态加载。\" class=\"headerlink\" title=\"根据这些需求，通过xml或者annotation去定义bean都不太合适。只能是通过java code去判断环境并动态加载。\"></a>根据这些需求，通过xml或者annotation去定义bean都不太合适。只能是通过java code去判断环境并动态加载。</h5><h5 id=\"省去spring-boot支持https以及多连接器的配置，相关的代码网络上很多。直接说遇到的主要问题吧。上面的demo通过mutablePropertyValues-addPropertyValue-quot-key-quot-quot-root-quot-的方式为目标class定义属性，但是要求属性key必须有相应的set方法。\"><a href=\"#省去spring-boot支持https以及多连接器的配置，相关的代码网络上很多。直接说遇到的主要问题吧。上面的demo通过mutablePropertyValues-addPropertyValue-quot-key-quot-quot-root-quot-的方式为目标class定义属性，但是要求属性key必须有相应的set方法。\" class=\"headerlink\" title=\"省去spring boot支持https以及多连接器的配置，相关的代码网络上很多。直接说遇到的主要问题吧。上面的demo通过mutablePropertyValues.addPropertyValue(&quot;key&quot;, &quot;root&quot;);的方式为目标class定义属性，但是要求属性key必须有相应的set方法。\"></a>省去spring boot支持https以及多连接器的配置，相关的代码网络上很多。直接说遇到的主要问题吧。上面的demo通过<code>mutablePropertyValues.addPropertyValue(&quot;key&quot;, &quot;root&quot;);</code>的方式为目标class定义属性，但是要求属性key必须有相应的set方法。</h5><pre><code class=\"lang-java\">@Configuration\npublic class HttpsBeanDefinitionRegistryPostProcessor implements BeanDefinitionRegistryPostProcessor, EnvironmentAware {\n\n    private String profile;\n\n    @Override\n    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry beanDefinitionRegistry) throws BeansException {\n        if (&quot;dev&quot;.equals(profile)){\n            AnnotatedBeanDefinition annotatedBeanDefinition = new AnnotatedGenericBeanDefinition(TomcatEmbeddedServletContainerFactory.class);\n            BeanDefinitionHolder beanDefinitionHolder = new BeanDefinitionHolder(annotatedBeanDefinition, &quot;tomcatEmbeddedServletContainerFactory&quot;);\n            BeanDefinitionReaderUtils.registerBeanDefinition(beanDefinitionHolder, beanDefinitionRegistry);\n        }\n    }\n\n    @Override\n    public void postProcessBeanFactory(ConfigurableListableBeanFactory configurableListableBeanFactory) throws BeansException {\n        MutablePropertyValues tomcatEmbeddedServletContainerFactory = configurableListableBeanFactory.getBeanDefinition(&quot;tomcatEmbeddedServletContainerFactory&quot;).getPropertyValues();\n        tomcatEmbeddedServletContainerFactory.addPropertyValue(&quot;additionalTomcatConnectors&quot;, getConnector());\n    }\n\n    public Connector getConnector(){\n        Connector connector = new Connector(&quot;org.apache.coyote.http11.Http11NioProtocol&quot;);\n        Http11NioProtocol protocol = (Http11NioProtocol) connector.getProtocolHandler();\n        connector.setScheme(&quot;https&quot;);\n        connector.setSecure(true);\n        connector.setPort(8443);\n        protocol.setSSLEnabled(true);\n        protocol.setKeystoreFile(&quot;/Users/winx/.keystore&quot;);\n        protocol.setKeystorePass(&quot;123456&quot;);\n        protocol.setTruststoreFile(&quot;/Users/winx/.keystore&quot;);\n        protocol.setTruststorePass(&quot;123456&quot;);\n        protocol.setKeyAlias(&quot;tomcat&quot;);\n        return connector;\n    }\n\n    @Override\n    public void setEnvironment(Environment environment) {\n        profile = environment.getProperty(&quot;profile&quot;);\n    }\n}\n</code></pre>\n<h5 id=\"在拿到MutablePropertyValues之后，想要给TomcatEmbeddedServletContainerFactory对象设置additionalTomcatConnectors属性，Connector中包含了https关键信息的设置。之后报错如下：\"><a href=\"#在拿到MutablePropertyValues之后，想要给TomcatEmbeddedServletContainerFactory对象设置additionalTomcatConnectors属性，Connector中包含了https关键信息的设置。之后报错如下：\" class=\"headerlink\" title=\"在拿到MutablePropertyValues之后，想要给TomcatEmbeddedServletContainerFactory对象设置additionalTomcatConnectors属性，Connector中包含了https关键信息的设置。之后报错如下：\"></a>在拿到<code>MutablePropertyValues</code>之后，想要给<code>TomcatEmbeddedServletContainerFactory</code>对象设置<code>additionalTomcatConnectors</code>属性，Connector中包含了https关键信息的设置。之后报错如下：</h5><pre><code>org.springframework.context.ApplicationContextException: Unable to start embedded container; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#39;tomcatEmbeddedServletContainerFactory&#39;: Error setting property values; nested exception is org.springframework.beans.NotWritablePropertyException: Invalid property &#39;additionalTomcatConnectors&#39; of bean class [org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedServletContainerFactory]: Bean property &#39;additionalTomcatConnectors&#39; is not writable or has an invalid setter method. Does the parameter type of the setter match the return type of the getter?\n    at org.springframework.boot.context.embedded.EmbeddedWebApplicationContext.onRefresh(EmbeddedWebApplicationContext.java:133) ~[spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n    at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:532) ~[spring-context-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n    at org.springframework.boot.context.embedded.EmbeddedWebApplicationContext.refresh(EmbeddedWebApplicationContext.java:118) ~[spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n    at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:760) [spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n    at org.springframework.boot.SpringApplication.createAndRefreshContext(SpringApplication.java:360) [spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n    at org.springframework.boot.SpringApplication.run(SpringApplication.java:306) [spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n    at org.springframework.boot.SpringApplication.run(SpringApplication.java:1185) [spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n    at org.springframework.boot.SpringApplication.run(SpringApplication.java:1174) [spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n    at com.winx.es.metis.RunMetis.main(RunMetis.java:47) [classes/:na]\nCaused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#39;tomcatEmbeddedServletContainerFactory&#39;: Error setting property values; nested exception is org.springframework.beans.NotWritablePropertyException: Invalid property &#39;additionalTomcatConnectors&#39; of bean class [org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedServletContainerFactory]: Bean property &#39;additionalTomcatConnectors&#39; is not writable or has an invalid setter method. Does the parameter type of the setter match the return type of the getter?\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyPropertyValues(AbstractAutowireCapableBeanFactory.java:1518) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1226) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:543) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:482) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n    at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:306) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n    at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n    at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:302) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n    at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n    at org.springframework.boot.context.embedded.EmbeddedWebApplicationContext.getEmbeddedServletContainerFactory(EmbeddedWebApplicationContext.java:195) ~[spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n    at org.springframework.boot.context.embedded.EmbeddedWebApplicationContext.createEmbeddedServletContainer(EmbeddedWebApplicationContext.java:158) ~[spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n    at org.springframework.boot.context.embedded.EmbeddedWebApplicationContext.onRefresh(EmbeddedWebApplicationContext.java:130) ~[spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n    ... 8 common frames omitted\nCaused by: org.springframework.beans.NotWritablePropertyException: Invalid property &#39;additionalTomcatConnectors&#39; of bean class [org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedServletContainerFactory]: Bean property &#39;additionalTomcatConnectors&#39; is not writable or has an invalid setter method. Does the parameter type of the setter match the return type of the getter?\n    at org.springframework.beans.BeanWrapperImpl.createNotWritablePropertyException(BeanWrapperImpl.java:230) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n    at org.springframework.beans.AbstractNestablePropertyAccessor.setPropertyValue(AbstractNestablePropertyAccessor.java:423) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n    at org.springframework.beans.AbstractNestablePropertyAccessor.setPropertyValue(AbstractNestablePropertyAccessor.java:280) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n    at org.springframework.beans.AbstractPropertyAccessor.setPropertyValues(AbstractPropertyAccessor.java:95) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n    at org.springframework.beans.AbstractPropertyAccessor.setPropertyValues(AbstractPropertyAccessor.java:75) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyPropertyValues(AbstractAutowireCapableBeanFactory.java:1514) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n    ... 18 common frames omitted\n</code></pre><h5 id=\"关键错误信息：Bean-property-39-additionalTomcatConnectors-39-is-not-writable-or-has-an-invalid-setter-method-Does-the-parameter-type-of-the-setter-match-the-return-type-of-the-getter-，没有权限写入以及没有找到相应的个体方法。\"><a href=\"#关键错误信息：Bean-property-39-additionalTomcatConnectors-39-is-not-writable-or-has-an-invalid-setter-method-Does-the-parameter-type-of-the-setter-match-the-return-type-of-the-getter-，没有权限写入以及没有找到相应的个体方法。\" class=\"headerlink\" title=\"关键错误信息：Bean property &#39;additionalTomcatConnectors&#39; is not writable or has an invalid setter method. Does the parameter type of the setter match the return type of the getter?，没有权限写入以及没有找到相应的个体方法。\"></a><strong>关键错误信息</strong>：<code>Bean property &#39;additionalTomcatConnectors&#39; is not writable or has an invalid setter method. Does the parameter type of the setter match the return type of the getter?</code>，没有权限写入以及没有找到相应的个体方法。</h5><h5 id=\"查看TomcatEmbeddedServletContainerFactory源码后发现其相应的设置方法如下：\"><a href=\"#查看TomcatEmbeddedServletContainerFactory源码后发现其相应的设置方法如下：\" class=\"headerlink\" title=\"查看TomcatEmbeddedServletContainerFactory源码后发现其相应的设置方法如下：\"></a>查看<code>TomcatEmbeddedServletContainerFactory</code>源码后发现其相应的设置方法如下：</h5><pre><code class=\"lang-java\">public void addAdditionalTomcatConnectors(Connector... connectors) {\n    Assert.notNull(connectors, &quot;Connectors must not be null&quot;);\n    this.additionalTomcatConnectors.addAll(Arrays.asList(connectors));\n}\n</code></pre>\n<h5 id=\"顿时觉得坑爹的add啊，之后在Bean-Definition的私有属性设置，以及通过方法设置属性值的方向去尝试解决问题，没有任何效果。几乎快要绝望的时候，突然灵机一动，为什么我不能自己定义一个不需要后置设置属性的TomcatEmbeddedServletContainerFactory呢，于是有了下面的代码：\"><a href=\"#顿时觉得坑爹的add啊，之后在Bean-Definition的私有属性设置，以及通过方法设置属性值的方向去尝试解决问题，没有任何效果。几乎快要绝望的时候，突然灵机一动，为什么我不能自己定义一个不需要后置设置属性的TomcatEmbeddedServletContainerFactory呢，于是有了下面的代码：\" class=\"headerlink\" title=\"顿时觉得坑爹的add啊，之后在Bean Definition的私有属性设置，以及通过方法设置属性值的方向去尝试解决问题，没有任何效果。几乎快要绝望的时候，突然灵机一动，为什么我不能自己定义一个不需要后置设置属性的TomcatEmbeddedServletContainerFactory呢，于是有了下面的代码：\"></a>顿时觉得坑爹的add啊，之后在Bean Definition的私有属性设置，以及通过方法设置属性值的方向去尝试解决问题，没有任何效果。几乎快要绝望的时候，突然灵机一动，为什么我不能自己定义一个不需要后置设置属性的<code>TomcatEmbeddedServletContainerFactory</code>呢，于是有了下面的代码：</h5><pre><code class=\"lang-java\">@Configuration\npublic class HttpsBeanDefinitionRegistryPostProcessor implements BeanDefinitionRegistryPostProcessor, EnvironmentAware {\n\n    private String profile;\n\n    @Override\n    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry beanDefinitionRegistry) throws BeansException {\n        if (&quot;dev&quot;.equals(profile)){\n            AnnotatedBeanDefinition annotatedBeanDefinition = new AnnotatedGenericBeanDefinition(HttpsTomcatEmbeddedServletContainerFactory.class);\n            BeanDefinitionHolder beanDefinitionHolder = new BeanDefinitionHolder(annotatedBeanDefinition, &quot;tomcatEmbeddedServletContainerFactory&quot;);\n            BeanDefinitionReaderUtils.registerBeanDefinition(beanDefinitionHolder, beanDefinitionRegistry);\n        }\n    }\n\n    @Override\n    public void postProcessBeanFactory(ConfigurableListableBeanFactory configurableListableBeanFactory) throws BeansException {}\n\n\n    @Override\n    public void setEnvironment(Environment environment) {\n        profile = environment.getProperty(&quot;profile&quot;);\n    }\n}\n</code></pre>\n<h5 id=\"注意上面的注入对象是HttpsTomcatEmbeddedServletContainerFactory，不是之前的TomcatEmbeddedServletContainerFactory，贴上HttpsTomcatEmbeddedServletContainerFactory代码：\"><a href=\"#注意上面的注入对象是HttpsTomcatEmbeddedServletContainerFactory，不是之前的TomcatEmbeddedServletContainerFactory，贴上HttpsTomcatEmbeddedServletContainerFactory代码：\" class=\"headerlink\" title=\"注意上面的注入对象是HttpsTomcatEmbeddedServletContainerFactory，不是之前的TomcatEmbeddedServletContainerFactory，贴上HttpsTomcatEmbeddedServletContainerFactory代码：\"></a>注意上面的注入对象是<code>HttpsTomcatEmbeddedServletContainerFactory</code>，不是之前的<code>TomcatEmbeddedServletContainerFactory</code>，贴上<code>HttpsTomcatEmbeddedServletContainerFactory</code>代码：</h5><pre><code class=\"lang-java\">import org.apache.catalina.connector.Connector;\nimport org.apache.coyote.http11.Http11NioProtocol;\nimport org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedServletContainerFactory;\n\n/**\n * @author winx\n * @create 2017-09-01.\n */\npublic class HttpsTomcatEmbeddedServletContainerFactory extends TomcatEmbeddedServletContainerFactory {\n\n    public HttpsTomcatEmbeddedServletContainerFactory() {\n        super();\n        Connector connector = new Connector(&quot;org.apache.coyote.http11.Http11NioProtocol&quot;);\n        Http11NioProtocol protocol = (Http11NioProtocol) connector.getProtocolHandler();\n        connector.setScheme(&quot;https&quot;);\n        connector.setSecure(true);\n        connector.setPort(8443);\n        protocol.setSSLEnabled(true);\n        protocol.setKeystoreFile(&quot;/Users/winx/.keystore&quot;);\n        protocol.setKeystorePass(&quot;123456&quot;);\n        protocol.setTruststoreFile(&quot;/Users/winx/.keystore&quot;);\n        protocol.setTruststorePass(&quot;123456&quot;);\n        protocol.setKeyAlias(&quot;tomcat&quot;);\n        addAdditionalTomcatConnectors(connector);\n    }\n}\n</code></pre>\n<h5 id=\"成功的解决了之前属性设置问题。\"><a href=\"#成功的解决了之前属性设置问题。\" class=\"headerlink\" title=\"成功的解决了之前属性设置问题。\"></a>成功的解决了之前属性设置问题。</h5>","site":{"data":{}},"excerpt":"<h5 id=\"通常情况下，我们通过XML或者Annotation两种方式配置Bean-Definition。从Spring-3-0开始，增加了一种新的途径来配置Bean-Definition，这就是通过Java-Code配置Bean-Definition。\"><a href=\"#通常情况下，我们通过XML或者Annotation两种方式配置Bean-Definition。从Spring-3-0开始，增加了一种新的途径来配置Bean-Definition，这就是通过Java-Code配置Bean-Definition。\" class=\"headerlink\" title=\"通常情况下，我们通过XML或者Annotation两种方式配置Bean Definition。从Spring 3.0开始，增加了一种新的途径来配置Bean Definition，这就是通过Java Code配置Bean Definition。\"></a>通常情况下，我们通过XML或者Annotation两种方式配置Bean Definition。从Spring 3.0开始，增加了一种新的途径来配置Bean Definition，这就是通过Java Code配置Bean Definition。</h5>","more":"<h4 id=\"Java-Code配置与XML和Annotation两种配置方式不同点在于：\"><a href=\"#Java-Code配置与XML和Annotation两种配置方式不同点在于：\" class=\"headerlink\" title=\"Java Code配置与XML和Annotation两种配置方式不同点在于：\"></a>Java Code配置与XML和Annotation两种配置方式不同点在于：</h4><h5 id=\"前两种方式XML和Annotation的配置方式为预定义方式，即开发人员通过XML文件或者Annotation预定义配置Bean的各种属性后，启动Spring容器，Spring容器会首先解析这些配置属性，生成对应的Bean-Definition-装入到DefaultListtableBeanFactory对象的属性容器中，以此同时，Spring框架也会定义内部使用的Bean定义，如Bean名为：org-springframework-context-annotation-internalConfigurationAnnotationProcessor的-ConfigurationClassPostProcessor-定义。而后此刻不会做任何Bean-Definition的解析动作，Spring框架会根据前两种配置，过滤出BeanDefinitionRegistryPostProcessor-类型的Bean定义，并通过Spring框架生成对应的Bean对象（如-ConfigurationClassPostProcessor-实例）。结合-Spring-上下文源码可知这个对象是一个-processor-类型工具类，Spring容器会在实例化开发人员所定义的-Bean-前先调用该-processor-的-postProcessBeanDefinitionRegistry-…-方法。此处实现基于-Java-Code-配置Bean-Definition的处理。\"><a href=\"#前两种方式XML和Annotation的配置方式为预定义方式，即开发人员通过XML文件或者Annotation预定义配置Bean的各种属性后，启动Spring容器，Spring容器会首先解析这些配置属性，生成对应的Bean-Definition-装入到DefaultListtableBeanFactory对象的属性容器中，以此同时，Spring框架也会定义内部使用的Bean定义，如Bean名为：org-springframework-context-annotation-internalConfigurationAnnotationProcessor的-ConfigurationClassPostProcessor-定义。而后此刻不会做任何Bean-Definition的解析动作，Spring框架会根据前两种配置，过滤出BeanDefinitionRegistryPostProcessor-类型的Bean定义，并通过Spring框架生成对应的Bean对象（如-ConfigurationClassPostProcessor-实例）。结合-Spring-上下文源码可知这个对象是一个-processor-类型工具类，Spring容器会在实例化开发人员所定义的-Bean-前先调用该-processor-的-postProcessBeanDefinitionRegistry-…-方法。此处实现基于-Java-Code-配置Bean-Definition的处理。\" class=\"headerlink\" title=\"前两种方式XML和Annotation的配置方式为预定义方式，即开发人员通过XML文件或者Annotation预定义配置Bean的各种属性后，启动Spring容器，Spring容器会首先解析这些配置属性，生成对应的Bean Definition,装入到DefaultListtableBeanFactory对象的属性容器中，以此同时，Spring框架也会定义内部使用的Bean定义，如Bean名为：org.springframework.context.annotation.internalConfigurationAnnotationProcessor的 ConfigurationClassPostProcessor 定义。而后此刻不会做任何Bean Definition的解析动作，Spring框架会根据前两种配置，过滤出BeanDefinitionRegistryPostProcessor 类型的Bean定义，并通过Spring框架生成对应的Bean对象（如 ConfigurationClassPostProcessor 实例）。结合 Spring 上下文源码可知这个对象是一个 processor 类型工具类，Spring容器会在实例化开发人员所定义的 Bean 前先调用该 processor 的 postProcessBeanDefinitionRegistry(…) 方法。此处实现基于 Java Code 配置Bean Definition的处理。\"></a>前两种方式XML和Annotation的配置方式为预定义方式，即开发人员通过XML文件或者Annotation预定义配置Bean的各种属性后，启动Spring容器，Spring容器会首先解析这些配置属性，生成对应的Bean Definition,装入到<code>DefaultListtableBeanFactory</code>对象的属性容器中，以此同时，Spring框架也会定义内部使用的Bean定义，如Bean名为：<code>org.springframework.context.annotation.internalConfigurationAnnotationProcessor</code>的 <code>ConfigurationClassPostProcessor</code> 定义。而后此刻不会做任何Bean Definition的解析动作，Spring框架会根据前两种配置，过滤出<code>BeanDefinitionRegistryPostProcessor</code> 类型的Bean定义，并通过Spring框架生成对应的Bean对象（如 <code>ConfigurationClassPostProcessor</code> 实例）。结合 Spring 上下文源码可知这个对象是一个 processor 类型工具类，<u>Spring容器会在实例化开发人员所定义的 Bean 前先调用该 processor 的 postProcessBeanDefinitionRegistry(…) 方法。此处实现基于 Java Code 配置Bean Definition的处理</u>。</h5><h5 id=\"基于-Java-Code-的配置方式，其执行原理不同于前两种。它是在-Spring-框架已经解析了基于-XML-和-Annotation-配置后，通过加入-BeanDefinitionRegistryPostProcessor-类型的-processor-来处理配置信息，让开发人员通过-Java-编程方式定义一个-Java-对象。其优点在于可以将配置信息集中在一定数量的-Java-对象中，同时通过-Java-编程方式，比基于-Annotation-方式具有更高的灵活性。并且该配置方式给开发人员提供了一种非常好的范例来增加用户自定义的解析工具类。其主要缺点在于与-Java-代码结合紧密，配置信息的改变需要重新编译-Java-代码，另外这是一种新引入的解析方式，需要一定的学习成本。\"><a href=\"#基于-Java-Code-的配置方式，其执行原理不同于前两种。它是在-Spring-框架已经解析了基于-XML-和-Annotation-配置后，通过加入-BeanDefinitionRegistryPostProcessor-类型的-processor-来处理配置信息，让开发人员通过-Java-编程方式定义一个-Java-对象。其优点在于可以将配置信息集中在一定数量的-Java-对象中，同时通过-Java-编程方式，比基于-Annotation-方式具有更高的灵活性。并且该配置方式给开发人员提供了一种非常好的范例来增加用户自定义的解析工具类。其主要缺点在于与-Java-代码结合紧密，配置信息的改变需要重新编译-Java-代码，另外这是一种新引入的解析方式，需要一定的学习成本。\" class=\"headerlink\" title=\"基于 Java Code 的配置方式，其执行原理不同于前两种。它是在 Spring 框架已经解析了基于 XML 和 Annotation 配置后，通过加入 BeanDefinitionRegistryPostProcessor 类型的 processor 来处理配置信息，让开发人员通过 Java 编程方式定义一个 Java 对象。其优点在于可以将配置信息集中在一定数量的 Java 对象中，同时通过 Java 编程方式，比基于 Annotation 方式具有更高的灵活性。并且该配置方式给开发人员提供了一种非常好的范例来增加用户自定义的解析工具类。其主要缺点在于与 Java 代码结合紧密，配置信息的改变需要重新编译 Java 代码，另外这是一种新引入的解析方式，需要一定的学习成本。\"></a>基于 Java Code 的配置方式，其执行原理不同于前两种。它是在 Spring 框架已经解析了基于 XML 和 Annotation 配置后，通过加入 BeanDefinitionRegistryPostProcessor 类型的 processor 来处理配置信息，让开发人员通过 Java 编程方式定义一个 Java 对象。其优点在于可以将配置信息集中在一定数量的 Java 对象中，同时通过 Java 编程方式，比基于 Annotation 方式具有更高的灵活性。并且该配置方式给开发人员提供了一种非常好的范例来增加用户自定义的解析工具类。其主要缺点在于与 Java 代码结合紧密，配置信息的改变需要重新编译 Java 代码，另外这是一种新引入的解析方式，需要一定的学习成本。</h5><p><br></p>\n<h4 id=\"提及一点的就是，Spring框架有3个主要的Hook类，分别是：\"><a href=\"#提及一点的就是，Spring框架有3个主要的Hook类，分别是：\" class=\"headerlink\" title=\"提及一点的就是，Spring框架有3个主要的Hook类，分别是：\"></a>提及一点的就是，Spring框架有3个主要的Hook类，分别是：</h4><p><code>org.springframework.context.ApplicationContextAware</code></p>\n<h5 id=\"它的setApplicationContext-方法将在Spring启动之前第一个被调用。\"><a href=\"#它的setApplicationContext-方法将在Spring启动之前第一个被调用。\" class=\"headerlink\" title=\"它的setApplicationContext 方法将在Spring启动之前第一个被调用。\"></a>它的setApplicationContext 方法将在Spring启动之前第一个被调用。</h5><p><code>org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor</code></p>\n<h5 id=\"它的postProcessBeanDefinitionRegistry-和-postProcessBeanFactory-方法是第二和第三被调用，它们在Bean初始化创建之前启动，如果Spring的bean需要的其他第三方中的组件，我们在这里将其注入给Spring。\"><a href=\"#它的postProcessBeanDefinitionRegistry-和-postProcessBeanFactory-方法是第二和第三被调用，它们在Bean初始化创建之前启动，如果Spring的bean需要的其他第三方中的组件，我们在这里将其注入给Spring。\" class=\"headerlink\" title=\"它的postProcessBeanDefinitionRegistry 和 postProcessBeanFactory 方法是第二和第三被调用，它们在Bean初始化创建之前启动，如果Spring的bean需要的其他第三方中的组件，我们在这里将其注入给Spring。\"></a>它的postProcessBeanDefinitionRegistry 和 postProcessBeanFactory 方法是第二和第三被调用，它们在Bean初始化创建之前启动，如果Spring的bean需要的其他第三方中的组件，我们在这里将其注入给Spring。</h5><p><code>org.springframework.context.ApplicationListener</code><br>用于在初始化完成后做一些事情，当Spring所有XML或元注解的Bean都启动被创建成功了，这时会调用它的唯一方法onApplicationEvent。<br><br></p>\n<h4 id=\"通过-BeanDefinitionRegistryPostProcessor-加载自己的bean的demo：\"><a href=\"#通过-BeanDefinitionRegistryPostProcessor-加载自己的bean的demo：\" class=\"headerlink\" title=\"通过 BeanDefinitionRegistryPostProcessor 加载自己的bean的demo：\"></a>通过 BeanDefinitionRegistryPostProcessor 加载自己的bean的demo：</h4><pre><code class=\"lang-java\">import org.springframework.beans.BeansException;\nimport org.springframework.beans.MutablePropertyValues;\nimport org.springframework.beans.factory.annotation.AnnotatedBeanDefinition;\nimport org.springframework.beans.factory.annotation.AnnotatedGenericBeanDefinition;\nimport org.springframework.beans.factory.config.BeanDefinition;\nimport org.springframework.beans.factory.config.BeanDefinitionHolder;\nimport org.springframework.beans.factory.config.ConfigurableListableBeanFactory;\nimport org.springframework.beans.factory.support.BeanDefinitionReaderUtils;\nimport org.springframework.beans.factory.support.BeanDefinitionRegistry;\nimport org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor;\n\n/**\n * @author winx\n * @create 2017-09-01.\n */\n@Configuration\npublic class MyBeanDefinitionRegistryPostProcessor implements BeanDefinitionRegistryPostProcessor {\n\n    /**\n     * 先执行：postProcessBeanDefinitionRegistry()方法\n     * 通过Class对象，注册自己的 BeanDefinition\n     */\n    @Override\n    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException {\n        try {\n            AnnotatedBeanDefinition annotatedBeanDefinition = new AnnotatedGenericBeanDefinition(Class.forName(&quot;&quot;));\n            BeanDefinitionHolder beanDefinitionHolder = new BeanDefinitionHolder(annotatedBeanDefinition, &quot;beanName&quot;);\n            BeanDefinitionReaderUtils.registerBeanDefinition(beanDefinitionHolder, registry);\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * 再执行：postProcessBeanFactory()方法。\n     * 通过 beanName 拿到注册后的 BeanDefinition\n     * 然后加入自定义属性，BeanDefinition 会在初始化bean时，将 Property 键值对插入到之前的Class对象属性中。\n     */\n    @Override\n    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {\n        BeanDefinition beanDefinition = beanFactory.getBeanDefinition(&quot;beanName&quot;);\n        MutablePropertyValues mutablePropertyValues = beanDefinition.getPropertyValues();\n        //加入属性.\n        mutablePropertyValues.addPropertyValue(&quot;username&quot;, &quot;root&quot;);\n    }\n}\n</code></pre>\n<h5 id=\"Configuration注解提示spring-boot通过该类加载bean\"><a href=\"#Configuration注解提示spring-boot通过该类加载bean\" class=\"headerlink\" title=\"@Configuration注解提示spring boot通过该类加载bean\"></a><code>@Configuration</code>注解提示spring boot通过该类加载bean</h5><h5 id=\"postProcessBeanDefinitionRegistry-通过Class对象，注册自己的-BeanDefinition\"><a href=\"#postProcessBeanDefinitionRegistry-通过Class对象，注册自己的-BeanDefinition\" class=\"headerlink\" title=\"postProcessBeanDefinitionRegistry() 通过Class对象，注册自己的 BeanDefinition\"></a><code>postProcessBeanDefinitionRegistry()</code> 通过Class对象，注册自己的 BeanDefinition</h5><h5 id=\"postProcessBeanFactory-方法会在postProcessBeanDefinitionRegistry-之后执行，-通过beanFactory拿到-BeanDefinition-后加入属性，这一步可以跳过。\"><a href=\"#postProcessBeanFactory-方法会在postProcessBeanDefinitionRegistry-之后执行，-通过beanFactory拿到-BeanDefinition-后加入属性，这一步可以跳过。\" class=\"headerlink\" title=\"postProcessBeanFactory()方法会在postProcessBeanDefinitionRegistry()之后执行， 通过beanFactory拿到 BeanDefinition 后加入属性，这一步可以跳过。\"></a><code>postProcessBeanFactory()</code>方法会在<code>postProcessBeanDefinitionRegistry()</code>之后执行， 通过beanFactory拿到 BeanDefinition 后加入属性，这一步可以跳过。</h5><h3 id=\"实际项目需求\"><a href=\"#实际项目需求\" class=\"headerlink\" title=\"实际项目需求\"></a>实际项目需求</h3><h5 id=\"目前项目分为线上环境和dev环境，项目本身只支持http服务，因为线上环境有nginx做反向代理，所以用http和https均能正常访问线上服务。但是本地环境相对简单，不能支持https服务。先在需要根据环境的不同。动态的扩张spring-boot的多连接器设置。当环境为dev时，即加载多连接器，分别用两个端口提供http和https服务。当环境不为dev时，只加载默认http即可。\"><a href=\"#目前项目分为线上环境和dev环境，项目本身只支持http服务，因为线上环境有nginx做反向代理，所以用http和https均能正常访问线上服务。但是本地环境相对简单，不能支持https服务。先在需要根据环境的不同。动态的扩张spring-boot的多连接器设置。当环境为dev时，即加载多连接器，分别用两个端口提供http和https服务。当环境不为dev时，只加载默认http即可。\" class=\"headerlink\" title=\"目前项目分为线上环境和dev环境，项目本身只支持http服务，因为线上环境有nginx做反向代理，所以用http和https均能正常访问线上服务。但是本地环境相对简单，不能支持https服务。先在需要根据环境的不同。动态的扩张spring boot的多连接器设置。当环境为dev时，即加载多连接器，分别用两个端口提供http和https服务。当环境不为dev时，只加载默认http即可。\"></a>目前项目分为线上环境和dev环境，项目本身只支持http服务，因为线上环境有nginx做反向代理，所以用http和https均能正常访问线上服务。但是本地环境相对简单，不能支持https服务。先在需要根据环境的不同。动态的扩张spring boot的多连接器设置。当环境为dev时，即加载多连接器，分别用两个端口提供http和https服务。当环境不为dev时，只加载默认http即可。</h5><h5 id=\"根据这些需求，通过xml或者annotation去定义bean都不太合适。只能是通过java-code去判断环境并动态加载。\"><a href=\"#根据这些需求，通过xml或者annotation去定义bean都不太合适。只能是通过java-code去判断环境并动态加载。\" class=\"headerlink\" title=\"根据这些需求，通过xml或者annotation去定义bean都不太合适。只能是通过java code去判断环境并动态加载。\"></a>根据这些需求，通过xml或者annotation去定义bean都不太合适。只能是通过java code去判断环境并动态加载。</h5><h5 id=\"省去spring-boot支持https以及多连接器的配置，相关的代码网络上很多。直接说遇到的主要问题吧。上面的demo通过mutablePropertyValues-addPropertyValue-quot-key-quot-quot-root-quot-的方式为目标class定义属性，但是要求属性key必须有相应的set方法。\"><a href=\"#省去spring-boot支持https以及多连接器的配置，相关的代码网络上很多。直接说遇到的主要问题吧。上面的demo通过mutablePropertyValues-addPropertyValue-quot-key-quot-quot-root-quot-的方式为目标class定义属性，但是要求属性key必须有相应的set方法。\" class=\"headerlink\" title=\"省去spring boot支持https以及多连接器的配置，相关的代码网络上很多。直接说遇到的主要问题吧。上面的demo通过mutablePropertyValues.addPropertyValue(&quot;key&quot;, &quot;root&quot;);的方式为目标class定义属性，但是要求属性key必须有相应的set方法。\"></a>省去spring boot支持https以及多连接器的配置，相关的代码网络上很多。直接说遇到的主要问题吧。上面的demo通过<code>mutablePropertyValues.addPropertyValue(&quot;key&quot;, &quot;root&quot;);</code>的方式为目标class定义属性，但是要求属性key必须有相应的set方法。</h5><pre><code class=\"lang-java\">@Configuration\npublic class HttpsBeanDefinitionRegistryPostProcessor implements BeanDefinitionRegistryPostProcessor, EnvironmentAware {\n\n    private String profile;\n\n    @Override\n    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry beanDefinitionRegistry) throws BeansException {\n        if (&quot;dev&quot;.equals(profile)){\n            AnnotatedBeanDefinition annotatedBeanDefinition = new AnnotatedGenericBeanDefinition(TomcatEmbeddedServletContainerFactory.class);\n            BeanDefinitionHolder beanDefinitionHolder = new BeanDefinitionHolder(annotatedBeanDefinition, &quot;tomcatEmbeddedServletContainerFactory&quot;);\n            BeanDefinitionReaderUtils.registerBeanDefinition(beanDefinitionHolder, beanDefinitionRegistry);\n        }\n    }\n\n    @Override\n    public void postProcessBeanFactory(ConfigurableListableBeanFactory configurableListableBeanFactory) throws BeansException {\n        MutablePropertyValues tomcatEmbeddedServletContainerFactory = configurableListableBeanFactory.getBeanDefinition(&quot;tomcatEmbeddedServletContainerFactory&quot;).getPropertyValues();\n        tomcatEmbeddedServletContainerFactory.addPropertyValue(&quot;additionalTomcatConnectors&quot;, getConnector());\n    }\n\n    public Connector getConnector(){\n        Connector connector = new Connector(&quot;org.apache.coyote.http11.Http11NioProtocol&quot;);\n        Http11NioProtocol protocol = (Http11NioProtocol) connector.getProtocolHandler();\n        connector.setScheme(&quot;https&quot;);\n        connector.setSecure(true);\n        connector.setPort(8443);\n        protocol.setSSLEnabled(true);\n        protocol.setKeystoreFile(&quot;/Users/winx/.keystore&quot;);\n        protocol.setKeystorePass(&quot;123456&quot;);\n        protocol.setTruststoreFile(&quot;/Users/winx/.keystore&quot;);\n        protocol.setTruststorePass(&quot;123456&quot;);\n        protocol.setKeyAlias(&quot;tomcat&quot;);\n        return connector;\n    }\n\n    @Override\n    public void setEnvironment(Environment environment) {\n        profile = environment.getProperty(&quot;profile&quot;);\n    }\n}\n</code></pre>\n<h5 id=\"在拿到MutablePropertyValues之后，想要给TomcatEmbeddedServletContainerFactory对象设置additionalTomcatConnectors属性，Connector中包含了https关键信息的设置。之后报错如下：\"><a href=\"#在拿到MutablePropertyValues之后，想要给TomcatEmbeddedServletContainerFactory对象设置additionalTomcatConnectors属性，Connector中包含了https关键信息的设置。之后报错如下：\" class=\"headerlink\" title=\"在拿到MutablePropertyValues之后，想要给TomcatEmbeddedServletContainerFactory对象设置additionalTomcatConnectors属性，Connector中包含了https关键信息的设置。之后报错如下：\"></a>在拿到<code>MutablePropertyValues</code>之后，想要给<code>TomcatEmbeddedServletContainerFactory</code>对象设置<code>additionalTomcatConnectors</code>属性，Connector中包含了https关键信息的设置。之后报错如下：</h5><pre><code>org.springframework.context.ApplicationContextException: Unable to start embedded container; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#39;tomcatEmbeddedServletContainerFactory&#39;: Error setting property values; nested exception is org.springframework.beans.NotWritablePropertyException: Invalid property &#39;additionalTomcatConnectors&#39; of bean class [org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedServletContainerFactory]: Bean property &#39;additionalTomcatConnectors&#39; is not writable or has an invalid setter method. Does the parameter type of the setter match the return type of the getter?\n    at org.springframework.boot.context.embedded.EmbeddedWebApplicationContext.onRefresh(EmbeddedWebApplicationContext.java:133) ~[spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n    at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:532) ~[spring-context-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n    at org.springframework.boot.context.embedded.EmbeddedWebApplicationContext.refresh(EmbeddedWebApplicationContext.java:118) ~[spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n    at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:760) [spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n    at org.springframework.boot.SpringApplication.createAndRefreshContext(SpringApplication.java:360) [spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n    at org.springframework.boot.SpringApplication.run(SpringApplication.java:306) [spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n    at org.springframework.boot.SpringApplication.run(SpringApplication.java:1185) [spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n    at org.springframework.boot.SpringApplication.run(SpringApplication.java:1174) [spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n    at com.winx.es.metis.RunMetis.main(RunMetis.java:47) [classes/:na]\nCaused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#39;tomcatEmbeddedServletContainerFactory&#39;: Error setting property values; nested exception is org.springframework.beans.NotWritablePropertyException: Invalid property &#39;additionalTomcatConnectors&#39; of bean class [org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedServletContainerFactory]: Bean property &#39;additionalTomcatConnectors&#39; is not writable or has an invalid setter method. Does the parameter type of the setter match the return type of the getter?\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyPropertyValues(AbstractAutowireCapableBeanFactory.java:1518) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1226) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:543) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:482) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n    at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:306) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n    at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n    at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:302) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n    at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n    at org.springframework.boot.context.embedded.EmbeddedWebApplicationContext.getEmbeddedServletContainerFactory(EmbeddedWebApplicationContext.java:195) ~[spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n    at org.springframework.boot.context.embedded.EmbeddedWebApplicationContext.createEmbeddedServletContainer(EmbeddedWebApplicationContext.java:158) ~[spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n    at org.springframework.boot.context.embedded.EmbeddedWebApplicationContext.onRefresh(EmbeddedWebApplicationContext.java:130) ~[spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n    ... 8 common frames omitted\nCaused by: org.springframework.beans.NotWritablePropertyException: Invalid property &#39;additionalTomcatConnectors&#39; of bean class [org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedServletContainerFactory]: Bean property &#39;additionalTomcatConnectors&#39; is not writable or has an invalid setter method. Does the parameter type of the setter match the return type of the getter?\n    at org.springframework.beans.BeanWrapperImpl.createNotWritablePropertyException(BeanWrapperImpl.java:230) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n    at org.springframework.beans.AbstractNestablePropertyAccessor.setPropertyValue(AbstractNestablePropertyAccessor.java:423) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n    at org.springframework.beans.AbstractNestablePropertyAccessor.setPropertyValue(AbstractNestablePropertyAccessor.java:280) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n    at org.springframework.beans.AbstractPropertyAccessor.setPropertyValues(AbstractPropertyAccessor.java:95) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n    at org.springframework.beans.AbstractPropertyAccessor.setPropertyValues(AbstractPropertyAccessor.java:75) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyPropertyValues(AbstractAutowireCapableBeanFactory.java:1514) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n    ... 18 common frames omitted\n</code></pre><h5 id=\"关键错误信息：Bean-property-39-additionalTomcatConnectors-39-is-not-writable-or-has-an-invalid-setter-method-Does-the-parameter-type-of-the-setter-match-the-return-type-of-the-getter-，没有权限写入以及没有找到相应的个体方法。\"><a href=\"#关键错误信息：Bean-property-39-additionalTomcatConnectors-39-is-not-writable-or-has-an-invalid-setter-method-Does-the-parameter-type-of-the-setter-match-the-return-type-of-the-getter-，没有权限写入以及没有找到相应的个体方法。\" class=\"headerlink\" title=\"关键错误信息：Bean property &#39;additionalTomcatConnectors&#39; is not writable or has an invalid setter method. Does the parameter type of the setter match the return type of the getter?，没有权限写入以及没有找到相应的个体方法。\"></a><strong>关键错误信息</strong>：<code>Bean property &#39;additionalTomcatConnectors&#39; is not writable or has an invalid setter method. Does the parameter type of the setter match the return type of the getter?</code>，没有权限写入以及没有找到相应的个体方法。</h5><h5 id=\"查看TomcatEmbeddedServletContainerFactory源码后发现其相应的设置方法如下：\"><a href=\"#查看TomcatEmbeddedServletContainerFactory源码后发现其相应的设置方法如下：\" class=\"headerlink\" title=\"查看TomcatEmbeddedServletContainerFactory源码后发现其相应的设置方法如下：\"></a>查看<code>TomcatEmbeddedServletContainerFactory</code>源码后发现其相应的设置方法如下：</h5><pre><code class=\"lang-java\">public void addAdditionalTomcatConnectors(Connector... connectors) {\n    Assert.notNull(connectors, &quot;Connectors must not be null&quot;);\n    this.additionalTomcatConnectors.addAll(Arrays.asList(connectors));\n}\n</code></pre>\n<h5 id=\"顿时觉得坑爹的add啊，之后在Bean-Definition的私有属性设置，以及通过方法设置属性值的方向去尝试解决问题，没有任何效果。几乎快要绝望的时候，突然灵机一动，为什么我不能自己定义一个不需要后置设置属性的TomcatEmbeddedServletContainerFactory呢，于是有了下面的代码：\"><a href=\"#顿时觉得坑爹的add啊，之后在Bean-Definition的私有属性设置，以及通过方法设置属性值的方向去尝试解决问题，没有任何效果。几乎快要绝望的时候，突然灵机一动，为什么我不能自己定义一个不需要后置设置属性的TomcatEmbeddedServletContainerFactory呢，于是有了下面的代码：\" class=\"headerlink\" title=\"顿时觉得坑爹的add啊，之后在Bean Definition的私有属性设置，以及通过方法设置属性值的方向去尝试解决问题，没有任何效果。几乎快要绝望的时候，突然灵机一动，为什么我不能自己定义一个不需要后置设置属性的TomcatEmbeddedServletContainerFactory呢，于是有了下面的代码：\"></a>顿时觉得坑爹的add啊，之后在Bean Definition的私有属性设置，以及通过方法设置属性值的方向去尝试解决问题，没有任何效果。几乎快要绝望的时候，突然灵机一动，为什么我不能自己定义一个不需要后置设置属性的<code>TomcatEmbeddedServletContainerFactory</code>呢，于是有了下面的代码：</h5><pre><code class=\"lang-java\">@Configuration\npublic class HttpsBeanDefinitionRegistryPostProcessor implements BeanDefinitionRegistryPostProcessor, EnvironmentAware {\n\n    private String profile;\n\n    @Override\n    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry beanDefinitionRegistry) throws BeansException {\n        if (&quot;dev&quot;.equals(profile)){\n            AnnotatedBeanDefinition annotatedBeanDefinition = new AnnotatedGenericBeanDefinition(HttpsTomcatEmbeddedServletContainerFactory.class);\n            BeanDefinitionHolder beanDefinitionHolder = new BeanDefinitionHolder(annotatedBeanDefinition, &quot;tomcatEmbeddedServletContainerFactory&quot;);\n            BeanDefinitionReaderUtils.registerBeanDefinition(beanDefinitionHolder, beanDefinitionRegistry);\n        }\n    }\n\n    @Override\n    public void postProcessBeanFactory(ConfigurableListableBeanFactory configurableListableBeanFactory) throws BeansException {}\n\n\n    @Override\n    public void setEnvironment(Environment environment) {\n        profile = environment.getProperty(&quot;profile&quot;);\n    }\n}\n</code></pre>\n<h5 id=\"注意上面的注入对象是HttpsTomcatEmbeddedServletContainerFactory，不是之前的TomcatEmbeddedServletContainerFactory，贴上HttpsTomcatEmbeddedServletContainerFactory代码：\"><a href=\"#注意上面的注入对象是HttpsTomcatEmbeddedServletContainerFactory，不是之前的TomcatEmbeddedServletContainerFactory，贴上HttpsTomcatEmbeddedServletContainerFactory代码：\" class=\"headerlink\" title=\"注意上面的注入对象是HttpsTomcatEmbeddedServletContainerFactory，不是之前的TomcatEmbeddedServletContainerFactory，贴上HttpsTomcatEmbeddedServletContainerFactory代码：\"></a>注意上面的注入对象是<code>HttpsTomcatEmbeddedServletContainerFactory</code>，不是之前的<code>TomcatEmbeddedServletContainerFactory</code>，贴上<code>HttpsTomcatEmbeddedServletContainerFactory</code>代码：</h5><pre><code class=\"lang-java\">import org.apache.catalina.connector.Connector;\nimport org.apache.coyote.http11.Http11NioProtocol;\nimport org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedServletContainerFactory;\n\n/**\n * @author winx\n * @create 2017-09-01.\n */\npublic class HttpsTomcatEmbeddedServletContainerFactory extends TomcatEmbeddedServletContainerFactory {\n\n    public HttpsTomcatEmbeddedServletContainerFactory() {\n        super();\n        Connector connector = new Connector(&quot;org.apache.coyote.http11.Http11NioProtocol&quot;);\n        Http11NioProtocol protocol = (Http11NioProtocol) connector.getProtocolHandler();\n        connector.setScheme(&quot;https&quot;);\n        connector.setSecure(true);\n        connector.setPort(8443);\n        protocol.setSSLEnabled(true);\n        protocol.setKeystoreFile(&quot;/Users/winx/.keystore&quot;);\n        protocol.setKeystorePass(&quot;123456&quot;);\n        protocol.setTruststoreFile(&quot;/Users/winx/.keystore&quot;);\n        protocol.setTruststorePass(&quot;123456&quot;);\n        protocol.setKeyAlias(&quot;tomcat&quot;);\n        addAdditionalTomcatConnectors(connector);\n    }\n}\n</code></pre>\n<h5 id=\"成功的解决了之前属性设置问题。\"><a href=\"#成功的解决了之前属性设置问题。\" class=\"headerlink\" title=\"成功的解决了之前属性设置问题。\"></a>成功的解决了之前属性设置问题。</h5>"},{"layout":"post","title":"大量订单的去重计算-BloomFilter","date":"2018-05-07T16:00:00.000Z","original":true,"tag":[["算法","arithmetic"]],"_content":"\n##### 如果需要对数据进行去重，我们最先想到一定是集合set，以及数据库的唯一索引。如果数据有持久化的需求，数据库的唯一索引是一个比较好的解决办法，因为这样你可以做分布式处理并且保证最终的一致性。如果数据不需要持久存储，只需要在内存当中去处理重复数据，则我们通常会使用set集合做处理。但是如果数据量特别大呢？我们如何处理\n<!-- more -->\n\n##### 最近的遇到的需求场景如下。我们有大量的用户打车订单数据，需要将订单和企业地理位置做挂钩。按照企业位置的一定半径范围统计订单情况，那么离得比较近的公司在一定范围内的很多订单都是重复的，为了不对这部分订单做重复处理，并且订单信息也不做数据库存储。我们需要在每次任务计算的时候对订单做是否重复判断。\n##### 目前的订单数据量大约在千万级别（只计算很小部分城市），能够预测到的未来将有数10亿的订单量。如果按照订单id做去重，订单的id为long类型，占用8个字节64bit。则订单号在内存中的占用量大约为：\n1. 1000w数据量\n<pre><code class=\"hljs\"><h6>8byte * 10<sup>7</sup> = 1024 * 1024 * 76.29 = 76.29MB\n</h6></code></pre>\n2. 10亿数据量\n<pre><code class=\"hljs\"><h6>76.29MB * 100 = 7.45GB\n</h6></code></pre>\n\n##### 可以看到，在数10亿的情况下内存占用已经达到7.5GB左右，虽然该占用量不是不能接受，但还是有优化空间的。那就是布隆过滤器（BloomFilter）。\n\n## BitMap\n##### 在介绍布隆过滤器之前，首先介绍BitMap，因为布隆过滤器的思路和原理就是通过BitMap转换过来的。\n##### 对于一个整型数，比如int a=1 在java内存中占32bit位，这是为了方便计算机的运算。但是对于某些应用场景而言，这属于一种巨大的浪费。比如我们判断这个数是否存在，我们真的需要把这个数用int类型完整的保留下来吗？答案当然是不需要，我们只需要用一个bit位去记录，0-未出现，1-出现。因此我们可以用对应的32bit位对应存储十进制的0-31，而这就是Bit-map的基本思想。Bit-map算法利用这种思想处理大量数据的排序、查询以及去重。\n\n### Bit-map应用之快速去重\n\n##### 2.5亿个整数中找出不重复的整数的个数，内存空间不足以容纳这2.5亿个整数。 \n##### 首先，根据“内存空间不足以容纳这2.5亿个整数”我们可以快速的联想到Bit-map。下边关键的问题就是怎么设计我们的Bit-map来表示这2.5亿个数字的状态了。其实这个问题很简单，一个数字的状态只有两种，分别为不存在，存在。因此，我们只需要1bit就可以对一个数字的状态进行存储了，我们设定一个数字不存在为0，存在一次1。那我们大概需要存储空间几十兆左右。\n##### 接下来的任务就是遍历一次这2.5亿个数字，判断对应下标的bit位，如果为0则表示之前没有出现过，并且将该位设置为1。如果为1则表示之前已经出现过，为重复数据，则可以丢弃。\n#### 优点：\n* 占用内存少 \n* 运算效率高\n\n#### 缺点：\n* 对于非连续数据，有可能中间会有大量的bit位没有使用，导致部分空间浪费\n* 对于不是从0开始的数据，需要找到一种映射关系，将已有的数据表示为从0开始的数据。比如原始数据是从100000为起点的整数，如果使用bitmap，将导致前面的100000个bit位没有使用上。最简单的办法是我们可以将原始数据做减100000的映射表示。\n\n### Bit-map应用之快速排序\n##### 假设我们要对0-7内的5个元素(4,7,2,5,3)排序（这里假设这些元素没有重复）,我们就可以采用Bit-map的方法来达到排序的目的。要表示8个数，我们就只需要8个Bit（1Bytes），将这些空间的所有Bit位都置为0。\n<table><tr>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n</tr></table>\n\n##### 将元素(4,7,2,5,3)对应下标位设置为1:\n<table><tr>\n<td>0</td>\n<td>0</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>0</td>\n<td>1</td>\n</tr></table>\n\n##### 遍历一遍Bit区域，将该位是一的位的编号输出（2，3，4，5，7），这样就达到了排序的目的，时间复杂度O(n)。\n#### 优点：\n* 运算效率高，不需要进行比较和移位；\n* 占用内存少，比如N=10000000；只需占用内存为N/8=1250000Byte=1.25M。 \n\n#### 缺点：\n* 所有的数据不能重复。即不可对重复的数据进行排序和查找。\n\n### JAVA当中的BitMap\n##### 既然介绍到BitMap，则简单介绍下JAVA当中的实现-BitSet\n##### BitSet实现中，使用long类型数组来表示所有的bit位，数组当中的一个long字段可以表示64位：\n```java\n/**\n * The number of words in the logical size of this BitSet.\n */\nprivate long[] words;\n```\n\n##### 具体的BitSet使用和原理，可以参考以下文章：\n1. [Java Bitset类 | 菜鸟教程](http://www.runoob.com/java/java-bitset-class.html)\n2. [Java BitSet](https://blog.csdn.net/top_code/article/details/40583279)\n\n## BloomFilter","source":"_posts/note/arithmetic/bloomfilter.md","raw":"---\nlayout: post\ntitle: 大量订单的去重计算-BloomFilter\ndate: 2018/05/08\ntags: [tech, arithmetic, index]\noriginal: true\ntag: [[算法, arithmetic]]\n---\n\n##### 如果需要对数据进行去重，我们最先想到一定是集合set，以及数据库的唯一索引。如果数据有持久化的需求，数据库的唯一索引是一个比较好的解决办法，因为这样你可以做分布式处理并且保证最终的一致性。如果数据不需要持久存储，只需要在内存当中去处理重复数据，则我们通常会使用set集合做处理。但是如果数据量特别大呢？我们如何处理\n<!-- more -->\n\n##### 最近的遇到的需求场景如下。我们有大量的用户打车订单数据，需要将订单和企业地理位置做挂钩。按照企业位置的一定半径范围统计订单情况，那么离得比较近的公司在一定范围内的很多订单都是重复的，为了不对这部分订单做重复处理，并且订单信息也不做数据库存储。我们需要在每次任务计算的时候对订单做是否重复判断。\n##### 目前的订单数据量大约在千万级别（只计算很小部分城市），能够预测到的未来将有数10亿的订单量。如果按照订单id做去重，订单的id为long类型，占用8个字节64bit。则订单号在内存中的占用量大约为：\n1. 1000w数据量\n<pre><code class=\"hljs\"><h6>8byte * 10<sup>7</sup> = 1024 * 1024 * 76.29 = 76.29MB\n</h6></code></pre>\n2. 10亿数据量\n<pre><code class=\"hljs\"><h6>76.29MB * 100 = 7.45GB\n</h6></code></pre>\n\n##### 可以看到，在数10亿的情况下内存占用已经达到7.5GB左右，虽然该占用量不是不能接受，但还是有优化空间的。那就是布隆过滤器（BloomFilter）。\n\n## BitMap\n##### 在介绍布隆过滤器之前，首先介绍BitMap，因为布隆过滤器的思路和原理就是通过BitMap转换过来的。\n##### 对于一个整型数，比如int a=1 在java内存中占32bit位，这是为了方便计算机的运算。但是对于某些应用场景而言，这属于一种巨大的浪费。比如我们判断这个数是否存在，我们真的需要把这个数用int类型完整的保留下来吗？答案当然是不需要，我们只需要用一个bit位去记录，0-未出现，1-出现。因此我们可以用对应的32bit位对应存储十进制的0-31，而这就是Bit-map的基本思想。Bit-map算法利用这种思想处理大量数据的排序、查询以及去重。\n\n### Bit-map应用之快速去重\n\n##### 2.5亿个整数中找出不重复的整数的个数，内存空间不足以容纳这2.5亿个整数。 \n##### 首先，根据“内存空间不足以容纳这2.5亿个整数”我们可以快速的联想到Bit-map。下边关键的问题就是怎么设计我们的Bit-map来表示这2.5亿个数字的状态了。其实这个问题很简单，一个数字的状态只有两种，分别为不存在，存在。因此，我们只需要1bit就可以对一个数字的状态进行存储了，我们设定一个数字不存在为0，存在一次1。那我们大概需要存储空间几十兆左右。\n##### 接下来的任务就是遍历一次这2.5亿个数字，判断对应下标的bit位，如果为0则表示之前没有出现过，并且将该位设置为1。如果为1则表示之前已经出现过，为重复数据，则可以丢弃。\n#### 优点：\n* 占用内存少 \n* 运算效率高\n\n#### 缺点：\n* 对于非连续数据，有可能中间会有大量的bit位没有使用，导致部分空间浪费\n* 对于不是从0开始的数据，需要找到一种映射关系，将已有的数据表示为从0开始的数据。比如原始数据是从100000为起点的整数，如果使用bitmap，将导致前面的100000个bit位没有使用上。最简单的办法是我们可以将原始数据做减100000的映射表示。\n\n### Bit-map应用之快速排序\n##### 假设我们要对0-7内的5个元素(4,7,2,5,3)排序（这里假设这些元素没有重复）,我们就可以采用Bit-map的方法来达到排序的目的。要表示8个数，我们就只需要8个Bit（1Bytes），将这些空间的所有Bit位都置为0。\n<table><tr>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n</tr></table>\n\n##### 将元素(4,7,2,5,3)对应下标位设置为1:\n<table><tr>\n<td>0</td>\n<td>0</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>0</td>\n<td>1</td>\n</tr></table>\n\n##### 遍历一遍Bit区域，将该位是一的位的编号输出（2，3，4，5，7），这样就达到了排序的目的，时间复杂度O(n)。\n#### 优点：\n* 运算效率高，不需要进行比较和移位；\n* 占用内存少，比如N=10000000；只需占用内存为N/8=1250000Byte=1.25M。 \n\n#### 缺点：\n* 所有的数据不能重复。即不可对重复的数据进行排序和查找。\n\n### JAVA当中的BitMap\n##### 既然介绍到BitMap，则简单介绍下JAVA当中的实现-BitSet\n##### BitSet实现中，使用long类型数组来表示所有的bit位，数组当中的一个long字段可以表示64位：\n```java\n/**\n * The number of words in the logical size of this BitSet.\n */\nprivate long[] words;\n```\n\n##### 具体的BitSet使用和原理，可以参考以下文章：\n1. [Java Bitset类 | 菜鸟教程](http://www.runoob.com/java/java-bitset-class.html)\n2. [Java BitSet](https://blog.csdn.net/top_code/article/details/40583279)\n\n## BloomFilter","slug":"note/arithmetic/bloomfilter","published":1,"updated":"2018-05-08T15:44:33.656Z","_id":"cjgxoy0q4006bjah16svk90jn","comments":1,"photos":[],"link":"","content":"<h5 id=\"如果需要对数据进行去重，我们最先想到一定是集合set，以及数据库的唯一索引。如果数据有持久化的需求，数据库的唯一索引是一个比较好的解决办法，因为这样你可以做分布式处理并且保证最终的一致性。如果数据不需要持久存储，只需要在内存当中去处理重复数据，则我们通常会使用set集合做处理。但是如果数据量特别大呢？我们如何处理\"><a href=\"#如果需要对数据进行去重，我们最先想到一定是集合set，以及数据库的唯一索引。如果数据有持久化的需求，数据库的唯一索引是一个比较好的解决办法，因为这样你可以做分布式处理并且保证最终的一致性。如果数据不需要持久存储，只需要在内存当中去处理重复数据，则我们通常会使用set集合做处理。但是如果数据量特别大呢？我们如何处理\" class=\"headerlink\" title=\"如果需要对数据进行去重，我们最先想到一定是集合set，以及数据库的唯一索引。如果数据有持久化的需求，数据库的唯一索引是一个比较好的解决办法，因为这样你可以做分布式处理并且保证最终的一致性。如果数据不需要持久存储，只需要在内存当中去处理重复数据，则我们通常会使用set集合做处理。但是如果数据量特别大呢？我们如何处理\"></a>如果需要对数据进行去重，我们最先想到一定是集合set，以及数据库的唯一索引。如果数据有持久化的需求，数据库的唯一索引是一个比较好的解决办法，因为这样你可以做分布式处理并且保证最终的一致性。如果数据不需要持久存储，只需要在内存当中去处理重复数据，则我们通常会使用set集合做处理。但是如果数据量特别大呢？我们如何处理</h5><a id=\"more\"></a>\n<h5 id=\"最近的遇到的需求场景如下。我们有大量的用户打车订单数据，需要将订单和企业地理位置做挂钩。按照企业位置的一定半径范围统计订单情况，那么离得比较近的公司在一定范围内的很多订单都是重复的，为了不对这部分订单做重复处理，并且订单信息也不做数据库存储。我们需要在每次任务计算的时候对订单做是否重复判断。\"><a href=\"#最近的遇到的需求场景如下。我们有大量的用户打车订单数据，需要将订单和企业地理位置做挂钩。按照企业位置的一定半径范围统计订单情况，那么离得比较近的公司在一定范围内的很多订单都是重复的，为了不对这部分订单做重复处理，并且订单信息也不做数据库存储。我们需要在每次任务计算的时候对订单做是否重复判断。\" class=\"headerlink\" title=\"最近的遇到的需求场景如下。我们有大量的用户打车订单数据，需要将订单和企业地理位置做挂钩。按照企业位置的一定半径范围统计订单情况，那么离得比较近的公司在一定范围内的很多订单都是重复的，为了不对这部分订单做重复处理，并且订单信息也不做数据库存储。我们需要在每次任务计算的时候对订单做是否重复判断。\"></a>最近的遇到的需求场景如下。我们有大量的用户打车订单数据，需要将订单和企业地理位置做挂钩。按照企业位置的一定半径范围统计订单情况，那么离得比较近的公司在一定范围内的很多订单都是重复的，为了不对这部分订单做重复处理，并且订单信息也不做数据库存储。我们需要在每次任务计算的时候对订单做是否重复判断。</h5><h5 id=\"目前的订单数据量大约在千万级别（只计算很小部分城市），能够预测到的未来将有数10亿的订单量。如果按照订单id做去重，订单的id为long类型，占用8个字节64bit。则订单号在内存中的占用量大约为：\"><a href=\"#目前的订单数据量大约在千万级别（只计算很小部分城市），能够预测到的未来将有数10亿的订单量。如果按照订单id做去重，订单的id为long类型，占用8个字节64bit。则订单号在内存中的占用量大约为：\" class=\"headerlink\" title=\"目前的订单数据量大约在千万级别（只计算很小部分城市），能够预测到的未来将有数10亿的订单量。如果按照订单id做去重，订单的id为long类型，占用8个字节64bit。则订单号在内存中的占用量大约为：\"></a>目前的订单数据量大约在千万级别（只计算很小部分城市），能够预测到的未来将有数10亿的订单量。如果按照订单id做去重，订单的id为long类型，占用8个字节64bit。则订单号在内存中的占用量大约为：</h5><ol>\n<li>1000w数据量<pre><code class=\"hljs\"><h6>8byte * 10<sup>7</sup> = 1024 * 1024 * 76.29 = 76.29MB\n</h6></code></pre></li>\n<li>10亿数据量<pre><code class=\"hljs\"><h6>76.29MB * 100 = 7.45GB\n</h6></code></pre>\n\n</li>\n</ol>\n<h5 id=\"可以看到，在数10亿的情况下内存占用已经达到7-5GB左右，虽然该占用量不是不能接受，但还是有优化空间的。那就是布隆过滤器（BloomFilter）。\"><a href=\"#可以看到，在数10亿的情况下内存占用已经达到7-5GB左右，虽然该占用量不是不能接受，但还是有优化空间的。那就是布隆过滤器（BloomFilter）。\" class=\"headerlink\" title=\"可以看到，在数10亿的情况下内存占用已经达到7.5GB左右，虽然该占用量不是不能接受，但还是有优化空间的。那就是布隆过滤器（BloomFilter）。\"></a>可以看到，在数10亿的情况下内存占用已经达到7.5GB左右，虽然该占用量不是不能接受，但还是有优化空间的。那就是布隆过滤器（BloomFilter）。</h5><h2 id=\"BitMap\"><a href=\"#BitMap\" class=\"headerlink\" title=\"BitMap\"></a>BitMap</h2><h5 id=\"在介绍布隆过滤器之前，首先介绍BitMap，因为布隆过滤器的思路和原理就是通过BitMap转换过来的。\"><a href=\"#在介绍布隆过滤器之前，首先介绍BitMap，因为布隆过滤器的思路和原理就是通过BitMap转换过来的。\" class=\"headerlink\" title=\"在介绍布隆过滤器之前，首先介绍BitMap，因为布隆过滤器的思路和原理就是通过BitMap转换过来的。\"></a>在介绍布隆过滤器之前，首先介绍BitMap，因为布隆过滤器的思路和原理就是通过BitMap转换过来的。</h5><h5 id=\"对于一个整型数，比如int-a-1-在java内存中占32bit位，这是为了方便计算机的运算。但是对于某些应用场景而言，这属于一种巨大的浪费。比如我们判断这个数是否存在，我们真的需要把这个数用int类型完整的保留下来吗？答案当然是不需要，我们只需要用一个bit位去记录，0-未出现，1-出现。因此我们可以用对应的32bit位对应存储十进制的0-31，而这就是Bit-map的基本思想。Bit-map算法利用这种思想处理大量数据的排序、查询以及去重。\"><a href=\"#对于一个整型数，比如int-a-1-在java内存中占32bit位，这是为了方便计算机的运算。但是对于某些应用场景而言，这属于一种巨大的浪费。比如我们判断这个数是否存在，我们真的需要把这个数用int类型完整的保留下来吗？答案当然是不需要，我们只需要用一个bit位去记录，0-未出现，1-出现。因此我们可以用对应的32bit位对应存储十进制的0-31，而这就是Bit-map的基本思想。Bit-map算法利用这种思想处理大量数据的排序、查询以及去重。\" class=\"headerlink\" title=\"对于一个整型数，比如int a=1 在java内存中占32bit位，这是为了方便计算机的运算。但是对于某些应用场景而言，这属于一种巨大的浪费。比如我们判断这个数是否存在，我们真的需要把这个数用int类型完整的保留下来吗？答案当然是不需要，我们只需要用一个bit位去记录，0-未出现，1-出现。因此我们可以用对应的32bit位对应存储十进制的0-31，而这就是Bit-map的基本思想。Bit-map算法利用这种思想处理大量数据的排序、查询以及去重。\"></a>对于一个整型数，比如int a=1 在java内存中占32bit位，这是为了方便计算机的运算。但是对于某些应用场景而言，这属于一种巨大的浪费。比如我们判断这个数是否存在，我们真的需要把这个数用int类型完整的保留下来吗？答案当然是不需要，我们只需要用一个bit位去记录，0-未出现，1-出现。因此我们可以用对应的32bit位对应存储十进制的0-31，而这就是Bit-map的基本思想。Bit-map算法利用这种思想处理大量数据的排序、查询以及去重。</h5><h3 id=\"Bit-map应用之快速去重\"><a href=\"#Bit-map应用之快速去重\" class=\"headerlink\" title=\"Bit-map应用之快速去重\"></a>Bit-map应用之快速去重</h3><h5 id=\"2-5亿个整数中找出不重复的整数的个数，内存空间不足以容纳这2-5亿个整数。\"><a href=\"#2-5亿个整数中找出不重复的整数的个数，内存空间不足以容纳这2-5亿个整数。\" class=\"headerlink\" title=\"2.5亿个整数中找出不重复的整数的个数，内存空间不足以容纳这2.5亿个整数。\"></a>2.5亿个整数中找出不重复的整数的个数，内存空间不足以容纳这2.5亿个整数。</h5><h5 id=\"首先，根据“内存空间不足以容纳这2-5亿个整数”我们可以快速的联想到Bit-map。下边关键的问题就是怎么设计我们的Bit-map来表示这2-5亿个数字的状态了。其实这个问题很简单，一个数字的状态只有两种，分别为不存在，存在。因此，我们只需要1bit就可以对一个数字的状态进行存储了，我们设定一个数字不存在为0，存在一次1。那我们大概需要存储空间几十兆左右。\"><a href=\"#首先，根据“内存空间不足以容纳这2-5亿个整数”我们可以快速的联想到Bit-map。下边关键的问题就是怎么设计我们的Bit-map来表示这2-5亿个数字的状态了。其实这个问题很简单，一个数字的状态只有两种，分别为不存在，存在。因此，我们只需要1bit就可以对一个数字的状态进行存储了，我们设定一个数字不存在为0，存在一次1。那我们大概需要存储空间几十兆左右。\" class=\"headerlink\" title=\"首先，根据“内存空间不足以容纳这2.5亿个整数”我们可以快速的联想到Bit-map。下边关键的问题就是怎么设计我们的Bit-map来表示这2.5亿个数字的状态了。其实这个问题很简单，一个数字的状态只有两种，分别为不存在，存在。因此，我们只需要1bit就可以对一个数字的状态进行存储了，我们设定一个数字不存在为0，存在一次1。那我们大概需要存储空间几十兆左右。\"></a>首先，根据“内存空间不足以容纳这2.5亿个整数”我们可以快速的联想到Bit-map。下边关键的问题就是怎么设计我们的Bit-map来表示这2.5亿个数字的状态了。其实这个问题很简单，一个数字的状态只有两种，分别为不存在，存在。因此，我们只需要1bit就可以对一个数字的状态进行存储了，我们设定一个数字不存在为0，存在一次1。那我们大概需要存储空间几十兆左右。</h5><h5 id=\"接下来的任务就是遍历一次这2-5亿个数字，判断对应下标的bit位，如果为0则表示之前没有出现过，并且将该位设置为1。如果为1则表示之前已经出现过，为重复数据，则可以丢弃。\"><a href=\"#接下来的任务就是遍历一次这2-5亿个数字，判断对应下标的bit位，如果为0则表示之前没有出现过，并且将该位设置为1。如果为1则表示之前已经出现过，为重复数据，则可以丢弃。\" class=\"headerlink\" title=\"接下来的任务就是遍历一次这2.5亿个数字，判断对应下标的bit位，如果为0则表示之前没有出现过，并且将该位设置为1。如果为1则表示之前已经出现过，为重复数据，则可以丢弃。\"></a>接下来的任务就是遍历一次这2.5亿个数字，判断对应下标的bit位，如果为0则表示之前没有出现过，并且将该位设置为1。如果为1则表示之前已经出现过，为重复数据，则可以丢弃。</h5><h4 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h4><ul>\n<li>占用内存少 </li>\n<li>运算效率高</li>\n</ul>\n<h4 id=\"缺点：\"><a href=\"#缺点：\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h4><ul>\n<li>对于非连续数据，有可能中间会有大量的bit位没有使用，导致部分空间浪费</li>\n<li>对于不是从0开始的数据，需要找到一种映射关系，将已有的数据表示为从0开始的数据。比如原始数据是从100000为起点的整数，如果使用bitmap，将导致前面的100000个bit位没有使用上。最简单的办法是我们可以将原始数据做减100000的映射表示。</li>\n</ul>\n<h3 id=\"Bit-map应用之快速排序\"><a href=\"#Bit-map应用之快速排序\" class=\"headerlink\" title=\"Bit-map应用之快速排序\"></a>Bit-map应用之快速排序</h3><h5 id=\"假设我们要对0-7内的5个元素-4-7-2-5-3-排序（这里假设这些元素没有重复）-我们就可以采用Bit-map的方法来达到排序的目的。要表示8个数，我们就只需要8个Bit（1Bytes），将这些空间的所有Bit位都置为0。\"><a href=\"#假设我们要对0-7内的5个元素-4-7-2-5-3-排序（这里假设这些元素没有重复）-我们就可以采用Bit-map的方法来达到排序的目的。要表示8个数，我们就只需要8个Bit（1Bytes），将这些空间的所有Bit位都置为0。\" class=\"headerlink\" title=\"假设我们要对0-7内的5个元素(4,7,2,5,3)排序（这里假设这些元素没有重复）,我们就可以采用Bit-map的方法来达到排序的目的。要表示8个数，我们就只需要8个Bit（1Bytes），将这些空间的所有Bit位都置为0。\"></a>假设我们要对0-7内的5个元素(4,7,2,5,3)排序（这里假设这些元素没有重复）,我们就可以采用Bit-map的方法来达到排序的目的。要表示8个数，我们就只需要8个Bit（1Bytes），将这些空间的所有Bit位都置为0。</h5><table><tr>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n</tr></table>\n\n<h5 id=\"将元素-4-7-2-5-3-对应下标位设置为1\"><a href=\"#将元素-4-7-2-5-3-对应下标位设置为1\" class=\"headerlink\" title=\"将元素(4,7,2,5,3)对应下标位设置为1:\"></a>将元素(4,7,2,5,3)对应下标位设置为1:</h5><table><tr>\n<td>0</td>\n<td>0</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>0</td>\n<td>1</td>\n</tr></table>\n\n<h5 id=\"遍历一遍Bit区域，将该位是一的位的编号输出（2，3，4，5，7），这样就达到了排序的目的，时间复杂度O-n-。\"><a href=\"#遍历一遍Bit区域，将该位是一的位的编号输出（2，3，4，5，7），这样就达到了排序的目的，时间复杂度O-n-。\" class=\"headerlink\" title=\"遍历一遍Bit区域，将该位是一的位的编号输出（2，3，4，5，7），这样就达到了排序的目的，时间复杂度O(n)。\"></a>遍历一遍Bit区域，将该位是一的位的编号输出（2，3，4，5，7），这样就达到了排序的目的，时间复杂度O(n)。</h5><h4 id=\"优点：-1\"><a href=\"#优点：-1\" class=\"headerlink\" title=\"优点：\"></a>优点：</h4><ul>\n<li>运算效率高，不需要进行比较和移位；</li>\n<li>占用内存少，比如N=10000000；只需占用内存为N/8=1250000Byte=1.25M。 </li>\n</ul>\n<h4 id=\"缺点：-1\"><a href=\"#缺点：-1\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h4><ul>\n<li>所有的数据不能重复。即不可对重复的数据进行排序和查找。</li>\n</ul>\n<h3 id=\"JAVA当中的BitMap\"><a href=\"#JAVA当中的BitMap\" class=\"headerlink\" title=\"JAVA当中的BitMap\"></a>JAVA当中的BitMap</h3><h5 id=\"既然介绍到BitMap，则简单介绍下JAVA当中的实现-BitSet\"><a href=\"#既然介绍到BitMap，则简单介绍下JAVA当中的实现-BitSet\" class=\"headerlink\" title=\"既然介绍到BitMap，则简单介绍下JAVA当中的实现-BitSet\"></a>既然介绍到BitMap，则简单介绍下JAVA当中的实现-BitSet</h5><h5 id=\"BitSet实现中，使用long类型数组来表示所有的bit位，数组当中的一个long字段可以表示64位：\"><a href=\"#BitSet实现中，使用long类型数组来表示所有的bit位，数组当中的一个long字段可以表示64位：\" class=\"headerlink\" title=\"BitSet实现中，使用long类型数组来表示所有的bit位，数组当中的一个long字段可以表示64位：\"></a>BitSet实现中，使用long类型数组来表示所有的bit位，数组当中的一个long字段可以表示64位：</h5><pre><code class=\"lang-java\">/**\n * The number of words in the logical size of this BitSet.\n */\nprivate long[] words;\n</code></pre>\n<h5 id=\"具体的BitSet使用和原理，可以参考以下文章：\"><a href=\"#具体的BitSet使用和原理，可以参考以下文章：\" class=\"headerlink\" title=\"具体的BitSet使用和原理，可以参考以下文章：\"></a>具体的BitSet使用和原理，可以参考以下文章：</h5><ol>\n<li><a href=\"http://www.runoob.com/java/java-bitset-class.html\" target=\"_blank\" rel=\"external\">Java Bitset类 | 菜鸟教程</a></li>\n<li><a href=\"https://blog.csdn.net/top_code/article/details/40583279\" target=\"_blank\" rel=\"external\">Java BitSet</a></li>\n</ol>\n<h2 id=\"BloomFilter\"><a href=\"#BloomFilter\" class=\"headerlink\" title=\"BloomFilter\"></a>BloomFilter</h2>","site":{"data":{}},"excerpt":"<h5 id=\"如果需要对数据进行去重，我们最先想到一定是集合set，以及数据库的唯一索引。如果数据有持久化的需求，数据库的唯一索引是一个比较好的解决办法，因为这样你可以做分布式处理并且保证最终的一致性。如果数据不需要持久存储，只需要在内存当中去处理重复数据，则我们通常会使用set集合做处理。但是如果数据量特别大呢？我们如何处理\"><a href=\"#如果需要对数据进行去重，我们最先想到一定是集合set，以及数据库的唯一索引。如果数据有持久化的需求，数据库的唯一索引是一个比较好的解决办法，因为这样你可以做分布式处理并且保证最终的一致性。如果数据不需要持久存储，只需要在内存当中去处理重复数据，则我们通常会使用set集合做处理。但是如果数据量特别大呢？我们如何处理\" class=\"headerlink\" title=\"如果需要对数据进行去重，我们最先想到一定是集合set，以及数据库的唯一索引。如果数据有持久化的需求，数据库的唯一索引是一个比较好的解决办法，因为这样你可以做分布式处理并且保证最终的一致性。如果数据不需要持久存储，只需要在内存当中去处理重复数据，则我们通常会使用set集合做处理。但是如果数据量特别大呢？我们如何处理\"></a>如果需要对数据进行去重，我们最先想到一定是集合set，以及数据库的唯一索引。如果数据有持久化的需求，数据库的唯一索引是一个比较好的解决办法，因为这样你可以做分布式处理并且保证最终的一致性。如果数据不需要持久存储，只需要在内存当中去处理重复数据，则我们通常会使用set集合做处理。但是如果数据量特别大呢？我们如何处理</h5>","more":"<h5 id=\"最近的遇到的需求场景如下。我们有大量的用户打车订单数据，需要将订单和企业地理位置做挂钩。按照企业位置的一定半径范围统计订单情况，那么离得比较近的公司在一定范围内的很多订单都是重复的，为了不对这部分订单做重复处理，并且订单信息也不做数据库存储。我们需要在每次任务计算的时候对订单做是否重复判断。\"><a href=\"#最近的遇到的需求场景如下。我们有大量的用户打车订单数据，需要将订单和企业地理位置做挂钩。按照企业位置的一定半径范围统计订单情况，那么离得比较近的公司在一定范围内的很多订单都是重复的，为了不对这部分订单做重复处理，并且订单信息也不做数据库存储。我们需要在每次任务计算的时候对订单做是否重复判断。\" class=\"headerlink\" title=\"最近的遇到的需求场景如下。我们有大量的用户打车订单数据，需要将订单和企业地理位置做挂钩。按照企业位置的一定半径范围统计订单情况，那么离得比较近的公司在一定范围内的很多订单都是重复的，为了不对这部分订单做重复处理，并且订单信息也不做数据库存储。我们需要在每次任务计算的时候对订单做是否重复判断。\"></a>最近的遇到的需求场景如下。我们有大量的用户打车订单数据，需要将订单和企业地理位置做挂钩。按照企业位置的一定半径范围统计订单情况，那么离得比较近的公司在一定范围内的很多订单都是重复的，为了不对这部分订单做重复处理，并且订单信息也不做数据库存储。我们需要在每次任务计算的时候对订单做是否重复判断。</h5><h5 id=\"目前的订单数据量大约在千万级别（只计算很小部分城市），能够预测到的未来将有数10亿的订单量。如果按照订单id做去重，订单的id为long类型，占用8个字节64bit。则订单号在内存中的占用量大约为：\"><a href=\"#目前的订单数据量大约在千万级别（只计算很小部分城市），能够预测到的未来将有数10亿的订单量。如果按照订单id做去重，订单的id为long类型，占用8个字节64bit。则订单号在内存中的占用量大约为：\" class=\"headerlink\" title=\"目前的订单数据量大约在千万级别（只计算很小部分城市），能够预测到的未来将有数10亿的订单量。如果按照订单id做去重，订单的id为long类型，占用8个字节64bit。则订单号在内存中的占用量大约为：\"></a>目前的订单数据量大约在千万级别（只计算很小部分城市），能够预测到的未来将有数10亿的订单量。如果按照订单id做去重，订单的id为long类型，占用8个字节64bit。则订单号在内存中的占用量大约为：</h5><ol>\n<li>1000w数据量<pre><code class=\"hljs\"><h6>8byte * 10<sup>7</sup> = 1024 * 1024 * 76.29 = 76.29MB\n</h6></code></pre></li>\n<li>10亿数据量<pre><code class=\"hljs\"><h6>76.29MB * 100 = 7.45GB\n</h6></code></pre>\n\n</li>\n</ol>\n<h5 id=\"可以看到，在数10亿的情况下内存占用已经达到7-5GB左右，虽然该占用量不是不能接受，但还是有优化空间的。那就是布隆过滤器（BloomFilter）。\"><a href=\"#可以看到，在数10亿的情况下内存占用已经达到7-5GB左右，虽然该占用量不是不能接受，但还是有优化空间的。那就是布隆过滤器（BloomFilter）。\" class=\"headerlink\" title=\"可以看到，在数10亿的情况下内存占用已经达到7.5GB左右，虽然该占用量不是不能接受，但还是有优化空间的。那就是布隆过滤器（BloomFilter）。\"></a>可以看到，在数10亿的情况下内存占用已经达到7.5GB左右，虽然该占用量不是不能接受，但还是有优化空间的。那就是布隆过滤器（BloomFilter）。</h5><h2 id=\"BitMap\"><a href=\"#BitMap\" class=\"headerlink\" title=\"BitMap\"></a>BitMap</h2><h5 id=\"在介绍布隆过滤器之前，首先介绍BitMap，因为布隆过滤器的思路和原理就是通过BitMap转换过来的。\"><a href=\"#在介绍布隆过滤器之前，首先介绍BitMap，因为布隆过滤器的思路和原理就是通过BitMap转换过来的。\" class=\"headerlink\" title=\"在介绍布隆过滤器之前，首先介绍BitMap，因为布隆过滤器的思路和原理就是通过BitMap转换过来的。\"></a>在介绍布隆过滤器之前，首先介绍BitMap，因为布隆过滤器的思路和原理就是通过BitMap转换过来的。</h5><h5 id=\"对于一个整型数，比如int-a-1-在java内存中占32bit位，这是为了方便计算机的运算。但是对于某些应用场景而言，这属于一种巨大的浪费。比如我们判断这个数是否存在，我们真的需要把这个数用int类型完整的保留下来吗？答案当然是不需要，我们只需要用一个bit位去记录，0-未出现，1-出现。因此我们可以用对应的32bit位对应存储十进制的0-31，而这就是Bit-map的基本思想。Bit-map算法利用这种思想处理大量数据的排序、查询以及去重。\"><a href=\"#对于一个整型数，比如int-a-1-在java内存中占32bit位，这是为了方便计算机的运算。但是对于某些应用场景而言，这属于一种巨大的浪费。比如我们判断这个数是否存在，我们真的需要把这个数用int类型完整的保留下来吗？答案当然是不需要，我们只需要用一个bit位去记录，0-未出现，1-出现。因此我们可以用对应的32bit位对应存储十进制的0-31，而这就是Bit-map的基本思想。Bit-map算法利用这种思想处理大量数据的排序、查询以及去重。\" class=\"headerlink\" title=\"对于一个整型数，比如int a=1 在java内存中占32bit位，这是为了方便计算机的运算。但是对于某些应用场景而言，这属于一种巨大的浪费。比如我们判断这个数是否存在，我们真的需要把这个数用int类型完整的保留下来吗？答案当然是不需要，我们只需要用一个bit位去记录，0-未出现，1-出现。因此我们可以用对应的32bit位对应存储十进制的0-31，而这就是Bit-map的基本思想。Bit-map算法利用这种思想处理大量数据的排序、查询以及去重。\"></a>对于一个整型数，比如int a=1 在java内存中占32bit位，这是为了方便计算机的运算。但是对于某些应用场景而言，这属于一种巨大的浪费。比如我们判断这个数是否存在，我们真的需要把这个数用int类型完整的保留下来吗？答案当然是不需要，我们只需要用一个bit位去记录，0-未出现，1-出现。因此我们可以用对应的32bit位对应存储十进制的0-31，而这就是Bit-map的基本思想。Bit-map算法利用这种思想处理大量数据的排序、查询以及去重。</h5><h3 id=\"Bit-map应用之快速去重\"><a href=\"#Bit-map应用之快速去重\" class=\"headerlink\" title=\"Bit-map应用之快速去重\"></a>Bit-map应用之快速去重</h3><h5 id=\"2-5亿个整数中找出不重复的整数的个数，内存空间不足以容纳这2-5亿个整数。\"><a href=\"#2-5亿个整数中找出不重复的整数的个数，内存空间不足以容纳这2-5亿个整数。\" class=\"headerlink\" title=\"2.5亿个整数中找出不重复的整数的个数，内存空间不足以容纳这2.5亿个整数。\"></a>2.5亿个整数中找出不重复的整数的个数，内存空间不足以容纳这2.5亿个整数。</h5><h5 id=\"首先，根据“内存空间不足以容纳这2-5亿个整数”我们可以快速的联想到Bit-map。下边关键的问题就是怎么设计我们的Bit-map来表示这2-5亿个数字的状态了。其实这个问题很简单，一个数字的状态只有两种，分别为不存在，存在。因此，我们只需要1bit就可以对一个数字的状态进行存储了，我们设定一个数字不存在为0，存在一次1。那我们大概需要存储空间几十兆左右。\"><a href=\"#首先，根据“内存空间不足以容纳这2-5亿个整数”我们可以快速的联想到Bit-map。下边关键的问题就是怎么设计我们的Bit-map来表示这2-5亿个数字的状态了。其实这个问题很简单，一个数字的状态只有两种，分别为不存在，存在。因此，我们只需要1bit就可以对一个数字的状态进行存储了，我们设定一个数字不存在为0，存在一次1。那我们大概需要存储空间几十兆左右。\" class=\"headerlink\" title=\"首先，根据“内存空间不足以容纳这2.5亿个整数”我们可以快速的联想到Bit-map。下边关键的问题就是怎么设计我们的Bit-map来表示这2.5亿个数字的状态了。其实这个问题很简单，一个数字的状态只有两种，分别为不存在，存在。因此，我们只需要1bit就可以对一个数字的状态进行存储了，我们设定一个数字不存在为0，存在一次1。那我们大概需要存储空间几十兆左右。\"></a>首先，根据“内存空间不足以容纳这2.5亿个整数”我们可以快速的联想到Bit-map。下边关键的问题就是怎么设计我们的Bit-map来表示这2.5亿个数字的状态了。其实这个问题很简单，一个数字的状态只有两种，分别为不存在，存在。因此，我们只需要1bit就可以对一个数字的状态进行存储了，我们设定一个数字不存在为0，存在一次1。那我们大概需要存储空间几十兆左右。</h5><h5 id=\"接下来的任务就是遍历一次这2-5亿个数字，判断对应下标的bit位，如果为0则表示之前没有出现过，并且将该位设置为1。如果为1则表示之前已经出现过，为重复数据，则可以丢弃。\"><a href=\"#接下来的任务就是遍历一次这2-5亿个数字，判断对应下标的bit位，如果为0则表示之前没有出现过，并且将该位设置为1。如果为1则表示之前已经出现过，为重复数据，则可以丢弃。\" class=\"headerlink\" title=\"接下来的任务就是遍历一次这2.5亿个数字，判断对应下标的bit位，如果为0则表示之前没有出现过，并且将该位设置为1。如果为1则表示之前已经出现过，为重复数据，则可以丢弃。\"></a>接下来的任务就是遍历一次这2.5亿个数字，判断对应下标的bit位，如果为0则表示之前没有出现过，并且将该位设置为1。如果为1则表示之前已经出现过，为重复数据，则可以丢弃。</h5><h4 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h4><ul>\n<li>占用内存少 </li>\n<li>运算效率高</li>\n</ul>\n<h4 id=\"缺点：\"><a href=\"#缺点：\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h4><ul>\n<li>对于非连续数据，有可能中间会有大量的bit位没有使用，导致部分空间浪费</li>\n<li>对于不是从0开始的数据，需要找到一种映射关系，将已有的数据表示为从0开始的数据。比如原始数据是从100000为起点的整数，如果使用bitmap，将导致前面的100000个bit位没有使用上。最简单的办法是我们可以将原始数据做减100000的映射表示。</li>\n</ul>\n<h3 id=\"Bit-map应用之快速排序\"><a href=\"#Bit-map应用之快速排序\" class=\"headerlink\" title=\"Bit-map应用之快速排序\"></a>Bit-map应用之快速排序</h3><h5 id=\"假设我们要对0-7内的5个元素-4-7-2-5-3-排序（这里假设这些元素没有重复）-我们就可以采用Bit-map的方法来达到排序的目的。要表示8个数，我们就只需要8个Bit（1Bytes），将这些空间的所有Bit位都置为0。\"><a href=\"#假设我们要对0-7内的5个元素-4-7-2-5-3-排序（这里假设这些元素没有重复）-我们就可以采用Bit-map的方法来达到排序的目的。要表示8个数，我们就只需要8个Bit（1Bytes），将这些空间的所有Bit位都置为0。\" class=\"headerlink\" title=\"假设我们要对0-7内的5个元素(4,7,2,5,3)排序（这里假设这些元素没有重复）,我们就可以采用Bit-map的方法来达到排序的目的。要表示8个数，我们就只需要8个Bit（1Bytes），将这些空间的所有Bit位都置为0。\"></a>假设我们要对0-7内的5个元素(4,7,2,5,3)排序（这里假设这些元素没有重复）,我们就可以采用Bit-map的方法来达到排序的目的。要表示8个数，我们就只需要8个Bit（1Bytes），将这些空间的所有Bit位都置为0。</h5><table><tr>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n</tr></table>\n\n<h5 id=\"将元素-4-7-2-5-3-对应下标位设置为1\"><a href=\"#将元素-4-7-2-5-3-对应下标位设置为1\" class=\"headerlink\" title=\"将元素(4,7,2,5,3)对应下标位设置为1:\"></a>将元素(4,7,2,5,3)对应下标位设置为1:</h5><table><tr>\n<td>0</td>\n<td>0</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>0</td>\n<td>1</td>\n</tr></table>\n\n<h5 id=\"遍历一遍Bit区域，将该位是一的位的编号输出（2，3，4，5，7），这样就达到了排序的目的，时间复杂度O-n-。\"><a href=\"#遍历一遍Bit区域，将该位是一的位的编号输出（2，3，4，5，7），这样就达到了排序的目的，时间复杂度O-n-。\" class=\"headerlink\" title=\"遍历一遍Bit区域，将该位是一的位的编号输出（2，3，4，5，7），这样就达到了排序的目的，时间复杂度O(n)。\"></a>遍历一遍Bit区域，将该位是一的位的编号输出（2，3，4，5，7），这样就达到了排序的目的，时间复杂度O(n)。</h5><h4 id=\"优点：-1\"><a href=\"#优点：-1\" class=\"headerlink\" title=\"优点：\"></a>优点：</h4><ul>\n<li>运算效率高，不需要进行比较和移位；</li>\n<li>占用内存少，比如N=10000000；只需占用内存为N/8=1250000Byte=1.25M。 </li>\n</ul>\n<h4 id=\"缺点：-1\"><a href=\"#缺点：-1\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h4><ul>\n<li>所有的数据不能重复。即不可对重复的数据进行排序和查找。</li>\n</ul>\n<h3 id=\"JAVA当中的BitMap\"><a href=\"#JAVA当中的BitMap\" class=\"headerlink\" title=\"JAVA当中的BitMap\"></a>JAVA当中的BitMap</h3><h5 id=\"既然介绍到BitMap，则简单介绍下JAVA当中的实现-BitSet\"><a href=\"#既然介绍到BitMap，则简单介绍下JAVA当中的实现-BitSet\" class=\"headerlink\" title=\"既然介绍到BitMap，则简单介绍下JAVA当中的实现-BitSet\"></a>既然介绍到BitMap，则简单介绍下JAVA当中的实现-BitSet</h5><h5 id=\"BitSet实现中，使用long类型数组来表示所有的bit位，数组当中的一个long字段可以表示64位：\"><a href=\"#BitSet实现中，使用long类型数组来表示所有的bit位，数组当中的一个long字段可以表示64位：\" class=\"headerlink\" title=\"BitSet实现中，使用long类型数组来表示所有的bit位，数组当中的一个long字段可以表示64位：\"></a>BitSet实现中，使用long类型数组来表示所有的bit位，数组当中的一个long字段可以表示64位：</h5><pre><code class=\"lang-java\">/**\n * The number of words in the logical size of this BitSet.\n */\nprivate long[] words;\n</code></pre>\n<h5 id=\"具体的BitSet使用和原理，可以参考以下文章：\"><a href=\"#具体的BitSet使用和原理，可以参考以下文章：\" class=\"headerlink\" title=\"具体的BitSet使用和原理，可以参考以下文章：\"></a>具体的BitSet使用和原理，可以参考以下文章：</h5><ol>\n<li><a href=\"http://www.runoob.com/java/java-bitset-class.html\" target=\"_blank\" rel=\"external\">Java Bitset类 | 菜鸟教程</a></li>\n<li><a href=\"https://blog.csdn.net/top_code/article/details/40583279\" target=\"_blank\" rel=\"external\">Java BitSet</a></li>\n</ol>\n<h2 id=\"BloomFilter\"><a href=\"#BloomFilter\" class=\"headerlink\" title=\"BloomFilter\"></a>BloomFilter</h2>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjgxop3le000mjah1fq4syab8","category_id":"cjgxop3ld000jjah1vb7qi9an","_id":"cjgxop3lk000wjah1diusrknm"},{"post_id":"cjgxop3l9000gjah1funx8vjm","category_id":"cjgxop3ld000jjah1vb7qi9an","_id":"cjgxop3ll000zjah1g0fq0z10"},{"post_id":"cjgxop3lf000pjah1ylifwkt8","category_id":"cjgxop3ld000jjah1vb7qi9an","_id":"cjgxop3ln0013jah1r3k2ajm1"},{"post_id":"cjgxop3lh000sjah13rg1c4qb","category_id":"cjgxop3ld000jjah1vb7qi9an","_id":"cjgxop3lo0015jah1yp8e8otx"},{"post_id":"cjgxop3ld000kjah1x105g93n","category_id":"cjgxop3ld000jjah1vb7qi9an","_id":"cjgxop3lp0018jah11ugylx8l"},{"post_id":"cjgxop3lj000vjah1aogpaw2o","category_id":"cjgxop3ld000jjah1vb7qi9an","_id":"cjgxop3lq001bjah11ovluehv"},{"post_id":"cjgxop3ll000yjah1xyzoiiz6","category_id":"cjgxop3ld000jjah1vb7qi9an","_id":"cjgxop3lw001fjah1oe074rtz"},{"post_id":"cjgxop3lm0012jah1vsmf4gbm","category_id":"cjgxop3ld000jjah1vb7qi9an","_id":"cjgxop3lx001ijah1fa9os6uu"},{"post_id":"cjgxop3ln0014jah166itohe4","category_id":"cjgxop3ld000jjah1vb7qi9an","_id":"cjgxop3m0001mjah1m637s554"},{"post_id":"cjgxop3lo0017jah1bgtf9sbq","category_id":"cjgxop3ld000jjah1vb7qi9an","_id":"cjgxop3m2001pjah11raodpd8"},{"post_id":"cjgxop3lp001ajah1y2eoi7t7","category_id":"cjgxop3ld000jjah1vb7qi9an","_id":"cjgxop3m3001sjah16t3ju284"},{"post_id":"cjgxop3lt001ejah1hxibenpb","category_id":"cjgxop3ld000jjah1vb7qi9an","_id":"cjgxop3m4001vjah1xk6h7ulw"},{"post_id":"cjgxop3lw001hjah1mlaut33h","category_id":"cjgxop3ld000jjah1vb7qi9an","_id":"cjgxop3m6001yjah1e8ipijhz"},{"post_id":"cjgxop3ly001ljah18shb64x1","category_id":"cjgxop3ld000jjah1vb7qi9an","_id":"cjgxop3m80021jah1dbuxpcsr"},{"post_id":"cjgxop3m1001ojah1mhgpd310","category_id":"cjgxop3ld000jjah1vb7qi9an","_id":"cjgxop3m90023jah14o3wsitl"},{"post_id":"cjgxop3m2001rjah19u7yyh3c","category_id":"cjgxop3ld000jjah1vb7qi9an","_id":"cjgxop3ma0025jah14fv6kfx1"},{"post_id":"cjgxop3m3001ujah18mo0plc4","category_id":"cjgxop3ld000jjah1vb7qi9an","_id":"cjgxop3mb0027jah18wd7bbag"},{"post_id":"cjgxop3m5001xjah1spkcufpa","category_id":"cjgxop3ld000jjah1vb7qi9an","_id":"cjgxop3mc0029jah1kmdh3zzz"},{"post_id":"cjgxop3m70020jah173h9j47v","category_id":"cjgxop3ld000jjah1vb7qi9an","_id":"cjgxop3md002bjah1xf2x5z7f"},{"post_id":"cjgxop3m90022jah1dl7ygtol","category_id":"cjgxop3ld000jjah1vb7qi9an","_id":"cjgxop3md002cjah1dzx8qgeu"},{"post_id":"cjgxop3ma0024jah1aw8jm7hz","category_id":"cjgxop3ld000jjah1vb7qi9an","_id":"cjgxop3me002djah1tievrf65"},{"post_id":"cjgxop3mb0026jah1ilxp44tr","category_id":"cjgxop3ld000jjah1vb7qi9an","_id":"cjgxop3me002ejah1xyfr2xnq"},{"post_id":"cjgxop3mc0028jah13vnotv6a","category_id":"cjgxop3ld000jjah1vb7qi9an","_id":"cjgxop3me002fjah174xitry5"},{"post_id":"cjgxop3mc002ajah1fpllmct1","category_id":"cjgxop3ld000jjah1vb7qi9an","_id":"cjgxop3me002gjah1i6rkz1l0"}],"PostTag":[{"post_id":"cjgxop3kt0001jah1pnmtencg","tag_id":"cjgxop3kw0003jah1wwb0mt8p","_id":"cjgxop3l7000cjah16xleq8bt"},{"post_id":"cjgxop3kt0001jah1pnmtencg","tag_id":"cjgxop3l20007jah1dpviqauo","_id":"cjgxop3l8000ejah1qp0m7uhl"},{"post_id":"cjgxop3ku0002jah13hqlenvn","tag_id":"cjgxop3kw0003jah1wwb0mt8p","_id":"cjgxop3le000ljah1qh831q1c"},{"post_id":"cjgxop3ku0002jah13hqlenvn","tag_id":"cjgxop3l20007jah1dpviqauo","_id":"cjgxop3lf000njah1e7lrqzer"},{"post_id":"cjgxop3l00005jah1i4hxvxar","tag_id":"cjgxop3kw0003jah1wwb0mt8p","_id":"cjgxop3lg000rjah133332sw9"},{"post_id":"cjgxop3l00005jah1i4hxvxar","tag_id":"cjgxop3l20007jah1dpviqauo","_id":"cjgxop3li000tjah1m4kzg3oe"},{"post_id":"cjgxop3l30008jah1e8la3lkj","tag_id":"cjgxop3lf000ojah1akq7w654","_id":"cjgxop3lk000xjah1jnm8lint"},{"post_id":"cjgxop3l30008jah1e8la3lkj","tag_id":"cjgxop3l20007jah1dpviqauo","_id":"cjgxop3lm0010jah1ynzps69b"},{"post_id":"cjgxop3l40009jah1gtgeiml7","tag_id":"cjgxop3lf000ojah1akq7w654","_id":"cjgxop3lp0019jah1l76lwprh"},{"post_id":"cjgxop3l40009jah1gtgeiml7","tag_id":"cjgxop3l20007jah1dpviqauo","_id":"cjgxop3lr001cjah1wl28z4i3"},{"post_id":"cjgxop3l40009jah1gtgeiml7","tag_id":"cjgxop3lm0011jah1jefxm0am","_id":"cjgxop3lw001gjah14746v2dt"},{"post_id":"cjgxop3l6000bjah1p4dpqrko","tag_id":"cjgxop3lf000ojah1akq7w654","_id":"cjgxop3ly001jjah19x51nuij"},{"post_id":"cjgxop3l6000bjah1p4dpqrko","tag_id":"cjgxop3l20007jah1dpviqauo","_id":"cjgxop3m1001njah1mpabjvyk"},{"post_id":"cjgxop3l7000djah18m2pgpxh","tag_id":"cjgxop3lf000ojah1akq7w654","_id":"cjgxop3m2001qjah1nh4oiy65"},{"post_id":"cjgxop3l7000djah18m2pgpxh","tag_id":"cjgxop3l20007jah1dpviqauo","_id":"cjgxop3m3001tjah1dgk3h12y"},{"post_id":"cjgxop3la000hjah1idyauv3l","tag_id":"cjgxop3lf000ojah1akq7w654","_id":"cjgxop3m5001wjah1oi02exc5"},{"post_id":"cjgxop3la000hjah1idyauv3l","tag_id":"cjgxop3l20007jah1dpviqauo","_id":"cjgxop3m7001zjah1u58i8di9"},{"post_id":"cjgxop3mz002ljah1srcjb5ya","tag_id":"cjgxop3lf000ojah1akq7w654","_id":"cjgxop3n1002ojah1cu6ks1eg"},{"post_id":"cjgxop3mz002ljah1srcjb5ya","tag_id":"cjgxop3my002jjah1nqt82lak","_id":"cjgxop3n3002qjah1m6eon4rx"},{"post_id":"cjgxop3mz002ljah1srcjb5ya","tag_id":"cjgxop3l20007jah1dpviqauo","_id":"cjgxop3n5002tjah1tv6zd4m4"},{"post_id":"cjgxop3mw002hjah1uah7y03z","tag_id":"cjgxop3lf000ojah1akq7w654","_id":"cjgxop3n6002vjah1yaomumja"},{"post_id":"cjgxop3mw002hjah1uah7y03z","tag_id":"cjgxop3my002jjah1nqt82lak","_id":"cjgxop3n8002xjah1vvwahed3"},{"post_id":"cjgxop3mw002hjah1uah7y03z","tag_id":"cjgxop3l20007jah1dpviqauo","_id":"cjgxop3na002zjah1i4dpwpsy"},{"post_id":"cjgxop3n0002mjah1gl17offp","tag_id":"cjgxop3lf000ojah1akq7w654","_id":"cjgxop3nb0031jah1zpmjc3je"},{"post_id":"cjgxop3n0002mjah1gl17offp","tag_id":"cjgxop3my002jjah1nqt82lak","_id":"cjgxop3nc0033jah1oimw1927"},{"post_id":"cjgxop3n0002mjah1gl17offp","tag_id":"cjgxop3l20007jah1dpviqauo","_id":"cjgxop3nd0035jah1929manfn"},{"post_id":"cjgxop3n1002pjah15s9uh2x2","tag_id":"cjgxop3lf000ojah1akq7w654","_id":"cjgxop3ne0037jah1nshr23gz"},{"post_id":"cjgxop3n1002pjah15s9uh2x2","tag_id":"cjgxop3my002jjah1nqt82lak","_id":"cjgxop3nf003ajah1vmnsndpx"},{"post_id":"cjgxop3n1002pjah15s9uh2x2","tag_id":"cjgxop3l20007jah1dpviqauo","_id":"cjgxop3ng003cjah19w4nu37f"},{"post_id":"cjgxop3mx002ijah1b38l9vb8","tag_id":"cjgxop3lf000ojah1akq7w654","_id":"cjgxop3nh003ejah1ktguufyh"},{"post_id":"cjgxop3mx002ijah1b38l9vb8","tag_id":"cjgxop3my002jjah1nqt82lak","_id":"cjgxop3nj003hjah104cgu29m"},{"post_id":"cjgxop3mx002ijah1b38l9vb8","tag_id":"cjgxop3l20007jah1dpviqauo","_id":"cjgxop3nl003jjah1cu8fa4z4"},{"post_id":"cjgxop3n3002rjah1ukljja90","tag_id":"cjgxop3lf000ojah1akq7w654","_id":"cjgxop3nn003mjah1md2beg4f"},{"post_id":"cjgxop3n3002rjah1ukljja90","tag_id":"cjgxop3my002jjah1nqt82lak","_id":"cjgxop3no003ojah13pnly0cp"},{"post_id":"cjgxop3n3002rjah1ukljja90","tag_id":"cjgxop3l20007jah1dpviqauo","_id":"cjgxop3np003rjah1n9uksffc"},{"post_id":"cjgxop3n5002ujah1uo4ej4fq","tag_id":"cjgxop3lf000ojah1akq7w654","_id":"cjgxop3nq003tjah1goy5eo4w"},{"post_id":"cjgxop3n5002ujah1uo4ej4fq","tag_id":"cjgxop3my002jjah1nqt82lak","_id":"cjgxop3nr003wjah1an97yyoa"},{"post_id":"cjgxop3n5002ujah1uo4ej4fq","tag_id":"cjgxop3l20007jah1dpviqauo","_id":"cjgxop3ns003yjah1qzh2s3wb"},{"post_id":"cjgxop3my002kjah10zize4g7","tag_id":"cjgxop3lf000ojah1akq7w654","_id":"cjgxop3nt0040jah1rqeim63e"},{"post_id":"cjgxop3my002kjah10zize4g7","tag_id":"cjgxop3my002jjah1nqt82lak","_id":"cjgxop3nu0043jah1f5bvhyhh"},{"post_id":"cjgxop3my002kjah10zize4g7","tag_id":"cjgxop3l20007jah1dpviqauo","_id":"cjgxop3nv0045jah160bh4sqp"},{"post_id":"cjgxop3n6002wjah1q41yrj0t","tag_id":"cjgxop3lf000ojah1akq7w654","_id":"cjgxop3nw0048jah1vib4tzog"},{"post_id":"cjgxop3n6002wjah1q41yrj0t","tag_id":"cjgxop3my002jjah1nqt82lak","_id":"cjgxop3nz004ajah16s50rsya"},{"post_id":"cjgxop3n6002wjah1q41yrj0t","tag_id":"cjgxop3l20007jah1dpviqauo","_id":"cjgxop3o1004djah17xmqpfum"},{"post_id":"cjgxop3n8002yjah1l7wzgheb","tag_id":"cjgxop3lf000ojah1akq7w654","_id":"cjgxop3o2004fjah1fpu1xkc5"},{"post_id":"cjgxop3n8002yjah1l7wzgheb","tag_id":"cjgxop3my002jjah1nqt82lak","_id":"cjgxop3o3004hjah10lntszav"},{"post_id":"cjgxop3n8002yjah1l7wzgheb","tag_id":"cjgxop3l20007jah1dpviqauo","_id":"cjgxop3o3004ijah1rfm61efh"},{"post_id":"cjgxop3na0030jah144qw9b6r","tag_id":"cjgxop3lf000ojah1akq7w654","_id":"cjgxop3o4004kjah1rukasshu"},{"post_id":"cjgxop3na0030jah144qw9b6r","tag_id":"cjgxop3my002jjah1nqt82lak","_id":"cjgxop3o4004ljah15335mo3s"},{"post_id":"cjgxop3na0030jah144qw9b6r","tag_id":"cjgxop3l20007jah1dpviqauo","_id":"cjgxop3o5004njah13h8lkn1g"},{"post_id":"cjgxop3nb0032jah1xng2j56a","tag_id":"cjgxop3lf000ojah1akq7w654","_id":"cjgxop3o5004ojah1do673k0l"},{"post_id":"cjgxop3nb0032jah1xng2j56a","tag_id":"cjgxop3my002jjah1nqt82lak","_id":"cjgxop3o5004qjah17kwqu71l"},{"post_id":"cjgxop3nb0032jah1xng2j56a","tag_id":"cjgxop3l20007jah1dpviqauo","_id":"cjgxop3o6004rjah1f33l5sv8"},{"post_id":"cjgxop3nc0034jah1tji3cycr","tag_id":"cjgxop3lf000ojah1akq7w654","_id":"cjgxop3o6004tjah1gnc77s28"},{"post_id":"cjgxop3nc0034jah1tji3cycr","tag_id":"cjgxop3my002jjah1nqt82lak","_id":"cjgxop3o6004ujah1ma97qjf1"},{"post_id":"cjgxop3nc0034jah1tji3cycr","tag_id":"cjgxop3l20007jah1dpviqauo","_id":"cjgxop3o6004vjah1xjrj7g7l"},{"post_id":"cjgxop3ng003djah1ad07f2em","tag_id":"cjgxop3lf000ojah1akq7w654","_id":"cjgxop3o6004wjah19sw4akkm"},{"post_id":"cjgxop3ng003djah1ad07f2em","tag_id":"cjgxop3l20007jah1dpviqauo","_id":"cjgxop3o7004xjah175e0jz8y"},{"post_id":"cjgxop3ng003djah1ad07f2em","tag_id":"cjgxop3nf0039jah1y9yt9mrb","_id":"cjgxop3o7004yjah1x1tmsvye"},{"post_id":"cjgxop3nd0036jah18elfa1cf","tag_id":"cjgxop3lf000ojah1akq7w654","_id":"cjgxop3o7004zjah1k2k4b5ge"},{"post_id":"cjgxop3nd0036jah18elfa1cf","tag_id":"cjgxop3l20007jah1dpviqauo","_id":"cjgxop3o70050jah14ybt7rse"},{"post_id":"cjgxop3nd0036jah18elfa1cf","tag_id":"cjgxop3nf0039jah1y9yt9mrb","_id":"cjgxop3o70051jah1btcj55oe"},{"post_id":"cjgxop3nh003fjah1egeivn20","tag_id":"cjgxop3lf000ojah1akq7w654","_id":"cjgxop3o70052jah1cywvkaik"},{"post_id":"cjgxop3nh003fjah1egeivn20","tag_id":"cjgxop3l20007jah1dpviqauo","_id":"cjgxop3o70053jah1ydz5yope"},{"post_id":"cjgxop3nj003ijah1b77wsana","tag_id":"cjgxop3lf000ojah1akq7w654","_id":"cjgxop3o70054jah1igc9jpse"},{"post_id":"cjgxop3nj003ijah1b77wsana","tag_id":"cjgxop3l20007jah1dpviqauo","_id":"cjgxop3o70055jah18dgk7hgh"},{"post_id":"cjgxop3ne0038jah1num3ym1l","tag_id":"cjgxop3lf000ojah1akq7w654","_id":"cjgxop3o70056jah15lm76h57"},{"post_id":"cjgxop3ne0038jah1num3ym1l","tag_id":"cjgxop3l20007jah1dpviqauo","_id":"cjgxop3o70057jah1qxmkear7"},{"post_id":"cjgxop3ne0038jah1num3ym1l","tag_id":"cjgxop3nf0039jah1y9yt9mrb","_id":"cjgxop3o80058jah151av63z6"},{"post_id":"cjgxop3nl003kjah10brritcc","tag_id":"cjgxop3lf000ojah1akq7w654","_id":"cjgxop3o80059jah1hr21wlgy"},{"post_id":"cjgxop3nl003kjah10brritcc","tag_id":"cjgxop3l20007jah1dpviqauo","_id":"cjgxop3o8005ajah1dr53l9uz"},{"post_id":"cjgxop3nn003njah1okvb9bs6","tag_id":"cjgxop3lf000ojah1akq7w654","_id":"cjgxop3o8005bjah1w25ehsm7"},{"post_id":"cjgxop3nn003njah1okvb9bs6","tag_id":"cjgxop3l20007jah1dpviqauo","_id":"cjgxop3o8005cjah1ca0gpjmd"},{"post_id":"cjgxop3no003pjah1r4z8lhcy","tag_id":"cjgxop3lf000ojah1akq7w654","_id":"cjgxop3o8005djah134gvof7w"},{"post_id":"cjgxop3no003pjah1r4z8lhcy","tag_id":"cjgxop3l20007jah1dpviqauo","_id":"cjgxop3o8005ejah1y49ohlm8"},{"post_id":"cjgxop3nf003bjah14ms4xf2v","tag_id":"cjgxop3nm003ljah1hwkds12p","_id":"cjgxop3o8005fjah1ewk12bv2"},{"post_id":"cjgxop3nf003bjah14ms4xf2v","tag_id":"cjgxop3np003qjah100vl87ak","_id":"cjgxop3o8005gjah1k2nue5eb"},{"post_id":"cjgxop3nq003ujah19kb67n5l","tag_id":"cjgxop3nm003ljah1hwkds12p","_id":"cjgxop3o8005hjah15m3l8g1g"},{"post_id":"cjgxop3np003sjah1r12pjjbg","tag_id":"cjgxop3lf000ojah1akq7w654","_id":"cjgxop3o8005ijah1o75ethx1"},{"post_id":"cjgxop3np003sjah1r12pjjbg","tag_id":"cjgxop3l20007jah1dpviqauo","_id":"cjgxop3o8005jjah1d2001b8g"},{"post_id":"cjgxop3np003sjah1r12pjjbg","tag_id":"cjgxop3nr003vjah1e49m4y0q","_id":"cjgxop3o9005kjah1wqktxfki"},{"post_id":"cjgxop3nr003xjah1reclq0mr","tag_id":"cjgxop3lf000ojah1akq7w654","_id":"cjgxop3o9005ljah1zj9d0kdn"},{"post_id":"cjgxop3nr003xjah1reclq0mr","tag_id":"cjgxop3l20007jah1dpviqauo","_id":"cjgxop3o9005mjah19juf40cn"},{"post_id":"cjgxop3nr003xjah1reclq0mr","tag_id":"cjgxop3nu0042jah154x4vcc7","_id":"cjgxop3o9005njah1rjt8a9sv"},{"post_id":"cjgxop3ns003zjah16xz95wa6","tag_id":"cjgxop3lf000ojah1akq7w654","_id":"cjgxop3o9005ojah19xoewos4"},{"post_id":"cjgxop3ns003zjah16xz95wa6","tag_id":"cjgxop3l20007jah1dpviqauo","_id":"cjgxop3o9005pjah143x433b0"},{"post_id":"cjgxop3ns003zjah16xz95wa6","tag_id":"cjgxop3nu0042jah154x4vcc7","_id":"cjgxop3o9005qjah1xwo25gmj"},{"post_id":"cjgxop3nt0041jah123sn7c85","tag_id":"cjgxop3lf000ojah1akq7w654","_id":"cjgxop3o9005rjah1566r8000"},{"post_id":"cjgxop3nt0041jah123sn7c85","tag_id":"cjgxop3l20007jah1dpviqauo","_id":"cjgxop3o9005sjah1k9irc74r"},{"post_id":"cjgxop3nt0041jah123sn7c85","tag_id":"cjgxop3nu0042jah154x4vcc7","_id":"cjgxop3o9005tjah1zc324k0u"},{"post_id":"cjgxop3nu0044jah10epobnll","tag_id":"cjgxop3lf000ojah1akq7w654","_id":"cjgxop3o9005ujah1k4soaszr"},{"post_id":"cjgxop3nu0044jah10epobnll","tag_id":"cjgxop3o2004gjah18ezszrgh","_id":"cjgxop3o9005vjah18jfrjgmz"},{"post_id":"cjgxop3nu0044jah10epobnll","tag_id":"cjgxop3l20007jah1dpviqauo","_id":"cjgxop3o9005wjah1bj5a6xq2"},{"post_id":"cjgxop3nu0044jah10epobnll","tag_id":"cjgxop3nr003vjah1e49m4y0q","_id":"cjgxop3oa005xjah1qw7no7gt"},{"post_id":"cjgxop3nv0046jah183ik7ufr","tag_id":"cjgxop3lf000ojah1akq7w654","_id":"cjgxop3oa005yjah1dwkb1742"},{"post_id":"cjgxop3nv0046jah183ik7ufr","tag_id":"cjgxop3o2004gjah18ezszrgh","_id":"cjgxop3oa005zjah1qdhzjr2v"},{"post_id":"cjgxop3nv0046jah183ik7ufr","tag_id":"cjgxop3l20007jah1dpviqauo","_id":"cjgxop3oa0060jah1xqrkvxv4"},{"post_id":"cjgxop3nv0046jah183ik7ufr","tag_id":"cjgxop3nr003vjah1e49m4y0q","_id":"cjgxop3oa0061jah1xf88111s"},{"post_id":"cjgxop3nx0049jah1xkzal9ni","tag_id":"cjgxop3lf000ojah1akq7w654","_id":"cjgxop3oa0062jah1adj21e91"},{"post_id":"cjgxop3nx0049jah1xkzal9ni","tag_id":"cjgxop3o2004gjah18ezszrgh","_id":"cjgxop3oa0063jah1mh49mtka"},{"post_id":"cjgxop3nx0049jah1xkzal9ni","tag_id":"cjgxop3l20007jah1dpviqauo","_id":"cjgxop3oa0064jah1tynerdao"},{"post_id":"cjgxop3nx0049jah1xkzal9ni","tag_id":"cjgxop3nr003vjah1e49m4y0q","_id":"cjgxop3oa0065jah1l2uz70hs"},{"post_id":"cjgxop3nz004bjah1mr9yy84u","tag_id":"cjgxop3o5004pjah1klzmv829","_id":"cjgxop3oa0066jah1pxdoaiwu"},{"post_id":"cjgxop3o1004ejah1eb513vqk","tag_id":"cjgxop3lf000ojah1akq7w654","_id":"cjgxop3oa0067jah1y4ram3yl"},{"post_id":"cjgxop3o1004ejah1eb513vqk","tag_id":"cjgxop3l20007jah1dpviqauo","_id":"cjgxop3oa0068jah180astqng"},{"post_id":"cjgxop3o1004ejah1eb513vqk","tag_id":"cjgxop3o6004sjah1hb7rg7fv","_id":"cjgxop3oa0069jah1q0l5khqo"},{"post_id":"cjgxop3o1004ejah1eb513vqk","tag_id":"cjgxop3nr003vjah1e49m4y0q","_id":"cjgxop3ob006ajah1bjk4d3ht"},{"post_id":"cjgxoy0q4006bjah16svk90jn","tag_id":"cjgxop3lf000ojah1akq7w654","_id":"cjgxoy0q8006cjah1s6wufijh"},{"post_id":"cjgxoy0q4006bjah16svk90jn","tag_id":"cjgxop3my002jjah1nqt82lak","_id":"cjgxoy0q9006djah1i3mc7i6y"},{"post_id":"cjgxoy0q4006bjah16svk90jn","tag_id":"cjgxop3l20007jah1dpviqauo","_id":"cjgxoy0q9006ejah1pnnctze3"}],"Tag":[{"name":"life","_id":"cjgxop3kw0003jah1wwb0mt8p"},{"name":"index","_id":"cjgxop3l20007jah1dpviqauo"},{"name":"tech","_id":"cjgxop3lf000ojah1akq7w654"},{"name":"network","_id":"cjgxop3lm0011jah1jefxm0am"},{"name":"arithmetic","_id":"cjgxop3my002jjah1nqt82lak"},{"name":"dubbo","_id":"cjgxop3nf0039jah1y9yt9mrb"},{"name":"java,java","_id":"cjgxop3nm003ljah1hwkds12p"},{"name":"dubbo,dubbo","_id":"cjgxop3np003qjah100vl87ak"},{"name":"java","_id":"cjgxop3nr003vjah1e49m4y0q"},{"name":"redis","_id":"cjgxop3nu0042jah154x4vcc7"},{"name":"river","_id":"cjgxop3o2004gjah18ezszrgh"},{"name":"hide","_id":"cjgxop3o5004pjah1klzmv829"},{"name":"spring","_id":"cjgxop3o6004sjah1hb7rg7fv"}]}}