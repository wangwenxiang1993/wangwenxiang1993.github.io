{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/img/arithmetic/BinaryTree.png","path":"img/arithmetic/BinaryTree.png","modified":0,"renderable":0},{"_id":"source/img/arithmetic/linked.jpg","path":"img/arithmetic/linked.jpg","modified":0,"renderable":0},{"_id":"source/img/arithmetic/linked2.jpg","path":"img/arithmetic/linked2.jpg","modified":0,"renderable":0},{"_id":"source/img/book/1984.jpg","path":"img/book/1984.jpg","modified":0,"renderable":0},{"_id":"source/img/book/TangledSkein.jpg","path":"img/book/TangledSkein.jpg","modified":0,"renderable":0},{"_id":"source/img/book/crowd.png","path":"img/book/crowd.png","modified":0,"renderable":0},{"_id":"source/img/book/fatherAndSon.jpeg","path":"img/book/fatherAndSon.jpeg","modified":0,"renderable":0},{"_id":"source/img/book/coreJavaVolume1.jpeg","path":"img/book/coreJavaVolume1.jpeg","modified":0,"renderable":0},{"_id":"source/img/book/love.jpeg","path":"img/book/love.jpeg","modified":0,"renderable":0},{"_id":"source/img/book/goldenAge.jpg","path":"img/book/goldenAge.jpg","modified":0,"renderable":0},{"_id":"source/img/book/loveYou.jpeg","path":"img/book/loveYou.jpeg","modified":0,"renderable":0},{"_id":"source/img/book/milk.jpeg","path":"img/book/milk.jpeg","modified":0,"renderable":0},{"_id":"source/img/book/thinkingInJava.jpeg","path":"img/book/thinkingInJava.jpeg","modified":0,"renderable":0},{"_id":"source/img/book/silentMajority.jpeg","path":"img/book/silentMajority.jpeg","modified":0,"renderable":0},{"_id":"source/img/book/town.jpg","path":"img/book/town.jpg","modified":0,"renderable":0},{"_id":"source/img/book/walkAtNight.jpeg","path":"img/book/walkAtNight.jpeg","modified":0,"renderable":0},{"_id":"source/img/pvalue/pvalue7.png","path":"img/pvalue/pvalue7.png","modified":0,"renderable":0},{"_id":"source/img/note/redisString.png","path":"img/note/redisString.png","modified":0,"renderable":0},{"_id":"source/img/note/secretkey1.png","path":"img/note/secretkey1.png","modified":0,"renderable":0},{"_id":"source/img/note/secretkey11.png","path":"img/note/secretkey11.png","modified":0,"renderable":0},{"_id":"source/img/note/secretkey10.png","path":"img/note/secretkey10.png","modified":0,"renderable":0},{"_id":"source/img/note/secretkey13.png","path":"img/note/secretkey13.png","modified":0,"renderable":0},{"_id":"source/img/note/secretkey14.jpg","path":"img/note/secretkey14.jpg","modified":0,"renderable":0},{"_id":"source/img/note/secretkey15.png","path":"img/note/secretkey15.png","modified":0,"renderable":0},{"_id":"source/img/note/secretkey16.png","path":"img/note/secretkey16.png","modified":0,"renderable":0},{"_id":"source/img/note/secretkey18.png","path":"img/note/secretkey18.png","modified":0,"renderable":0},{"_id":"source/img/note/secretkey19.jpg","path":"img/note/secretkey19.jpg","modified":0,"renderable":0},{"_id":"source/img/note/secretkey20.png","path":"img/note/secretkey20.png","modified":0,"renderable":0},{"_id":"source/img/note/secretkey3.png","path":"img/note/secretkey3.png","modified":0,"renderable":0},{"_id":"source/img/note/secretkey2.png","path":"img/note/secretkey2.png","modified":0,"renderable":0},{"_id":"source/img/note/secretkey4.png","path":"img/note/secretkey4.png","modified":0,"renderable":0},{"_id":"source/img/note/secretkey5.png","path":"img/note/secretkey5.png","modified":0,"renderable":0},{"_id":"source/img/note/secretkey6.png","path":"img/note/secretkey6.png","modified":0,"renderable":0},{"_id":"source/img/note/secretkey8.png","path":"img/note/secretkey8.png","modified":0,"renderable":0},{"_id":"source/img/zookeeper/zookeeper1.jpg","path":"img/zookeeper/zookeeper1.jpg","modified":0,"renderable":0},{"_id":"source/img/zookeeper/role.jpg","path":"img/zookeeper/role.jpg","modified":0,"renderable":0},{"_id":"source/img/zookeeper/zookeeper2.jpg","path":"img/zookeeper/zookeeper2.jpg","modified":0,"renderable":0},{"_id":"source/img/zookeeper/zookeeperLc2.jpg","path":"img/zookeeper/zookeeperLc2.jpg","modified":0,"renderable":0},{"_id":"source/img/zookeeper/zookeeperLc.jpg","path":"img/zookeeper/zookeeperLc.jpg","modified":0,"renderable":0},{"_id":"source/img/zookeeper/zookeeperLc3.jpg","path":"img/zookeeper/zookeeperLc3.jpg","modified":0,"renderable":0},{"_id":"source/img/zookeeper/zookeeperLc4.jpg","path":"img/zookeeper/zookeeperLc4.jpg","modified":0,"renderable":0},{"_id":"source/img/zookeeper/zookeeperLc5.jpg","path":"img/zookeeper/zookeeperLc5.jpg","modified":0,"renderable":0},{"_id":"source/img/zookeeper/zookeeperModel.jpg","path":"img/zookeeper/zookeeperModel.jpg","modified":0,"renderable":0},{"_id":"themes/maybe/source/css/font-awesome.min.css","path":"css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/maybe/source/css/highlight.css","path":"css/highlight.css","modified":0,"renderable":1},{"_id":"themes/maybe/source/css/style.css","path":"css/style.css","modified":0,"renderable":1},{"_id":"themes/maybe/source/img/photo.png","path":"img/photo.png","modified":0,"renderable":1},{"_id":"themes/maybe/source/js/base.js","path":"js/base.js","modified":0,"renderable":1},{"_id":"themes/maybe/source/js/canvas-nest.min.js","path":"js/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/maybe/source/js/jquery.tagcloud.js","path":"js/jquery.tagcloud.js","modified":0,"renderable":1},{"_id":"themes/maybe/source/js/highlight.pack.js","path":"js/highlight.pack.js","modified":0,"renderable":1},{"_id":"source/img/life/chongqing-bg.jpeg","path":"img/life/chongqing-bg.jpeg","modified":0,"renderable":0},{"_id":"source/img/life/chongqing.jpeg","path":"img/life/chongqing.jpeg","modified":0,"renderable":0},{"_id":"source/img/life/yllh.jpeg","path":"img/life/yllh.jpeg","modified":0,"renderable":0},{"_id":"source/img/pvalue/pvalue1.png","path":"img/pvalue/pvalue1.png","modified":0,"renderable":0},{"_id":"source/img/pvalue/pvalue2.png","path":"img/pvalue/pvalue2.png","modified":0,"renderable":0},{"_id":"source/img/note/secretkey7.png","path":"img/note/secretkey7.png","modified":0,"renderable":0},{"_id":"source/img/note/secretkey9.png","path":"img/note/secretkey9.png","modified":0,"renderable":0},{"_id":"themes/maybe/source/img/favicon.ico","path":"img/favicon.ico","modified":0,"renderable":1},{"_id":"themes/maybe/source/img/guide.jpeg","path":"img/guide.jpeg","modified":0,"renderable":1},{"_id":"themes/maybe/source/fonts/FontAwesome.otf","path":"fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/maybe/source/fonts/fontawesome-webfont.eot","path":"fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/maybe/source/fonts/fontawesome-webfont.woff2","path":"fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/maybe/source/fonts/fontawesome-webfont.woff","path":"fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/maybe/source/js/jquery-1.7.1.min.js","path":"js/jquery-1.7.1.min.js","modified":0,"renderable":1},{"_id":"source/img/book/varietyShop.jpeg","path":"img/book/varietyShop.jpeg","modified":0,"renderable":0},{"_id":"source/img/life/2016-roommate.jpeg","path":"img/life/2016-roommate.jpeg","modified":0,"renderable":0},{"_id":"source/img/life/2016-bg.jpg","path":"img/life/2016-bg.jpg","modified":0,"renderable":0},{"_id":"source/img/life/cqupt.jpeg","path":"img/life/cqupt.jpeg","modified":0,"renderable":0},{"_id":"source/img/life/jianshui.jpeg","path":"img/life/jianshui.jpeg","modified":0,"renderable":0},{"_id":"source/img/life/fish.jpeg","path":"img/life/fish.jpeg","modified":0,"renderable":0},{"_id":"source/img/life/qiuwei.jpeg","path":"img/life/qiuwei.jpeg","modified":0,"renderable":0},{"_id":"source/img/life/myself.jpeg","path":"img/life/myself.jpeg","modified":0,"renderable":0},{"_id":"source/img/pvalue/pvalue5.png","path":"img/pvalue/pvalue5.png","modified":0,"renderable":0},{"_id":"source/img/pvalue/pvalue3.jpeg","path":"img/pvalue/pvalue3.jpeg","modified":0,"renderable":0},{"_id":"source/img/pvalue/pvalue4.png","path":"img/pvalue/pvalue4.png","modified":0,"renderable":0},{"_id":"source/img/pvalue/pvalue6.png","path":"img/pvalue/pvalue6.png","modified":0,"renderable":0},{"_id":"source/img/note/secretkey12.png","path":"img/note/secretkey12.png","modified":0,"renderable":0},{"_id":"source/img/note/secretkey17.png","path":"img/note/secretkey17.png","modified":0,"renderable":0},{"_id":"themes/maybe/source/img/home-bg.jpg","path":"img/home-bg.jpg","modified":0,"renderable":1},{"_id":"themes/maybe/source/img/note-bg.jpg","path":"img/note-bg.jpg","modified":0,"renderable":1},{"_id":"themes/maybe/source/img/river-bg.jpg","path":"img/river-bg.jpg","modified":0,"renderable":1},{"_id":"themes/maybe/source/img/read-bg.jpg","path":"img/read-bg.jpg","modified":0,"renderable":1},{"_id":"themes/maybe/source/fonts/fontawesome-webfont.ttf","path":"fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"source/img/life/2016-qunar.jpeg","path":"img/life/2016-qunar.jpeg","modified":0,"renderable":0},{"_id":"source/img/note/ThreadLocal.png","path":"img/note/ThreadLocal.png","modified":0,"renderable":0},{"_id":"themes/maybe/source/img/life-bg.jpg","path":"img/life-bg.jpg","modified":0,"renderable":1},{"_id":"source/img/book/pestis.jpeg","path":"img/book/pestis.jpeg","modified":0,"renderable":0},{"_id":"themes/maybe/source/img/project-bg.jpg","path":"img/project-bg.jpg","modified":0,"renderable":1},{"_id":"themes/maybe/source/fonts/fontawesome-webfont.svg","path":"fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/maybe/source/img/guide.png","path":"img/guide.png","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/resume.md","hash":"d3d3ef1aed3e740036e35e97243d5fce1342b8ae","modified":1502796706000},{"_id":"themes/maybe/layout/book.ejs","hash":"1984cec69d4bc8bf58a2d66d01348f3d5ee3a077","modified":1502796706000},{"_id":"themes/maybe/layout/category.ejs","hash":"38d62125a1e0c9a8ea602a03b6d27949aea98162","modified":1502796706000},{"_id":"themes/maybe/layout/index.ejs","hash":"1e14b73b3d56be216921ceae2c927a70978961ad","modified":1502796706000},{"_id":"themes/maybe/layout/tag.ejs","hash":"e2f52fdcd2fcdf13eda50a63fd19c5168a3b1f3e","modified":1507528737550},{"_id":"themes/maybe/layout/layout.ejs","hash":"bbbd28c8cf82e79b0f97f8cdedc993ed9e174440","modified":1502796706000},{"_id":"themes/maybe/layout/post.ejs","hash":"445b11af96af5591c828331723ac89d5f6f56e21","modified":1507529128409},{"_id":"source/_posts/arithmetic/array.md","hash":"cd90d728717dd377c52e315d2c4a884849dc50f2","modified":1507305802646},{"_id":"source/_posts/arithmetic/array1.md","hash":"c072bc2e81fb610f028aea54334778416cd9757d","modified":1507305802629},{"_id":"source/_posts/arithmetic/glodBars.md","hash":"c28d485b12fbcd9917b400cbadef49b5bf40109d","modified":1507305802637},{"_id":"source/_posts/arithmetic/JAVA-pValue.md","hash":"028c40ed80f84abbe0e9e0f880d3a17d600fe914","modified":1507305802643},{"_id":"source/_posts/arithmetic/binaryTree.md","hash":"766280d433c9f16c1049528c26132998d517132f","modified":1507305802641},{"_id":"source/_posts/arithmetic/leftString.md","hash":"2d69f74be139b49b8b34724a9fe0845166cae9f3","modified":1507305802654},{"_id":"source/_posts/arithmetic/stringContains.md","hash":"31386bf5ddb4cc328da8e726ab92f34f86de8ac6","modified":1507305802634},{"_id":"source/_posts/life/failure.md","hash":"d572e0c6365635ae2ac1d01066e3b4864966b2dd","modified":1507528584360},{"_id":"source/_posts/arithmetic/linkedList.md","hash":"a26438efb5d9eee44cd47b8cfc8c15508e130dad","modified":1507305802649},{"_id":"source/_posts/life/interview.md","hash":"ae1c671fde3537a6e2f13ebe6a5847544e1e97af","modified":1507521503597},{"_id":"source/_posts/life/chongqing.md","hash":"fb9f95e668744d40fc6e2aee2943b9e312485ad2","modified":1507528581709},{"_id":"source/_posts/life/summary-2016.md","hash":"b15b3c7c3a40aca475dbe9cf72f6906912870701","modified":1507528587807},{"_id":"source/_posts/life/yunnan.md","hash":"3595fb262ca5e71e474ca4f483d1e70267bfa873","modified":1507521501023},{"_id":"source/_posts/note/springbootDynamic.md","hash":"26b9c9f772bc707c80ab9dd17a8b0ad44fad3c1a","modified":1507529013058},{"_id":"source/_posts/note/secretKey.md","hash":"da82c800bea783160664443a5da0fafef1106286","modified":1504250168000},{"_id":"source/_posts/note/threadLocal.md","hash":"6a66f1f488a76d0859c96ee10f18b0456f45b9c9","modified":1507306457151},{"_id":"source/_posts/note/vimNotes.md","hash":"08cb14891ab7bf8a1577c4be54e78db5a197dd0c","modified":1502796706000},{"_id":"source/_posts/note/redisString.md","hash":"c6f10054d5786a2f6b0968644f790796423e965c","modified":1507305849052},{"_id":"source/_posts/note/zookeeper.md","hash":"f2fe4dad4a397109cbbd039a797ea2de102d22bf","modified":1502796706000},{"_id":"source/_posts/read/GriefGroceryStore.md","hash":"5e270b760dbad759dce89c327e09e0d5b8c9da3e","modified":1502796706000},{"_id":"source/_posts/read/1984.md","hash":"19a787490266891fcec9c5d1eee899f04682db0e","modified":1502796706000},{"_id":"source/_posts/read/crowd.md","hash":"88d77eb906123f1047e63ece096d03ab6e1b6735","modified":1502796706000},{"_id":"source/_posts/read/coreJava.md","hash":"2955b82a0e95153737331a498a3e690d005be470","modified":1502796706000},{"_id":"source/_posts/read/fatherAndSon.md","hash":"30a52dee9d63b61c5cb5cc2365e68ec9ebffc6b5","modified":1502796706000},{"_id":"source/_posts/read/economics.md","hash":"446508ffe4a3625daf833deb32e1b83e344270d3","modified":1502796706000},{"_id":"source/_posts/read/goldenAge.md","hash":"c96420022e590e61c73cb17e41662d73c007408b","modified":1502796706000},{"_id":"source/_posts/read/love.md","hash":"0f557c57a5a51d4d2734a9cfa145d4d057625acb","modified":1502796706000},{"_id":"source/_posts/read/loveYou.md","hash":"f212c22013f27962bf1ab9194b6187c0c787c190","modified":1502796706000},{"_id":"source/_posts/read/thinkInJava.md","hash":"d9c5c8b3d4ab522f72e8c2b2a88e07bfda0daf32","modified":1502796706000},{"_id":"source/_posts/read/silentMajority.md","hash":"75a72bdf136de653876bd8907f9ea8b1f8b09d4d","modified":1506597051327},{"_id":"source/_posts/read/pestis.md","hash":"03e4adf7dce4a47442f43065bbb9b17b285a91ae","modified":1506597314025},{"_id":"source/_posts/read/town.md","hash":"37b5889fe2055d597eba94812d5324be820b70e1","modified":1502796706000},{"_id":"source/_posts/read/tangledSkein.md","hash":"cee997c94a2eadfb48aaa2ed0a8f34450222e508","modified":1507295427846},{"_id":"source/_posts/read/walkAtNight.md","hash":"315f16f86963923a66a6b038333e5632aa03de70","modified":1502796706000},{"_id":"source/_posts/river/RiverIntroduce.md","hash":"99479c466fc993b026de6c5bd237624cf24cbaef","modified":1507307184380},{"_id":"source/_posts/river/aop.md","hash":"ff8ea8de47b476e4a079ef07ce445ca8a303c886","modified":1507305944338},{"_id":"source/_posts/river/cache.md","hash":"3f7d7797b471e83dc23bcccdf1bf6aca1cd96307","modified":1507305944345},{"_id":"source/img/arithmetic/BinaryTree.png","hash":"d9ef674ba717242f55c9c5decf2aae551e207069","modified":1502796706000},{"_id":"source/img/arithmetic/linked.jpg","hash":"df3837050ce67ed7aedfda7a6454e4dedbe3af67","modified":1502796706000},{"_id":"source/img/arithmetic/linked2.jpg","hash":"8f1a60ba2b8a52ce2523601e74876f73535d5ee5","modified":1502796706000},{"_id":"source/img/book/1984.jpg","hash":"657d7f593bd28718d87dfe696463958431e4588d","modified":1502796706000},{"_id":"source/img/book/TangledSkein.jpg","hash":"5411c3b479d8a41427d123f45f8b68faf5cf2725","modified":1507295229000},{"_id":"source/img/book/crowd.png","hash":"c361d7acab3ce2677fe3a36ee7e60a72798ed0b8","modified":1502796706000},{"_id":"source/img/book/fatherAndSon.jpeg","hash":"9e646337ead2f99132e452c8b1d2990ff5bcea6e","modified":1502796706000},{"_id":"source/img/book/coreJavaVolume1.jpeg","hash":"8ac34b32089baa4b522bd353339e79f74a807ca2","modified":1502796706000},{"_id":"source/img/book/love.jpeg","hash":"10370ec4f714a1db9e039eccb697f3755ac51012","modified":1502796706000},{"_id":"source/img/book/goldenAge.jpg","hash":"d74779434ac03d77554ad6b12d2e60c8ab7c42b9","modified":1502796706000},{"_id":"source/img/book/loveYou.jpeg","hash":"b8b1df875965e3064b30cbdeecb507e3c4355371","modified":1502796706000},{"_id":"source/img/book/milk.jpeg","hash":"8689c651dbb9f897e3a5071c4c49c43050a1cae4","modified":1502796706000},{"_id":"source/img/book/thinkingInJava.jpeg","hash":"d06ecc2cc3ed14957e01383288588b83368de1b5","modified":1502796706000},{"_id":"source/img/book/silentMajority.jpeg","hash":"154a59d24ff8c9c4fc7dfe69fd1bd3afad05aa26","modified":1506596898000},{"_id":"source/img/book/town.jpg","hash":"b4b00fda9d63d31b7e60528bbfec5b042c84594e","modified":1502796706000},{"_id":"source/img/book/walkAtNight.jpeg","hash":"c8cc896b67e7757c831896416a16516fdc34edc9","modified":1502796706000},{"_id":"source/img/pvalue/pvalue7.png","hash":"bfc9e87c820598e35401f3e526f6f57101efe170","modified":1502796706000},{"_id":"source/img/note/redisString.png","hash":"a1ecd38c51481ad56ce9378505e9c734df9b25e8","modified":1502796706000},{"_id":"source/img/note/secretkey1.png","hash":"be22f8d379a64a49d2dffa72f4010d5bb6a69e2c","modified":1504249376000},{"_id":"source/img/note/secretkey11.png","hash":"4e36aad5297b9510ee140a49c264648f08ff05e8","modified":1504249796000},{"_id":"source/img/note/secretkey10.png","hash":"a9e6a93bf9fbb48378c094f15c8a0d57368f178c","modified":1504249788000},{"_id":"source/img/note/secretkey13.png","hash":"bd844fe0071827fe03fe41a12fd952db0fc80cac","modified":1504249809000},{"_id":"source/img/note/secretkey14.jpg","hash":"ca2f64a3efe33a0dc67c757d21c187895c5f3d43","modified":1504249815000},{"_id":"source/img/note/secretkey15.png","hash":"c72a7c54229fc249b24deb9febdd734e89cac89c","modified":1504249821000},{"_id":"source/img/note/secretkey16.png","hash":"9752d983379cdd21b2075fd01c8868946fcf9035","modified":1504249826000},{"_id":"source/img/note/secretkey18.png","hash":"52900b1460bd2d4732483bcb5a48d6ea6082eb88","modified":1504249840000},{"_id":"source/img/note/secretkey19.jpg","hash":"67ae9db1b2c2b6b67477ed98e0b3a826a2b3aeaf","modified":1504249846000},{"_id":"source/img/note/secretkey20.png","hash":"50bf4bf5ff3c6eb026c82978b18eb3f5d9af9acd","modified":1504249852000},{"_id":"source/img/note/secretkey3.png","hash":"699bc451171e1be86d7b5319c2000967954d00fe","modified":1504249743000},{"_id":"source/img/note/secretkey2.png","hash":"439d5fd8256f90701519052557d56b122bcb2592","modified":1504249724000},{"_id":"source/img/note/secretkey4.png","hash":"ff2a98019333df6697a12b4a84c970a2c007e8a8","modified":1504249750000},{"_id":"source/img/note/secretkey5.png","hash":"d630a0577a4e8a3c4ad09127272e33888ae2bb43","modified":1504249757000},{"_id":"source/img/note/secretkey6.png","hash":"9403bfe3f2780ea99f387a0eb04c725083959c0a","modified":1504249763000},{"_id":"source/img/note/secretkey8.png","hash":"82d1fc38824a2df7daab49f0e342ccb0d3e704f4","modified":1504249776000},{"_id":"source/img/zookeeper/zookeeper1.jpg","hash":"a0fc99c61a07863e1e2e6578644b9b4c8d7e9a9d","modified":1502796706000},{"_id":"source/img/zookeeper/role.jpg","hash":"d122fcac106bc7683d39df78e0cdfd9872ffdce2","modified":1502796706000},{"_id":"source/img/zookeeper/zookeeper2.jpg","hash":"90d4398129d68d137a308b9b2af2cd85777f5daf","modified":1502796706000},{"_id":"source/img/zookeeper/zookeeperLc2.jpg","hash":"97825787eebfb7f5076792a0022911d45808f24a","modified":1502796706000},{"_id":"source/img/zookeeper/zookeeperLc.jpg","hash":"f0c2c035130233d388a1d5339b9796182e890223","modified":1502796706000},{"_id":"source/img/zookeeper/zookeeperLc3.jpg","hash":"3279498c50ea972f1e5abbad70c0cb634faa2284","modified":1502796706000},{"_id":"source/img/zookeeper/zookeeperLc4.jpg","hash":"83582be653544a3717b8a67199fae5a2e5f871a9","modified":1502796706000},{"_id":"source/img/zookeeper/zookeeperLc5.jpg","hash":"da3a39de610f48d2eba48eb72105b0b11dbb34f3","modified":1502796706000},{"_id":"source/img/zookeeper/zookeeperModel.jpg","hash":"004e3d74e27234ca7a74ac15af37a3bbeac8331d","modified":1502796706000},{"_id":"themes/maybe/source/css/font-awesome.min.css","hash":"a3ee202873390015bbebdce1d4a150c8208043c5","modified":1502796706000},{"_id":"themes/maybe/source/css/highlight.css","hash":"b89f3798b9fdce33ba7618077cfc35a95a20ffe3","modified":1502796706000},{"_id":"themes/maybe/source/css/style.css","hash":"ce7501d5d7ac7a5e5cd4a637e51abf9da3cb3e65","modified":1507306288468},{"_id":"themes/maybe/source/img/photo.png","hash":"dab7b9e06f7a1321ad178288d17ac0cf474e17df","modified":1502796706000},{"_id":"themes/maybe/source/js/base.js","hash":"e1360046dca6b9693822922e1040335a0c13f55c","modified":1502796706000},{"_id":"themes/maybe/source/js/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1502796706000},{"_id":"themes/maybe/layout/_partial/article.ejs","hash":"821b4217e69e633d68749cbdc5e5edf4b2328498","modified":1502796706000},{"_id":"themes/maybe/layout/_partial/books.ejs","hash":"d1f7ad1d231c5890a0448c619e3206172f11da6b","modified":1502796706000},{"_id":"themes/maybe/source/js/jquery.tagcloud.js","hash":"6d20fd10cc7ac4c2c94f206ac3285334b297cbf9","modified":1502796706000},{"_id":"themes/maybe/source/js/highlight.pack.js","hash":"c65d53d610fd48e1fbac66ac096699a4be8860fe","modified":1502796706000},{"_id":"themes/maybe/layout/_partial/info_min.ejs","hash":"c3437e9b7d7e169322e05afed83d43bed8b39c24","modified":1507305386480},{"_id":"themes/maybe/layout/_partial/footer.ejs","hash":"672aab472f9d362e49b56ce44f3b1dd8a975541b","modified":1502796706000},{"_id":"themes/maybe/layout/_partial/info.ejs","hash":"a14ab3735947f3f9696f5371bdbdb17733bfcff8","modified":1502796706000},{"_id":"themes/maybe/layout/_partial/title.ejs","hash":"b4c6a4211513ae837a923847fef107d5787d40a7","modified":1507302738510},{"_id":"themes/maybe/layout/_partial/resume.ejs","hash":"bd559022a17bf00520e5dee65deb1317338bbf02","modified":1502796706000},{"_id":"themes/maybe/layout/_partial/posts.ejs","hash":"40107c5b66386eac974e5f74c69d4c77fd2db0c6","modified":1507529128401},{"_id":"source/img/life/chongqing-bg.jpeg","hash":"c928c23fec7b87485d8452b421ec6e97dcfd153d","modified":1502796706000},{"_id":"source/img/life/chongqing.jpeg","hash":"1dbd3cc765e8647f2c8212885c1f92b7d5fe0da7","modified":1502796706000},{"_id":"source/img/life/yllh.jpeg","hash":"f5d37b61cece1507fff6f3161f9ce37c45d9c732","modified":1502796706000},{"_id":"source/img/pvalue/pvalue1.png","hash":"cee2568e455fd434c2255f9aea92b045c598fd1c","modified":1502796706000},{"_id":"source/img/pvalue/pvalue2.png","hash":"8a4671f34809d8c4fe55a015dc8da626e58d581e","modified":1502796706000},{"_id":"source/img/note/secretkey7.png","hash":"8e0af9de4f099d317045936ec87d9ac54e204af0","modified":1504249769000},{"_id":"source/img/note/secretkey9.png","hash":"fbe2d5f8d7adefd99d85b23e2ad50cd3f67bcfcc","modified":1504249782000},{"_id":"themes/maybe/source/img/favicon.ico","hash":"306c23de9697d77d5a123ecb10eb4b3cf1ac3b49","modified":1502796706000},{"_id":"themes/maybe/source/img/guide.jpeg","hash":"5f82a588eef9afb72264df0e9ea68fe17911dfef","modified":1502796706000},{"_id":"themes/maybe/source/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1502796706000},{"_id":"themes/maybe/source/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1502796706000},{"_id":"themes/maybe/source/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1502796706000},{"_id":"themes/maybe/source/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1502796706000},{"_id":"themes/maybe/source/js/jquery-1.7.1.min.js","hash":"d1e1f3f0828fa66fb5744f42bc912694e06300f9","modified":1502796706000},{"_id":"source/img/book/varietyShop.jpeg","hash":"0198030d9d492b101a5deec63621d9746961aad8","modified":1502796706000},{"_id":"source/img/life/2016-roommate.jpeg","hash":"4e5a47e2d9aef492184e19b93a6b2aa93e029c8e","modified":1502796706000},{"_id":"source/img/life/2016-bg.jpg","hash":"6710230ec17d4bebaaf0f8a457512433abf0dc97","modified":1502796706000},{"_id":"source/img/life/cqupt.jpeg","hash":"e110e3ef0807b93d2549f2ef1b35e66323704cd1","modified":1502796706000},{"_id":"source/img/life/jianshui.jpeg","hash":"9bdbec0a2d39c8e92d4f3dff1ce764f2a751b2b2","modified":1502796706000},{"_id":"source/img/life/fish.jpeg","hash":"b36c84444a40f658a6d5a112989722e925f303fc","modified":1502796706000},{"_id":"source/img/life/qiuwei.jpeg","hash":"fe3f9b98e3a75f067d835c29adc37fc0e32bac5e","modified":1502796706000},{"_id":"source/img/life/myself.jpeg","hash":"2389e4b8d634824404b6a16ac6382f4cd367d180","modified":1502796706000},{"_id":"source/img/pvalue/pvalue5.png","hash":"39a6690b579ee31d1ab6dab8dcc32456aaf787f8","modified":1502796706000},{"_id":"source/img/pvalue/pvalue3.jpeg","hash":"8f7a050e342907a74e3ad35c3e52076eba5ac2f1","modified":1502796706000},{"_id":"source/img/pvalue/pvalue4.png","hash":"bae37ceaaa098f40ac342af9dc676e7dc00e0411","modified":1502796706000},{"_id":"source/img/pvalue/pvalue6.png","hash":"5231c3636459437c1b3e9493dcaa3e82f7e9cb1d","modified":1502796706000},{"_id":"source/img/note/secretkey12.png","hash":"83346c36207aa6533fe4d85afd5855ce702214ce","modified":1504249803000},{"_id":"source/img/note/secretkey17.png","hash":"336ccad5e6a52fbba0577c3f607a65c27e23ddba","modified":1504249833000},{"_id":"themes/maybe/source/img/home-bg.jpg","hash":"990f6f9dd0ecb5348bfcc47305553d58c0d8f326","modified":1502796706000},{"_id":"themes/maybe/source/img/note-bg.jpg","hash":"3e03d6c9590ea59075c7f5538d7da389f640fab6","modified":1502796706000},{"_id":"themes/maybe/source/img/river-bg.jpg","hash":"0e60e28189fff882c534c946b1df6a3f8c164eb1","modified":1502796706000},{"_id":"themes/maybe/source/img/read-bg.jpg","hash":"7fa2822cf1ae346c77f2fbb1a2aecb44899f0178","modified":1502796706000},{"_id":"themes/maybe/source/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1502796706000},{"_id":"themes/maybe/layout/_partial/_widget/author.ejs","hash":"136dcaa261490bd94ce5b2543e2a517ecbc72e2e","modified":1502796706000},{"_id":"themes/maybe/layout/_partial/_widget/color.ejs","hash":"3b14d409ab84f375db489ce0657498971f425257","modified":1502796706000},{"_id":"themes/maybe/layout/_partial/_widget/url.ejs","hash":"87ec086d3544a2bafa0d47e0e8995317ef3b748c","modified":1502796706000},{"_id":"themes/maybe/layout/_partial/post/date.ejs","hash":"1a35973ab623f279b073ca6c526f547afb250906","modified":1502796706000},{"_id":"source/img/life/2016-qunar.jpeg","hash":"076fc1b0b7008e0e183853ebbc5fe8160c704406","modified":1502796706000},{"_id":"source/img/note/ThreadLocal.png","hash":"6b61c575fea70117183e6a9ca554a19d69b2b423","modified":1502796706000},{"_id":"themes/maybe/source/img/life-bg.jpg","hash":"967bc3a78eaf83b9f27fd7e02618083b2446d45c","modified":1502796706000},{"_id":"source/img/book/pestis.jpeg","hash":"ce70a2c5cb44a584dc6ffa256029714d2aad36b7","modified":1506597144000},{"_id":"themes/maybe/source/img/project-bg.jpg","hash":"309aa99f6db30ab07caeeb620e5b3d0f22f326b3","modified":1502796706000},{"_id":"themes/maybe/source/fonts/fontawesome-webfont.svg","hash":"c0522272bbaef2acb3d341912754d6ea2d0ecfc0","modified":1502796706000},{"_id":"themes/maybe/source/img/guide.png","hash":"01385d1071ee75c9e7eb358ec113b9eaaf097bf3","modified":1502796706000},{"_id":"themes/maybe/layout/_partial/_widget/date.ejs","hash":"21d49305881125627db2e5e76fc37067b9356f03","modified":1507302738504}],"Category":[{"name":"read","_id":"cj8g07xl200154kh9r28xa2k3"}],"Data":[],"Page":[],"Post":[{"layout":"post","title":"王文祥的简历","date":"2017-02-12T16:00:00.000Z","type":"resume","_content":"","source":"_posts/resume.md","raw":"---\nlayout: post\ntitle: 王文祥的简历\ndate: 2017/02/13\ntype: resume\n---\n","slug":"resume","published":1,"updated":"2017-08-15T11:31:46.000Z","comments":1,"photos":[],"link":"","_id":"cj8g07xjg00004kh9n4lmhbo3","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"post","title":"人生需要失败","date":"2017-03-17T16:00:00.000Z","original":true,"_content":"\n##### 其实今天的事情远没有标题说的这么严重，但是我确实很重视这次面试。快手的第一次面试。\n\n##### 面试的前半部分非常顺利，聊了一些在去哪儿的工作以及系统。直到面试官问我来快手希望做哪方面的工作。身为一个java开发，居然说最想作算法方面的工作，虽然我极力强调我只是对算法比较感兴趣，实在没有多专业，如果可以我很希望可以往这方面发展。但是面试官还是给了我一道比较专业的算法题。加上后面的一些表现。导致这次面试的失败。\n\n<!--more-->\n\n##### 快手确实是一个我很想去的公司，但是我却没有为这次面试做足够的准备。面试出来以后说不难过是假的。\n##### 人生十有八九都是不如意的，失败也是为了更好的前进。整装待发，继续前进吧。\n#### 附上一张女朋友拍的面试背影\n![面试背影](../../img/life/myself.jpeg)\n\n## 面试算法题\n### 不输入任何参数，尽量精确的计算p值\n##### 解题过程现在还不是很会，和概率论和积分有关，好好看看再记录下来吧。\n### 偶数的数组里面有一些正数，分成两个大小一样的子数组，两个数组之和尽量相等\n##### [解题思路](../../arithmetic/array1/)","source":"_posts/life/failure.md","raw":"---\nlayout: post\ntitle: 人生需要失败\ndate: 2017/03/18\noriginal: true\ntags: [life, index]\n---\n\n##### 其实今天的事情远没有标题说的这么严重，但是我确实很重视这次面试。快手的第一次面试。\n\n##### 面试的前半部分非常顺利，聊了一些在去哪儿的工作以及系统。直到面试官问我来快手希望做哪方面的工作。身为一个java开发，居然说最想作算法方面的工作，虽然我极力强调我只是对算法比较感兴趣，实在没有多专业，如果可以我很希望可以往这方面发展。但是面试官还是给了我一道比较专业的算法题。加上后面的一些表现。导致这次面试的失败。\n\n<!--more-->\n\n##### 快手确实是一个我很想去的公司，但是我却没有为这次面试做足够的准备。面试出来以后说不难过是假的。\n##### 人生十有八九都是不如意的，失败也是为了更好的前进。整装待发，继续前进吧。\n#### 附上一张女朋友拍的面试背影\n![面试背影](../../img/life/myself.jpeg)\n\n## 面试算法题\n### 不输入任何参数，尽量精确的计算p值\n##### 解题过程现在还不是很会，和概率论和积分有关，好好看看再记录下来吧。\n### 偶数的数组里面有一些正数，分成两个大小一样的子数组，两个数组之和尽量相等\n##### [解题思路](../../arithmetic/array1/)","slug":"life/failure","published":1,"updated":"2017-10-09T05:56:24.360Z","_id":"cj8g07xkd000b4kh972c7v05f","comments":1,"photos":[],"link":"","content":"<h5 id=\"其实今天的事情远没有标题说的这么严重，但是我确实很重视这次面试。快手的第一次面试。\"><a href=\"#其实今天的事情远没有标题说的这么严重，但是我确实很重视这次面试。快手的第一次面试。\" class=\"headerlink\" title=\"其实今天的事情远没有标题说的这么严重，但是我确实很重视这次面试。快手的第一次面试。\"></a>其实今天的事情远没有标题说的这么严重，但是我确实很重视这次面试。快手的第一次面试。</h5><h5 id=\"面试的前半部分非常顺利，聊了一些在去哪儿的工作以及系统。直到面试官问我来快手希望做哪方面的工作。身为一个java开发，居然说最想作算法方面的工作，虽然我极力强调我只是对算法比较感兴趣，实在没有多专业，如果可以我很希望可以往这方面发展。但是面试官还是给了我一道比较专业的算法题。加上后面的一些表现。导致这次面试的失败。\"><a href=\"#面试的前半部分非常顺利，聊了一些在去哪儿的工作以及系统。直到面试官问我来快手希望做哪方面的工作。身为一个java开发，居然说最想作算法方面的工作，虽然我极力强调我只是对算法比较感兴趣，实在没有多专业，如果可以我很希望可以往这方面发展。但是面试官还是给了我一道比较专业的算法题。加上后面的一些表现。导致这次面试的失败。\" class=\"headerlink\" title=\"面试的前半部分非常顺利，聊了一些在去哪儿的工作以及系统。直到面试官问我来快手希望做哪方面的工作。身为一个java开发，居然说最想作算法方面的工作，虽然我极力强调我只是对算法比较感兴趣，实在没有多专业，如果可以我很希望可以往这方面发展。但是面试官还是给了我一道比较专业的算法题。加上后面的一些表现。导致这次面试的失败。\"></a>面试的前半部分非常顺利，聊了一些在去哪儿的工作以及系统。直到面试官问我来快手希望做哪方面的工作。身为一个java开发，居然说最想作算法方面的工作，虽然我极力强调我只是对算法比较感兴趣，实在没有多专业，如果可以我很希望可以往这方面发展。但是面试官还是给了我一道比较专业的算法题。加上后面的一些表现。导致这次面试的失败。</h5><a id=\"more\"></a>\n<h5 id=\"快手确实是一个我很想去的公司，但是我却没有为这次面试做足够的准备。面试出来以后说不难过是假的。\"><a href=\"#快手确实是一个我很想去的公司，但是我却没有为这次面试做足够的准备。面试出来以后说不难过是假的。\" class=\"headerlink\" title=\"快手确实是一个我很想去的公司，但是我却没有为这次面试做足够的准备。面试出来以后说不难过是假的。\"></a>快手确实是一个我很想去的公司，但是我却没有为这次面试做足够的准备。面试出来以后说不难过是假的。</h5><h5 id=\"人生十有八九都是不如意的，失败也是为了更好的前进。整装待发，继续前进吧。\"><a href=\"#人生十有八九都是不如意的，失败也是为了更好的前进。整装待发，继续前进吧。\" class=\"headerlink\" title=\"人生十有八九都是不如意的，失败也是为了更好的前进。整装待发，继续前进吧。\"></a>人生十有八九都是不如意的，失败也是为了更好的前进。整装待发，继续前进吧。</h5><h4 id=\"附上一张女朋友拍的面试背影\"><a href=\"#附上一张女朋友拍的面试背影\" class=\"headerlink\" title=\"附上一张女朋友拍的面试背影\"></a>附上一张女朋友拍的面试背影</h4><p><img src=\"../../img/life/myself.jpeg\" alt=\"面试背影\"></p>\n<h2 id=\"面试算法题\"><a href=\"#面试算法题\" class=\"headerlink\" title=\"面试算法题\"></a>面试算法题</h2><h3 id=\"不输入任何参数，尽量精确的计算p值\"><a href=\"#不输入任何参数，尽量精确的计算p值\" class=\"headerlink\" title=\"不输入任何参数，尽量精确的计算p值\"></a>不输入任何参数，尽量精确的计算p值</h3><h5 id=\"解题过程现在还不是很会，和概率论和积分有关，好好看看再记录下来吧。\"><a href=\"#解题过程现在还不是很会，和概率论和积分有关，好好看看再记录下来吧。\" class=\"headerlink\" title=\"解题过程现在还不是很会，和概率论和积分有关，好好看看再记录下来吧。\"></a>解题过程现在还不是很会，和概率论和积分有关，好好看看再记录下来吧。</h5><h3 id=\"偶数的数组里面有一些正数，分成两个大小一样的子数组，两个数组之和尽量相等\"><a href=\"#偶数的数组里面有一些正数，分成两个大小一样的子数组，两个数组之和尽量相等\" class=\"headerlink\" title=\"偶数的数组里面有一些正数，分成两个大小一样的子数组，两个数组之和尽量相等\"></a>偶数的数组里面有一些正数，分成两个大小一样的子数组，两个数组之和尽量相等</h3><h5 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a><a href=\"../../arithmetic/array1/\">解题思路</a></h5>","site":{"data":{}},"excerpt":"<h5 id=\"其实今天的事情远没有标题说的这么严重，但是我确实很重视这次面试。快手的第一次面试。\"><a href=\"#其实今天的事情远没有标题说的这么严重，但是我确实很重视这次面试。快手的第一次面试。\" class=\"headerlink\" title=\"其实今天的事情远没有标题说的这么严重，但是我确实很重视这次面试。快手的第一次面试。\"></a>其实今天的事情远没有标题说的这么严重，但是我确实很重视这次面试。快手的第一次面试。</h5><h5 id=\"面试的前半部分非常顺利，聊了一些在去哪儿的工作以及系统。直到面试官问我来快手希望做哪方面的工作。身为一个java开发，居然说最想作算法方面的工作，虽然我极力强调我只是对算法比较感兴趣，实在没有多专业，如果可以我很希望可以往这方面发展。但是面试官还是给了我一道比较专业的算法题。加上后面的一些表现。导致这次面试的失败。\"><a href=\"#面试的前半部分非常顺利，聊了一些在去哪儿的工作以及系统。直到面试官问我来快手希望做哪方面的工作。身为一个java开发，居然说最想作算法方面的工作，虽然我极力强调我只是对算法比较感兴趣，实在没有多专业，如果可以我很希望可以往这方面发展。但是面试官还是给了我一道比较专业的算法题。加上后面的一些表现。导致这次面试的失败。\" class=\"headerlink\" title=\"面试的前半部分非常顺利，聊了一些在去哪儿的工作以及系统。直到面试官问我来快手希望做哪方面的工作。身为一个java开发，居然说最想作算法方面的工作，虽然我极力强调我只是对算法比较感兴趣，实在没有多专业，如果可以我很希望可以往这方面发展。但是面试官还是给了我一道比较专业的算法题。加上后面的一些表现。导致这次面试的失败。\"></a>面试的前半部分非常顺利，聊了一些在去哪儿的工作以及系统。直到面试官问我来快手希望做哪方面的工作。身为一个java开发，居然说最想作算法方面的工作，虽然我极力强调我只是对算法比较感兴趣，实在没有多专业，如果可以我很希望可以往这方面发展。但是面试官还是给了我一道比较专业的算法题。加上后面的一些表现。导致这次面试的失败。</h5>","more":"<h5 id=\"快手确实是一个我很想去的公司，但是我却没有为这次面试做足够的准备。面试出来以后说不难过是假的。\"><a href=\"#快手确实是一个我很想去的公司，但是我却没有为这次面试做足够的准备。面试出来以后说不难过是假的。\" class=\"headerlink\" title=\"快手确实是一个我很想去的公司，但是我却没有为这次面试做足够的准备。面试出来以后说不难过是假的。\"></a>快手确实是一个我很想去的公司，但是我却没有为这次面试做足够的准备。面试出来以后说不难过是假的。</h5><h5 id=\"人生十有八九都是不如意的，失败也是为了更好的前进。整装待发，继续前进吧。\"><a href=\"#人生十有八九都是不如意的，失败也是为了更好的前进。整装待发，继续前进吧。\" class=\"headerlink\" title=\"人生十有八九都是不如意的，失败也是为了更好的前进。整装待发，继续前进吧。\"></a>人生十有八九都是不如意的，失败也是为了更好的前进。整装待发，继续前进吧。</h5><h4 id=\"附上一张女朋友拍的面试背影\"><a href=\"#附上一张女朋友拍的面试背影\" class=\"headerlink\" title=\"附上一张女朋友拍的面试背影\"></a>附上一张女朋友拍的面试背影</h4><p><img src=\"../../img/life/myself.jpeg\" alt=\"面试背影\"></p>\n<h2 id=\"面试算法题\"><a href=\"#面试算法题\" class=\"headerlink\" title=\"面试算法题\"></a>面试算法题</h2><h3 id=\"不输入任何参数，尽量精确的计算p值\"><a href=\"#不输入任何参数，尽量精确的计算p值\" class=\"headerlink\" title=\"不输入任何参数，尽量精确的计算p值\"></a>不输入任何参数，尽量精确的计算p值</h3><h5 id=\"解题过程现在还不是很会，和概率论和积分有关，好好看看再记录下来吧。\"><a href=\"#解题过程现在还不是很会，和概率论和积分有关，好好看看再记录下来吧。\" class=\"headerlink\" title=\"解题过程现在还不是很会，和概率论和积分有关，好好看看再记录下来吧。\"></a>解题过程现在还不是很会，和概率论和积分有关，好好看看再记录下来吧。</h5><h3 id=\"偶数的数组里面有一些正数，分成两个大小一样的子数组，两个数组之和尽量相等\"><a href=\"#偶数的数组里面有一些正数，分成两个大小一样的子数组，两个数组之和尽量相等\" class=\"headerlink\" title=\"偶数的数组里面有一些正数，分成两个大小一样的子数组，两个数组之和尽量相等\"></a>偶数的数组里面有一些正数，分成两个大小一样的子数组，两个数组之和尽量相等</h3><h5 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a><a href=\"../../arithmetic/array1/\">解题思路</a></h5>"},{"layout":"post","title":"最近的一些面试感受","date":"2017-08-30T16:00:00.000Z","original":true,"_content":"\n##### 　　自从7月份从去哪儿出来以后，这段时间一直在陆陆续续的面试一些公司。包括58、京东、滴滴、美团、阿里。面试的过程既痛苦又开心，最近也是感受颇多。希望能够在记录下来，激励自己不断学习、前进。\n<!--more-->\n\n### 　　58、京东、滴滴、美团\n##### 　　这几家公司面试的时间比较早，在7月份就已经面试完成。\n##### 　　其中58是去哪儿出来以后面试的第一家公司，基本上投了简历以后马上就有人给我打电话通知面试。然后面试得过程其实还算正常，但是二面回去等通知（感觉三面就已经是hr面了），二面结束的时候面试官给我的评价是技术还行，但是感觉不太踏实。后等了一个星期没有结果，联系面试官告知没有通过。给我的反馈是感觉基础有点差。\n\n##### 　　京东的面试也是在一天之内完成了，大大小小进过了4、5轮面试。过程还算顺利。只是hr好像不太待见我们，因为京东的薪资普遍偏低，可能hr自己也感觉我不太能够接受他们给的薪资。但是因为面试官很看好我，给了我很多帮组，包括帮我去争取额外的级别和薪资。以及在我拒绝了hr的offer还给了一个星期的考虑时间。加上我之后对京东福利的一些了解，所以现在对京东的印象是非常好的。\n\n##### 　　滴滴是拿到offer并且接受了。企业级事业部-私车同行。还是很有挑战的。\n\n##### 　　美团比较遗憾，走到了3面，也和hr聊了薪资。hr也说了给我催offer。但是还是没有拿到offer。这个比较坑了。然后就是吐槽一下美团的办事效率吧。\n\n##### 　　阿里是最心疼的。一直从7月份面试到今天，一共面了6轮，3个部门。最终还是没有拿到offer。也是阿里的面试让我感触很多，发现自己的不足。阿里的面试过程中，最大的问题还是在于之前qunar的工作内容，系统设计，没能很好的表达清楚。对于系统的一些难点，以及遇到的一些问题，没能很好的回答清楚。其实如果抱着完成任务的心态去处理事情，会发现很多事情都很简单。但是如果你仔细去钻研的话，会发现自己有很多东西都明白其原理和过程。之前的工作可能就缺少了这份钻研，以及自己的总结能力有待提高。导致对于之前的系统的认识还是停留在很表面的层次。这是我最想改正的地方。也很感谢阿里的这几轮面试，真的是面累了，心很累，报的希望越大，失望也越大。所以还是需要静下心来好好钻研与学习。阿里来年再战！！！","source":"_posts/life/interview.md","raw":"---\nlayout: post\ntitle: 最近的一些面试感受\ndate: 2017/08/31\noriginal: true\ntags: [life, index]\n---\n\n##### 　　自从7月份从去哪儿出来以后，这段时间一直在陆陆续续的面试一些公司。包括58、京东、滴滴、美团、阿里。面试的过程既痛苦又开心，最近也是感受颇多。希望能够在记录下来，激励自己不断学习、前进。\n<!--more-->\n\n### 　　58、京东、滴滴、美团\n##### 　　这几家公司面试的时间比较早，在7月份就已经面试完成。\n##### 　　其中58是去哪儿出来以后面试的第一家公司，基本上投了简历以后马上就有人给我打电话通知面试。然后面试得过程其实还算正常，但是二面回去等通知（感觉三面就已经是hr面了），二面结束的时候面试官给我的评价是技术还行，但是感觉不太踏实。后等了一个星期没有结果，联系面试官告知没有通过。给我的反馈是感觉基础有点差。\n\n##### 　　京东的面试也是在一天之内完成了，大大小小进过了4、5轮面试。过程还算顺利。只是hr好像不太待见我们，因为京东的薪资普遍偏低，可能hr自己也感觉我不太能够接受他们给的薪资。但是因为面试官很看好我，给了我很多帮组，包括帮我去争取额外的级别和薪资。以及在我拒绝了hr的offer还给了一个星期的考虑时间。加上我之后对京东福利的一些了解，所以现在对京东的印象是非常好的。\n\n##### 　　滴滴是拿到offer并且接受了。企业级事业部-私车同行。还是很有挑战的。\n\n##### 　　美团比较遗憾，走到了3面，也和hr聊了薪资。hr也说了给我催offer。但是还是没有拿到offer。这个比较坑了。然后就是吐槽一下美团的办事效率吧。\n\n##### 　　阿里是最心疼的。一直从7月份面试到今天，一共面了6轮，3个部门。最终还是没有拿到offer。也是阿里的面试让我感触很多，发现自己的不足。阿里的面试过程中，最大的问题还是在于之前qunar的工作内容，系统设计，没能很好的表达清楚。对于系统的一些难点，以及遇到的一些问题，没能很好的回答清楚。其实如果抱着完成任务的心态去处理事情，会发现很多事情都很简单。但是如果你仔细去钻研的话，会发现自己有很多东西都明白其原理和过程。之前的工作可能就缺少了这份钻研，以及自己的总结能力有待提高。导致对于之前的系统的认识还是停留在很表面的层次。这是我最想改正的地方。也很感谢阿里的这几轮面试，真的是面累了，心很累，报的希望越大，失望也越大。所以还是需要静下心来好好钻研与学习。阿里来年再战！！！","slug":"life/interview","published":1,"updated":"2017-10-09T03:58:23.597Z","_id":"cj8g07xkl000c4kh90yhlzlzy","comments":1,"photos":[],"link":"","content":"<h5 id=\"自从7月份从去哪儿出来以后，这段时间一直在陆陆续续的面试一些公司。包括58、京东、滴滴、美团、阿里。面试的过程既痛苦又开心，最近也是感受颇多。希望能够在记录下来，激励自己不断学习、前进。\"><a href=\"#自从7月份从去哪儿出来以后，这段时间一直在陆陆续续的面试一些公司。包括58、京东、滴滴、美团、阿里。面试的过程既痛苦又开心，最近也是感受颇多。希望能够在记录下来，激励自己不断学习、前进。\" class=\"headerlink\" title=\"　　自从7月份从去哪儿出来以后，这段时间一直在陆陆续续的面试一些公司。包括58、京东、滴滴、美团、阿里。面试的过程既痛苦又开心，最近也是感受颇多。希望能够在记录下来，激励自己不断学习、前进。\"></a>　　自从7月份从去哪儿出来以后，这段时间一直在陆陆续续的面试一些公司。包括58、京东、滴滴、美团、阿里。面试的过程既痛苦又开心，最近也是感受颇多。希望能够在记录下来，激励自己不断学习、前进。</h5><a id=\"more\"></a>\n<h3 id=\"58、京东、滴滴、美团\"><a href=\"#58、京东、滴滴、美团\" class=\"headerlink\" title=\"　　58、京东、滴滴、美团\"></a>　　58、京东、滴滴、美团</h3><h5 id=\"这几家公司面试的时间比较早，在7月份就已经面试完成。\"><a href=\"#这几家公司面试的时间比较早，在7月份就已经面试完成。\" class=\"headerlink\" title=\"　　这几家公司面试的时间比较早，在7月份就已经面试完成。\"></a>　　这几家公司面试的时间比较早，在7月份就已经面试完成。</h5><h5 id=\"其中58是去哪儿出来以后面试的第一家公司，基本上投了简历以后马上就有人给我打电话通知面试。然后面试得过程其实还算正常，但是二面回去等通知（感觉三面就已经是hr面了），二面结束的时候面试官给我的评价是技术还行，但是感觉不太踏实。后等了一个星期没有结果，联系面试官告知没有通过。给我的反馈是感觉基础有点差。\"><a href=\"#其中58是去哪儿出来以后面试的第一家公司，基本上投了简历以后马上就有人给我打电话通知面试。然后面试得过程其实还算正常，但是二面回去等通知（感觉三面就已经是hr面了），二面结束的时候面试官给我的评价是技术还行，但是感觉不太踏实。后等了一个星期没有结果，联系面试官告知没有通过。给我的反馈是感觉基础有点差。\" class=\"headerlink\" title=\"　　其中58是去哪儿出来以后面试的第一家公司，基本上投了简历以后马上就有人给我打电话通知面试。然后面试得过程其实还算正常，但是二面回去等通知（感觉三面就已经是hr面了），二面结束的时候面试官给我的评价是技术还行，但是感觉不太踏实。后等了一个星期没有结果，联系面试官告知没有通过。给我的反馈是感觉基础有点差。\"></a>　　其中58是去哪儿出来以后面试的第一家公司，基本上投了简历以后马上就有人给我打电话通知面试。然后面试得过程其实还算正常，但是二面回去等通知（感觉三面就已经是hr面了），二面结束的时候面试官给我的评价是技术还行，但是感觉不太踏实。后等了一个星期没有结果，联系面试官告知没有通过。给我的反馈是感觉基础有点差。</h5><h5 id=\"京东的面试也是在一天之内完成了，大大小小进过了4、5轮面试。过程还算顺利。只是hr好像不太待见我们，因为京东的薪资普遍偏低，可能hr自己也感觉我不太能够接受他们给的薪资。但是因为面试官很看好我，给了我很多帮组，包括帮我去争取额外的级别和薪资。以及在我拒绝了hr的offer还给了一个星期的考虑时间。加上我之后对京东福利的一些了解，所以现在对京东的印象是非常好的。\"><a href=\"#京东的面试也是在一天之内完成了，大大小小进过了4、5轮面试。过程还算顺利。只是hr好像不太待见我们，因为京东的薪资普遍偏低，可能hr自己也感觉我不太能够接受他们给的薪资。但是因为面试官很看好我，给了我很多帮组，包括帮我去争取额外的级别和薪资。以及在我拒绝了hr的offer还给了一个星期的考虑时间。加上我之后对京东福利的一些了解，所以现在对京东的印象是非常好的。\" class=\"headerlink\" title=\"　　京东的面试也是在一天之内完成了，大大小小进过了4、5轮面试。过程还算顺利。只是hr好像不太待见我们，因为京东的薪资普遍偏低，可能hr自己也感觉我不太能够接受他们给的薪资。但是因为面试官很看好我，给了我很多帮组，包括帮我去争取额外的级别和薪资。以及在我拒绝了hr的offer还给了一个星期的考虑时间。加上我之后对京东福利的一些了解，所以现在对京东的印象是非常好的。\"></a>　　京东的面试也是在一天之内完成了，大大小小进过了4、5轮面试。过程还算顺利。只是hr好像不太待见我们，因为京东的薪资普遍偏低，可能hr自己也感觉我不太能够接受他们给的薪资。但是因为面试官很看好我，给了我很多帮组，包括帮我去争取额外的级别和薪资。以及在我拒绝了hr的offer还给了一个星期的考虑时间。加上我之后对京东福利的一些了解，所以现在对京东的印象是非常好的。</h5><h5 id=\"滴滴是拿到offer并且接受了。企业级事业部-私车同行。还是很有挑战的。\"><a href=\"#滴滴是拿到offer并且接受了。企业级事业部-私车同行。还是很有挑战的。\" class=\"headerlink\" title=\"　　滴滴是拿到offer并且接受了。企业级事业部-私车同行。还是很有挑战的。\"></a>　　滴滴是拿到offer并且接受了。企业级事业部-私车同行。还是很有挑战的。</h5><h5 id=\"美团比较遗憾，走到了3面，也和hr聊了薪资。hr也说了给我催offer。但是还是没有拿到offer。这个比较坑了。然后就是吐槽一下美团的办事效率吧。\"><a href=\"#美团比较遗憾，走到了3面，也和hr聊了薪资。hr也说了给我催offer。但是还是没有拿到offer。这个比较坑了。然后就是吐槽一下美团的办事效率吧。\" class=\"headerlink\" title=\"　　美团比较遗憾，走到了3面，也和hr聊了薪资。hr也说了给我催offer。但是还是没有拿到offer。这个比较坑了。然后就是吐槽一下美团的办事效率吧。\"></a>　　美团比较遗憾，走到了3面，也和hr聊了薪资。hr也说了给我催offer。但是还是没有拿到offer。这个比较坑了。然后就是吐槽一下美团的办事效率吧。</h5><h5 id=\"阿里是最心疼的。一直从7月份面试到今天，一共面了6轮，3个部门。最终还是没有拿到offer。也是阿里的面试让我感触很多，发现自己的不足。阿里的面试过程中，最大的问题还是在于之前qunar的工作内容，系统设计，没能很好的表达清楚。对于系统的一些难点，以及遇到的一些问题，没能很好的回答清楚。其实如果抱着完成任务的心态去处理事情，会发现很多事情都很简单。但是如果你仔细去钻研的话，会发现自己有很多东西都明白其原理和过程。之前的工作可能就缺少了这份钻研，以及自己的总结能力有待提高。导致对于之前的系统的认识还是停留在很表面的层次。这是我最想改正的地方。也很感谢阿里的这几轮面试，真的是面累了，心很累，报的希望越大，失望也越大。所以还是需要静下心来好好钻研与学习。阿里来年再战！！！\"><a href=\"#阿里是最心疼的。一直从7月份面试到今天，一共面了6轮，3个部门。最终还是没有拿到offer。也是阿里的面试让我感触很多，发现自己的不足。阿里的面试过程中，最大的问题还是在于之前qunar的工作内容，系统设计，没能很好的表达清楚。对于系统的一些难点，以及遇到的一些问题，没能很好的回答清楚。其实如果抱着完成任务的心态去处理事情，会发现很多事情都很简单。但是如果你仔细去钻研的话，会发现自己有很多东西都明白其原理和过程。之前的工作可能就缺少了这份钻研，以及自己的总结能力有待提高。导致对于之前的系统的认识还是停留在很表面的层次。这是我最想改正的地方。也很感谢阿里的这几轮面试，真的是面累了，心很累，报的希望越大，失望也越大。所以还是需要静下心来好好钻研与学习。阿里来年再战！！！\" class=\"headerlink\" title=\"　　阿里是最心疼的。一直从7月份面试到今天，一共面了6轮，3个部门。最终还是没有拿到offer。也是阿里的面试让我感触很多，发现自己的不足。阿里的面试过程中，最大的问题还是在于之前qunar的工作内容，系统设计，没能很好的表达清楚。对于系统的一些难点，以及遇到的一些问题，没能很好的回答清楚。其实如果抱着完成任务的心态去处理事情，会发现很多事情都很简单。但是如果你仔细去钻研的话，会发现自己有很多东西都明白其原理和过程。之前的工作可能就缺少了这份钻研，以及自己的总结能力有待提高。导致对于之前的系统的认识还是停留在很表面的层次。这是我最想改正的地方。也很感谢阿里的这几轮面试，真的是面累了，心很累，报的希望越大，失望也越大。所以还是需要静下心来好好钻研与学习。阿里来年再战！！！\"></a>　　阿里是最心疼的。一直从7月份面试到今天，一共面了6轮，3个部门。最终还是没有拿到offer。也是阿里的面试让我感触很多，发现自己的不足。阿里的面试过程中，最大的问题还是在于之前qunar的工作内容，系统设计，没能很好的表达清楚。对于系统的一些难点，以及遇到的一些问题，没能很好的回答清楚。其实如果抱着完成任务的心态去处理事情，会发现很多事情都很简单。但是如果你仔细去钻研的话，会发现自己有很多东西都明白其原理和过程。之前的工作可能就缺少了这份钻研，以及自己的总结能力有待提高。导致对于之前的系统的认识还是停留在很表面的层次。这是我最想改正的地方。也很感谢阿里的这几轮面试，真的是面累了，心很累，报的希望越大，失望也越大。所以还是需要静下心来好好钻研与学习。阿里来年再战！！！</h5>","site":{"data":{}},"excerpt":"<h5 id=\"自从7月份从去哪儿出来以后，这段时间一直在陆陆续续的面试一些公司。包括58、京东、滴滴、美团、阿里。面试的过程既痛苦又开心，最近也是感受颇多。希望能够在记录下来，激励自己不断学习、前进。\"><a href=\"#自从7月份从去哪儿出来以后，这段时间一直在陆陆续续的面试一些公司。包括58、京东、滴滴、美团、阿里。面试的过程既痛苦又开心，最近也是感受颇多。希望能够在记录下来，激励自己不断学习、前进。\" class=\"headerlink\" title=\"　　自从7月份从去哪儿出来以后，这段时间一直在陆陆续续的面试一些公司。包括58、京东、滴滴、美团、阿里。面试的过程既痛苦又开心，最近也是感受颇多。希望能够在记录下来，激励自己不断学习、前进。\"></a>　　自从7月份从去哪儿出来以后，这段时间一直在陆陆续续的面试一些公司。包括58、京东、滴滴、美团、阿里。面试的过程既痛苦又开心，最近也是感受颇多。希望能够在记录下来，激励自己不断学习、前进。</h5>","more":"<h3 id=\"58、京东、滴滴、美团\"><a href=\"#58、京东、滴滴、美团\" class=\"headerlink\" title=\"　　58、京东、滴滴、美团\"></a>　　58、京东、滴滴、美团</h3><h5 id=\"这几家公司面试的时间比较早，在7月份就已经面试完成。\"><a href=\"#这几家公司面试的时间比较早，在7月份就已经面试完成。\" class=\"headerlink\" title=\"　　这几家公司面试的时间比较早，在7月份就已经面试完成。\"></a>　　这几家公司面试的时间比较早，在7月份就已经面试完成。</h5><h5 id=\"其中58是去哪儿出来以后面试的第一家公司，基本上投了简历以后马上就有人给我打电话通知面试。然后面试得过程其实还算正常，但是二面回去等通知（感觉三面就已经是hr面了），二面结束的时候面试官给我的评价是技术还行，但是感觉不太踏实。后等了一个星期没有结果，联系面试官告知没有通过。给我的反馈是感觉基础有点差。\"><a href=\"#其中58是去哪儿出来以后面试的第一家公司，基本上投了简历以后马上就有人给我打电话通知面试。然后面试得过程其实还算正常，但是二面回去等通知（感觉三面就已经是hr面了），二面结束的时候面试官给我的评价是技术还行，但是感觉不太踏实。后等了一个星期没有结果，联系面试官告知没有通过。给我的反馈是感觉基础有点差。\" class=\"headerlink\" title=\"　　其中58是去哪儿出来以后面试的第一家公司，基本上投了简历以后马上就有人给我打电话通知面试。然后面试得过程其实还算正常，但是二面回去等通知（感觉三面就已经是hr面了），二面结束的时候面试官给我的评价是技术还行，但是感觉不太踏实。后等了一个星期没有结果，联系面试官告知没有通过。给我的反馈是感觉基础有点差。\"></a>　　其中58是去哪儿出来以后面试的第一家公司，基本上投了简历以后马上就有人给我打电话通知面试。然后面试得过程其实还算正常，但是二面回去等通知（感觉三面就已经是hr面了），二面结束的时候面试官给我的评价是技术还行，但是感觉不太踏实。后等了一个星期没有结果，联系面试官告知没有通过。给我的反馈是感觉基础有点差。</h5><h5 id=\"京东的面试也是在一天之内完成了，大大小小进过了4、5轮面试。过程还算顺利。只是hr好像不太待见我们，因为京东的薪资普遍偏低，可能hr自己也感觉我不太能够接受他们给的薪资。但是因为面试官很看好我，给了我很多帮组，包括帮我去争取额外的级别和薪资。以及在我拒绝了hr的offer还给了一个星期的考虑时间。加上我之后对京东福利的一些了解，所以现在对京东的印象是非常好的。\"><a href=\"#京东的面试也是在一天之内完成了，大大小小进过了4、5轮面试。过程还算顺利。只是hr好像不太待见我们，因为京东的薪资普遍偏低，可能hr自己也感觉我不太能够接受他们给的薪资。但是因为面试官很看好我，给了我很多帮组，包括帮我去争取额外的级别和薪资。以及在我拒绝了hr的offer还给了一个星期的考虑时间。加上我之后对京东福利的一些了解，所以现在对京东的印象是非常好的。\" class=\"headerlink\" title=\"　　京东的面试也是在一天之内完成了，大大小小进过了4、5轮面试。过程还算顺利。只是hr好像不太待见我们，因为京东的薪资普遍偏低，可能hr自己也感觉我不太能够接受他们给的薪资。但是因为面试官很看好我，给了我很多帮组，包括帮我去争取额外的级别和薪资。以及在我拒绝了hr的offer还给了一个星期的考虑时间。加上我之后对京东福利的一些了解，所以现在对京东的印象是非常好的。\"></a>　　京东的面试也是在一天之内完成了，大大小小进过了4、5轮面试。过程还算顺利。只是hr好像不太待见我们，因为京东的薪资普遍偏低，可能hr自己也感觉我不太能够接受他们给的薪资。但是因为面试官很看好我，给了我很多帮组，包括帮我去争取额外的级别和薪资。以及在我拒绝了hr的offer还给了一个星期的考虑时间。加上我之后对京东福利的一些了解，所以现在对京东的印象是非常好的。</h5><h5 id=\"滴滴是拿到offer并且接受了。企业级事业部-私车同行。还是很有挑战的。\"><a href=\"#滴滴是拿到offer并且接受了。企业级事业部-私车同行。还是很有挑战的。\" class=\"headerlink\" title=\"　　滴滴是拿到offer并且接受了。企业级事业部-私车同行。还是很有挑战的。\"></a>　　滴滴是拿到offer并且接受了。企业级事业部-私车同行。还是很有挑战的。</h5><h5 id=\"美团比较遗憾，走到了3面，也和hr聊了薪资。hr也说了给我催offer。但是还是没有拿到offer。这个比较坑了。然后就是吐槽一下美团的办事效率吧。\"><a href=\"#美团比较遗憾，走到了3面，也和hr聊了薪资。hr也说了给我催offer。但是还是没有拿到offer。这个比较坑了。然后就是吐槽一下美团的办事效率吧。\" class=\"headerlink\" title=\"　　美团比较遗憾，走到了3面，也和hr聊了薪资。hr也说了给我催offer。但是还是没有拿到offer。这个比较坑了。然后就是吐槽一下美团的办事效率吧。\"></a>　　美团比较遗憾，走到了3面，也和hr聊了薪资。hr也说了给我催offer。但是还是没有拿到offer。这个比较坑了。然后就是吐槽一下美团的办事效率吧。</h5><h5 id=\"阿里是最心疼的。一直从7月份面试到今天，一共面了6轮，3个部门。最终还是没有拿到offer。也是阿里的面试让我感触很多，发现自己的不足。阿里的面试过程中，最大的问题还是在于之前qunar的工作内容，系统设计，没能很好的表达清楚。对于系统的一些难点，以及遇到的一些问题，没能很好的回答清楚。其实如果抱着完成任务的心态去处理事情，会发现很多事情都很简单。但是如果你仔细去钻研的话，会发现自己有很多东西都明白其原理和过程。之前的工作可能就缺少了这份钻研，以及自己的总结能力有待提高。导致对于之前的系统的认识还是停留在很表面的层次。这是我最想改正的地方。也很感谢阿里的这几轮面试，真的是面累了，心很累，报的希望越大，失望也越大。所以还是需要静下心来好好钻研与学习。阿里来年再战！！！\"><a href=\"#阿里是最心疼的。一直从7月份面试到今天，一共面了6轮，3个部门。最终还是没有拿到offer。也是阿里的面试让我感触很多，发现自己的不足。阿里的面试过程中，最大的问题还是在于之前qunar的工作内容，系统设计，没能很好的表达清楚。对于系统的一些难点，以及遇到的一些问题，没能很好的回答清楚。其实如果抱着完成任务的心态去处理事情，会发现很多事情都很简单。但是如果你仔细去钻研的话，会发现自己有很多东西都明白其原理和过程。之前的工作可能就缺少了这份钻研，以及自己的总结能力有待提高。导致对于之前的系统的认识还是停留在很表面的层次。这是我最想改正的地方。也很感谢阿里的这几轮面试，真的是面累了，心很累，报的希望越大，失望也越大。所以还是需要静下心来好好钻研与学习。阿里来年再战！！！\" class=\"headerlink\" title=\"　　阿里是最心疼的。一直从7月份面试到今天，一共面了6轮，3个部门。最终还是没有拿到offer。也是阿里的面试让我感触很多，发现自己的不足。阿里的面试过程中，最大的问题还是在于之前qunar的工作内容，系统设计，没能很好的表达清楚。对于系统的一些难点，以及遇到的一些问题，没能很好的回答清楚。其实如果抱着完成任务的心态去处理事情，会发现很多事情都很简单。但是如果你仔细去钻研的话，会发现自己有很多东西都明白其原理和过程。之前的工作可能就缺少了这份钻研，以及自己的总结能力有待提高。导致对于之前的系统的认识还是停留在很表面的层次。这是我最想改正的地方。也很感谢阿里的这几轮面试，真的是面累了，心很累，报的希望越大，失望也越大。所以还是需要静下心来好好钻研与学习。阿里来年再战！！！\"></a>　　阿里是最心疼的。一直从7月份面试到今天，一共面了6轮，3个部门。最终还是没有拿到offer。也是阿里的面试让我感触很多，发现自己的不足。阿里的面试过程中，最大的问题还是在于之前qunar的工作内容，系统设计，没能很好的表达清楚。对于系统的一些难点，以及遇到的一些问题，没能很好的回答清楚。其实如果抱着完成任务的心态去处理事情，会发现很多事情都很简单。但是如果你仔细去钻研的话，会发现自己有很多东西都明白其原理和过程。之前的工作可能就缺少了这份钻研，以及自己的总结能力有待提高。导致对于之前的系统的认识还是停留在很表面的层次。这是我最想改正的地方。也很感谢阿里的这几轮面试，真的是面累了，心很累，报的希望越大，失望也越大。所以还是需要静下心来好好钻研与学习。阿里来年再战！！！</h5>"},{"layout":"post","title":"又到重庆","date":"2017-03-05T16:00:00.000Z","original":true,"img":"life/chongqing-bg.jpeg","_content":"\n##### 　　去年6月份毕业之后，怎么也没有先到这么快又回到的重庆。之前想过很多次，再到重庆的时候会是什么时候，可能是几年后的同学聚会，可能是工作休假去重庆游玩。但是无论怎样，也没有想到仅仅隔了半年就又到了重庆。\n<!--more-->\n\n##### 　　这次去重庆是因为部门的团建，原本计划去韩国或者是成都，投票之后就决定去重庆了（醉了）。其实我去重庆读书的时候，对重庆是没有多少感情的，觉得这个城市很陌生，没有家里好，这种感觉一直持续到大四，直到我离开重庆去北京工作和实习，才发现我已经对重庆有了一种莫名的情感在里面，虽然我没有在这里恋爱。这种情感在我下了飞机以后则更加明显。\n\n##### 　　到达重庆江北机场是在3月3号的凌晨1点，之前的一天我们还在公司卖力的工作。下了飞机以后便往预定的青年旅社赶，但是我们根本不是去休息的，因为我们的重庆之旅才刚刚开始，没有人想早早的睡觉。凌晨1点的重庆已经没有平时的拥堵，但是走在路上，我还是有一种特别熟悉的感觉，我对秋薇说，我好想还是一个学生。\n\n![青年旅舍合影](../../img/life/chongqing.jpeg)    <div class='img-note'>青年旅舍合影</div>\n\n##### 　　我确实变成了一个学生，在我第二天来到重邮之后。公司没有组织大家集体活动，都是各自行动。第二天在离开青舍，找到酒店之后，我和秋薇便直奔重邮。说来很巧，我们住的酒店在解放碑，这里正好有346路公交车直达重邮。一路上的风景还是没有变，路过了南坪，路过了会展中心。其实大学期间我并没有去过重庆的多少地方，因为本身比较宅，加上整天和几个大老爷们待在一起，所以重庆的路我认识的实在不多，这点也被同事们吐槽了。\n\n##### 　　重邮在我眼里几乎就没有变，除了千喜鹤食堂。我顺着数图、老操场、篮球场、千喜鹤来到28栋。不知道是因为这条路太过于熟悉，还是学校变化实在不大，我没有了之前的激动，心情也慢慢平复下来。这一圈走完之后，竟然想着快点离开。当然，离开之前又去了一次\"火山石烫鱼\"。\n\n![重邮新食堂](../../img/life/cqupt.jpeg)    <div class='img-note'>重邮新食堂</div>\n![火山石烫鱼](../../img/life/fish.jpeg)    <div class='img-note'>火山石烫鱼</div>\n\n##### 　　如果说我为什么在离开重邮的时候又喜欢上了重庆，一定是因为那些人，那些同学和朋友。第二天我就见到了磊哥，还是原来的样子，几乎没有变。我们都是性格含蓄的人。因为时间比较紧，只和磊哥聊了一个小时左右，我们说了很多毕业后的感受，没有装逼，没有浮夸，说的都是真心话。磊哥确实变了，变成熟了，不再那么放荡不羁了。直到现在我都在想，我应该和磊哥去喝上几杯的。哎，不知道下次见面是什么时候。\n\n![余磊和刘航](../../img/life/yllh.jpeg)    <div class='img-note'>余磊和刘航</div>\n\n##### 　　按道理来说，重庆应该是比北京更加湿润的。但我的症状却恰恰相反，因为没有唇膏，加上女朋友\"舍不得\"给我买新的，我的嘴唇周围已经干到龟裂。这实在是难受。后来分析可能是因为酒店的房间里面太干燥了。女朋友则比我更惨一些，亲戚来了，加上肚子疼，再加上感冒发烧导致声音沙哑，已经到了不能说话的地步。实在是好过不到哪里去。不过幸好有我的悉心照顾，最后安全返回北京。\n\n![秋薇和我](../../img/life/qiuwei.jpeg)    <div class='img-note'>秋薇和我</div>\n","source":"_posts/life/chongqing.md","raw":"---\nlayout: post\ntitle: 又到重庆\ndate: 2017/03/06\ntags: [life, index]\noriginal: true\nimg: life/chongqing-bg.jpeg\n---\n\n##### 　　去年6月份毕业之后，怎么也没有先到这么快又回到的重庆。之前想过很多次，再到重庆的时候会是什么时候，可能是几年后的同学聚会，可能是工作休假去重庆游玩。但是无论怎样，也没有想到仅仅隔了半年就又到了重庆。\n<!--more-->\n\n##### 　　这次去重庆是因为部门的团建，原本计划去韩国或者是成都，投票之后就决定去重庆了（醉了）。其实我去重庆读书的时候，对重庆是没有多少感情的，觉得这个城市很陌生，没有家里好，这种感觉一直持续到大四，直到我离开重庆去北京工作和实习，才发现我已经对重庆有了一种莫名的情感在里面，虽然我没有在这里恋爱。这种情感在我下了飞机以后则更加明显。\n\n##### 　　到达重庆江北机场是在3月3号的凌晨1点，之前的一天我们还在公司卖力的工作。下了飞机以后便往预定的青年旅社赶，但是我们根本不是去休息的，因为我们的重庆之旅才刚刚开始，没有人想早早的睡觉。凌晨1点的重庆已经没有平时的拥堵，但是走在路上，我还是有一种特别熟悉的感觉，我对秋薇说，我好想还是一个学生。\n\n![青年旅舍合影](../../img/life/chongqing.jpeg)    <div class='img-note'>青年旅舍合影</div>\n\n##### 　　我确实变成了一个学生，在我第二天来到重邮之后。公司没有组织大家集体活动，都是各自行动。第二天在离开青舍，找到酒店之后，我和秋薇便直奔重邮。说来很巧，我们住的酒店在解放碑，这里正好有346路公交车直达重邮。一路上的风景还是没有变，路过了南坪，路过了会展中心。其实大学期间我并没有去过重庆的多少地方，因为本身比较宅，加上整天和几个大老爷们待在一起，所以重庆的路我认识的实在不多，这点也被同事们吐槽了。\n\n##### 　　重邮在我眼里几乎就没有变，除了千喜鹤食堂。我顺着数图、老操场、篮球场、千喜鹤来到28栋。不知道是因为这条路太过于熟悉，还是学校变化实在不大，我没有了之前的激动，心情也慢慢平复下来。这一圈走完之后，竟然想着快点离开。当然，离开之前又去了一次\"火山石烫鱼\"。\n\n![重邮新食堂](../../img/life/cqupt.jpeg)    <div class='img-note'>重邮新食堂</div>\n![火山石烫鱼](../../img/life/fish.jpeg)    <div class='img-note'>火山石烫鱼</div>\n\n##### 　　如果说我为什么在离开重邮的时候又喜欢上了重庆，一定是因为那些人，那些同学和朋友。第二天我就见到了磊哥，还是原来的样子，几乎没有变。我们都是性格含蓄的人。因为时间比较紧，只和磊哥聊了一个小时左右，我们说了很多毕业后的感受，没有装逼，没有浮夸，说的都是真心话。磊哥确实变了，变成熟了，不再那么放荡不羁了。直到现在我都在想，我应该和磊哥去喝上几杯的。哎，不知道下次见面是什么时候。\n\n![余磊和刘航](../../img/life/yllh.jpeg)    <div class='img-note'>余磊和刘航</div>\n\n##### 　　按道理来说，重庆应该是比北京更加湿润的。但我的症状却恰恰相反，因为没有唇膏，加上女朋友\"舍不得\"给我买新的，我的嘴唇周围已经干到龟裂。这实在是难受。后来分析可能是因为酒店的房间里面太干燥了。女朋友则比我更惨一些，亲戚来了，加上肚子疼，再加上感冒发烧导致声音沙哑，已经到了不能说话的地步。实在是好过不到哪里去。不过幸好有我的悉心照顾，最后安全返回北京。\n\n![秋薇和我](../../img/life/qiuwei.jpeg)    <div class='img-note'>秋薇和我</div>\n","slug":"life/chongqing","published":1,"updated":"2017-10-09T05:56:21.709Z","_id":"cj8g07xko000g4kh90lmowpxv","comments":1,"photos":[],"link":"","content":"<h5 id=\"去年6月份毕业之后，怎么也没有先到这么快又回到的重庆。之前想过很多次，再到重庆的时候会是什么时候，可能是几年后的同学聚会，可能是工作休假去重庆游玩。但是无论怎样，也没有想到仅仅隔了半年就又到了重庆。\"><a href=\"#去年6月份毕业之后，怎么也没有先到这么快又回到的重庆。之前想过很多次，再到重庆的时候会是什么时候，可能是几年后的同学聚会，可能是工作休假去重庆游玩。但是无论怎样，也没有想到仅仅隔了半年就又到了重庆。\" class=\"headerlink\" title=\"　　去年6月份毕业之后，怎么也没有先到这么快又回到的重庆。之前想过很多次，再到重庆的时候会是什么时候，可能是几年后的同学聚会，可能是工作休假去重庆游玩。但是无论怎样，也没有想到仅仅隔了半年就又到了重庆。\"></a>　　去年6月份毕业之后，怎么也没有先到这么快又回到的重庆。之前想过很多次，再到重庆的时候会是什么时候，可能是几年后的同学聚会，可能是工作休假去重庆游玩。但是无论怎样，也没有想到仅仅隔了半年就又到了重庆。</h5><a id=\"more\"></a>\n<h5 id=\"这次去重庆是因为部门的团建，原本计划去韩国或者是成都，投票之后就决定去重庆了（醉了）。其实我去重庆读书的时候，对重庆是没有多少感情的，觉得这个城市很陌生，没有家里好，这种感觉一直持续到大四，直到我离开重庆去北京工作和实习，才发现我已经对重庆有了一种莫名的情感在里面，虽然我没有在这里恋爱。这种情感在我下了飞机以后则更加明显。\"><a href=\"#这次去重庆是因为部门的团建，原本计划去韩国或者是成都，投票之后就决定去重庆了（醉了）。其实我去重庆读书的时候，对重庆是没有多少感情的，觉得这个城市很陌生，没有家里好，这种感觉一直持续到大四，直到我离开重庆去北京工作和实习，才发现我已经对重庆有了一种莫名的情感在里面，虽然我没有在这里恋爱。这种情感在我下了飞机以后则更加明显。\" class=\"headerlink\" title=\"　　这次去重庆是因为部门的团建，原本计划去韩国或者是成都，投票之后就决定去重庆了（醉了）。其实我去重庆读书的时候，对重庆是没有多少感情的，觉得这个城市很陌生，没有家里好，这种感觉一直持续到大四，直到我离开重庆去北京工作和实习，才发现我已经对重庆有了一种莫名的情感在里面，虽然我没有在这里恋爱。这种情感在我下了飞机以后则更加明显。\"></a>　　这次去重庆是因为部门的团建，原本计划去韩国或者是成都，投票之后就决定去重庆了（醉了）。其实我去重庆读书的时候，对重庆是没有多少感情的，觉得这个城市很陌生，没有家里好，这种感觉一直持续到大四，直到我离开重庆去北京工作和实习，才发现我已经对重庆有了一种莫名的情感在里面，虽然我没有在这里恋爱。这种情感在我下了飞机以后则更加明显。</h5><h5 id=\"到达重庆江北机场是在3月3号的凌晨1点，之前的一天我们还在公司卖力的工作。下了飞机以后便往预定的青年旅社赶，但是我们根本不是去休息的，因为我们的重庆之旅才刚刚开始，没有人想早早的睡觉。凌晨1点的重庆已经没有平时的拥堵，但是走在路上，我还是有一种特别熟悉的感觉，我对秋薇说，我好想还是一个学生。\"><a href=\"#到达重庆江北机场是在3月3号的凌晨1点，之前的一天我们还在公司卖力的工作。下了飞机以后便往预定的青年旅社赶，但是我们根本不是去休息的，因为我们的重庆之旅才刚刚开始，没有人想早早的睡觉。凌晨1点的重庆已经没有平时的拥堵，但是走在路上，我还是有一种特别熟悉的感觉，我对秋薇说，我好想还是一个学生。\" class=\"headerlink\" title=\"　　到达重庆江北机场是在3月3号的凌晨1点，之前的一天我们还在公司卖力的工作。下了飞机以后便往预定的青年旅社赶，但是我们根本不是去休息的，因为我们的重庆之旅才刚刚开始，没有人想早早的睡觉。凌晨1点的重庆已经没有平时的拥堵，但是走在路上，我还是有一种特别熟悉的感觉，我对秋薇说，我好想还是一个学生。\"></a>　　到达重庆江北机场是在3月3号的凌晨1点，之前的一天我们还在公司卖力的工作。下了飞机以后便往预定的青年旅社赶，但是我们根本不是去休息的，因为我们的重庆之旅才刚刚开始，没有人想早早的睡觉。凌晨1点的重庆已经没有平时的拥堵，但是走在路上，我还是有一种特别熟悉的感觉，我对秋薇说，我好想还是一个学生。</h5><p><img src=\"../../img/life/chongqing.jpeg\" alt=\"青年旅舍合影\">    <div class=\"img-note\">青年旅舍合影</div></p>\n<h5 id=\"我确实变成了一个学生，在我第二天来到重邮之后。公司没有组织大家集体活动，都是各自行动。第二天在离开青舍，找到酒店之后，我和秋薇便直奔重邮。说来很巧，我们住的酒店在解放碑，这里正好有346路公交车直达重邮。一路上的风景还是没有变，路过了南坪，路过了会展中心。其实大学期间我并没有去过重庆的多少地方，因为本身比较宅，加上整天和几个大老爷们待在一起，所以重庆的路我认识的实在不多，这点也被同事们吐槽了。\"><a href=\"#我确实变成了一个学生，在我第二天来到重邮之后。公司没有组织大家集体活动，都是各自行动。第二天在离开青舍，找到酒店之后，我和秋薇便直奔重邮。说来很巧，我们住的酒店在解放碑，这里正好有346路公交车直达重邮。一路上的风景还是没有变，路过了南坪，路过了会展中心。其实大学期间我并没有去过重庆的多少地方，因为本身比较宅，加上整天和几个大老爷们待在一起，所以重庆的路我认识的实在不多，这点也被同事们吐槽了。\" class=\"headerlink\" title=\"　　我确实变成了一个学生，在我第二天来到重邮之后。公司没有组织大家集体活动，都是各自行动。第二天在离开青舍，找到酒店之后，我和秋薇便直奔重邮。说来很巧，我们住的酒店在解放碑，这里正好有346路公交车直达重邮。一路上的风景还是没有变，路过了南坪，路过了会展中心。其实大学期间我并没有去过重庆的多少地方，因为本身比较宅，加上整天和几个大老爷们待在一起，所以重庆的路我认识的实在不多，这点也被同事们吐槽了。\"></a>　　我确实变成了一个学生，在我第二天来到重邮之后。公司没有组织大家集体活动，都是各自行动。第二天在离开青舍，找到酒店之后，我和秋薇便直奔重邮。说来很巧，我们住的酒店在解放碑，这里正好有346路公交车直达重邮。一路上的风景还是没有变，路过了南坪，路过了会展中心。其实大学期间我并没有去过重庆的多少地方，因为本身比较宅，加上整天和几个大老爷们待在一起，所以重庆的路我认识的实在不多，这点也被同事们吐槽了。</h5><h5 id=\"重邮在我眼里几乎就没有变，除了千喜鹤食堂。我顺着数图、老操场、篮球场、千喜鹤来到28栋。不知道是因为这条路太过于熟悉，还是学校变化实在不大，我没有了之前的激动，心情也慢慢平复下来。这一圈走完之后，竟然想着快点离开。当然，离开之前又去了一次”火山石烫鱼”。\"><a href=\"#重邮在我眼里几乎就没有变，除了千喜鹤食堂。我顺着数图、老操场、篮球场、千喜鹤来到28栋。不知道是因为这条路太过于熟悉，还是学校变化实在不大，我没有了之前的激动，心情也慢慢平复下来。这一圈走完之后，竟然想着快点离开。当然，离开之前又去了一次”火山石烫鱼”。\" class=\"headerlink\" title=\"　　重邮在我眼里几乎就没有变，除了千喜鹤食堂。我顺着数图、老操场、篮球场、千喜鹤来到28栋。不知道是因为这条路太过于熟悉，还是学校变化实在不大，我没有了之前的激动，心情也慢慢平复下来。这一圈走完之后，竟然想着快点离开。当然，离开之前又去了一次”火山石烫鱼”。\"></a>　　重邮在我眼里几乎就没有变，除了千喜鹤食堂。我顺着数图、老操场、篮球场、千喜鹤来到28栋。不知道是因为这条路太过于熟悉，还是学校变化实在不大，我没有了之前的激动，心情也慢慢平复下来。这一圈走完之后，竟然想着快点离开。当然，离开之前又去了一次”火山石烫鱼”。</h5><p><img src=\"../../img/life/cqupt.jpeg\" alt=\"重邮新食堂\">    <div class=\"img-note\">重邮新食堂</div><br><img src=\"../../img/life/fish.jpeg\" alt=\"火山石烫鱼\">    <div class=\"img-note\">火山石烫鱼</div></p>\n<h5 id=\"如果说我为什么在离开重邮的时候又喜欢上了重庆，一定是因为那些人，那些同学和朋友。第二天我就见到了磊哥，还是原来的样子，几乎没有变。我们都是性格含蓄的人。因为时间比较紧，只和磊哥聊了一个小时左右，我们说了很多毕业后的感受，没有装逼，没有浮夸，说的都是真心话。磊哥确实变了，变成熟了，不再那么放荡不羁了。直到现在我都在想，我应该和磊哥去喝上几杯的。哎，不知道下次见面是什么时候。\"><a href=\"#如果说我为什么在离开重邮的时候又喜欢上了重庆，一定是因为那些人，那些同学和朋友。第二天我就见到了磊哥，还是原来的样子，几乎没有变。我们都是性格含蓄的人。因为时间比较紧，只和磊哥聊了一个小时左右，我们说了很多毕业后的感受，没有装逼，没有浮夸，说的都是真心话。磊哥确实变了，变成熟了，不再那么放荡不羁了。直到现在我都在想，我应该和磊哥去喝上几杯的。哎，不知道下次见面是什么时候。\" class=\"headerlink\" title=\"　　如果说我为什么在离开重邮的时候又喜欢上了重庆，一定是因为那些人，那些同学和朋友。第二天我就见到了磊哥，还是原来的样子，几乎没有变。我们都是性格含蓄的人。因为时间比较紧，只和磊哥聊了一个小时左右，我们说了很多毕业后的感受，没有装逼，没有浮夸，说的都是真心话。磊哥确实变了，变成熟了，不再那么放荡不羁了。直到现在我都在想，我应该和磊哥去喝上几杯的。哎，不知道下次见面是什么时候。\"></a>　　如果说我为什么在离开重邮的时候又喜欢上了重庆，一定是因为那些人，那些同学和朋友。第二天我就见到了磊哥，还是原来的样子，几乎没有变。我们都是性格含蓄的人。因为时间比较紧，只和磊哥聊了一个小时左右，我们说了很多毕业后的感受，没有装逼，没有浮夸，说的都是真心话。磊哥确实变了，变成熟了，不再那么放荡不羁了。直到现在我都在想，我应该和磊哥去喝上几杯的。哎，不知道下次见面是什么时候。</h5><p><img src=\"../../img/life/yllh.jpeg\" alt=\"余磊和刘航\">    <div class=\"img-note\">余磊和刘航</div></p>\n<h5 id=\"按道理来说，重庆应该是比北京更加湿润的。但我的症状却恰恰相反，因为没有唇膏，加上女朋友”舍不得”给我买新的，我的嘴唇周围已经干到龟裂。这实在是难受。后来分析可能是因为酒店的房间里面太干燥了。女朋友则比我更惨一些，亲戚来了，加上肚子疼，再加上感冒发烧导致声音沙哑，已经到了不能说话的地步。实在是好过不到哪里去。不过幸好有我的悉心照顾，最后安全返回北京。\"><a href=\"#按道理来说，重庆应该是比北京更加湿润的。但我的症状却恰恰相反，因为没有唇膏，加上女朋友”舍不得”给我买新的，我的嘴唇周围已经干到龟裂。这实在是难受。后来分析可能是因为酒店的房间里面太干燥了。女朋友则比我更惨一些，亲戚来了，加上肚子疼，再加上感冒发烧导致声音沙哑，已经到了不能说话的地步。实在是好过不到哪里去。不过幸好有我的悉心照顾，最后安全返回北京。\" class=\"headerlink\" title=\"　　按道理来说，重庆应该是比北京更加湿润的。但我的症状却恰恰相反，因为没有唇膏，加上女朋友”舍不得”给我买新的，我的嘴唇周围已经干到龟裂。这实在是难受。后来分析可能是因为酒店的房间里面太干燥了。女朋友则比我更惨一些，亲戚来了，加上肚子疼，再加上感冒发烧导致声音沙哑，已经到了不能说话的地步。实在是好过不到哪里去。不过幸好有我的悉心照顾，最后安全返回北京。\"></a>　　按道理来说，重庆应该是比北京更加湿润的。但我的症状却恰恰相反，因为没有唇膏，加上女朋友”舍不得”给我买新的，我的嘴唇周围已经干到龟裂。这实在是难受。后来分析可能是因为酒店的房间里面太干燥了。女朋友则比我更惨一些，亲戚来了，加上肚子疼，再加上感冒发烧导致声音沙哑，已经到了不能说话的地步。实在是好过不到哪里去。不过幸好有我的悉心照顾，最后安全返回北京。</h5><p><img src=\"../../img/life/qiuwei.jpeg\" alt=\"秋薇和我\">    <div class=\"img-note\">秋薇和我</div></p>\n","site":{"data":{}},"excerpt":"<h5 id=\"去年6月份毕业之后，怎么也没有先到这么快又回到的重庆。之前想过很多次，再到重庆的时候会是什么时候，可能是几年后的同学聚会，可能是工作休假去重庆游玩。但是无论怎样，也没有想到仅仅隔了半年就又到了重庆。\"><a href=\"#去年6月份毕业之后，怎么也没有先到这么快又回到的重庆。之前想过很多次，再到重庆的时候会是什么时候，可能是几年后的同学聚会，可能是工作休假去重庆游玩。但是无论怎样，也没有想到仅仅隔了半年就又到了重庆。\" class=\"headerlink\" title=\"　　去年6月份毕业之后，怎么也没有先到这么快又回到的重庆。之前想过很多次，再到重庆的时候会是什么时候，可能是几年后的同学聚会，可能是工作休假去重庆游玩。但是无论怎样，也没有想到仅仅隔了半年就又到了重庆。\"></a>　　去年6月份毕业之后，怎么也没有先到这么快又回到的重庆。之前想过很多次，再到重庆的时候会是什么时候，可能是几年后的同学聚会，可能是工作休假去重庆游玩。但是无论怎样，也没有想到仅仅隔了半年就又到了重庆。</h5>","more":"<h5 id=\"这次去重庆是因为部门的团建，原本计划去韩国或者是成都，投票之后就决定去重庆了（醉了）。其实我去重庆读书的时候，对重庆是没有多少感情的，觉得这个城市很陌生，没有家里好，这种感觉一直持续到大四，直到我离开重庆去北京工作和实习，才发现我已经对重庆有了一种莫名的情感在里面，虽然我没有在这里恋爱。这种情感在我下了飞机以后则更加明显。\"><a href=\"#这次去重庆是因为部门的团建，原本计划去韩国或者是成都，投票之后就决定去重庆了（醉了）。其实我去重庆读书的时候，对重庆是没有多少感情的，觉得这个城市很陌生，没有家里好，这种感觉一直持续到大四，直到我离开重庆去北京工作和实习，才发现我已经对重庆有了一种莫名的情感在里面，虽然我没有在这里恋爱。这种情感在我下了飞机以后则更加明显。\" class=\"headerlink\" title=\"　　这次去重庆是因为部门的团建，原本计划去韩国或者是成都，投票之后就决定去重庆了（醉了）。其实我去重庆读书的时候，对重庆是没有多少感情的，觉得这个城市很陌生，没有家里好，这种感觉一直持续到大四，直到我离开重庆去北京工作和实习，才发现我已经对重庆有了一种莫名的情感在里面，虽然我没有在这里恋爱。这种情感在我下了飞机以后则更加明显。\"></a>　　这次去重庆是因为部门的团建，原本计划去韩国或者是成都，投票之后就决定去重庆了（醉了）。其实我去重庆读书的时候，对重庆是没有多少感情的，觉得这个城市很陌生，没有家里好，这种感觉一直持续到大四，直到我离开重庆去北京工作和实习，才发现我已经对重庆有了一种莫名的情感在里面，虽然我没有在这里恋爱。这种情感在我下了飞机以后则更加明显。</h5><h5 id=\"到达重庆江北机场是在3月3号的凌晨1点，之前的一天我们还在公司卖力的工作。下了飞机以后便往预定的青年旅社赶，但是我们根本不是去休息的，因为我们的重庆之旅才刚刚开始，没有人想早早的睡觉。凌晨1点的重庆已经没有平时的拥堵，但是走在路上，我还是有一种特别熟悉的感觉，我对秋薇说，我好想还是一个学生。\"><a href=\"#到达重庆江北机场是在3月3号的凌晨1点，之前的一天我们还在公司卖力的工作。下了飞机以后便往预定的青年旅社赶，但是我们根本不是去休息的，因为我们的重庆之旅才刚刚开始，没有人想早早的睡觉。凌晨1点的重庆已经没有平时的拥堵，但是走在路上，我还是有一种特别熟悉的感觉，我对秋薇说，我好想还是一个学生。\" class=\"headerlink\" title=\"　　到达重庆江北机场是在3月3号的凌晨1点，之前的一天我们还在公司卖力的工作。下了飞机以后便往预定的青年旅社赶，但是我们根本不是去休息的，因为我们的重庆之旅才刚刚开始，没有人想早早的睡觉。凌晨1点的重庆已经没有平时的拥堵，但是走在路上，我还是有一种特别熟悉的感觉，我对秋薇说，我好想还是一个学生。\"></a>　　到达重庆江北机场是在3月3号的凌晨1点，之前的一天我们还在公司卖力的工作。下了飞机以后便往预定的青年旅社赶，但是我们根本不是去休息的，因为我们的重庆之旅才刚刚开始，没有人想早早的睡觉。凌晨1点的重庆已经没有平时的拥堵，但是走在路上，我还是有一种特别熟悉的感觉，我对秋薇说，我好想还是一个学生。</h5><p><img src=\"../../img/life/chongqing.jpeg\" alt=\"青年旅舍合影\">    <div class=\"img-note\">青年旅舍合影</div></p>\n<h5 id=\"我确实变成了一个学生，在我第二天来到重邮之后。公司没有组织大家集体活动，都是各自行动。第二天在离开青舍，找到酒店之后，我和秋薇便直奔重邮。说来很巧，我们住的酒店在解放碑，这里正好有346路公交车直达重邮。一路上的风景还是没有变，路过了南坪，路过了会展中心。其实大学期间我并没有去过重庆的多少地方，因为本身比较宅，加上整天和几个大老爷们待在一起，所以重庆的路我认识的实在不多，这点也被同事们吐槽了。\"><a href=\"#我确实变成了一个学生，在我第二天来到重邮之后。公司没有组织大家集体活动，都是各自行动。第二天在离开青舍，找到酒店之后，我和秋薇便直奔重邮。说来很巧，我们住的酒店在解放碑，这里正好有346路公交车直达重邮。一路上的风景还是没有变，路过了南坪，路过了会展中心。其实大学期间我并没有去过重庆的多少地方，因为本身比较宅，加上整天和几个大老爷们待在一起，所以重庆的路我认识的实在不多，这点也被同事们吐槽了。\" class=\"headerlink\" title=\"　　我确实变成了一个学生，在我第二天来到重邮之后。公司没有组织大家集体活动，都是各自行动。第二天在离开青舍，找到酒店之后，我和秋薇便直奔重邮。说来很巧，我们住的酒店在解放碑，这里正好有346路公交车直达重邮。一路上的风景还是没有变，路过了南坪，路过了会展中心。其实大学期间我并没有去过重庆的多少地方，因为本身比较宅，加上整天和几个大老爷们待在一起，所以重庆的路我认识的实在不多，这点也被同事们吐槽了。\"></a>　　我确实变成了一个学生，在我第二天来到重邮之后。公司没有组织大家集体活动，都是各自行动。第二天在离开青舍，找到酒店之后，我和秋薇便直奔重邮。说来很巧，我们住的酒店在解放碑，这里正好有346路公交车直达重邮。一路上的风景还是没有变，路过了南坪，路过了会展中心。其实大学期间我并没有去过重庆的多少地方，因为本身比较宅，加上整天和几个大老爷们待在一起，所以重庆的路我认识的实在不多，这点也被同事们吐槽了。</h5><h5 id=\"重邮在我眼里几乎就没有变，除了千喜鹤食堂。我顺着数图、老操场、篮球场、千喜鹤来到28栋。不知道是因为这条路太过于熟悉，还是学校变化实在不大，我没有了之前的激动，心情也慢慢平复下来。这一圈走完之后，竟然想着快点离开。当然，离开之前又去了一次”火山石烫鱼”。\"><a href=\"#重邮在我眼里几乎就没有变，除了千喜鹤食堂。我顺着数图、老操场、篮球场、千喜鹤来到28栋。不知道是因为这条路太过于熟悉，还是学校变化实在不大，我没有了之前的激动，心情也慢慢平复下来。这一圈走完之后，竟然想着快点离开。当然，离开之前又去了一次”火山石烫鱼”。\" class=\"headerlink\" title=\"　　重邮在我眼里几乎就没有变，除了千喜鹤食堂。我顺着数图、老操场、篮球场、千喜鹤来到28栋。不知道是因为这条路太过于熟悉，还是学校变化实在不大，我没有了之前的激动，心情也慢慢平复下来。这一圈走完之后，竟然想着快点离开。当然，离开之前又去了一次”火山石烫鱼”。\"></a>　　重邮在我眼里几乎就没有变，除了千喜鹤食堂。我顺着数图、老操场、篮球场、千喜鹤来到28栋。不知道是因为这条路太过于熟悉，还是学校变化实在不大，我没有了之前的激动，心情也慢慢平复下来。这一圈走完之后，竟然想着快点离开。当然，离开之前又去了一次”火山石烫鱼”。</h5><p><img src=\"../../img/life/cqupt.jpeg\" alt=\"重邮新食堂\">    <div class=\"img-note\">重邮新食堂</div><br><img src=\"../../img/life/fish.jpeg\" alt=\"火山石烫鱼\">    <div class=\"img-note\">火山石烫鱼</div></p>\n<h5 id=\"如果说我为什么在离开重邮的时候又喜欢上了重庆，一定是因为那些人，那些同学和朋友。第二天我就见到了磊哥，还是原来的样子，几乎没有变。我们都是性格含蓄的人。因为时间比较紧，只和磊哥聊了一个小时左右，我们说了很多毕业后的感受，没有装逼，没有浮夸，说的都是真心话。磊哥确实变了，变成熟了，不再那么放荡不羁了。直到现在我都在想，我应该和磊哥去喝上几杯的。哎，不知道下次见面是什么时候。\"><a href=\"#如果说我为什么在离开重邮的时候又喜欢上了重庆，一定是因为那些人，那些同学和朋友。第二天我就见到了磊哥，还是原来的样子，几乎没有变。我们都是性格含蓄的人。因为时间比较紧，只和磊哥聊了一个小时左右，我们说了很多毕业后的感受，没有装逼，没有浮夸，说的都是真心话。磊哥确实变了，变成熟了，不再那么放荡不羁了。直到现在我都在想，我应该和磊哥去喝上几杯的。哎，不知道下次见面是什么时候。\" class=\"headerlink\" title=\"　　如果说我为什么在离开重邮的时候又喜欢上了重庆，一定是因为那些人，那些同学和朋友。第二天我就见到了磊哥，还是原来的样子，几乎没有变。我们都是性格含蓄的人。因为时间比较紧，只和磊哥聊了一个小时左右，我们说了很多毕业后的感受，没有装逼，没有浮夸，说的都是真心话。磊哥确实变了，变成熟了，不再那么放荡不羁了。直到现在我都在想，我应该和磊哥去喝上几杯的。哎，不知道下次见面是什么时候。\"></a>　　如果说我为什么在离开重邮的时候又喜欢上了重庆，一定是因为那些人，那些同学和朋友。第二天我就见到了磊哥，还是原来的样子，几乎没有变。我们都是性格含蓄的人。因为时间比较紧，只和磊哥聊了一个小时左右，我们说了很多毕业后的感受，没有装逼，没有浮夸，说的都是真心话。磊哥确实变了，变成熟了，不再那么放荡不羁了。直到现在我都在想，我应该和磊哥去喝上几杯的。哎，不知道下次见面是什么时候。</h5><p><img src=\"../../img/life/yllh.jpeg\" alt=\"余磊和刘航\">    <div class=\"img-note\">余磊和刘航</div></p>\n<h5 id=\"按道理来说，重庆应该是比北京更加湿润的。但我的症状却恰恰相反，因为没有唇膏，加上女朋友”舍不得”给我买新的，我的嘴唇周围已经干到龟裂。这实在是难受。后来分析可能是因为酒店的房间里面太干燥了。女朋友则比我更惨一些，亲戚来了，加上肚子疼，再加上感冒发烧导致声音沙哑，已经到了不能说话的地步。实在是好过不到哪里去。不过幸好有我的悉心照顾，最后安全返回北京。\"><a href=\"#按道理来说，重庆应该是比北京更加湿润的。但我的症状却恰恰相反，因为没有唇膏，加上女朋友”舍不得”给我买新的，我的嘴唇周围已经干到龟裂。这实在是难受。后来分析可能是因为酒店的房间里面太干燥了。女朋友则比我更惨一些，亲戚来了，加上肚子疼，再加上感冒发烧导致声音沙哑，已经到了不能说话的地步。实在是好过不到哪里去。不过幸好有我的悉心照顾，最后安全返回北京。\" class=\"headerlink\" title=\"　　按道理来说，重庆应该是比北京更加湿润的。但我的症状却恰恰相反，因为没有唇膏，加上女朋友”舍不得”给我买新的，我的嘴唇周围已经干到龟裂。这实在是难受。后来分析可能是因为酒店的房间里面太干燥了。女朋友则比我更惨一些，亲戚来了，加上肚子疼，再加上感冒发烧导致声音沙哑，已经到了不能说话的地步。实在是好过不到哪里去。不过幸好有我的悉心照顾，最后安全返回北京。\"></a>　　按道理来说，重庆应该是比北京更加湿润的。但我的症状却恰恰相反，因为没有唇膏，加上女朋友”舍不得”给我买新的，我的嘴唇周围已经干到龟裂。这实在是难受。后来分析可能是因为酒店的房间里面太干燥了。女朋友则比我更惨一些，亲戚来了，加上肚子疼，再加上感冒发烧导致声音沙哑，已经到了不能说话的地步。实在是好过不到哪里去。不过幸好有我的悉心照顾，最后安全返回北京。</h5><p><img src=\"../../img/life/qiuwei.jpeg\" alt=\"秋薇和我\">    <div class=\"img-note\">秋薇和我</div></p>"},{"layout":"post","title":"2016走了","date":"2016-12-31T16:00:00.000Z","original":true,"img":"/life/2016-bg.jpg","color":"#777","_content":"\n##### 　　2017年1月份已经快过去了，再有两天就是春节。在这之前的春节，都是作为一个学生的身份，自然是有寒假的，这第一年工作，却要等到大年三十才能回家，多少还是有些不适应。加上北京这两天风特别大，这不，得了感冒了，今天还请了一天病假，才有时间坐在家里开始完成这一篇16年总结。其实20多天前就计划要写年终总结，但是最近很多事情都在耽误这一计划。加上需要将博客从jekyll迁移到hexo，使得每次打开博客，大部分时间都是在完成博客页面主题的编写，所以在博客文章上花的时间少了很多（其实之前好像也没花多少时间，惭愧）。\n<!--more-->\n\n##### 　　其实除了几篇技术文章，我几乎没有写过博客，以前倒是坚持写过一段时间的日记，但也总是断断续续。这当中一个很重要的原因就是从小作文就不太好，不太会用文字去描述身边的事情和自己的想法（比如上面这一段文字，就花了大概十分钟，删删减减才完成的），但我本身是很想去表达一些东西的。这个博客是16年10月份左右搭建起来的，大部分时间都用在了前端页面的编写上面了，起初是希望能够做一些技术上的总结，后来发现可以将生活中的一些总结也记录在此，再之后又添加了read版块。有点偏题了，已经不像是年终总结了。下面开始回到正题。\n\n##### 　　去年这一年是我从一个面向学校的学生转变为面向社会的工作者的一年。和很多毕业生一样，有一点迷茫，也有对未来的无限向往，我们就像一个个梦想家，有着无限的期望。但是我现在更希望做一个实干家，或者说行动大于空想。我是在15年的9月21号左右通过qunar面试的，这之前也参加过其他公司的校招，但是我之前的校招经历比较坎坷。因此我对qunar是非常感激的，加上面试的两位面试官也给我很好的感觉。所以在拿到qunar的offer之后，我几乎没有再考虑过其他公司。虽然随之而来的消息是qunar被携程合并，管理层的集体退出，以及多家航司对qunar的联合打击。\n\n##### 　　16年春节后，来到北京参加qunar的技术培训，和另外几个qunar的小伙伴，一起合租，一个房间睡了三个人，当时算了下，那一套房子有5个房间，一共住了14个人，当时最大的愿望就是，转正之后一定要有自己房间。期间公司培训的内容就是java后端开发那一套，个人觉得那是面向初学者的，所以我一有时间就去写毕业设计了，现在想起来多少有一些后悔。这可以算是我第一次参加工作，之前在学校很少出去兼职赚钱，大多数时间都是在团队或者实验室写代码做项目，感觉自己确实很契合程序员这个职业-够宅够闷骚。\n![2016-qunar技术培训照片](../../img/life/2016-qunar.jpeg)\n\n##### 　　5月初的时候，趁着劳动节就回学校了，因为马上就要做毕业答辩，但是论文什么都还没写。记得离开北京的时候，还是挺高兴的，毕竟学校还有一大堆的同学和朋友在等着我回去。期间和几个好朋友去了一趟云南，这是第一次去云南，我们先是坐飞机来到了昆明，然后去了大理、丽江、香格里拉。那边的风景实在是很漂亮，特别是从大理的苍山上俯瞰整个大理。说来也是缘分，之后我在qunar工作认识的，也就是我现在的女朋友，就是来自云南的，因此我觉得我和云南还是挺有缘分的。回到学校，便是答辩，合照，聚会。有些细节现在已经忘记，记得最清楚的是毕业季真的很难过。可能是因为大家都舍不得，室友们几乎都是同一天走的。\n![2016-室友毕业小聚](../../img/life/2016-roommate.jpeg)\n\n##### 　　兜兜转转，现在已经是2017年1月26号凌晨1点半，我正在火车站的候车室内席地而坐，等候回家的列车，车需要等到3点半才行，但是我现在已经有点困了。说到回家，虽然已经工作，但是今年回家的次数还真不少。除掉办领身份证、办理护照回去两次，另外还回去了大概两三次。可能是因为要工作了，想到以后没有了暑假，只有过年才有时间回家，所以一有时间便往家里赶。幸运的是，父母现在身体还算好,能够照顾好自己。希望他们永远健康。\n\n##### 　　继续说说2016吧，其实也没什么好说的了。对了，我和我的女朋友就是这一年在公司认识的，和她在一起4个多月了，吵了无数次架，我们的感情却越来越深，她真的是一个好女孩，希望在我今后的道路当中，都有她的陪伴。至于2016年这一年的工作情况，就不在这里总结了，总之希望新的一年越来越好。我也需要更加努力。这一年对我来说有一个大的变化就是，之前我是一个悲观主义者，对很多东西都不看好，认为那都是命中注定，我们改变不了什么，我们太渺小了。现在，我依然认为我们改变不了任何事情，但是我坚信我们可以改变自己。这个世界不是你想象中的那个样子，你也没有办法将它改变成你想要的样子，那就改变你自己，改变你看这个世界的角度和观点，那世界将是一个崭新的世界。\n","source":"_posts/life/summary-2016.md","raw":"---\nlayout: post\ntitle: 2016走了\ndate: 2017/01/01\ntags: [life, index]\noriginal: true\nimg: /life/2016-bg.jpg\ncolor: \"#777\"\n---\n\n##### 　　2017年1月份已经快过去了，再有两天就是春节。在这之前的春节，都是作为一个学生的身份，自然是有寒假的，这第一年工作，却要等到大年三十才能回家，多少还是有些不适应。加上北京这两天风特别大，这不，得了感冒了，今天还请了一天病假，才有时间坐在家里开始完成这一篇16年总结。其实20多天前就计划要写年终总结，但是最近很多事情都在耽误这一计划。加上需要将博客从jekyll迁移到hexo，使得每次打开博客，大部分时间都是在完成博客页面主题的编写，所以在博客文章上花的时间少了很多（其实之前好像也没花多少时间，惭愧）。\n<!--more-->\n\n##### 　　其实除了几篇技术文章，我几乎没有写过博客，以前倒是坚持写过一段时间的日记，但也总是断断续续。这当中一个很重要的原因就是从小作文就不太好，不太会用文字去描述身边的事情和自己的想法（比如上面这一段文字，就花了大概十分钟，删删减减才完成的），但我本身是很想去表达一些东西的。这个博客是16年10月份左右搭建起来的，大部分时间都用在了前端页面的编写上面了，起初是希望能够做一些技术上的总结，后来发现可以将生活中的一些总结也记录在此，再之后又添加了read版块。有点偏题了，已经不像是年终总结了。下面开始回到正题。\n\n##### 　　去年这一年是我从一个面向学校的学生转变为面向社会的工作者的一年。和很多毕业生一样，有一点迷茫，也有对未来的无限向往，我们就像一个个梦想家，有着无限的期望。但是我现在更希望做一个实干家，或者说行动大于空想。我是在15年的9月21号左右通过qunar面试的，这之前也参加过其他公司的校招，但是我之前的校招经历比较坎坷。因此我对qunar是非常感激的，加上面试的两位面试官也给我很好的感觉。所以在拿到qunar的offer之后，我几乎没有再考虑过其他公司。虽然随之而来的消息是qunar被携程合并，管理层的集体退出，以及多家航司对qunar的联合打击。\n\n##### 　　16年春节后，来到北京参加qunar的技术培训，和另外几个qunar的小伙伴，一起合租，一个房间睡了三个人，当时算了下，那一套房子有5个房间，一共住了14个人，当时最大的愿望就是，转正之后一定要有自己房间。期间公司培训的内容就是java后端开发那一套，个人觉得那是面向初学者的，所以我一有时间就去写毕业设计了，现在想起来多少有一些后悔。这可以算是我第一次参加工作，之前在学校很少出去兼职赚钱，大多数时间都是在团队或者实验室写代码做项目，感觉自己确实很契合程序员这个职业-够宅够闷骚。\n![2016-qunar技术培训照片](../../img/life/2016-qunar.jpeg)\n\n##### 　　5月初的时候，趁着劳动节就回学校了，因为马上就要做毕业答辩，但是论文什么都还没写。记得离开北京的时候，还是挺高兴的，毕竟学校还有一大堆的同学和朋友在等着我回去。期间和几个好朋友去了一趟云南，这是第一次去云南，我们先是坐飞机来到了昆明，然后去了大理、丽江、香格里拉。那边的风景实在是很漂亮，特别是从大理的苍山上俯瞰整个大理。说来也是缘分，之后我在qunar工作认识的，也就是我现在的女朋友，就是来自云南的，因此我觉得我和云南还是挺有缘分的。回到学校，便是答辩，合照，聚会。有些细节现在已经忘记，记得最清楚的是毕业季真的很难过。可能是因为大家都舍不得，室友们几乎都是同一天走的。\n![2016-室友毕业小聚](../../img/life/2016-roommate.jpeg)\n\n##### 　　兜兜转转，现在已经是2017年1月26号凌晨1点半，我正在火车站的候车室内席地而坐，等候回家的列车，车需要等到3点半才行，但是我现在已经有点困了。说到回家，虽然已经工作，但是今年回家的次数还真不少。除掉办领身份证、办理护照回去两次，另外还回去了大概两三次。可能是因为要工作了，想到以后没有了暑假，只有过年才有时间回家，所以一有时间便往家里赶。幸运的是，父母现在身体还算好,能够照顾好自己。希望他们永远健康。\n\n##### 　　继续说说2016吧，其实也没什么好说的了。对了，我和我的女朋友就是这一年在公司认识的，和她在一起4个多月了，吵了无数次架，我们的感情却越来越深，她真的是一个好女孩，希望在我今后的道路当中，都有她的陪伴。至于2016年这一年的工作情况，就不在这里总结了，总之希望新的一年越来越好。我也需要更加努力。这一年对我来说有一个大的变化就是，之前我是一个悲观主义者，对很多东西都不看好，认为那都是命中注定，我们改变不了什么，我们太渺小了。现在，我依然认为我们改变不了任何事情，但是我坚信我们可以改变自己。这个世界不是你想象中的那个样子，你也没有办法将它改变成你想要的样子，那就改变你自己，改变你看这个世界的角度和观点，那世界将是一个崭新的世界。\n","slug":"life/summary-2016","published":1,"updated":"2017-10-09T05:56:27.807Z","_id":"cj8g07xkp000j4kh90zb3f7jm","comments":1,"photos":[],"link":"","content":"<h5 id=\"2017年1月份已经快过去了，再有两天就是春节。在这之前的春节，都是作为一个学生的身份，自然是有寒假的，这第一年工作，却要等到大年三十才能回家，多少还是有些不适应。加上北京这两天风特别大，这不，得了感冒了，今天还请了一天病假，才有时间坐在家里开始完成这一篇16年总结。其实20多天前就计划要写年终总结，但是最近很多事情都在耽误这一计划。加上需要将博客从jekyll迁移到hexo，使得每次打开博客，大部分时间都是在完成博客页面主题的编写，所以在博客文章上花的时间少了很多（其实之前好像也没花多少时间，惭愧）。\"><a href=\"#2017年1月份已经快过去了，再有两天就是春节。在这之前的春节，都是作为一个学生的身份，自然是有寒假的，这第一年工作，却要等到大年三十才能回家，多少还是有些不适应。加上北京这两天风特别大，这不，得了感冒了，今天还请了一天病假，才有时间坐在家里开始完成这一篇16年总结。其实20多天前就计划要写年终总结，但是最近很多事情都在耽误这一计划。加上需要将博客从jekyll迁移到hexo，使得每次打开博客，大部分时间都是在完成博客页面主题的编写，所以在博客文章上花的时间少了很多（其实之前好像也没花多少时间，惭愧）。\" class=\"headerlink\" title=\"　　2017年1月份已经快过去了，再有两天就是春节。在这之前的春节，都是作为一个学生的身份，自然是有寒假的，这第一年工作，却要等到大年三十才能回家，多少还是有些不适应。加上北京这两天风特别大，这不，得了感冒了，今天还请了一天病假，才有时间坐在家里开始完成这一篇16年总结。其实20多天前就计划要写年终总结，但是最近很多事情都在耽误这一计划。加上需要将博客从jekyll迁移到hexo，使得每次打开博客，大部分时间都是在完成博客页面主题的编写，所以在博客文章上花的时间少了很多（其实之前好像也没花多少时间，惭愧）。\"></a>　　2017年1月份已经快过去了，再有两天就是春节。在这之前的春节，都是作为一个学生的身份，自然是有寒假的，这第一年工作，却要等到大年三十才能回家，多少还是有些不适应。加上北京这两天风特别大，这不，得了感冒了，今天还请了一天病假，才有时间坐在家里开始完成这一篇16年总结。其实20多天前就计划要写年终总结，但是最近很多事情都在耽误这一计划。加上需要将博客从jekyll迁移到hexo，使得每次打开博客，大部分时间都是在完成博客页面主题的编写，所以在博客文章上花的时间少了很多（其实之前好像也没花多少时间，惭愧）。</h5><a id=\"more\"></a>\n<h5 id=\"其实除了几篇技术文章，我几乎没有写过博客，以前倒是坚持写过一段时间的日记，但也总是断断续续。这当中一个很重要的原因就是从小作文就不太好，不太会用文字去描述身边的事情和自己的想法（比如上面这一段文字，就花了大概十分钟，删删减减才完成的），但我本身是很想去表达一些东西的。这个博客是16年10月份左右搭建起来的，大部分时间都用在了前端页面的编写上面了，起初是希望能够做一些技术上的总结，后来发现可以将生活中的一些总结也记录在此，再之后又添加了read版块。有点偏题了，已经不像是年终总结了。下面开始回到正题。\"><a href=\"#其实除了几篇技术文章，我几乎没有写过博客，以前倒是坚持写过一段时间的日记，但也总是断断续续。这当中一个很重要的原因就是从小作文就不太好，不太会用文字去描述身边的事情和自己的想法（比如上面这一段文字，就花了大概十分钟，删删减减才完成的），但我本身是很想去表达一些东西的。这个博客是16年10月份左右搭建起来的，大部分时间都用在了前端页面的编写上面了，起初是希望能够做一些技术上的总结，后来发现可以将生活中的一些总结也记录在此，再之后又添加了read版块。有点偏题了，已经不像是年终总结了。下面开始回到正题。\" class=\"headerlink\" title=\"　　其实除了几篇技术文章，我几乎没有写过博客，以前倒是坚持写过一段时间的日记，但也总是断断续续。这当中一个很重要的原因就是从小作文就不太好，不太会用文字去描述身边的事情和自己的想法（比如上面这一段文字，就花了大概十分钟，删删减减才完成的），但我本身是很想去表达一些东西的。这个博客是16年10月份左右搭建起来的，大部分时间都用在了前端页面的编写上面了，起初是希望能够做一些技术上的总结，后来发现可以将生活中的一些总结也记录在此，再之后又添加了read版块。有点偏题了，已经不像是年终总结了。下面开始回到正题。\"></a>　　其实除了几篇技术文章，我几乎没有写过博客，以前倒是坚持写过一段时间的日记，但也总是断断续续。这当中一个很重要的原因就是从小作文就不太好，不太会用文字去描述身边的事情和自己的想法（比如上面这一段文字，就花了大概十分钟，删删减减才完成的），但我本身是很想去表达一些东西的。这个博客是16年10月份左右搭建起来的，大部分时间都用在了前端页面的编写上面了，起初是希望能够做一些技术上的总结，后来发现可以将生活中的一些总结也记录在此，再之后又添加了read版块。有点偏题了，已经不像是年终总结了。下面开始回到正题。</h5><h5 id=\"去年这一年是我从一个面向学校的学生转变为面向社会的工作者的一年。和很多毕业生一样，有一点迷茫，也有对未来的无限向往，我们就像一个个梦想家，有着无限的期望。但是我现在更希望做一个实干家，或者说行动大于空想。我是在15年的9月21号左右通过qunar面试的，这之前也参加过其他公司的校招，但是我之前的校招经历比较坎坷。因此我对qunar是非常感激的，加上面试的两位面试官也给我很好的感觉。所以在拿到qunar的offer之后，我几乎没有再考虑过其他公司。虽然随之而来的消息是qunar被携程合并，管理层的集体退出，以及多家航司对qunar的联合打击。\"><a href=\"#去年这一年是我从一个面向学校的学生转变为面向社会的工作者的一年。和很多毕业生一样，有一点迷茫，也有对未来的无限向往，我们就像一个个梦想家，有着无限的期望。但是我现在更希望做一个实干家，或者说行动大于空想。我是在15年的9月21号左右通过qunar面试的，这之前也参加过其他公司的校招，但是我之前的校招经历比较坎坷。因此我对qunar是非常感激的，加上面试的两位面试官也给我很好的感觉。所以在拿到qunar的offer之后，我几乎没有再考虑过其他公司。虽然随之而来的消息是qunar被携程合并，管理层的集体退出，以及多家航司对qunar的联合打击。\" class=\"headerlink\" title=\"　　去年这一年是我从一个面向学校的学生转变为面向社会的工作者的一年。和很多毕业生一样，有一点迷茫，也有对未来的无限向往，我们就像一个个梦想家，有着无限的期望。但是我现在更希望做一个实干家，或者说行动大于空想。我是在15年的9月21号左右通过qunar面试的，这之前也参加过其他公司的校招，但是我之前的校招经历比较坎坷。因此我对qunar是非常感激的，加上面试的两位面试官也给我很好的感觉。所以在拿到qunar的offer之后，我几乎没有再考虑过其他公司。虽然随之而来的消息是qunar被携程合并，管理层的集体退出，以及多家航司对qunar的联合打击。\"></a>　　去年这一年是我从一个面向学校的学生转变为面向社会的工作者的一年。和很多毕业生一样，有一点迷茫，也有对未来的无限向往，我们就像一个个梦想家，有着无限的期望。但是我现在更希望做一个实干家，或者说行动大于空想。我是在15年的9月21号左右通过qunar面试的，这之前也参加过其他公司的校招，但是我之前的校招经历比较坎坷。因此我对qunar是非常感激的，加上面试的两位面试官也给我很好的感觉。所以在拿到qunar的offer之后，我几乎没有再考虑过其他公司。虽然随之而来的消息是qunar被携程合并，管理层的集体退出，以及多家航司对qunar的联合打击。</h5><h5 id=\"16年春节后，来到北京参加qunar的技术培训，和另外几个qunar的小伙伴，一起合租，一个房间睡了三个人，当时算了下，那一套房子有5个房间，一共住了14个人，当时最大的愿望就是，转正之后一定要有自己房间。期间公司培训的内容就是java后端开发那一套，个人觉得那是面向初学者的，所以我一有时间就去写毕业设计了，现在想起来多少有一些后悔。这可以算是我第一次参加工作，之前在学校很少出去兼职赚钱，大多数时间都是在团队或者实验室写代码做项目，感觉自己确实很契合程序员这个职业-够宅够闷骚。\"><a href=\"#16年春节后，来到北京参加qunar的技术培训，和另外几个qunar的小伙伴，一起合租，一个房间睡了三个人，当时算了下，那一套房子有5个房间，一共住了14个人，当时最大的愿望就是，转正之后一定要有自己房间。期间公司培训的内容就是java后端开发那一套，个人觉得那是面向初学者的，所以我一有时间就去写毕业设计了，现在想起来多少有一些后悔。这可以算是我第一次参加工作，之前在学校很少出去兼职赚钱，大多数时间都是在团队或者实验室写代码做项目，感觉自己确实很契合程序员这个职业-够宅够闷骚。\" class=\"headerlink\" title=\"　　16年春节后，来到北京参加qunar的技术培训，和另外几个qunar的小伙伴，一起合租，一个房间睡了三个人，当时算了下，那一套房子有5个房间，一共住了14个人，当时最大的愿望就是，转正之后一定要有自己房间。期间公司培训的内容就是java后端开发那一套，个人觉得那是面向初学者的，所以我一有时间就去写毕业设计了，现在想起来多少有一些后悔。这可以算是我第一次参加工作，之前在学校很少出去兼职赚钱，大多数时间都是在团队或者实验室写代码做项目，感觉自己确实很契合程序员这个职业-够宅够闷骚。\"></a>　　16年春节后，来到北京参加qunar的技术培训，和另外几个qunar的小伙伴，一起合租，一个房间睡了三个人，当时算了下，那一套房子有5个房间，一共住了14个人，当时最大的愿望就是，转正之后一定要有自己房间。期间公司培训的内容就是java后端开发那一套，个人觉得那是面向初学者的，所以我一有时间就去写毕业设计了，现在想起来多少有一些后悔。这可以算是我第一次参加工作，之前在学校很少出去兼职赚钱，大多数时间都是在团队或者实验室写代码做项目，感觉自己确实很契合程序员这个职业-够宅够闷骚。</h5><p><img src=\"../../img/life/2016-qunar.jpeg\" alt=\"2016-qunar技术培训照片\"></p>\n<h5 id=\"5月初的时候，趁着劳动节就回学校了，因为马上就要做毕业答辩，但是论文什么都还没写。记得离开北京的时候，还是挺高兴的，毕竟学校还有一大堆的同学和朋友在等着我回去。期间和几个好朋友去了一趟云南，这是第一次去云南，我们先是坐飞机来到了昆明，然后去了大理、丽江、香格里拉。那边的风景实在是很漂亮，特别是从大理的苍山上俯瞰整个大理。说来也是缘分，之后我在qunar工作认识的，也就是我现在的女朋友，就是来自云南的，因此我觉得我和云南还是挺有缘分的。回到学校，便是答辩，合照，聚会。有些细节现在已经忘记，记得最清楚的是毕业季真的很难过。可能是因为大家都舍不得，室友们几乎都是同一天走的。\"><a href=\"#5月初的时候，趁着劳动节就回学校了，因为马上就要做毕业答辩，但是论文什么都还没写。记得离开北京的时候，还是挺高兴的，毕竟学校还有一大堆的同学和朋友在等着我回去。期间和几个好朋友去了一趟云南，这是第一次去云南，我们先是坐飞机来到了昆明，然后去了大理、丽江、香格里拉。那边的风景实在是很漂亮，特别是从大理的苍山上俯瞰整个大理。说来也是缘分，之后我在qunar工作认识的，也就是我现在的女朋友，就是来自云南的，因此我觉得我和云南还是挺有缘分的。回到学校，便是答辩，合照，聚会。有些细节现在已经忘记，记得最清楚的是毕业季真的很难过。可能是因为大家都舍不得，室友们几乎都是同一天走的。\" class=\"headerlink\" title=\"　　5月初的时候，趁着劳动节就回学校了，因为马上就要做毕业答辩，但是论文什么都还没写。记得离开北京的时候，还是挺高兴的，毕竟学校还有一大堆的同学和朋友在等着我回去。期间和几个好朋友去了一趟云南，这是第一次去云南，我们先是坐飞机来到了昆明，然后去了大理、丽江、香格里拉。那边的风景实在是很漂亮，特别是从大理的苍山上俯瞰整个大理。说来也是缘分，之后我在qunar工作认识的，也就是我现在的女朋友，就是来自云南的，因此我觉得我和云南还是挺有缘分的。回到学校，便是答辩，合照，聚会。有些细节现在已经忘记，记得最清楚的是毕业季真的很难过。可能是因为大家都舍不得，室友们几乎都是同一天走的。\"></a>　　5月初的时候，趁着劳动节就回学校了，因为马上就要做毕业答辩，但是论文什么都还没写。记得离开北京的时候，还是挺高兴的，毕竟学校还有一大堆的同学和朋友在等着我回去。期间和几个好朋友去了一趟云南，这是第一次去云南，我们先是坐飞机来到了昆明，然后去了大理、丽江、香格里拉。那边的风景实在是很漂亮，特别是从大理的苍山上俯瞰整个大理。说来也是缘分，之后我在qunar工作认识的，也就是我现在的女朋友，就是来自云南的，因此我觉得我和云南还是挺有缘分的。回到学校，便是答辩，合照，聚会。有些细节现在已经忘记，记得最清楚的是毕业季真的很难过。可能是因为大家都舍不得，室友们几乎都是同一天走的。</h5><p><img src=\"../../img/life/2016-roommate.jpeg\" alt=\"2016-室友毕业小聚\"></p>\n<h5 id=\"兜兜转转，现在已经是2017年1月26号凌晨1点半，我正在火车站的候车室内席地而坐，等候回家的列车，车需要等到3点半才行，但是我现在已经有点困了。说到回家，虽然已经工作，但是今年回家的次数还真不少。除掉办领身份证、办理护照回去两次，另外还回去了大概两三次。可能是因为要工作了，想到以后没有了暑假，只有过年才有时间回家，所以一有时间便往家里赶。幸运的是，父母现在身体还算好-能够照顾好自己。希望他们永远健康。\"><a href=\"#兜兜转转，现在已经是2017年1月26号凌晨1点半，我正在火车站的候车室内席地而坐，等候回家的列车，车需要等到3点半才行，但是我现在已经有点困了。说到回家，虽然已经工作，但是今年回家的次数还真不少。除掉办领身份证、办理护照回去两次，另外还回去了大概两三次。可能是因为要工作了，想到以后没有了暑假，只有过年才有时间回家，所以一有时间便往家里赶。幸运的是，父母现在身体还算好-能够照顾好自己。希望他们永远健康。\" class=\"headerlink\" title=\"　　兜兜转转，现在已经是2017年1月26号凌晨1点半，我正在火车站的候车室内席地而坐，等候回家的列车，车需要等到3点半才行，但是我现在已经有点困了。说到回家，虽然已经工作，但是今年回家的次数还真不少。除掉办领身份证、办理护照回去两次，另外还回去了大概两三次。可能是因为要工作了，想到以后没有了暑假，只有过年才有时间回家，所以一有时间便往家里赶。幸运的是，父母现在身体还算好,能够照顾好自己。希望他们永远健康。\"></a>　　兜兜转转，现在已经是2017年1月26号凌晨1点半，我正在火车站的候车室内席地而坐，等候回家的列车，车需要等到3点半才行，但是我现在已经有点困了。说到回家，虽然已经工作，但是今年回家的次数还真不少。除掉办领身份证、办理护照回去两次，另外还回去了大概两三次。可能是因为要工作了，想到以后没有了暑假，只有过年才有时间回家，所以一有时间便往家里赶。幸运的是，父母现在身体还算好,能够照顾好自己。希望他们永远健康。</h5><h5 id=\"继续说说2016吧，其实也没什么好说的了。对了，我和我的女朋友就是这一年在公司认识的，和她在一起4个多月了，吵了无数次架，我们的感情却越来越深，她真的是一个好女孩，希望在我今后的道路当中，都有她的陪伴。至于2016年这一年的工作情况，就不在这里总结了，总之希望新的一年越来越好。我也需要更加努力。这一年对我来说有一个大的变化就是，之前我是一个悲观主义者，对很多东西都不看好，认为那都是命中注定，我们改变不了什么，我们太渺小了。现在，我依然认为我们改变不了任何事情，但是我坚信我们可以改变自己。这个世界不是你想象中的那个样子，你也没有办法将它改变成你想要的样子，那就改变你自己，改变你看这个世界的角度和观点，那世界将是一个崭新的世界。\"><a href=\"#继续说说2016吧，其实也没什么好说的了。对了，我和我的女朋友就是这一年在公司认识的，和她在一起4个多月了，吵了无数次架，我们的感情却越来越深，她真的是一个好女孩，希望在我今后的道路当中，都有她的陪伴。至于2016年这一年的工作情况，就不在这里总结了，总之希望新的一年越来越好。我也需要更加努力。这一年对我来说有一个大的变化就是，之前我是一个悲观主义者，对很多东西都不看好，认为那都是命中注定，我们改变不了什么，我们太渺小了。现在，我依然认为我们改变不了任何事情，但是我坚信我们可以改变自己。这个世界不是你想象中的那个样子，你也没有办法将它改变成你想要的样子，那就改变你自己，改变你看这个世界的角度和观点，那世界将是一个崭新的世界。\" class=\"headerlink\" title=\"　　继续说说2016吧，其实也没什么好说的了。对了，我和我的女朋友就是这一年在公司认识的，和她在一起4个多月了，吵了无数次架，我们的感情却越来越深，她真的是一个好女孩，希望在我今后的道路当中，都有她的陪伴。至于2016年这一年的工作情况，就不在这里总结了，总之希望新的一年越来越好。我也需要更加努力。这一年对我来说有一个大的变化就是，之前我是一个悲观主义者，对很多东西都不看好，认为那都是命中注定，我们改变不了什么，我们太渺小了。现在，我依然认为我们改变不了任何事情，但是我坚信我们可以改变自己。这个世界不是你想象中的那个样子，你也没有办法将它改变成你想要的样子，那就改变你自己，改变你看这个世界的角度和观点，那世界将是一个崭新的世界。\"></a>　　继续说说2016吧，其实也没什么好说的了。对了，我和我的女朋友就是这一年在公司认识的，和她在一起4个多月了，吵了无数次架，我们的感情却越来越深，她真的是一个好女孩，希望在我今后的道路当中，都有她的陪伴。至于2016年这一年的工作情况，就不在这里总结了，总之希望新的一年越来越好。我也需要更加努力。这一年对我来说有一个大的变化就是，之前我是一个悲观主义者，对很多东西都不看好，认为那都是命中注定，我们改变不了什么，我们太渺小了。现在，我依然认为我们改变不了任何事情，但是我坚信我们可以改变自己。这个世界不是你想象中的那个样子，你也没有办法将它改变成你想要的样子，那就改变你自己，改变你看这个世界的角度和观点，那世界将是一个崭新的世界。</h5>","site":{"data":{}},"excerpt":"<h5 id=\"2017年1月份已经快过去了，再有两天就是春节。在这之前的春节，都是作为一个学生的身份，自然是有寒假的，这第一年工作，却要等到大年三十才能回家，多少还是有些不适应。加上北京这两天风特别大，这不，得了感冒了，今天还请了一天病假，才有时间坐在家里开始完成这一篇16年总结。其实20多天前就计划要写年终总结，但是最近很多事情都在耽误这一计划。加上需要将博客从jekyll迁移到hexo，使得每次打开博客，大部分时间都是在完成博客页面主题的编写，所以在博客文章上花的时间少了很多（其实之前好像也没花多少时间，惭愧）。\"><a href=\"#2017年1月份已经快过去了，再有两天就是春节。在这之前的春节，都是作为一个学生的身份，自然是有寒假的，这第一年工作，却要等到大年三十才能回家，多少还是有些不适应。加上北京这两天风特别大，这不，得了感冒了，今天还请了一天病假，才有时间坐在家里开始完成这一篇16年总结。其实20多天前就计划要写年终总结，但是最近很多事情都在耽误这一计划。加上需要将博客从jekyll迁移到hexo，使得每次打开博客，大部分时间都是在完成博客页面主题的编写，所以在博客文章上花的时间少了很多（其实之前好像也没花多少时间，惭愧）。\" class=\"headerlink\" title=\"　　2017年1月份已经快过去了，再有两天就是春节。在这之前的春节，都是作为一个学生的身份，自然是有寒假的，这第一年工作，却要等到大年三十才能回家，多少还是有些不适应。加上北京这两天风特别大，这不，得了感冒了，今天还请了一天病假，才有时间坐在家里开始完成这一篇16年总结。其实20多天前就计划要写年终总结，但是最近很多事情都在耽误这一计划。加上需要将博客从jekyll迁移到hexo，使得每次打开博客，大部分时间都是在完成博客页面主题的编写，所以在博客文章上花的时间少了很多（其实之前好像也没花多少时间，惭愧）。\"></a>　　2017年1月份已经快过去了，再有两天就是春节。在这之前的春节，都是作为一个学生的身份，自然是有寒假的，这第一年工作，却要等到大年三十才能回家，多少还是有些不适应。加上北京这两天风特别大，这不，得了感冒了，今天还请了一天病假，才有时间坐在家里开始完成这一篇16年总结。其实20多天前就计划要写年终总结，但是最近很多事情都在耽误这一计划。加上需要将博客从jekyll迁移到hexo，使得每次打开博客，大部分时间都是在完成博客页面主题的编写，所以在博客文章上花的时间少了很多（其实之前好像也没花多少时间，惭愧）。</h5>","more":"<h5 id=\"其实除了几篇技术文章，我几乎没有写过博客，以前倒是坚持写过一段时间的日记，但也总是断断续续。这当中一个很重要的原因就是从小作文就不太好，不太会用文字去描述身边的事情和自己的想法（比如上面这一段文字，就花了大概十分钟，删删减减才完成的），但我本身是很想去表达一些东西的。这个博客是16年10月份左右搭建起来的，大部分时间都用在了前端页面的编写上面了，起初是希望能够做一些技术上的总结，后来发现可以将生活中的一些总结也记录在此，再之后又添加了read版块。有点偏题了，已经不像是年终总结了。下面开始回到正题。\"><a href=\"#其实除了几篇技术文章，我几乎没有写过博客，以前倒是坚持写过一段时间的日记，但也总是断断续续。这当中一个很重要的原因就是从小作文就不太好，不太会用文字去描述身边的事情和自己的想法（比如上面这一段文字，就花了大概十分钟，删删减减才完成的），但我本身是很想去表达一些东西的。这个博客是16年10月份左右搭建起来的，大部分时间都用在了前端页面的编写上面了，起初是希望能够做一些技术上的总结，后来发现可以将生活中的一些总结也记录在此，再之后又添加了read版块。有点偏题了，已经不像是年终总结了。下面开始回到正题。\" class=\"headerlink\" title=\"　　其实除了几篇技术文章，我几乎没有写过博客，以前倒是坚持写过一段时间的日记，但也总是断断续续。这当中一个很重要的原因就是从小作文就不太好，不太会用文字去描述身边的事情和自己的想法（比如上面这一段文字，就花了大概十分钟，删删减减才完成的），但我本身是很想去表达一些东西的。这个博客是16年10月份左右搭建起来的，大部分时间都用在了前端页面的编写上面了，起初是希望能够做一些技术上的总结，后来发现可以将生活中的一些总结也记录在此，再之后又添加了read版块。有点偏题了，已经不像是年终总结了。下面开始回到正题。\"></a>　　其实除了几篇技术文章，我几乎没有写过博客，以前倒是坚持写过一段时间的日记，但也总是断断续续。这当中一个很重要的原因就是从小作文就不太好，不太会用文字去描述身边的事情和自己的想法（比如上面这一段文字，就花了大概十分钟，删删减减才完成的），但我本身是很想去表达一些东西的。这个博客是16年10月份左右搭建起来的，大部分时间都用在了前端页面的编写上面了，起初是希望能够做一些技术上的总结，后来发现可以将生活中的一些总结也记录在此，再之后又添加了read版块。有点偏题了，已经不像是年终总结了。下面开始回到正题。</h5><h5 id=\"去年这一年是我从一个面向学校的学生转变为面向社会的工作者的一年。和很多毕业生一样，有一点迷茫，也有对未来的无限向往，我们就像一个个梦想家，有着无限的期望。但是我现在更希望做一个实干家，或者说行动大于空想。我是在15年的9月21号左右通过qunar面试的，这之前也参加过其他公司的校招，但是我之前的校招经历比较坎坷。因此我对qunar是非常感激的，加上面试的两位面试官也给我很好的感觉。所以在拿到qunar的offer之后，我几乎没有再考虑过其他公司。虽然随之而来的消息是qunar被携程合并，管理层的集体退出，以及多家航司对qunar的联合打击。\"><a href=\"#去年这一年是我从一个面向学校的学生转变为面向社会的工作者的一年。和很多毕业生一样，有一点迷茫，也有对未来的无限向往，我们就像一个个梦想家，有着无限的期望。但是我现在更希望做一个实干家，或者说行动大于空想。我是在15年的9月21号左右通过qunar面试的，这之前也参加过其他公司的校招，但是我之前的校招经历比较坎坷。因此我对qunar是非常感激的，加上面试的两位面试官也给我很好的感觉。所以在拿到qunar的offer之后，我几乎没有再考虑过其他公司。虽然随之而来的消息是qunar被携程合并，管理层的集体退出，以及多家航司对qunar的联合打击。\" class=\"headerlink\" title=\"　　去年这一年是我从一个面向学校的学生转变为面向社会的工作者的一年。和很多毕业生一样，有一点迷茫，也有对未来的无限向往，我们就像一个个梦想家，有着无限的期望。但是我现在更希望做一个实干家，或者说行动大于空想。我是在15年的9月21号左右通过qunar面试的，这之前也参加过其他公司的校招，但是我之前的校招经历比较坎坷。因此我对qunar是非常感激的，加上面试的两位面试官也给我很好的感觉。所以在拿到qunar的offer之后，我几乎没有再考虑过其他公司。虽然随之而来的消息是qunar被携程合并，管理层的集体退出，以及多家航司对qunar的联合打击。\"></a>　　去年这一年是我从一个面向学校的学生转变为面向社会的工作者的一年。和很多毕业生一样，有一点迷茫，也有对未来的无限向往，我们就像一个个梦想家，有着无限的期望。但是我现在更希望做一个实干家，或者说行动大于空想。我是在15年的9月21号左右通过qunar面试的，这之前也参加过其他公司的校招，但是我之前的校招经历比较坎坷。因此我对qunar是非常感激的，加上面试的两位面试官也给我很好的感觉。所以在拿到qunar的offer之后，我几乎没有再考虑过其他公司。虽然随之而来的消息是qunar被携程合并，管理层的集体退出，以及多家航司对qunar的联合打击。</h5><h5 id=\"16年春节后，来到北京参加qunar的技术培训，和另外几个qunar的小伙伴，一起合租，一个房间睡了三个人，当时算了下，那一套房子有5个房间，一共住了14个人，当时最大的愿望就是，转正之后一定要有自己房间。期间公司培训的内容就是java后端开发那一套，个人觉得那是面向初学者的，所以我一有时间就去写毕业设计了，现在想起来多少有一些后悔。这可以算是我第一次参加工作，之前在学校很少出去兼职赚钱，大多数时间都是在团队或者实验室写代码做项目，感觉自己确实很契合程序员这个职业-够宅够闷骚。\"><a href=\"#16年春节后，来到北京参加qunar的技术培训，和另外几个qunar的小伙伴，一起合租，一个房间睡了三个人，当时算了下，那一套房子有5个房间，一共住了14个人，当时最大的愿望就是，转正之后一定要有自己房间。期间公司培训的内容就是java后端开发那一套，个人觉得那是面向初学者的，所以我一有时间就去写毕业设计了，现在想起来多少有一些后悔。这可以算是我第一次参加工作，之前在学校很少出去兼职赚钱，大多数时间都是在团队或者实验室写代码做项目，感觉自己确实很契合程序员这个职业-够宅够闷骚。\" class=\"headerlink\" title=\"　　16年春节后，来到北京参加qunar的技术培训，和另外几个qunar的小伙伴，一起合租，一个房间睡了三个人，当时算了下，那一套房子有5个房间，一共住了14个人，当时最大的愿望就是，转正之后一定要有自己房间。期间公司培训的内容就是java后端开发那一套，个人觉得那是面向初学者的，所以我一有时间就去写毕业设计了，现在想起来多少有一些后悔。这可以算是我第一次参加工作，之前在学校很少出去兼职赚钱，大多数时间都是在团队或者实验室写代码做项目，感觉自己确实很契合程序员这个职业-够宅够闷骚。\"></a>　　16年春节后，来到北京参加qunar的技术培训，和另外几个qunar的小伙伴，一起合租，一个房间睡了三个人，当时算了下，那一套房子有5个房间，一共住了14个人，当时最大的愿望就是，转正之后一定要有自己房间。期间公司培训的内容就是java后端开发那一套，个人觉得那是面向初学者的，所以我一有时间就去写毕业设计了，现在想起来多少有一些后悔。这可以算是我第一次参加工作，之前在学校很少出去兼职赚钱，大多数时间都是在团队或者实验室写代码做项目，感觉自己确实很契合程序员这个职业-够宅够闷骚。</h5><p><img src=\"../../img/life/2016-qunar.jpeg\" alt=\"2016-qunar技术培训照片\"></p>\n<h5 id=\"5月初的时候，趁着劳动节就回学校了，因为马上就要做毕业答辩，但是论文什么都还没写。记得离开北京的时候，还是挺高兴的，毕竟学校还有一大堆的同学和朋友在等着我回去。期间和几个好朋友去了一趟云南，这是第一次去云南，我们先是坐飞机来到了昆明，然后去了大理、丽江、香格里拉。那边的风景实在是很漂亮，特别是从大理的苍山上俯瞰整个大理。说来也是缘分，之后我在qunar工作认识的，也就是我现在的女朋友，就是来自云南的，因此我觉得我和云南还是挺有缘分的。回到学校，便是答辩，合照，聚会。有些细节现在已经忘记，记得最清楚的是毕业季真的很难过。可能是因为大家都舍不得，室友们几乎都是同一天走的。\"><a href=\"#5月初的时候，趁着劳动节就回学校了，因为马上就要做毕业答辩，但是论文什么都还没写。记得离开北京的时候，还是挺高兴的，毕竟学校还有一大堆的同学和朋友在等着我回去。期间和几个好朋友去了一趟云南，这是第一次去云南，我们先是坐飞机来到了昆明，然后去了大理、丽江、香格里拉。那边的风景实在是很漂亮，特别是从大理的苍山上俯瞰整个大理。说来也是缘分，之后我在qunar工作认识的，也就是我现在的女朋友，就是来自云南的，因此我觉得我和云南还是挺有缘分的。回到学校，便是答辩，合照，聚会。有些细节现在已经忘记，记得最清楚的是毕业季真的很难过。可能是因为大家都舍不得，室友们几乎都是同一天走的。\" class=\"headerlink\" title=\"　　5月初的时候，趁着劳动节就回学校了，因为马上就要做毕业答辩，但是论文什么都还没写。记得离开北京的时候，还是挺高兴的，毕竟学校还有一大堆的同学和朋友在等着我回去。期间和几个好朋友去了一趟云南，这是第一次去云南，我们先是坐飞机来到了昆明，然后去了大理、丽江、香格里拉。那边的风景实在是很漂亮，特别是从大理的苍山上俯瞰整个大理。说来也是缘分，之后我在qunar工作认识的，也就是我现在的女朋友，就是来自云南的，因此我觉得我和云南还是挺有缘分的。回到学校，便是答辩，合照，聚会。有些细节现在已经忘记，记得最清楚的是毕业季真的很难过。可能是因为大家都舍不得，室友们几乎都是同一天走的。\"></a>　　5月初的时候，趁着劳动节就回学校了，因为马上就要做毕业答辩，但是论文什么都还没写。记得离开北京的时候，还是挺高兴的，毕竟学校还有一大堆的同学和朋友在等着我回去。期间和几个好朋友去了一趟云南，这是第一次去云南，我们先是坐飞机来到了昆明，然后去了大理、丽江、香格里拉。那边的风景实在是很漂亮，特别是从大理的苍山上俯瞰整个大理。说来也是缘分，之后我在qunar工作认识的，也就是我现在的女朋友，就是来自云南的，因此我觉得我和云南还是挺有缘分的。回到学校，便是答辩，合照，聚会。有些细节现在已经忘记，记得最清楚的是毕业季真的很难过。可能是因为大家都舍不得，室友们几乎都是同一天走的。</h5><p><img src=\"../../img/life/2016-roommate.jpeg\" alt=\"2016-室友毕业小聚\"></p>\n<h5 id=\"兜兜转转，现在已经是2017年1月26号凌晨1点半，我正在火车站的候车室内席地而坐，等候回家的列车，车需要等到3点半才行，但是我现在已经有点困了。说到回家，虽然已经工作，但是今年回家的次数还真不少。除掉办领身份证、办理护照回去两次，另外还回去了大概两三次。可能是因为要工作了，想到以后没有了暑假，只有过年才有时间回家，所以一有时间便往家里赶。幸运的是，父母现在身体还算好-能够照顾好自己。希望他们永远健康。\"><a href=\"#兜兜转转，现在已经是2017年1月26号凌晨1点半，我正在火车站的候车室内席地而坐，等候回家的列车，车需要等到3点半才行，但是我现在已经有点困了。说到回家，虽然已经工作，但是今年回家的次数还真不少。除掉办领身份证、办理护照回去两次，另外还回去了大概两三次。可能是因为要工作了，想到以后没有了暑假，只有过年才有时间回家，所以一有时间便往家里赶。幸运的是，父母现在身体还算好-能够照顾好自己。希望他们永远健康。\" class=\"headerlink\" title=\"　　兜兜转转，现在已经是2017年1月26号凌晨1点半，我正在火车站的候车室内席地而坐，等候回家的列车，车需要等到3点半才行，但是我现在已经有点困了。说到回家，虽然已经工作，但是今年回家的次数还真不少。除掉办领身份证、办理护照回去两次，另外还回去了大概两三次。可能是因为要工作了，想到以后没有了暑假，只有过年才有时间回家，所以一有时间便往家里赶。幸运的是，父母现在身体还算好,能够照顾好自己。希望他们永远健康。\"></a>　　兜兜转转，现在已经是2017年1月26号凌晨1点半，我正在火车站的候车室内席地而坐，等候回家的列车，车需要等到3点半才行，但是我现在已经有点困了。说到回家，虽然已经工作，但是今年回家的次数还真不少。除掉办领身份证、办理护照回去两次，另外还回去了大概两三次。可能是因为要工作了，想到以后没有了暑假，只有过年才有时间回家，所以一有时间便往家里赶。幸运的是，父母现在身体还算好,能够照顾好自己。希望他们永远健康。</h5><h5 id=\"继续说说2016吧，其实也没什么好说的了。对了，我和我的女朋友就是这一年在公司认识的，和她在一起4个多月了，吵了无数次架，我们的感情却越来越深，她真的是一个好女孩，希望在我今后的道路当中，都有她的陪伴。至于2016年这一年的工作情况，就不在这里总结了，总之希望新的一年越来越好。我也需要更加努力。这一年对我来说有一个大的变化就是，之前我是一个悲观主义者，对很多东西都不看好，认为那都是命中注定，我们改变不了什么，我们太渺小了。现在，我依然认为我们改变不了任何事情，但是我坚信我们可以改变自己。这个世界不是你想象中的那个样子，你也没有办法将它改变成你想要的样子，那就改变你自己，改变你看这个世界的角度和观点，那世界将是一个崭新的世界。\"><a href=\"#继续说说2016吧，其实也没什么好说的了。对了，我和我的女朋友就是这一年在公司认识的，和她在一起4个多月了，吵了无数次架，我们的感情却越来越深，她真的是一个好女孩，希望在我今后的道路当中，都有她的陪伴。至于2016年这一年的工作情况，就不在这里总结了，总之希望新的一年越来越好。我也需要更加努力。这一年对我来说有一个大的变化就是，之前我是一个悲观主义者，对很多东西都不看好，认为那都是命中注定，我们改变不了什么，我们太渺小了。现在，我依然认为我们改变不了任何事情，但是我坚信我们可以改变自己。这个世界不是你想象中的那个样子，你也没有办法将它改变成你想要的样子，那就改变你自己，改变你看这个世界的角度和观点，那世界将是一个崭新的世界。\" class=\"headerlink\" title=\"　　继续说说2016吧，其实也没什么好说的了。对了，我和我的女朋友就是这一年在公司认识的，和她在一起4个多月了，吵了无数次架，我们的感情却越来越深，她真的是一个好女孩，希望在我今后的道路当中，都有她的陪伴。至于2016年这一年的工作情况，就不在这里总结了，总之希望新的一年越来越好。我也需要更加努力。这一年对我来说有一个大的变化就是，之前我是一个悲观主义者，对很多东西都不看好，认为那都是命中注定，我们改变不了什么，我们太渺小了。现在，我依然认为我们改变不了任何事情，但是我坚信我们可以改变自己。这个世界不是你想象中的那个样子，你也没有办法将它改变成你想要的样子，那就改变你自己，改变你看这个世界的角度和观点，那世界将是一个崭新的世界。\"></a>　　继续说说2016吧，其实也没什么好说的了。对了，我和我的女朋友就是这一年在公司认识的，和她在一起4个多月了，吵了无数次架，我们的感情却越来越深，她真的是一个好女孩，希望在我今后的道路当中，都有她的陪伴。至于2016年这一年的工作情况，就不在这里总结了，总之希望新的一年越来越好。我也需要更加努力。这一年对我来说有一个大的变化就是，之前我是一个悲观主义者，对很多东西都不看好，认为那都是命中注定，我们改变不了什么，我们太渺小了。现在，我依然认为我们改变不了任何事情，但是我坚信我们可以改变自己。这个世界不是你想象中的那个样子，你也没有办法将它改变成你想要的样子，那就改变你自己，改变你看这个世界的角度和观点，那世界将是一个崭新的世界。</h5>"},{"layout":"post","title":"又到云南","date":"2017-04-03T16:00:00.000Z","original":true,"_content":"\n##### 　　趁着清明节，加上1.5天年假和0.5的事假，一共5天，我和媳妇儿来回到了她的家乡——云南建水。这不是我第一次来到云南，却是我第一次来到她家里。一路上我看着王小波的《黄金时代》，说说笑笑，我竟然一点都不紧张。\n<!--more-->\n\n##### 　　三天的时间，吃了几顿米线和上了两次坟，时间居然就这样过去了。现在我们已经在回北京的路上\n\n![我和秋薇在建水](../../img/life/jianshui.jpeg)    <div class='img-note'>我和秋薇在建水</div>","source":"_posts/life/yunnan.md","raw":"---\nlayout: post\ntitle: 又到云南\ndate: 2017/04/04\noriginal: true\ntags: [life, index]\n---\n\n##### 　　趁着清明节，加上1.5天年假和0.5的事假，一共5天，我和媳妇儿来回到了她的家乡——云南建水。这不是我第一次来到云南，却是我第一次来到她家里。一路上我看着王小波的《黄金时代》，说说笑笑，我竟然一点都不紧张。\n<!--more-->\n\n##### 　　三天的时间，吃了几顿米线和上了两次坟，时间居然就这样过去了。现在我们已经在回北京的路上\n\n![我和秋薇在建水](../../img/life/jianshui.jpeg)    <div class='img-note'>我和秋薇在建水</div>","slug":"life/yunnan","published":1,"updated":"2017-10-09T03:58:21.023Z","_id":"cj8g07xkq000l4kh955xvs1i9","comments":1,"photos":[],"link":"","content":"<h5 id=\"趁着清明节，加上1-5天年假和0-5的事假，一共5天，我和媳妇儿来回到了她的家乡——云南建水。这不是我第一次来到云南，却是我第一次来到她家里。一路上我看着王小波的《黄金时代》，说说笑笑，我竟然一点都不紧张。\"><a href=\"#趁着清明节，加上1-5天年假和0-5的事假，一共5天，我和媳妇儿来回到了她的家乡——云南建水。这不是我第一次来到云南，却是我第一次来到她家里。一路上我看着王小波的《黄金时代》，说说笑笑，我竟然一点都不紧张。\" class=\"headerlink\" title=\"　　趁着清明节，加上1.5天年假和0.5的事假，一共5天，我和媳妇儿来回到了她的家乡——云南建水。这不是我第一次来到云南，却是我第一次来到她家里。一路上我看着王小波的《黄金时代》，说说笑笑，我竟然一点都不紧张。\"></a>　　趁着清明节，加上1.5天年假和0.5的事假，一共5天，我和媳妇儿来回到了她的家乡——云南建水。这不是我第一次来到云南，却是我第一次来到她家里。一路上我看着王小波的《黄金时代》，说说笑笑，我竟然一点都不紧张。</h5><a id=\"more\"></a>\n<h5 id=\"三天的时间，吃了几顿米线和上了两次坟，时间居然就这样过去了。现在我们已经在回北京的路上\"><a href=\"#三天的时间，吃了几顿米线和上了两次坟，时间居然就这样过去了。现在我们已经在回北京的路上\" class=\"headerlink\" title=\"　　三天的时间，吃了几顿米线和上了两次坟，时间居然就这样过去了。现在我们已经在回北京的路上\"></a>　　三天的时间，吃了几顿米线和上了两次坟，时间居然就这样过去了。现在我们已经在回北京的路上</h5><p><img src=\"../../img/life/jianshui.jpeg\" alt=\"我和秋薇在建水\">    <div class=\"img-note\">我和秋薇在建水</div></p>\n","site":{"data":{}},"excerpt":"<h5 id=\"趁着清明节，加上1-5天年假和0-5的事假，一共5天，我和媳妇儿来回到了她的家乡——云南建水。这不是我第一次来到云南，却是我第一次来到她家里。一路上我看着王小波的《黄金时代》，说说笑笑，我竟然一点都不紧张。\"><a href=\"#趁着清明节，加上1-5天年假和0-5的事假，一共5天，我和媳妇儿来回到了她的家乡——云南建水。这不是我第一次来到云南，却是我第一次来到她家里。一路上我看着王小波的《黄金时代》，说说笑笑，我竟然一点都不紧张。\" class=\"headerlink\" title=\"　　趁着清明节，加上1.5天年假和0.5的事假，一共5天，我和媳妇儿来回到了她的家乡——云南建水。这不是我第一次来到云南，却是我第一次来到她家里。一路上我看着王小波的《黄金时代》，说说笑笑，我竟然一点都不紧张。\"></a>　　趁着清明节，加上1.5天年假和0.5的事假，一共5天，我和媳妇儿来回到了她的家乡——云南建水。这不是我第一次来到云南，却是我第一次来到她家里。一路上我看着王小波的《黄金时代》，说说笑笑，我竟然一点都不紧张。</h5>","more":"<h5 id=\"三天的时间，吃了几顿米线和上了两次坟，时间居然就这样过去了。现在我们已经在回北京的路上\"><a href=\"#三天的时间，吃了几顿米线和上了两次坟，时间居然就这样过去了。现在我们已经在回北京的路上\" class=\"headerlink\" title=\"　　三天的时间，吃了几顿米线和上了两次坟，时间居然就这样过去了。现在我们已经在回北京的路上\"></a>　　三天的时间，吃了几顿米线和上了两次坟，时间居然就这样过去了。现在我们已经在回北京的路上</h5><p><img src=\"../../img/life/jianshui.jpeg\" alt=\"我和秋薇在建水\">    <div class=\"img-note\">我和秋薇在建水</div></p>"},{"layout":"post","title":"等分数组","date":"2017-04-15T16:00:00.000Z","original":true,"tag":[["算法","arithmetic"]],"_content":"\n## 题目要求：\n##### 偶数的数组里面有一些正数，分成两个大小一样的子数组，两个数组之和尽量相等\n<!--more-->\n\n## 分析过程：\n##### 题目要求比较简单，也很容易理解\n### 解法一\n##### 因为是尽量相等，所以最简单的方法就是。依次遍历原数组中的每个数，判断两个子数组的和，将该数放入到和较小的那个数组中。以此类推，直到遍历完成。这样能够在原数组的顺序下，两个数组都是尽量相等的。\n##### 但是问题是如果原数组当中最后一个数比其他数大很多，就会导致子数组在最后一步后相差得比较大。\n\n### 解法二\n##### 解法二是针对解法一的一种优化，为了解决解法一种的问题，需要对原数组进行排序，排序算法这里就不多讲，只需要将原数组排列成从大到小的顺序，然后再按照解法一去等分原数组。\n\n## 最后再说一些：\n##### 解法二的过程很有意思，就像如果要把一个框内尽量多的装水果，应该先装大的水果，再用小的水果将框填满。等分数组也是先将大的数先放入子数组，这样就方便后面的过程去调试和精细话。\n","source":"_posts/arithmetic/array1.md","raw":"---\nlayout: post\ntitle: 等分数组\ndate: 2017/04/16\ntags: [tech, arithmetic, index]\noriginal: true\ntag: [[算法, arithmetic]]\n---\n\n## 题目要求：\n##### 偶数的数组里面有一些正数，分成两个大小一样的子数组，两个数组之和尽量相等\n<!--more-->\n\n## 分析过程：\n##### 题目要求比较简单，也很容易理解\n### 解法一\n##### 因为是尽量相等，所以最简单的方法就是。依次遍历原数组中的每个数，判断两个子数组的和，将该数放入到和较小的那个数组中。以此类推，直到遍历完成。这样能够在原数组的顺序下，两个数组都是尽量相等的。\n##### 但是问题是如果原数组当中最后一个数比其他数大很多，就会导致子数组在最后一步后相差得比较大。\n\n### 解法二\n##### 解法二是针对解法一的一种优化，为了解决解法一种的问题，需要对原数组进行排序，排序算法这里就不多讲，只需要将原数组排列成从大到小的顺序，然后再按照解法一去等分原数组。\n\n## 最后再说一些：\n##### 解法二的过程很有意思，就像如果要把一个框内尽量多的装水果，应该先装大的水果，再用小的水果将框填满。等分数组也是先将大的数先放入子数组，这样就方便后面的过程去调试和精细话。\n","slug":"arithmetic/array1","published":1,"updated":"2017-10-06T16:03:22.628Z","comments":1,"photos":[],"link":"","_id":"cj8jros6q000030s6w98402ss","content":"<h2 id=\"题目要求：\"><a href=\"#题目要求：\" class=\"headerlink\" title=\"题目要求：\"></a>题目要求：</h2><h5 id=\"偶数的数组里面有一些正数，分成两个大小一样的子数组，两个数组之和尽量相等\"><a href=\"#偶数的数组里面有一些正数，分成两个大小一样的子数组，两个数组之和尽量相等\" class=\"headerlink\" title=\"偶数的数组里面有一些正数，分成两个大小一样的子数组，两个数组之和尽量相等\"></a>偶数的数组里面有一些正数，分成两个大小一样的子数组，两个数组之和尽量相等</h5><a id=\"more\"></a>\n<h2 id=\"分析过程：\"><a href=\"#分析过程：\" class=\"headerlink\" title=\"分析过程：\"></a>分析过程：</h2><h5 id=\"题目要求比较简单，也很容易理解\"><a href=\"#题目要求比较简单，也很容易理解\" class=\"headerlink\" title=\"题目要求比较简单，也很容易理解\"></a>题目要求比较简单，也很容易理解</h5><h3 id=\"解法一\"><a href=\"#解法一\" class=\"headerlink\" title=\"解法一\"></a>解法一</h3><h5 id=\"因为是尽量相等，所以最简单的方法就是。依次遍历原数组中的每个数，判断两个子数组的和，将该数放入到和较小的那个数组中。以此类推，直到遍历完成。这样能够在原数组的顺序下，两个数组都是尽量相等的。\"><a href=\"#因为是尽量相等，所以最简单的方法就是。依次遍历原数组中的每个数，判断两个子数组的和，将该数放入到和较小的那个数组中。以此类推，直到遍历完成。这样能够在原数组的顺序下，两个数组都是尽量相等的。\" class=\"headerlink\" title=\"因为是尽量相等，所以最简单的方法就是。依次遍历原数组中的每个数，判断两个子数组的和，将该数放入到和较小的那个数组中。以此类推，直到遍历完成。这样能够在原数组的顺序下，两个数组都是尽量相等的。\"></a>因为是尽量相等，所以最简单的方法就是。依次遍历原数组中的每个数，判断两个子数组的和，将该数放入到和较小的那个数组中。以此类推，直到遍历完成。这样能够在原数组的顺序下，两个数组都是尽量相等的。</h5><h5 id=\"但是问题是如果原数组当中最后一个数比其他数大很多，就会导致子数组在最后一步后相差得比较大。\"><a href=\"#但是问题是如果原数组当中最后一个数比其他数大很多，就会导致子数组在最后一步后相差得比较大。\" class=\"headerlink\" title=\"但是问题是如果原数组当中最后一个数比其他数大很多，就会导致子数组在最后一步后相差得比较大。\"></a>但是问题是如果原数组当中最后一个数比其他数大很多，就会导致子数组在最后一步后相差得比较大。</h5><h3 id=\"解法二\"><a href=\"#解法二\" class=\"headerlink\" title=\"解法二\"></a>解法二</h3><h5 id=\"解法二是针对解法一的一种优化，为了解决解法一种的问题，需要对原数组进行排序，排序算法这里就不多讲，只需要将原数组排列成从大到小的顺序，然后再按照解法一去等分原数组。\"><a href=\"#解法二是针对解法一的一种优化，为了解决解法一种的问题，需要对原数组进行排序，排序算法这里就不多讲，只需要将原数组排列成从大到小的顺序，然后再按照解法一去等分原数组。\" class=\"headerlink\" title=\"解法二是针对解法一的一种优化，为了解决解法一种的问题，需要对原数组进行排序，排序算法这里就不多讲，只需要将原数组排列成从大到小的顺序，然后再按照解法一去等分原数组。\"></a>解法二是针对解法一的一种优化，为了解决解法一种的问题，需要对原数组进行排序，排序算法这里就不多讲，只需要将原数组排列成从大到小的顺序，然后再按照解法一去等分原数组。</h5><h2 id=\"最后再说一些：\"><a href=\"#最后再说一些：\" class=\"headerlink\" title=\"最后再说一些：\"></a>最后再说一些：</h2><h5 id=\"解法二的过程很有意思，就像如果要把一个框内尽量多的装水果，应该先装大的水果，再用小的水果将框填满。等分数组也是先将大的数先放入子数组，这样就方便后面的过程去调试和精细话。\"><a href=\"#解法二的过程很有意思，就像如果要把一个框内尽量多的装水果，应该先装大的水果，再用小的水果将框填满。等分数组也是先将大的数先放入子数组，这样就方便后面的过程去调试和精细话。\" class=\"headerlink\" title=\"解法二的过程很有意思，就像如果要把一个框内尽量多的装水果，应该先装大的水果，再用小的水果将框填满。等分数组也是先将大的数先放入子数组，这样就方便后面的过程去调试和精细话。\"></a>解法二的过程很有意思，就像如果要把一个框内尽量多的装水果，应该先装大的水果，再用小的水果将框填满。等分数组也是先将大的数先放入子数组，这样就方便后面的过程去调试和精细话。</h5>","site":{"data":{}},"excerpt":"<h2 id=\"题目要求：\"><a href=\"#题目要求：\" class=\"headerlink\" title=\"题目要求：\"></a>题目要求：</h2><h5 id=\"偶数的数组里面有一些正数，分成两个大小一样的子数组，两个数组之和尽量相等\"><a href=\"#偶数的数组里面有一些正数，分成两个大小一样的子数组，两个数组之和尽量相等\" class=\"headerlink\" title=\"偶数的数组里面有一些正数，分成两个大小一样的子数组，两个数组之和尽量相等\"></a>偶数的数组里面有一些正数，分成两个大小一样的子数组，两个数组之和尽量相等</h5>","more":"<h2 id=\"分析过程：\"><a href=\"#分析过程：\" class=\"headerlink\" title=\"分析过程：\"></a>分析过程：</h2><h5 id=\"题目要求比较简单，也很容易理解\"><a href=\"#题目要求比较简单，也很容易理解\" class=\"headerlink\" title=\"题目要求比较简单，也很容易理解\"></a>题目要求比较简单，也很容易理解</h5><h3 id=\"解法一\"><a href=\"#解法一\" class=\"headerlink\" title=\"解法一\"></a>解法一</h3><h5 id=\"因为是尽量相等，所以最简单的方法就是。依次遍历原数组中的每个数，判断两个子数组的和，将该数放入到和较小的那个数组中。以此类推，直到遍历完成。这样能够在原数组的顺序下，两个数组都是尽量相等的。\"><a href=\"#因为是尽量相等，所以最简单的方法就是。依次遍历原数组中的每个数，判断两个子数组的和，将该数放入到和较小的那个数组中。以此类推，直到遍历完成。这样能够在原数组的顺序下，两个数组都是尽量相等的。\" class=\"headerlink\" title=\"因为是尽量相等，所以最简单的方法就是。依次遍历原数组中的每个数，判断两个子数组的和，将该数放入到和较小的那个数组中。以此类推，直到遍历完成。这样能够在原数组的顺序下，两个数组都是尽量相等的。\"></a>因为是尽量相等，所以最简单的方法就是。依次遍历原数组中的每个数，判断两个子数组的和，将该数放入到和较小的那个数组中。以此类推，直到遍历完成。这样能够在原数组的顺序下，两个数组都是尽量相等的。</h5><h5 id=\"但是问题是如果原数组当中最后一个数比其他数大很多，就会导致子数组在最后一步后相差得比较大。\"><a href=\"#但是问题是如果原数组当中最后一个数比其他数大很多，就会导致子数组在最后一步后相差得比较大。\" class=\"headerlink\" title=\"但是问题是如果原数组当中最后一个数比其他数大很多，就会导致子数组在最后一步后相差得比较大。\"></a>但是问题是如果原数组当中最后一个数比其他数大很多，就会导致子数组在最后一步后相差得比较大。</h5><h3 id=\"解法二\"><a href=\"#解法二\" class=\"headerlink\" title=\"解法二\"></a>解法二</h3><h5 id=\"解法二是针对解法一的一种优化，为了解决解法一种的问题，需要对原数组进行排序，排序算法这里就不多讲，只需要将原数组排列成从大到小的顺序，然后再按照解法一去等分原数组。\"><a href=\"#解法二是针对解法一的一种优化，为了解决解法一种的问题，需要对原数组进行排序，排序算法这里就不多讲，只需要将原数组排列成从大到小的顺序，然后再按照解法一去等分原数组。\" class=\"headerlink\" title=\"解法二是针对解法一的一种优化，为了解决解法一种的问题，需要对原数组进行排序，排序算法这里就不多讲，只需要将原数组排列成从大到小的顺序，然后再按照解法一去等分原数组。\"></a>解法二是针对解法一的一种优化，为了解决解法一种的问题，需要对原数组进行排序，排序算法这里就不多讲，只需要将原数组排列成从大到小的顺序，然后再按照解法一去等分原数组。</h5><h2 id=\"最后再说一些：\"><a href=\"#最后再说一些：\" class=\"headerlink\" title=\"最后再说一些：\"></a>最后再说一些：</h2><h5 id=\"解法二的过程很有意思，就像如果要把一个框内尽量多的装水果，应该先装大的水果，再用小的水果将框填满。等分数组也是先将大的数先放入子数组，这样就方便后面的过程去调试和精细话。\"><a href=\"#解法二的过程很有意思，就像如果要把一个框内尽量多的装水果，应该先装大的水果，再用小的水果将框填满。等分数组也是先将大的数先放入子数组，这样就方便后面的过程去调试和精细话。\" class=\"headerlink\" title=\"解法二的过程很有意思，就像如果要把一个框内尽量多的装水果，应该先装大的水果，再用小的水果将框填满。等分数组也是先将大的数先放入子数组，这样就方便后面的过程去调试和精细话。\"></a>解法二的过程很有意思，就像如果要把一个框内尽量多的装水果，应该先装大的水果，再用小的水果将框填满。等分数组也是先将大的数先放入子数组，这样就方便后面的过程去调试和精细话。</h5>"},{"layout":"post","title":"假设检验中的P值计算-JAVA","date":"2016-12-27T16:00:00.000Z","original":true,"tag":[["算法","arithmetic"]],"_content":"\n##### 　　最近产品提出需求，对于ab实验，希望能够通过实验数据计算出P值，以对数据的准确性做一个直观判断。最开始不知道P值是一个什么概念，觉得应该很简单，baidu或者google以下应该会有很多开源的代码或者jar包；又或者是自己将P值公式实现便可。但是一番查找后发现没有想的这么简单，网络上对于P值得计算过程大多含糊不清，更别提完整的计算代码。最后没办法，只有通过自己拿起概率论书本重新进行学习，以下便记录自己从P值是什么到java实现的一些细节。\n<!--more-->\n\n## 1. 统计学中P值\n##### 　　P值是指当假设为真时所得到的观察结果的概率，简单讲P值就是概率，反映某一事件发生的可能性大小。下面几个比较重要的基础概念对于理解P值的意义会有帮助。\n### 1.1 概率论中几个比较重要的基础概念\n#### 1.1.1 原假设与备择假设：\n##### __原假设（H<sub>0</sub>）__：通常将研究者想手机证据予以反对的假设称为原假设，用H<sub>0</sub>表示；\n##### __备择假设（H<sub>1</sub>）__：通常将研究者想收集证据予以支持的假设称为备择假设，或称研究假设，用H<sub>1</sub>活H<sub>2</sub>表示。\n\n##### 　　举个栗子：\n<div class=\"highlighter-rouge\"><pre class=\"highlight\"><code>某品牌洗涤剂在产品说明书中声称：平均净含量不少于500g。从消费者利益出发，有关研究人员要通过抽检其中的一批产品来验证该产品制造商的说明是否属实。    \n解：对于该洗涤剂的平均含量的真值为μ。如果抽检的结果发现μ<500，则表明该产品说明书中关于其净含量的内容是不真实的。一般来说，研究者抽检的意图是倾向于证实这种洗涤剂的平均净含量不符合说明书中的概述，因为这不符合说明书的陈述。如果研究者对于产品说明丝毫没有质疑，也就没有必要抽检了。所以μ<500是研究者想要收集证据支持的观点。    \n<br><h6>H<sub>0</sub>:μ≥500(净含量符合说明书);</h6><h6>H<sub>1</sub>:μ&lt;500(净含量不符合说明书)。</h6></code></pre></div>\n\n\n<div class=\"highlighter-rouge\"><pre class=\"highlight\"><code>一家研究机构估计，某城市中家庭拥有汽车的比例超过30%。为了验证这一估计是否正确，该研究机构随机抽取了一个样本进行检验。     \n解：设该城市中家庭拥有汽车的比例真值为π。显然，研究者想收集证据予以支持的假设是:该城市中家庭拥有汽车的比例超过30%。因此建立的原假设与备择假设应为\n<h6>H<sub>0</sub>:π≤30%（家庭拥有汽车的比例不超过30%）;</h6><h6>H<sub>1</sub>:π>30%（家庭拥有汽车的比例超过30%）。</h6></code></pre></div>\n\n* 原假设和备择假设是一个完备事件组，而且互相对立。也就是说在一项假设检验中，必有且只有一个成立；\n* 在假设检验中，等号\"=\"总是放在原假设上。   \n\n#### 1.1.2 单侧检验和双侧检验：\n##### __单侧检验__：备择假设具有特定的方向性，并含有符号\">\"或\"<\"的假设检验；\n##### __双侧检验__：备择假设没有特定的方向性，并含有符号\"≠\"的假设检验。     \n![假设检验的基本形式](../../img/pvalue/pvalue1.png)    <div class='img-note'>假设检验的基本形式</div>\n\n#### 1.1.3 两类错误与显著水平    \n##### 　　如前所述，原假设与备择假设不能同时成立，我们要么拒绝原假设，要么不拒绝原假设。我们希望的情况是：当原假设正确时没有拒绝它，当原假设不正确时拒绝它。但是我们无法保证不犯错。假设检验中过程中可能发生以下两类错误：    \n##### __I类错误__：当原假设为真是拒绝原假设，所犯的错误称为第I类错误；    \n##### __II类错误__：当原假设为假时没有拒绝原假设，所犯错误称为第II类错误。    \n![假设检验的结论与后果](../../img/pvalue/pvalue2.png)   <div class='img-note'>假设检验的结论与后果</div>\n\n##### 　　只有当原假设被拒绝时，我们才会犯第I类错误；只有当原假设未被拒绝时，我们才会犯第II类错误。因此，我们可以不犯第I类错误或不犯第II类错误，但不可能两类错误都不犯。两类错误就像一个跷跷板，当一个概率增大时，另一个减小。人们只能在两类错误的发生概率之间进行平衡。一般来说，发生哪一类错误的后果更为严重，就应该首要控制哪类错误发生的概率，但由于犯第I类错误的概率是可以又研究者控制的，因为此在假设检验中，人们往往先控制第I类错误的发生概率。\n\n``\n发生第I类错误的概率常被用于度量检验结论的可靠性，并将这一概率称为显著性水平，记为α。\n``\n\n##### 　　__显著水平__ 是人们事先指定的犯第I类错误概率α的最大允许值。显著水平α越小，犯第I类错误的可能性自然就越小，但犯第II类错误的可能性则随之增大。作为一个普遍使用的原则，人们通常选择显著性水平为0.05或比0.05更小的概率。\n\n#### 1.1.4 标准化检测量与拒绝域\n\n##### 　　__检验统计量__ 实际上是总体参数的点估计量，但点估计量并不能直接作为检验的统计量，只有将其标准化后，才能用于度量它与原假设的参数之间的差异程度。实际上，假设检验中所用的检验统计量都是标准化检验统计量，它反映了点估计量（比如样本均值）与假设的总体参数（比如假设的总体均值）相比相差了多少个标准差。\n\n$$标准化检验统计量 = \\frac{点估计量 - 假设值}{点估计量的抽样标准差}$$\n\n##### 　　__拒绝域__ 能够拒绝原假设的检验统计量的所有可能取值的集合。是由显著性水平α所围成的区域。如果利用样本观测结果计算出来的检验统计量的具体数值落在了拒绝域内，就拒绝原假设，否则就不拒绝原假设。\n![显著性水平、拒绝域和临界值](../../img/pvalue/pvalue3.jpeg)<div class='img-note'>显著性水平、拒绝域和临界值</div>\n\n##### 　　当样本容量固定时，拒绝域的面积随α的减小而减小。α值越小，拒绝域假设所需的检验统计量的临界值与原假设的参数值就越远。\n\n### 1.2 利用P值进行决策\n##### 　　显著性水平α是在检验之前确定的，这也就意味着我们事先确定了拒绝域。这样，不论检验统计量的值是大是小，只要它的值落入拒绝域就拒绝原假设，否者就不拒绝原假设。这种固定的显著性水平α对检验结果只能提供检验结论可靠性的一个大致范围，无法给出观测数据与原假设之间不一致程度的精确度量。\n\n##### 　　__P值__ 在原假设为真的条件下，检验统计量的观察值大于或等于其计算值的概率，称为P值。P值是反映实际观测到的数据与原假设之间不一致程度的一个概率值。P值越小，说明实际观测到的数据与原假设之间不一致的程度就越大，检验的结果也就越显著。\n\n### 1.3 一个总体参数的检验\n##### 　　当我们研究一个总体时，要检验的参数主要是总体均值μ、总体比例π和总体方差σ<SUP>2</SUP>。由于检验的参数不同，计算检验统计量的方法也有所不同。\n\n#### 1.3.1 总体均值的检验\n##### 　　对于总体均值进行假设检验，采用什么检验步骤和检验统计量取决于我们所抽取的样本是大样本（n≥30）还是小样本（n<30），此外还需要区分总体是否服从正太分布、总体方差σ<SUP>2</SUP>是否已知等几种情况。\n![大样本情况下一个总体均值的检验方法](../../img/pvalue/pvalue4.png)    <div class='img-note'>大样本情况下一个总体均值的检验方法</div>\n![小样本情况下一个总体均值的检验方法](../../img/pvalue/pvalue5.png)    <div class='img-note'>小样本情况下一个总体均值的检验方法</div>\n\n##### 　　Z表示转换为标准正太分布下的检验统计量。\n\n#### 1.3.2 总体比例的检验\n##### 　　总体比例是指总体中具有某种相同特征的个体所占的比例，这些特征可以是数据型的（如一定的重量、一定的厚度或一定规格等），也可以是品质型的（如男女比例、学历等级、职称高低等）。\n##### 　　在构造检验统计量时，我们仍然利用样本比例p与总体比例π之间的距离等于多少个标准差来衡量，因为在大样本情况下统计量p近似服从正太分布，而统计量\n$$z = \\frac{P - π_0}{\\sqrt{\\frac{π_0(1-π_0)}{n}}}$$\n\n![大样本情况下一个总体比例的检验方法](../../img/pvalue/pvalue6.png)    <div class='img-note'>大样本情况下一个总体比例的检验方法</div>\n\n### 1.4 两个总体参数的检验\n##### 　　在实际研究中，我们常常要比较两个总体的差异，如一所学校的重点班和普通班两个班级学生的英语成绩是否有显著差异；生产企业在改进生产线后的平均产量与原生产线的平均产量相比是否有显著提高等等。\n![两个总体均值之差的三种基本假设检验形式](../../img/pvalue/pvalue7.png)    <div class='img-note'>两个总体均值之差的三种基本假设检验形式</div>\n\n## 2. JAVA实现P值计算\n","source":"_posts/arithmetic/JAVA-pValue.md","raw":"---\nlayout: post\ntitle: 假设检验中的P值计算-JAVA\ndate: 2016/12/28\ntags: [tech, arithmetic, index]\noriginal: true\ntag: [[算法, arithmetic]]\n---\n\n##### 　　最近产品提出需求，对于ab实验，希望能够通过实验数据计算出P值，以对数据的准确性做一个直观判断。最开始不知道P值是一个什么概念，觉得应该很简单，baidu或者google以下应该会有很多开源的代码或者jar包；又或者是自己将P值公式实现便可。但是一番查找后发现没有想的这么简单，网络上对于P值得计算过程大多含糊不清，更别提完整的计算代码。最后没办法，只有通过自己拿起概率论书本重新进行学习，以下便记录自己从P值是什么到java实现的一些细节。\n<!--more-->\n\n## 1. 统计学中P值\n##### 　　P值是指当假设为真时所得到的观察结果的概率，简单讲P值就是概率，反映某一事件发生的可能性大小。下面几个比较重要的基础概念对于理解P值的意义会有帮助。\n### 1.1 概率论中几个比较重要的基础概念\n#### 1.1.1 原假设与备择假设：\n##### __原假设（H<sub>0</sub>）__：通常将研究者想手机证据予以反对的假设称为原假设，用H<sub>0</sub>表示；\n##### __备择假设（H<sub>1</sub>）__：通常将研究者想收集证据予以支持的假设称为备择假设，或称研究假设，用H<sub>1</sub>活H<sub>2</sub>表示。\n\n##### 　　举个栗子：\n<div class=\"highlighter-rouge\"><pre class=\"highlight\"><code>某品牌洗涤剂在产品说明书中声称：平均净含量不少于500g。从消费者利益出发，有关研究人员要通过抽检其中的一批产品来验证该产品制造商的说明是否属实。    \n解：对于该洗涤剂的平均含量的真值为μ。如果抽检的结果发现μ<500，则表明该产品说明书中关于其净含量的内容是不真实的。一般来说，研究者抽检的意图是倾向于证实这种洗涤剂的平均净含量不符合说明书中的概述，因为这不符合说明书的陈述。如果研究者对于产品说明丝毫没有质疑，也就没有必要抽检了。所以μ<500是研究者想要收集证据支持的观点。    \n<br><h6>H<sub>0</sub>:μ≥500(净含量符合说明书);</h6><h6>H<sub>1</sub>:μ&lt;500(净含量不符合说明书)。</h6></code></pre></div>\n\n\n<div class=\"highlighter-rouge\"><pre class=\"highlight\"><code>一家研究机构估计，某城市中家庭拥有汽车的比例超过30%。为了验证这一估计是否正确，该研究机构随机抽取了一个样本进行检验。     \n解：设该城市中家庭拥有汽车的比例真值为π。显然，研究者想收集证据予以支持的假设是:该城市中家庭拥有汽车的比例超过30%。因此建立的原假设与备择假设应为\n<h6>H<sub>0</sub>:π≤30%（家庭拥有汽车的比例不超过30%）;</h6><h6>H<sub>1</sub>:π>30%（家庭拥有汽车的比例超过30%）。</h6></code></pre></div>\n\n* 原假设和备择假设是一个完备事件组，而且互相对立。也就是说在一项假设检验中，必有且只有一个成立；\n* 在假设检验中，等号\"=\"总是放在原假设上。   \n\n#### 1.1.2 单侧检验和双侧检验：\n##### __单侧检验__：备择假设具有特定的方向性，并含有符号\">\"或\"<\"的假设检验；\n##### __双侧检验__：备择假设没有特定的方向性，并含有符号\"≠\"的假设检验。     \n![假设检验的基本形式](../../img/pvalue/pvalue1.png)    <div class='img-note'>假设检验的基本形式</div>\n\n#### 1.1.3 两类错误与显著水平    \n##### 　　如前所述，原假设与备择假设不能同时成立，我们要么拒绝原假设，要么不拒绝原假设。我们希望的情况是：当原假设正确时没有拒绝它，当原假设不正确时拒绝它。但是我们无法保证不犯错。假设检验中过程中可能发生以下两类错误：    \n##### __I类错误__：当原假设为真是拒绝原假设，所犯的错误称为第I类错误；    \n##### __II类错误__：当原假设为假时没有拒绝原假设，所犯错误称为第II类错误。    \n![假设检验的结论与后果](../../img/pvalue/pvalue2.png)   <div class='img-note'>假设检验的结论与后果</div>\n\n##### 　　只有当原假设被拒绝时，我们才会犯第I类错误；只有当原假设未被拒绝时，我们才会犯第II类错误。因此，我们可以不犯第I类错误或不犯第II类错误，但不可能两类错误都不犯。两类错误就像一个跷跷板，当一个概率增大时，另一个减小。人们只能在两类错误的发生概率之间进行平衡。一般来说，发生哪一类错误的后果更为严重，就应该首要控制哪类错误发生的概率，但由于犯第I类错误的概率是可以又研究者控制的，因为此在假设检验中，人们往往先控制第I类错误的发生概率。\n\n``\n发生第I类错误的概率常被用于度量检验结论的可靠性，并将这一概率称为显著性水平，记为α。\n``\n\n##### 　　__显著水平__ 是人们事先指定的犯第I类错误概率α的最大允许值。显著水平α越小，犯第I类错误的可能性自然就越小，但犯第II类错误的可能性则随之增大。作为一个普遍使用的原则，人们通常选择显著性水平为0.05或比0.05更小的概率。\n\n#### 1.1.4 标准化检测量与拒绝域\n\n##### 　　__检验统计量__ 实际上是总体参数的点估计量，但点估计量并不能直接作为检验的统计量，只有将其标准化后，才能用于度量它与原假设的参数之间的差异程度。实际上，假设检验中所用的检验统计量都是标准化检验统计量，它反映了点估计量（比如样本均值）与假设的总体参数（比如假设的总体均值）相比相差了多少个标准差。\n\n$$标准化检验统计量 = \\frac{点估计量 - 假设值}{点估计量的抽样标准差}$$\n\n##### 　　__拒绝域__ 能够拒绝原假设的检验统计量的所有可能取值的集合。是由显著性水平α所围成的区域。如果利用样本观测结果计算出来的检验统计量的具体数值落在了拒绝域内，就拒绝原假设，否则就不拒绝原假设。\n![显著性水平、拒绝域和临界值](../../img/pvalue/pvalue3.jpeg)<div class='img-note'>显著性水平、拒绝域和临界值</div>\n\n##### 　　当样本容量固定时，拒绝域的面积随α的减小而减小。α值越小，拒绝域假设所需的检验统计量的临界值与原假设的参数值就越远。\n\n### 1.2 利用P值进行决策\n##### 　　显著性水平α是在检验之前确定的，这也就意味着我们事先确定了拒绝域。这样，不论检验统计量的值是大是小，只要它的值落入拒绝域就拒绝原假设，否者就不拒绝原假设。这种固定的显著性水平α对检验结果只能提供检验结论可靠性的一个大致范围，无法给出观测数据与原假设之间不一致程度的精确度量。\n\n##### 　　__P值__ 在原假设为真的条件下，检验统计量的观察值大于或等于其计算值的概率，称为P值。P值是反映实际观测到的数据与原假设之间不一致程度的一个概率值。P值越小，说明实际观测到的数据与原假设之间不一致的程度就越大，检验的结果也就越显著。\n\n### 1.3 一个总体参数的检验\n##### 　　当我们研究一个总体时，要检验的参数主要是总体均值μ、总体比例π和总体方差σ<SUP>2</SUP>。由于检验的参数不同，计算检验统计量的方法也有所不同。\n\n#### 1.3.1 总体均值的检验\n##### 　　对于总体均值进行假设检验，采用什么检验步骤和检验统计量取决于我们所抽取的样本是大样本（n≥30）还是小样本（n<30），此外还需要区分总体是否服从正太分布、总体方差σ<SUP>2</SUP>是否已知等几种情况。\n![大样本情况下一个总体均值的检验方法](../../img/pvalue/pvalue4.png)    <div class='img-note'>大样本情况下一个总体均值的检验方法</div>\n![小样本情况下一个总体均值的检验方法](../../img/pvalue/pvalue5.png)    <div class='img-note'>小样本情况下一个总体均值的检验方法</div>\n\n##### 　　Z表示转换为标准正太分布下的检验统计量。\n\n#### 1.3.2 总体比例的检验\n##### 　　总体比例是指总体中具有某种相同特征的个体所占的比例，这些特征可以是数据型的（如一定的重量、一定的厚度或一定规格等），也可以是品质型的（如男女比例、学历等级、职称高低等）。\n##### 　　在构造检验统计量时，我们仍然利用样本比例p与总体比例π之间的距离等于多少个标准差来衡量，因为在大样本情况下统计量p近似服从正太分布，而统计量\n$$z = \\frac{P - π_0}{\\sqrt{\\frac{π_0(1-π_0)}{n}}}$$\n\n![大样本情况下一个总体比例的检验方法](../../img/pvalue/pvalue6.png)    <div class='img-note'>大样本情况下一个总体比例的检验方法</div>\n\n### 1.4 两个总体参数的检验\n##### 　　在实际研究中，我们常常要比较两个总体的差异，如一所学校的重点班和普通班两个班级学生的英语成绩是否有显著差异；生产企业在改进生产线后的平均产量与原生产线的平均产量相比是否有显著提高等等。\n![两个总体均值之差的三种基本假设检验形式](../../img/pvalue/pvalue7.png)    <div class='img-note'>两个总体均值之差的三种基本假设检验形式</div>\n\n## 2. JAVA实现P值计算\n","slug":"arithmetic/JAVA-pValue","published":1,"updated":"2017-10-06T16:03:22.643Z","comments":1,"photos":[],"link":"","_id":"cj8jros6u000130s68u7rnj5r","content":"<h5 id=\"最近产品提出需求，对于ab实验，希望能够通过实验数据计算出P值，以对数据的准确性做一个直观判断。最开始不知道P值是一个什么概念，觉得应该很简单，baidu或者google以下应该会有很多开源的代码或者jar包；又或者是自己将P值公式实现便可。但是一番查找后发现没有想的这么简单，网络上对于P值得计算过程大多含糊不清，更别提完整的计算代码。最后没办法，只有通过自己拿起概率论书本重新进行学习，以下便记录自己从P值是什么到java实现的一些细节。\"><a href=\"#最近产品提出需求，对于ab实验，希望能够通过实验数据计算出P值，以对数据的准确性做一个直观判断。最开始不知道P值是一个什么概念，觉得应该很简单，baidu或者google以下应该会有很多开源的代码或者jar包；又或者是自己将P值公式实现便可。但是一番查找后发现没有想的这么简单，网络上对于P值得计算过程大多含糊不清，更别提完整的计算代码。最后没办法，只有通过自己拿起概率论书本重新进行学习，以下便记录自己从P值是什么到java实现的一些细节。\" class=\"headerlink\" title=\"　　最近产品提出需求，对于ab实验，希望能够通过实验数据计算出P值，以对数据的准确性做一个直观判断。最开始不知道P值是一个什么概念，觉得应该很简单，baidu或者google以下应该会有很多开源的代码或者jar包；又或者是自己将P值公式实现便可。但是一番查找后发现没有想的这么简单，网络上对于P值得计算过程大多含糊不清，更别提完整的计算代码。最后没办法，只有通过自己拿起概率论书本重新进行学习，以下便记录自己从P值是什么到java实现的一些细节。\"></a>　　最近产品提出需求，对于ab实验，希望能够通过实验数据计算出P值，以对数据的准确性做一个直观判断。最开始不知道P值是一个什么概念，觉得应该很简单，baidu或者google以下应该会有很多开源的代码或者jar包；又或者是自己将P值公式实现便可。但是一番查找后发现没有想的这么简单，网络上对于P值得计算过程大多含糊不清，更别提完整的计算代码。最后没办法，只有通过自己拿起概率论书本重新进行学习，以下便记录自己从P值是什么到java实现的一些细节。</h5><a id=\"more\"></a>\n<h2 id=\"1-统计学中P值\"><a href=\"#1-统计学中P值\" class=\"headerlink\" title=\"1. 统计学中P值\"></a>1. 统计学中P值</h2><h5 id=\"P值是指当假设为真时所得到的观察结果的概率，简单讲P值就是概率，反映某一事件发生的可能性大小。下面几个比较重要的基础概念对于理解P值的意义会有帮助。\"><a href=\"#P值是指当假设为真时所得到的观察结果的概率，简单讲P值就是概率，反映某一事件发生的可能性大小。下面几个比较重要的基础概念对于理解P值的意义会有帮助。\" class=\"headerlink\" title=\"　　P值是指当假设为真时所得到的观察结果的概率，简单讲P值就是概率，反映某一事件发生的可能性大小。下面几个比较重要的基础概念对于理解P值的意义会有帮助。\"></a>　　P值是指当假设为真时所得到的观察结果的概率，简单讲P值就是概率，反映某一事件发生的可能性大小。下面几个比较重要的基础概念对于理解P值的意义会有帮助。</h5><h3 id=\"1-1-概率论中几个比较重要的基础概念\"><a href=\"#1-1-概率论中几个比较重要的基础概念\" class=\"headerlink\" title=\"1.1 概率论中几个比较重要的基础概念\"></a>1.1 概率论中几个比较重要的基础概念</h3><h4 id=\"1-1-1-原假设与备择假设：\"><a href=\"#1-1-1-原假设与备择假设：\" class=\"headerlink\" title=\"1.1.1 原假设与备择假设：\"></a>1.1.1 原假设与备择假设：</h4><h5 id=\"原假设（H0）：通常将研究者想手机证据予以反对的假设称为原假设，用H0表示；\"><a href=\"#原假设（H0）：通常将研究者想手机证据予以反对的假设称为原假设，用H0表示；\" class=\"headerlink\" title=\"原假设（H0）：通常将研究者想手机证据予以反对的假设称为原假设，用H0表示；\"></a><strong>原假设（H<sub>0</sub>）</strong>：通常将研究者想手机证据予以反对的假设称为原假设，用H<sub>0</sub>表示；</h5><h5 id=\"备择假设（H1）：通常将研究者想收集证据予以支持的假设称为备择假设，或称研究假设，用H1活H2表示。\"><a href=\"#备择假设（H1）：通常将研究者想收集证据予以支持的假设称为备择假设，或称研究假设，用H1活H2表示。\" class=\"headerlink\" title=\"备择假设（H1）：通常将研究者想收集证据予以支持的假设称为备择假设，或称研究假设，用H1活H2表示。\"></a><strong>备择假设（H<sub>1</sub>）</strong>：通常将研究者想收集证据予以支持的假设称为备择假设，或称研究假设，用H<sub>1</sub>活H<sub>2</sub>表示。</h5><h5 id=\"举个栗子：\"><a href=\"#举个栗子：\" class=\"headerlink\" title=\"　　举个栗子：\"></a>　　举个栗子：</h5><div class=\"highlighter-rouge\"><pre class=\"highlight\"><code>某品牌洗涤剂在产品说明书中声称：平均净含量不少于500g。从消费者利益出发，有关研究人员要通过抽检其中的一批产品来验证该产品制造商的说明是否属实。    \n解：对于该洗涤剂的平均含量的真值为μ。如果抽检的结果发现μ<500，则表明该产品说明书中关于其净含量的内容是不真实的。一般来说，研究者抽检的意图是倾向于证实这种洗涤剂的平均净含量不符合说明书中的概述，因为这不符合说明书的陈述。如果研究者对于产品说明丝毫没有质疑，也就没有必要抽检了。所以μ<500是研究者想要收集证据支持的观点。 <br=\"\"><h6>H<sub>0</sub>:μ≥500(净含量符合说明书);</h6><h6>H<sub>1</sub>:μ&lt;500(净含量不符合说明书)。</h6></500，则表明该产品说明书中关于其净含量的内容是不真实的。一般来说，研究者抽检的意图是倾向于证实这种洗涤剂的平均净含量不符合说明书中的概述，因为这不符合说明书的陈述。如果研究者对于产品说明丝毫没有质疑，也就没有必要抽检了。所以μ<500是研究者想要收集证据支持的观点。></code></pre></div>\n\n\n<div class=\"highlighter-rouge\"><pre class=\"highlight\"><code>一家研究机构估计，某城市中家庭拥有汽车的比例超过30%。为了验证这一估计是否正确，该研究机构随机抽取了一个样本进行检验。     \n解：设该城市中家庭拥有汽车的比例真值为π。显然，研究者想收集证据予以支持的假设是:该城市中家庭拥有汽车的比例超过30%。因此建立的原假设与备择假设应为\n<h6>H<sub>0</sub>:π≤30%（家庭拥有汽车的比例不超过30%）;</h6><h6>H<sub>1</sub>:π>30%（家庭拥有汽车的比例超过30%）。</h6></code></pre></div>\n\n<ul>\n<li>原假设和备择假设是一个完备事件组，而且互相对立。也就是说在一项假设检验中，必有且只有一个成立；</li>\n<li>在假设检验中，等号”=”总是放在原假设上。   </li>\n</ul>\n<h4 id=\"1-1-2-单侧检验和双侧检验：\"><a href=\"#1-1-2-单侧检验和双侧检验：\" class=\"headerlink\" title=\"1.1.2 单侧检验和双侧检验：\"></a>1.1.2 单侧检验和双侧检验：</h4><h5 id=\"单侧检验：备择假设具有特定的方向性，并含有符号”-gt-”或”-lt-”的假设检验；\"><a href=\"#单侧检验：备择假设具有特定的方向性，并含有符号”-gt-”或”-lt-”的假设检验；\" class=\"headerlink\" title=\"单侧检验：备择假设具有特定的方向性，并含有符号”&gt;”或”&lt;”的假设检验；\"></a><strong>单侧检验</strong>：备择假设具有特定的方向性，并含有符号”&gt;”或”&lt;”的假设检验；</h5><h5 id=\"双侧检验：备择假设没有特定的方向性，并含有符号”≠”的假设检验。\"><a href=\"#双侧检验：备择假设没有特定的方向性，并含有符号”≠”的假设检验。\" class=\"headerlink\" title=\"双侧检验：备择假设没有特定的方向性，并含有符号”≠”的假设检验。\"></a><strong>双侧检验</strong>：备择假设没有特定的方向性，并含有符号”≠”的假设检验。</h5><p><img src=\"../../img/pvalue/pvalue1.png\" alt=\"假设检验的基本形式\">    <div class=\"img-note\">假设检验的基本形式</div></p>\n<h4 id=\"1-1-3-两类错误与显著水平\"><a href=\"#1-1-3-两类错误与显著水平\" class=\"headerlink\" title=\"1.1.3 两类错误与显著水平\"></a>1.1.3 两类错误与显著水平</h4><h5 id=\"如前所述，原假设与备择假设不能同时成立，我们要么拒绝原假设，要么不拒绝原假设。我们希望的情况是：当原假设正确时没有拒绝它，当原假设不正确时拒绝它。但是我们无法保证不犯错。假设检验中过程中可能发生以下两类错误：\"><a href=\"#如前所述，原假设与备择假设不能同时成立，我们要么拒绝原假设，要么不拒绝原假设。我们希望的情况是：当原假设正确时没有拒绝它，当原假设不正确时拒绝它。但是我们无法保证不犯错。假设检验中过程中可能发生以下两类错误：\" class=\"headerlink\" title=\"　　如前所述，原假设与备择假设不能同时成立，我们要么拒绝原假设，要么不拒绝原假设。我们希望的情况是：当原假设正确时没有拒绝它，当原假设不正确时拒绝它。但是我们无法保证不犯错。假设检验中过程中可能发生以下两类错误：\"></a>　　如前所述，原假设与备择假设不能同时成立，我们要么拒绝原假设，要么不拒绝原假设。我们希望的情况是：当原假设正确时没有拒绝它，当原假设不正确时拒绝它。但是我们无法保证不犯错。假设检验中过程中可能发生以下两类错误：</h5><h5 id=\"I类错误：当原假设为真是拒绝原假设，所犯的错误称为第I类错误；\"><a href=\"#I类错误：当原假设为真是拒绝原假设，所犯的错误称为第I类错误；\" class=\"headerlink\" title=\"I类错误：当原假设为真是拒绝原假设，所犯的错误称为第I类错误；\"></a><strong>I类错误</strong>：当原假设为真是拒绝原假设，所犯的错误称为第I类错误；</h5><h5 id=\"II类错误：当原假设为假时没有拒绝原假设，所犯错误称为第II类错误。\"><a href=\"#II类错误：当原假设为假时没有拒绝原假设，所犯错误称为第II类错误。\" class=\"headerlink\" title=\"II类错误：当原假设为假时没有拒绝原假设，所犯错误称为第II类错误。\"></a><strong>II类错误</strong>：当原假设为假时没有拒绝原假设，所犯错误称为第II类错误。</h5><p><img src=\"../../img/pvalue/pvalue2.png\" alt=\"假设检验的结论与后果\">   <div class=\"img-note\">假设检验的结论与后果</div></p>\n<h5 id=\"只有当原假设被拒绝时，我们才会犯第I类错误；只有当原假设未被拒绝时，我们才会犯第II类错误。因此，我们可以不犯第I类错误或不犯第II类错误，但不可能两类错误都不犯。两类错误就像一个跷跷板，当一个概率增大时，另一个减小。人们只能在两类错误的发生概率之间进行平衡。一般来说，发生哪一类错误的后果更为严重，就应该首要控制哪类错误发生的概率，但由于犯第I类错误的概率是可以又研究者控制的，因为此在假设检验中，人们往往先控制第I类错误的发生概率。\"><a href=\"#只有当原假设被拒绝时，我们才会犯第I类错误；只有当原假设未被拒绝时，我们才会犯第II类错误。因此，我们可以不犯第I类错误或不犯第II类错误，但不可能两类错误都不犯。两类错误就像一个跷跷板，当一个概率增大时，另一个减小。人们只能在两类错误的发生概率之间进行平衡。一般来说，发生哪一类错误的后果更为严重，就应该首要控制哪类错误发生的概率，但由于犯第I类错误的概率是可以又研究者控制的，因为此在假设检验中，人们往往先控制第I类错误的发生概率。\" class=\"headerlink\" title=\"　　只有当原假设被拒绝时，我们才会犯第I类错误；只有当原假设未被拒绝时，我们才会犯第II类错误。因此，我们可以不犯第I类错误或不犯第II类错误，但不可能两类错误都不犯。两类错误就像一个跷跷板，当一个概率增大时，另一个减小。人们只能在两类错误的发生概率之间进行平衡。一般来说，发生哪一类错误的后果更为严重，就应该首要控制哪类错误发生的概率，但由于犯第I类错误的概率是可以又研究者控制的，因为此在假设检验中，人们往往先控制第I类错误的发生概率。\"></a>　　只有当原假设被拒绝时，我们才会犯第I类错误；只有当原假设未被拒绝时，我们才会犯第II类错误。因此，我们可以不犯第I类错误或不犯第II类错误，但不可能两类错误都不犯。两类错误就像一个跷跷板，当一个概率增大时，另一个减小。人们只能在两类错误的发生概率之间进行平衡。一般来说，发生哪一类错误的后果更为严重，就应该首要控制哪类错误发生的概率，但由于犯第I类错误的概率是可以又研究者控制的，因为此在假设检验中，人们往往先控制第I类错误的发生概率。</h5><p><code>发生第I类错误的概率常被用于度量检验结论的可靠性，并将这一概率称为显著性水平，记为α。</code></p>\n<h5 id=\"显著水平-是人们事先指定的犯第I类错误概率α的最大允许值。显著水平α越小，犯第I类错误的可能性自然就越小，但犯第II类错误的可能性则随之增大。作为一个普遍使用的原则，人们通常选择显著性水平为0-05或比0-05更小的概率。\"><a href=\"#显著水平-是人们事先指定的犯第I类错误概率α的最大允许值。显著水平α越小，犯第I类错误的可能性自然就越小，但犯第II类错误的可能性则随之增大。作为一个普遍使用的原则，人们通常选择显著性水平为0-05或比0-05更小的概率。\" class=\"headerlink\" title=\"　　显著水平 是人们事先指定的犯第I类错误概率α的最大允许值。显著水平α越小，犯第I类错误的可能性自然就越小，但犯第II类错误的可能性则随之增大。作为一个普遍使用的原则，人们通常选择显著性水平为0.05或比0.05更小的概率。\"></a>　　<strong>显著水平</strong> 是人们事先指定的犯第I类错误概率α的最大允许值。显著水平α越小，犯第I类错误的可能性自然就越小，但犯第II类错误的可能性则随之增大。作为一个普遍使用的原则，人们通常选择显著性水平为0.05或比0.05更小的概率。</h5><h4 id=\"1-1-4-标准化检测量与拒绝域\"><a href=\"#1-1-4-标准化检测量与拒绝域\" class=\"headerlink\" title=\"1.1.4 标准化检测量与拒绝域\"></a>1.1.4 标准化检测量与拒绝域</h4><h5 id=\"检验统计量-实际上是总体参数的点估计量，但点估计量并不能直接作为检验的统计量，只有将其标准化后，才能用于度量它与原假设的参数之间的差异程度。实际上，假设检验中所用的检验统计量都是标准化检验统计量，它反映了点估计量（比如样本均值）与假设的总体参数（比如假设的总体均值）相比相差了多少个标准差。\"><a href=\"#检验统计量-实际上是总体参数的点估计量，但点估计量并不能直接作为检验的统计量，只有将其标准化后，才能用于度量它与原假设的参数之间的差异程度。实际上，假设检验中所用的检验统计量都是标准化检验统计量，它反映了点估计量（比如样本均值）与假设的总体参数（比如假设的总体均值）相比相差了多少个标准差。\" class=\"headerlink\" title=\"　　检验统计量 实际上是总体参数的点估计量，但点估计量并不能直接作为检验的统计量，只有将其标准化后，才能用于度量它与原假设的参数之间的差异程度。实际上，假设检验中所用的检验统计量都是标准化检验统计量，它反映了点估计量（比如样本均值）与假设的总体参数（比如假设的总体均值）相比相差了多少个标准差。\"></a>　　<strong>检验统计量</strong> 实际上是总体参数的点估计量，但点估计量并不能直接作为检验的统计量，只有将其标准化后，才能用于度量它与原假设的参数之间的差异程度。实际上，假设检验中所用的检验统计量都是标准化检验统计量，它反映了点估计量（比如样本均值）与假设的总体参数（比如假设的总体均值）相比相差了多少个标准差。</h5><script type=\"math/tex; mode=display\">标准化检验统计量 = \\frac{点估计量 - 假设值}{点估计量的抽样标准差}</script><h5 id=\"拒绝域-能够拒绝原假设的检验统计量的所有可能取值的集合。是由显著性水平α所围成的区域。如果利用样本观测结果计算出来的检验统计量的具体数值落在了拒绝域内，就拒绝原假设，否则就不拒绝原假设。\"><a href=\"#拒绝域-能够拒绝原假设的检验统计量的所有可能取值的集合。是由显著性水平α所围成的区域。如果利用样本观测结果计算出来的检验统计量的具体数值落在了拒绝域内，就拒绝原假设，否则就不拒绝原假设。\" class=\"headerlink\" title=\"　　拒绝域 能够拒绝原假设的检验统计量的所有可能取值的集合。是由显著性水平α所围成的区域。如果利用样本观测结果计算出来的检验统计量的具体数值落在了拒绝域内，就拒绝原假设，否则就不拒绝原假设。\"></a>　　<strong>拒绝域</strong> 能够拒绝原假设的检验统计量的所有可能取值的集合。是由显著性水平α所围成的区域。如果利用样本观测结果计算出来的检验统计量的具体数值落在了拒绝域内，就拒绝原假设，否则就不拒绝原假设。</h5><p><img src=\"../../img/pvalue/pvalue3.jpeg\" alt=\"显著性水平、拒绝域和临界值\"><div class=\"img-note\">显著性水平、拒绝域和临界值</div></p>\n<h5 id=\"当样本容量固定时，拒绝域的面积随α的减小而减小。α值越小，拒绝域假设所需的检验统计量的临界值与原假设的参数值就越远。\"><a href=\"#当样本容量固定时，拒绝域的面积随α的减小而减小。α值越小，拒绝域假设所需的检验统计量的临界值与原假设的参数值就越远。\" class=\"headerlink\" title=\"　　当样本容量固定时，拒绝域的面积随α的减小而减小。α值越小，拒绝域假设所需的检验统计量的临界值与原假设的参数值就越远。\"></a>　　当样本容量固定时，拒绝域的面积随α的减小而减小。α值越小，拒绝域假设所需的检验统计量的临界值与原假设的参数值就越远。</h5><h3 id=\"1-2-利用P值进行决策\"><a href=\"#1-2-利用P值进行决策\" class=\"headerlink\" title=\"1.2 利用P值进行决策\"></a>1.2 利用P值进行决策</h3><h5 id=\"显著性水平α是在检验之前确定的，这也就意味着我们事先确定了拒绝域。这样，不论检验统计量的值是大是小，只要它的值落入拒绝域就拒绝原假设，否者就不拒绝原假设。这种固定的显著性水平α对检验结果只能提供检验结论可靠性的一个大致范围，无法给出观测数据与原假设之间不一致程度的精确度量。\"><a href=\"#显著性水平α是在检验之前确定的，这也就意味着我们事先确定了拒绝域。这样，不论检验统计量的值是大是小，只要它的值落入拒绝域就拒绝原假设，否者就不拒绝原假设。这种固定的显著性水平α对检验结果只能提供检验结论可靠性的一个大致范围，无法给出观测数据与原假设之间不一致程度的精确度量。\" class=\"headerlink\" title=\"　　显著性水平α是在检验之前确定的，这也就意味着我们事先确定了拒绝域。这样，不论检验统计量的值是大是小，只要它的值落入拒绝域就拒绝原假设，否者就不拒绝原假设。这种固定的显著性水平α对检验结果只能提供检验结论可靠性的一个大致范围，无法给出观测数据与原假设之间不一致程度的精确度量。\"></a>　　显著性水平α是在检验之前确定的，这也就意味着我们事先确定了拒绝域。这样，不论检验统计量的值是大是小，只要它的值落入拒绝域就拒绝原假设，否者就不拒绝原假设。这种固定的显著性水平α对检验结果只能提供检验结论可靠性的一个大致范围，无法给出观测数据与原假设之间不一致程度的精确度量。</h5><h5 id=\"P值-在原假设为真的条件下，检验统计量的观察值大于或等于其计算值的概率，称为P值。P值是反映实际观测到的数据与原假设之间不一致程度的一个概率值。P值越小，说明实际观测到的数据与原假设之间不一致的程度就越大，检验的结果也就越显著。\"><a href=\"#P值-在原假设为真的条件下，检验统计量的观察值大于或等于其计算值的概率，称为P值。P值是反映实际观测到的数据与原假设之间不一致程度的一个概率值。P值越小，说明实际观测到的数据与原假设之间不一致的程度就越大，检验的结果也就越显著。\" class=\"headerlink\" title=\"　　P值 在原假设为真的条件下，检验统计量的观察值大于或等于其计算值的概率，称为P值。P值是反映实际观测到的数据与原假设之间不一致程度的一个概率值。P值越小，说明实际观测到的数据与原假设之间不一致的程度就越大，检验的结果也就越显著。\"></a>　　<strong>P值</strong> 在原假设为真的条件下，检验统计量的观察值大于或等于其计算值的概率，称为P值。P值是反映实际观测到的数据与原假设之间不一致程度的一个概率值。P值越小，说明实际观测到的数据与原假设之间不一致的程度就越大，检验的结果也就越显著。</h5><h3 id=\"1-3-一个总体参数的检验\"><a href=\"#1-3-一个总体参数的检验\" class=\"headerlink\" title=\"1.3 一个总体参数的检验\"></a>1.3 一个总体参数的检验</h3><h5 id=\"当我们研究一个总体时，要检验的参数主要是总体均值μ、总体比例π和总体方差σ2。由于检验的参数不同，计算检验统计量的方法也有所不同。\"><a href=\"#当我们研究一个总体时，要检验的参数主要是总体均值μ、总体比例π和总体方差σ2。由于检验的参数不同，计算检验统计量的方法也有所不同。\" class=\"headerlink\" title=\"　　当我们研究一个总体时，要检验的参数主要是总体均值μ、总体比例π和总体方差σ2。由于检验的参数不同，计算检验统计量的方法也有所不同。\"></a>　　当我们研究一个总体时，要检验的参数主要是总体均值μ、总体比例π和总体方差σ<sup>2</sup>。由于检验的参数不同，计算检验统计量的方法也有所不同。</h5><h4 id=\"1-3-1-总体均值的检验\"><a href=\"#1-3-1-总体均值的检验\" class=\"headerlink\" title=\"1.3.1 总体均值的检验\"></a>1.3.1 总体均值的检验</h4><h5 id=\"对于总体均值进行假设检验，采用什么检验步骤和检验统计量取决于我们所抽取的样本是大样本（n≥30）还是小样本（n\"><a href=\"#对于总体均值进行假设检验，采用什么检验步骤和检验统计量取决于我们所抽取的样本是大样本（n≥30）还是小样本（n\" class=\"headerlink\" title=\"　　对于总体均值进行假设检验，采用什么检验步骤和检验统计量取决于我们所抽取的样本是大样本（n≥30）还是小样本（n\"></a>　　对于总体均值进行假设检验，采用什么检验步骤和检验统计量取决于我们所抽取的样本是大样本（n≥30）还是小样本（n<30），此外还需要区分总体是否服从正太分布、总体方差σ<sup>2&lt;/SUP&gt;是否已知等几种情况。</30），此外还需要区分总体是否服从正太分布、总体方差σ<sup></h5><p><img src=\"../../img/pvalue/pvalue4.png\" alt=\"大样本情况下一个总体均值的检验方法\">    <div class=\"img-note\">大样本情况下一个总体均值的检验方法</div><br><img src=\"../../img/pvalue/pvalue5.png\" alt=\"小样本情况下一个总体均值的检验方法\">    <div class=\"img-note\">小样本情况下一个总体均值的检验方法</div></p>\n<h5 id=\"Z表示转换为标准正太分布下的检验统计量。\"><a href=\"#Z表示转换为标准正太分布下的检验统计量。\" class=\"headerlink\" title=\"　　Z表示转换为标准正太分布下的检验统计量。\"></a>　　Z表示转换为标准正太分布下的检验统计量。</h5><h4 id=\"1-3-2-总体比例的检验\"><a href=\"#1-3-2-总体比例的检验\" class=\"headerlink\" title=\"1.3.2 总体比例的检验\"></a>1.3.2 总体比例的检验</h4><h5 id=\"总体比例是指总体中具有某种相同特征的个体所占的比例，这些特征可以是数据型的（如一定的重量、一定的厚度或一定规格等），也可以是品质型的（如男女比例、学历等级、职称高低等）。\"><a href=\"#总体比例是指总体中具有某种相同特征的个体所占的比例，这些特征可以是数据型的（如一定的重量、一定的厚度或一定规格等），也可以是品质型的（如男女比例、学历等级、职称高低等）。\" class=\"headerlink\" title=\"　　总体比例是指总体中具有某种相同特征的个体所占的比例，这些特征可以是数据型的（如一定的重量、一定的厚度或一定规格等），也可以是品质型的（如男女比例、学历等级、职称高低等）。\"></a>　　总体比例是指总体中具有某种相同特征的个体所占的比例，这些特征可以是数据型的（如一定的重量、一定的厚度或一定规格等），也可以是品质型的（如男女比例、学历等级、职称高低等）。</h5><h5 id=\"在构造检验统计量时，我们仍然利用样本比例p与总体比例π之间的距离等于多少个标准差来衡量，因为在大样本情况下统计量p近似服从正太分布，而统计量\"><a href=\"#在构造检验统计量时，我们仍然利用样本比例p与总体比例π之间的距离等于多少个标准差来衡量，因为在大样本情况下统计量p近似服从正太分布，而统计量\" class=\"headerlink\" title=\"　　在构造检验统计量时，我们仍然利用样本比例p与总体比例π之间的距离等于多少个标准差来衡量，因为在大样本情况下统计量p近似服从正太分布，而统计量\"></a>　　在构造检验统计量时，我们仍然利用样本比例p与总体比例π之间的距离等于多少个标准差来衡量，因为在大样本情况下统计量p近似服从正太分布，而统计量</h5><script type=\"math/tex; mode=display\">z = \\frac{P - π_0}{\\sqrt{\\frac{π_0(1-π_0)}{n}}}</script><p><img src=\"../../img/pvalue/pvalue6.png\" alt=\"大样本情况下一个总体比例的检验方法\">    <div class=\"img-note\">大样本情况下一个总体比例的检验方法</div></p>\n<h3 id=\"1-4-两个总体参数的检验\"><a href=\"#1-4-两个总体参数的检验\" class=\"headerlink\" title=\"1.4 两个总体参数的检验\"></a>1.4 两个总体参数的检验</h3><h5 id=\"在实际研究中，我们常常要比较两个总体的差异，如一所学校的重点班和普通班两个班级学生的英语成绩是否有显著差异；生产企业在改进生产线后的平均产量与原生产线的平均产量相比是否有显著提高等等。\"><a href=\"#在实际研究中，我们常常要比较两个总体的差异，如一所学校的重点班和普通班两个班级学生的英语成绩是否有显著差异；生产企业在改进生产线后的平均产量与原生产线的平均产量相比是否有显著提高等等。\" class=\"headerlink\" title=\"　　在实际研究中，我们常常要比较两个总体的差异，如一所学校的重点班和普通班两个班级学生的英语成绩是否有显著差异；生产企业在改进生产线后的平均产量与原生产线的平均产量相比是否有显著提高等等。\"></a>　　在实际研究中，我们常常要比较两个总体的差异，如一所学校的重点班和普通班两个班级学生的英语成绩是否有显著差异；生产企业在改进生产线后的平均产量与原生产线的平均产量相比是否有显著提高等等。</h5><p><img src=\"../../img/pvalue/pvalue7.png\" alt=\"两个总体均值之差的三种基本假设检验形式\">    <div class=\"img-note\">两个总体均值之差的三种基本假设检验形式</div></p>\n<h2 id=\"2-JAVA实现P值计算\"><a href=\"#2-JAVA实现P值计算\" class=\"headerlink\" title=\"2. JAVA实现P值计算\"></a>2. JAVA实现P值计算</h2>","site":{"data":{}},"excerpt":"<h5 id=\"最近产品提出需求，对于ab实验，希望能够通过实验数据计算出P值，以对数据的准确性做一个直观判断。最开始不知道P值是一个什么概念，觉得应该很简单，baidu或者google以下应该会有很多开源的代码或者jar包；又或者是自己将P值公式实现便可。但是一番查找后发现没有想的这么简单，网络上对于P值得计算过程大多含糊不清，更别提完整的计算代码。最后没办法，只有通过自己拿起概率论书本重新进行学习，以下便记录自己从P值是什么到java实现的一些细节。\"><a href=\"#最近产品提出需求，对于ab实验，希望能够通过实验数据计算出P值，以对数据的准确性做一个直观判断。最开始不知道P值是一个什么概念，觉得应该很简单，baidu或者google以下应该会有很多开源的代码或者jar包；又或者是自己将P值公式实现便可。但是一番查找后发现没有想的这么简单，网络上对于P值得计算过程大多含糊不清，更别提完整的计算代码。最后没办法，只有通过自己拿起概率论书本重新进行学习，以下便记录自己从P值是什么到java实现的一些细节。\" class=\"headerlink\" title=\"　　最近产品提出需求，对于ab实验，希望能够通过实验数据计算出P值，以对数据的准确性做一个直观判断。最开始不知道P值是一个什么概念，觉得应该很简单，baidu或者google以下应该会有很多开源的代码或者jar包；又或者是自己将P值公式实现便可。但是一番查找后发现没有想的这么简单，网络上对于P值得计算过程大多含糊不清，更别提完整的计算代码。最后没办法，只有通过自己拿起概率论书本重新进行学习，以下便记录自己从P值是什么到java实现的一些细节。\"></a>　　最近产品提出需求，对于ab实验，希望能够通过实验数据计算出P值，以对数据的准确性做一个直观判断。最开始不知道P值是一个什么概念，觉得应该很简单，baidu或者google以下应该会有很多开源的代码或者jar包；又或者是自己将P值公式实现便可。但是一番查找后发现没有想的这么简单，网络上对于P值得计算过程大多含糊不清，更别提完整的计算代码。最后没办法，只有通过自己拿起概率论书本重新进行学习，以下便记录自己从P值是什么到java实现的一些细节。</h5>","more":"<h2 id=\"1-统计学中P值\"><a href=\"#1-统计学中P值\" class=\"headerlink\" title=\"1. 统计学中P值\"></a>1. 统计学中P值</h2><h5 id=\"P值是指当假设为真时所得到的观察结果的概率，简单讲P值就是概率，反映某一事件发生的可能性大小。下面几个比较重要的基础概念对于理解P值的意义会有帮助。\"><a href=\"#P值是指当假设为真时所得到的观察结果的概率，简单讲P值就是概率，反映某一事件发生的可能性大小。下面几个比较重要的基础概念对于理解P值的意义会有帮助。\" class=\"headerlink\" title=\"　　P值是指当假设为真时所得到的观察结果的概率，简单讲P值就是概率，反映某一事件发生的可能性大小。下面几个比较重要的基础概念对于理解P值的意义会有帮助。\"></a>　　P值是指当假设为真时所得到的观察结果的概率，简单讲P值就是概率，反映某一事件发生的可能性大小。下面几个比较重要的基础概念对于理解P值的意义会有帮助。</h5><h3 id=\"1-1-概率论中几个比较重要的基础概念\"><a href=\"#1-1-概率论中几个比较重要的基础概念\" class=\"headerlink\" title=\"1.1 概率论中几个比较重要的基础概念\"></a>1.1 概率论中几个比较重要的基础概念</h3><h4 id=\"1-1-1-原假设与备择假设：\"><a href=\"#1-1-1-原假设与备择假设：\" class=\"headerlink\" title=\"1.1.1 原假设与备择假设：\"></a>1.1.1 原假设与备择假设：</h4><h5 id=\"原假设（H0）：通常将研究者想手机证据予以反对的假设称为原假设，用H0表示；\"><a href=\"#原假设（H0）：通常将研究者想手机证据予以反对的假设称为原假设，用H0表示；\" class=\"headerlink\" title=\"原假设（H0）：通常将研究者想手机证据予以反对的假设称为原假设，用H0表示；\"></a><strong>原假设（H<sub>0</sub>）</strong>：通常将研究者想手机证据予以反对的假设称为原假设，用H<sub>0</sub>表示；</h5><h5 id=\"备择假设（H1）：通常将研究者想收集证据予以支持的假设称为备择假设，或称研究假设，用H1活H2表示。\"><a href=\"#备择假设（H1）：通常将研究者想收集证据予以支持的假设称为备择假设，或称研究假设，用H1活H2表示。\" class=\"headerlink\" title=\"备择假设（H1）：通常将研究者想收集证据予以支持的假设称为备择假设，或称研究假设，用H1活H2表示。\"></a><strong>备择假设（H<sub>1</sub>）</strong>：通常将研究者想收集证据予以支持的假设称为备择假设，或称研究假设，用H<sub>1</sub>活H<sub>2</sub>表示。</h5><h5 id=\"举个栗子：\"><a href=\"#举个栗子：\" class=\"headerlink\" title=\"　　举个栗子：\"></a>　　举个栗子：</h5><div class=\"highlighter-rouge\"><pre class=\"highlight\"><code>某品牌洗涤剂在产品说明书中声称：平均净含量不少于500g。从消费者利益出发，有关研究人员要通过抽检其中的一批产品来验证该产品制造商的说明是否属实。    \n解：对于该洗涤剂的平均含量的真值为μ。如果抽检的结果发现μ<500，则表明该产品说明书中关于其净含量的内容是不真实的。一般来说，研究者抽检的意图是倾向于证实这种洗涤剂的平均净含量不符合说明书中的概述，因为这不符合说明书的陈述。如果研究者对于产品说明丝毫没有质疑，也就没有必要抽检了。所以μ<500是研究者想要收集证据支持的观点。 <br=\"\"><h6>H<sub>0</sub>:μ≥500(净含量符合说明书);</h6><h6>H<sub>1</sub>:μ&lt;500(净含量不符合说明书)。</h6></500，则表明该产品说明书中关于其净含量的内容是不真实的。一般来说，研究者抽检的意图是倾向于证实这种洗涤剂的平均净含量不符合说明书中的概述，因为这不符合说明书的陈述。如果研究者对于产品说明丝毫没有质疑，也就没有必要抽检了。所以μ<500是研究者想要收集证据支持的观点。></code></pre></div>\n\n\n<div class=\"highlighter-rouge\"><pre class=\"highlight\"><code>一家研究机构估计，某城市中家庭拥有汽车的比例超过30%。为了验证这一估计是否正确，该研究机构随机抽取了一个样本进行检验。     \n解：设该城市中家庭拥有汽车的比例真值为π。显然，研究者想收集证据予以支持的假设是:该城市中家庭拥有汽车的比例超过30%。因此建立的原假设与备择假设应为\n<h6>H<sub>0</sub>:π≤30%（家庭拥有汽车的比例不超过30%）;</h6><h6>H<sub>1</sub>:π>30%（家庭拥有汽车的比例超过30%）。</h6></code></pre></div>\n\n<ul>\n<li>原假设和备择假设是一个完备事件组，而且互相对立。也就是说在一项假设检验中，必有且只有一个成立；</li>\n<li>在假设检验中，等号”=”总是放在原假设上。   </li>\n</ul>\n<h4 id=\"1-1-2-单侧检验和双侧检验：\"><a href=\"#1-1-2-单侧检验和双侧检验：\" class=\"headerlink\" title=\"1.1.2 单侧检验和双侧检验：\"></a>1.1.2 单侧检验和双侧检验：</h4><h5 id=\"单侧检验：备择假设具有特定的方向性，并含有符号”-gt-”或”-lt-”的假设检验；\"><a href=\"#单侧检验：备择假设具有特定的方向性，并含有符号”-gt-”或”-lt-”的假设检验；\" class=\"headerlink\" title=\"单侧检验：备择假设具有特定的方向性，并含有符号”&gt;”或”&lt;”的假设检验；\"></a><strong>单侧检验</strong>：备择假设具有特定的方向性，并含有符号”&gt;”或”&lt;”的假设检验；</h5><h5 id=\"双侧检验：备择假设没有特定的方向性，并含有符号”≠”的假设检验。\"><a href=\"#双侧检验：备择假设没有特定的方向性，并含有符号”≠”的假设检验。\" class=\"headerlink\" title=\"双侧检验：备择假设没有特定的方向性，并含有符号”≠”的假设检验。\"></a><strong>双侧检验</strong>：备择假设没有特定的方向性，并含有符号”≠”的假设检验。</h5><p><img src=\"../../img/pvalue/pvalue1.png\" alt=\"假设检验的基本形式\">    <div class=\"img-note\">假设检验的基本形式</div></p>\n<h4 id=\"1-1-3-两类错误与显著水平\"><a href=\"#1-1-3-两类错误与显著水平\" class=\"headerlink\" title=\"1.1.3 两类错误与显著水平\"></a>1.1.3 两类错误与显著水平</h4><h5 id=\"如前所述，原假设与备择假设不能同时成立，我们要么拒绝原假设，要么不拒绝原假设。我们希望的情况是：当原假设正确时没有拒绝它，当原假设不正确时拒绝它。但是我们无法保证不犯错。假设检验中过程中可能发生以下两类错误：\"><a href=\"#如前所述，原假设与备择假设不能同时成立，我们要么拒绝原假设，要么不拒绝原假设。我们希望的情况是：当原假设正确时没有拒绝它，当原假设不正确时拒绝它。但是我们无法保证不犯错。假设检验中过程中可能发生以下两类错误：\" class=\"headerlink\" title=\"　　如前所述，原假设与备择假设不能同时成立，我们要么拒绝原假设，要么不拒绝原假设。我们希望的情况是：当原假设正确时没有拒绝它，当原假设不正确时拒绝它。但是我们无法保证不犯错。假设检验中过程中可能发生以下两类错误：\"></a>　　如前所述，原假设与备择假设不能同时成立，我们要么拒绝原假设，要么不拒绝原假设。我们希望的情况是：当原假设正确时没有拒绝它，当原假设不正确时拒绝它。但是我们无法保证不犯错。假设检验中过程中可能发生以下两类错误：</h5><h5 id=\"I类错误：当原假设为真是拒绝原假设，所犯的错误称为第I类错误；\"><a href=\"#I类错误：当原假设为真是拒绝原假设，所犯的错误称为第I类错误；\" class=\"headerlink\" title=\"I类错误：当原假设为真是拒绝原假设，所犯的错误称为第I类错误；\"></a><strong>I类错误</strong>：当原假设为真是拒绝原假设，所犯的错误称为第I类错误；</h5><h5 id=\"II类错误：当原假设为假时没有拒绝原假设，所犯错误称为第II类错误。\"><a href=\"#II类错误：当原假设为假时没有拒绝原假设，所犯错误称为第II类错误。\" class=\"headerlink\" title=\"II类错误：当原假设为假时没有拒绝原假设，所犯错误称为第II类错误。\"></a><strong>II类错误</strong>：当原假设为假时没有拒绝原假设，所犯错误称为第II类错误。</h5><p><img src=\"../../img/pvalue/pvalue2.png\" alt=\"假设检验的结论与后果\">   <div class=\"img-note\">假设检验的结论与后果</div></p>\n<h5 id=\"只有当原假设被拒绝时，我们才会犯第I类错误；只有当原假设未被拒绝时，我们才会犯第II类错误。因此，我们可以不犯第I类错误或不犯第II类错误，但不可能两类错误都不犯。两类错误就像一个跷跷板，当一个概率增大时，另一个减小。人们只能在两类错误的发生概率之间进行平衡。一般来说，发生哪一类错误的后果更为严重，就应该首要控制哪类错误发生的概率，但由于犯第I类错误的概率是可以又研究者控制的，因为此在假设检验中，人们往往先控制第I类错误的发生概率。\"><a href=\"#只有当原假设被拒绝时，我们才会犯第I类错误；只有当原假设未被拒绝时，我们才会犯第II类错误。因此，我们可以不犯第I类错误或不犯第II类错误，但不可能两类错误都不犯。两类错误就像一个跷跷板，当一个概率增大时，另一个减小。人们只能在两类错误的发生概率之间进行平衡。一般来说，发生哪一类错误的后果更为严重，就应该首要控制哪类错误发生的概率，但由于犯第I类错误的概率是可以又研究者控制的，因为此在假设检验中，人们往往先控制第I类错误的发生概率。\" class=\"headerlink\" title=\"　　只有当原假设被拒绝时，我们才会犯第I类错误；只有当原假设未被拒绝时，我们才会犯第II类错误。因此，我们可以不犯第I类错误或不犯第II类错误，但不可能两类错误都不犯。两类错误就像一个跷跷板，当一个概率增大时，另一个减小。人们只能在两类错误的发生概率之间进行平衡。一般来说，发生哪一类错误的后果更为严重，就应该首要控制哪类错误发生的概率，但由于犯第I类错误的概率是可以又研究者控制的，因为此在假设检验中，人们往往先控制第I类错误的发生概率。\"></a>　　只有当原假设被拒绝时，我们才会犯第I类错误；只有当原假设未被拒绝时，我们才会犯第II类错误。因此，我们可以不犯第I类错误或不犯第II类错误，但不可能两类错误都不犯。两类错误就像一个跷跷板，当一个概率增大时，另一个减小。人们只能在两类错误的发生概率之间进行平衡。一般来说，发生哪一类错误的后果更为严重，就应该首要控制哪类错误发生的概率，但由于犯第I类错误的概率是可以又研究者控制的，因为此在假设检验中，人们往往先控制第I类错误的发生概率。</h5><p><code>发生第I类错误的概率常被用于度量检验结论的可靠性，并将这一概率称为显著性水平，记为α。</code></p>\n<h5 id=\"显著水平-是人们事先指定的犯第I类错误概率α的最大允许值。显著水平α越小，犯第I类错误的可能性自然就越小，但犯第II类错误的可能性则随之增大。作为一个普遍使用的原则，人们通常选择显著性水平为0-05或比0-05更小的概率。\"><a href=\"#显著水平-是人们事先指定的犯第I类错误概率α的最大允许值。显著水平α越小，犯第I类错误的可能性自然就越小，但犯第II类错误的可能性则随之增大。作为一个普遍使用的原则，人们通常选择显著性水平为0-05或比0-05更小的概率。\" class=\"headerlink\" title=\"　　显著水平 是人们事先指定的犯第I类错误概率α的最大允许值。显著水平α越小，犯第I类错误的可能性自然就越小，但犯第II类错误的可能性则随之增大。作为一个普遍使用的原则，人们通常选择显著性水平为0.05或比0.05更小的概率。\"></a>　　<strong>显著水平</strong> 是人们事先指定的犯第I类错误概率α的最大允许值。显著水平α越小，犯第I类错误的可能性自然就越小，但犯第II类错误的可能性则随之增大。作为一个普遍使用的原则，人们通常选择显著性水平为0.05或比0.05更小的概率。</h5><h4 id=\"1-1-4-标准化检测量与拒绝域\"><a href=\"#1-1-4-标准化检测量与拒绝域\" class=\"headerlink\" title=\"1.1.4 标准化检测量与拒绝域\"></a>1.1.4 标准化检测量与拒绝域</h4><h5 id=\"检验统计量-实际上是总体参数的点估计量，但点估计量并不能直接作为检验的统计量，只有将其标准化后，才能用于度量它与原假设的参数之间的差异程度。实际上，假设检验中所用的检验统计量都是标准化检验统计量，它反映了点估计量（比如样本均值）与假设的总体参数（比如假设的总体均值）相比相差了多少个标准差。\"><a href=\"#检验统计量-实际上是总体参数的点估计量，但点估计量并不能直接作为检验的统计量，只有将其标准化后，才能用于度量它与原假设的参数之间的差异程度。实际上，假设检验中所用的检验统计量都是标准化检验统计量，它反映了点估计量（比如样本均值）与假设的总体参数（比如假设的总体均值）相比相差了多少个标准差。\" class=\"headerlink\" title=\"　　检验统计量 实际上是总体参数的点估计量，但点估计量并不能直接作为检验的统计量，只有将其标准化后，才能用于度量它与原假设的参数之间的差异程度。实际上，假设检验中所用的检验统计量都是标准化检验统计量，它反映了点估计量（比如样本均值）与假设的总体参数（比如假设的总体均值）相比相差了多少个标准差。\"></a>　　<strong>检验统计量</strong> 实际上是总体参数的点估计量，但点估计量并不能直接作为检验的统计量，只有将其标准化后，才能用于度量它与原假设的参数之间的差异程度。实际上，假设检验中所用的检验统计量都是标准化检验统计量，它反映了点估计量（比如样本均值）与假设的总体参数（比如假设的总体均值）相比相差了多少个标准差。</h5><script type=\"math/tex; mode=display\">标准化检验统计量 = \\frac{点估计量 - 假设值}{点估计量的抽样标准差}</script><h5 id=\"拒绝域-能够拒绝原假设的检验统计量的所有可能取值的集合。是由显著性水平α所围成的区域。如果利用样本观测结果计算出来的检验统计量的具体数值落在了拒绝域内，就拒绝原假设，否则就不拒绝原假设。\"><a href=\"#拒绝域-能够拒绝原假设的检验统计量的所有可能取值的集合。是由显著性水平α所围成的区域。如果利用样本观测结果计算出来的检验统计量的具体数值落在了拒绝域内，就拒绝原假设，否则就不拒绝原假设。\" class=\"headerlink\" title=\"　　拒绝域 能够拒绝原假设的检验统计量的所有可能取值的集合。是由显著性水平α所围成的区域。如果利用样本观测结果计算出来的检验统计量的具体数值落在了拒绝域内，就拒绝原假设，否则就不拒绝原假设。\"></a>　　<strong>拒绝域</strong> 能够拒绝原假设的检验统计量的所有可能取值的集合。是由显著性水平α所围成的区域。如果利用样本观测结果计算出来的检验统计量的具体数值落在了拒绝域内，就拒绝原假设，否则就不拒绝原假设。</h5><p><img src=\"../../img/pvalue/pvalue3.jpeg\" alt=\"显著性水平、拒绝域和临界值\"><div class=\"img-note\">显著性水平、拒绝域和临界值</div></p>\n<h5 id=\"当样本容量固定时，拒绝域的面积随α的减小而减小。α值越小，拒绝域假设所需的检验统计量的临界值与原假设的参数值就越远。\"><a href=\"#当样本容量固定时，拒绝域的面积随α的减小而减小。α值越小，拒绝域假设所需的检验统计量的临界值与原假设的参数值就越远。\" class=\"headerlink\" title=\"　　当样本容量固定时，拒绝域的面积随α的减小而减小。α值越小，拒绝域假设所需的检验统计量的临界值与原假设的参数值就越远。\"></a>　　当样本容量固定时，拒绝域的面积随α的减小而减小。α值越小，拒绝域假设所需的检验统计量的临界值与原假设的参数值就越远。</h5><h3 id=\"1-2-利用P值进行决策\"><a href=\"#1-2-利用P值进行决策\" class=\"headerlink\" title=\"1.2 利用P值进行决策\"></a>1.2 利用P值进行决策</h3><h5 id=\"显著性水平α是在检验之前确定的，这也就意味着我们事先确定了拒绝域。这样，不论检验统计量的值是大是小，只要它的值落入拒绝域就拒绝原假设，否者就不拒绝原假设。这种固定的显著性水平α对检验结果只能提供检验结论可靠性的一个大致范围，无法给出观测数据与原假设之间不一致程度的精确度量。\"><a href=\"#显著性水平α是在检验之前确定的，这也就意味着我们事先确定了拒绝域。这样，不论检验统计量的值是大是小，只要它的值落入拒绝域就拒绝原假设，否者就不拒绝原假设。这种固定的显著性水平α对检验结果只能提供检验结论可靠性的一个大致范围，无法给出观测数据与原假设之间不一致程度的精确度量。\" class=\"headerlink\" title=\"　　显著性水平α是在检验之前确定的，这也就意味着我们事先确定了拒绝域。这样，不论检验统计量的值是大是小，只要它的值落入拒绝域就拒绝原假设，否者就不拒绝原假设。这种固定的显著性水平α对检验结果只能提供检验结论可靠性的一个大致范围，无法给出观测数据与原假设之间不一致程度的精确度量。\"></a>　　显著性水平α是在检验之前确定的，这也就意味着我们事先确定了拒绝域。这样，不论检验统计量的值是大是小，只要它的值落入拒绝域就拒绝原假设，否者就不拒绝原假设。这种固定的显著性水平α对检验结果只能提供检验结论可靠性的一个大致范围，无法给出观测数据与原假设之间不一致程度的精确度量。</h5><h5 id=\"P值-在原假设为真的条件下，检验统计量的观察值大于或等于其计算值的概率，称为P值。P值是反映实际观测到的数据与原假设之间不一致程度的一个概率值。P值越小，说明实际观测到的数据与原假设之间不一致的程度就越大，检验的结果也就越显著。\"><a href=\"#P值-在原假设为真的条件下，检验统计量的观察值大于或等于其计算值的概率，称为P值。P值是反映实际观测到的数据与原假设之间不一致程度的一个概率值。P值越小，说明实际观测到的数据与原假设之间不一致的程度就越大，检验的结果也就越显著。\" class=\"headerlink\" title=\"　　P值 在原假设为真的条件下，检验统计量的观察值大于或等于其计算值的概率，称为P值。P值是反映实际观测到的数据与原假设之间不一致程度的一个概率值。P值越小，说明实际观测到的数据与原假设之间不一致的程度就越大，检验的结果也就越显著。\"></a>　　<strong>P值</strong> 在原假设为真的条件下，检验统计量的观察值大于或等于其计算值的概率，称为P值。P值是反映实际观测到的数据与原假设之间不一致程度的一个概率值。P值越小，说明实际观测到的数据与原假设之间不一致的程度就越大，检验的结果也就越显著。</h5><h3 id=\"1-3-一个总体参数的检验\"><a href=\"#1-3-一个总体参数的检验\" class=\"headerlink\" title=\"1.3 一个总体参数的检验\"></a>1.3 一个总体参数的检验</h3><h5 id=\"当我们研究一个总体时，要检验的参数主要是总体均值μ、总体比例π和总体方差σ2。由于检验的参数不同，计算检验统计量的方法也有所不同。\"><a href=\"#当我们研究一个总体时，要检验的参数主要是总体均值μ、总体比例π和总体方差σ2。由于检验的参数不同，计算检验统计量的方法也有所不同。\" class=\"headerlink\" title=\"　　当我们研究一个总体时，要检验的参数主要是总体均值μ、总体比例π和总体方差σ2。由于检验的参数不同，计算检验统计量的方法也有所不同。\"></a>　　当我们研究一个总体时，要检验的参数主要是总体均值μ、总体比例π和总体方差σ<sup>2</sup>。由于检验的参数不同，计算检验统计量的方法也有所不同。</h5><h4 id=\"1-3-1-总体均值的检验\"><a href=\"#1-3-1-总体均值的检验\" class=\"headerlink\" title=\"1.3.1 总体均值的检验\"></a>1.3.1 总体均值的检验</h4><h5 id=\"对于总体均值进行假设检验，采用什么检验步骤和检验统计量取决于我们所抽取的样本是大样本（n≥30）还是小样本（n\"><a href=\"#对于总体均值进行假设检验，采用什么检验步骤和检验统计量取决于我们所抽取的样本是大样本（n≥30）还是小样本（n\" class=\"headerlink\" title=\"　　对于总体均值进行假设检验，采用什么检验步骤和检验统计量取决于我们所抽取的样本是大样本（n≥30）还是小样本（n\"></a>　　对于总体均值进行假设检验，采用什么检验步骤和检验统计量取决于我们所抽取的样本是大样本（n≥30）还是小样本（n<30），此外还需要区分总体是否服从正太分布、总体方差σ<sup>2&lt;/SUP&gt;是否已知等几种情况。</30），此外还需要区分总体是否服从正太分布、总体方差σ<sup></h5><p><img src=\"../../img/pvalue/pvalue4.png\" alt=\"大样本情况下一个总体均值的检验方法\">    <div class=\"img-note\">大样本情况下一个总体均值的检验方法</div><br><img src=\"../../img/pvalue/pvalue5.png\" alt=\"小样本情况下一个总体均值的检验方法\">    <div class=\"img-note\">小样本情况下一个总体均值的检验方法</div></p>\n<h5 id=\"Z表示转换为标准正太分布下的检验统计量。\"><a href=\"#Z表示转换为标准正太分布下的检验统计量。\" class=\"headerlink\" title=\"　　Z表示转换为标准正太分布下的检验统计量。\"></a>　　Z表示转换为标准正太分布下的检验统计量。</h5><h4 id=\"1-3-2-总体比例的检验\"><a href=\"#1-3-2-总体比例的检验\" class=\"headerlink\" title=\"1.3.2 总体比例的检验\"></a>1.3.2 总体比例的检验</h4><h5 id=\"总体比例是指总体中具有某种相同特征的个体所占的比例，这些特征可以是数据型的（如一定的重量、一定的厚度或一定规格等），也可以是品质型的（如男女比例、学历等级、职称高低等）。\"><a href=\"#总体比例是指总体中具有某种相同特征的个体所占的比例，这些特征可以是数据型的（如一定的重量、一定的厚度或一定规格等），也可以是品质型的（如男女比例、学历等级、职称高低等）。\" class=\"headerlink\" title=\"　　总体比例是指总体中具有某种相同特征的个体所占的比例，这些特征可以是数据型的（如一定的重量、一定的厚度或一定规格等），也可以是品质型的（如男女比例、学历等级、职称高低等）。\"></a>　　总体比例是指总体中具有某种相同特征的个体所占的比例，这些特征可以是数据型的（如一定的重量、一定的厚度或一定规格等），也可以是品质型的（如男女比例、学历等级、职称高低等）。</h5><h5 id=\"在构造检验统计量时，我们仍然利用样本比例p与总体比例π之间的距离等于多少个标准差来衡量，因为在大样本情况下统计量p近似服从正太分布，而统计量\"><a href=\"#在构造检验统计量时，我们仍然利用样本比例p与总体比例π之间的距离等于多少个标准差来衡量，因为在大样本情况下统计量p近似服从正太分布，而统计量\" class=\"headerlink\" title=\"　　在构造检验统计量时，我们仍然利用样本比例p与总体比例π之间的距离等于多少个标准差来衡量，因为在大样本情况下统计量p近似服从正太分布，而统计量\"></a>　　在构造检验统计量时，我们仍然利用样本比例p与总体比例π之间的距离等于多少个标准差来衡量，因为在大样本情况下统计量p近似服从正太分布，而统计量</h5><script type=\"math/tex; mode=display\">z = \\frac{P - π_0}{\\sqrt{\\frac{π_0(1-π_0)}{n}}}</script><p><img src=\"../../img/pvalue/pvalue6.png\" alt=\"大样本情况下一个总体比例的检验方法\">    <div class=\"img-note\">大样本情况下一个总体比例的检验方法</div></p>\n<h3 id=\"1-4-两个总体参数的检验\"><a href=\"#1-4-两个总体参数的检验\" class=\"headerlink\" title=\"1.4 两个总体参数的检验\"></a>1.4 两个总体参数的检验</h3><h5 id=\"在实际研究中，我们常常要比较两个总体的差异，如一所学校的重点班和普通班两个班级学生的英语成绩是否有显著差异；生产企业在改进生产线后的平均产量与原生产线的平均产量相比是否有显著提高等等。\"><a href=\"#在实际研究中，我们常常要比较两个总体的差异，如一所学校的重点班和普通班两个班级学生的英语成绩是否有显著差异；生产企业在改进生产线后的平均产量与原生产线的平均产量相比是否有显著提高等等。\" class=\"headerlink\" title=\"　　在实际研究中，我们常常要比较两个总体的差异，如一所学校的重点班和普通班两个班级学生的英语成绩是否有显著差异；生产企业在改进生产线后的平均产量与原生产线的平均产量相比是否有显著提高等等。\"></a>　　在实际研究中，我们常常要比较两个总体的差异，如一所学校的重点班和普通班两个班级学生的英语成绩是否有显著差异；生产企业在改进生产线后的平均产量与原生产线的平均产量相比是否有显著提高等等。</h5><p><img src=\"../../img/pvalue/pvalue7.png\" alt=\"两个总体均值之差的三种基本假设检验形式\">    <div class=\"img-note\">两个总体均值之差的三种基本假设检验形式</div></p>\n<h2 id=\"2-JAVA实现P值计算\"><a href=\"#2-JAVA实现P值计算\" class=\"headerlink\" title=\"2. JAVA实现P值计算\"></a>2. JAVA实现P值计算</h2>"},{"layout":"post","title":"根据上排给出十个数，在其下排填出对应的十个数","date":"2017-02-15T16:00:00.000Z","original":true,"tag":[["算法","arithmetic"]],"_content":"\n## 题目要求：\n##### 给你10分钟时间，根据上排给出十个数，在其下排填出对应的十个数,要求下排每个数都是先前上排那十个数在下排出现的次数。\n##### 上排的十个数如下：【0，1，2，3，4，5，6，7，8，9】\n<!--more-->\n\n### 举个例子，\n##### 上排数值: 0,1,2,3,4,5,6,7,8,9\n##### 下排数值: 6,2,1,0,0,0,1,0,0,0\n##### 0在下排出现了6次，1在下排出现了2次，\n##### 2在下排出现了1次，3在下排出现了0次...\n\n## 分析过程：\n##### 看到题目的时候觉得有一点绕，切没有太理解题目，以为是一直循环输出下排数组，于是有了下面的解题过程。\n### 根据题目得到的一些条件：\n1. 10个数，每个数都大于等于0；\n2. 下排的数字为上排数字出现的次数；\n3. 基于条件2，下排数字相加一定等于10；\n4. 基于条件3，下排数字有0，要么下排全等于1，很明显全等于1就不符合条件2，所以下排数字一定有0；\n5. 根据条件4，上排数字也有0；\n\n#### 基于上面几个条件，做出下面的一些假设：\n##### 上排的10个数中，有n个数字为0，则非0的数有10-n：\n$$ \\underbrace{0...0}_{\\text{n个0}},\\overbrace{v_1...v_i}^{\\text{10-n个非0数字}} $$\n##### 如果上排为0的下排也为0，显然不符合条件2，所以0的下排数字为非0，切所有0的下排数字相等，假设为非0数x,则上排一定有一个数字为x,对应的下排数字为n：\n$$ 上排：0...0,v_1...v_i,x $$\n$$ 下排：\\underbrace{x...x}_{\\text{n个x}},i_1...i_i,n $$\n##### 上排的0在下排为x，则说明下排有x个0,进一步得出下面的组合：\n$$ 上排：0...0,v_1...v_i,v_j...v_k,x $$\n$$ 下排：\\underbrace{x...x}_{\\text{n个x}},\\underbrace{0....0}_{\\text{x个0}},i_i....i_k,n $$\n##### 根据条件1，下排一共10个数，所以：\n$$ n+x+1≤10 $$\n##### 根据条件3，下排数字相加等于10，所以：\n$$ nx+n≤10 $$\n##### 当v<sub>j</sub>到v<sub>k</sub>不存在，也就是个数为0时，上面两个不等式的等号成立，所以有以下两个函数：\n$$\\begin{cases}\nn+x+1=10 \\\\\\\\\nnx+n=10 \\\\\\\\\nx,n 为 正整数\n\\end{cases}\n\\implies\n\\begin{cases}\nn+x+1<10 \\\\\\\\\nnx+n<10 \\\\\\\\\nx,n 为 正整数\n\\end{cases}\n$$\n##### 因为x，n均为正整数，所以枚举所有情况如下：\n$$\nn=\\begin{cases}\n[1,2,3,4] &x=1 \\\\\\\\\n[1,2,3] &x=2 \\\\\\\\\n[1,2,] &x=3 \\\\\\\\\n[1] &x=4 \\\\\\\\\n[1] &x=5 \\\\\\\\\n[1] &x=6 \\\\\\\\\n[1] &x=7 \\\\\\\\\n[1] &x=8\n\\end{cases}\n$$\n##### 于是我基于这种组合，将6,2,1,0,0,0,1,0,0,0默认为上排函数，发现n=6,计算不出下排函数。百度以后发现，人家根本不是按照我的这种方式去计算。下面说一下正确的解题思路.\n\n## 解题：\n##### 它的原型跟八皇后有点类似，都是用回溯递归的方法去一次一次尝试，直到找出正确解。\n##### 具体的想法是：不断的去从下排数组中捉取在上排数组中对应位置中出现的个数，如果个数不对就更新下排数组中对应的值，只到找到正确值。（下排数组先初始为任意值）\n##### 如：\n##### 上排数组A：0,1,2,3,4,5,6,7,8,9\n##### 下排数组B：0,1,2,3,4,5,6,7,8,9\n##### 从上牌数组Index = 0开始，A[0] = 0，0在下排数组中的个数为1，那么下排数组B此时就要更新为：1,1,2,3,4,5,6,7,8,9\n##### Index = 1, A[1] = 1, 1在下排数组中的个数为2，那么下排数组B此时就要更新为：1,2,2,3,4,5,6,7,8,9，从此不断的往下进行，只要找不到正确值就一直往下进行，如果Index >= 数组长度时，那么重新恢复Index = 0再往下进行测试直到找出正确解。\n\n## 最后再说一些：\n##### 其实按照上面的这种解题思路，我的解题过程也不能算是错误的，只是排除了大部分的可能性。并且题目也理解有误，所以以后做题一定要看清楚题，理解题目的正真含义。\n","source":"_posts/arithmetic/array.md","raw":"---\nlayout: post\ntitle: 根据上排给出十个数，在其下排填出对应的十个数\ndate: 2017/02/16\ntags: [tech, arithmetic, index]\noriginal: true\ntag: [[算法, arithmetic]]\n---\n\n## 题目要求：\n##### 给你10分钟时间，根据上排给出十个数，在其下排填出对应的十个数,要求下排每个数都是先前上排那十个数在下排出现的次数。\n##### 上排的十个数如下：【0，1，2，3，4，5，6，7，8，9】\n<!--more-->\n\n### 举个例子，\n##### 上排数值: 0,1,2,3,4,5,6,7,8,9\n##### 下排数值: 6,2,1,0,0,0,1,0,0,0\n##### 0在下排出现了6次，1在下排出现了2次，\n##### 2在下排出现了1次，3在下排出现了0次...\n\n## 分析过程：\n##### 看到题目的时候觉得有一点绕，切没有太理解题目，以为是一直循环输出下排数组，于是有了下面的解题过程。\n### 根据题目得到的一些条件：\n1. 10个数，每个数都大于等于0；\n2. 下排的数字为上排数字出现的次数；\n3. 基于条件2，下排数字相加一定等于10；\n4. 基于条件3，下排数字有0，要么下排全等于1，很明显全等于1就不符合条件2，所以下排数字一定有0；\n5. 根据条件4，上排数字也有0；\n\n#### 基于上面几个条件，做出下面的一些假设：\n##### 上排的10个数中，有n个数字为0，则非0的数有10-n：\n$$ \\underbrace{0...0}_{\\text{n个0}},\\overbrace{v_1...v_i}^{\\text{10-n个非0数字}} $$\n##### 如果上排为0的下排也为0，显然不符合条件2，所以0的下排数字为非0，切所有0的下排数字相等，假设为非0数x,则上排一定有一个数字为x,对应的下排数字为n：\n$$ 上排：0...0,v_1...v_i,x $$\n$$ 下排：\\underbrace{x...x}_{\\text{n个x}},i_1...i_i,n $$\n##### 上排的0在下排为x，则说明下排有x个0,进一步得出下面的组合：\n$$ 上排：0...0,v_1...v_i,v_j...v_k,x $$\n$$ 下排：\\underbrace{x...x}_{\\text{n个x}},\\underbrace{0....0}_{\\text{x个0}},i_i....i_k,n $$\n##### 根据条件1，下排一共10个数，所以：\n$$ n+x+1≤10 $$\n##### 根据条件3，下排数字相加等于10，所以：\n$$ nx+n≤10 $$\n##### 当v<sub>j</sub>到v<sub>k</sub>不存在，也就是个数为0时，上面两个不等式的等号成立，所以有以下两个函数：\n$$\\begin{cases}\nn+x+1=10 \\\\\\\\\nnx+n=10 \\\\\\\\\nx,n 为 正整数\n\\end{cases}\n\\implies\n\\begin{cases}\nn+x+1<10 \\\\\\\\\nnx+n<10 \\\\\\\\\nx,n 为 正整数\n\\end{cases}\n$$\n##### 因为x，n均为正整数，所以枚举所有情况如下：\n$$\nn=\\begin{cases}\n[1,2,3,4] &x=1 \\\\\\\\\n[1,2,3] &x=2 \\\\\\\\\n[1,2,] &x=3 \\\\\\\\\n[1] &x=4 \\\\\\\\\n[1] &x=5 \\\\\\\\\n[1] &x=6 \\\\\\\\\n[1] &x=7 \\\\\\\\\n[1] &x=8\n\\end{cases}\n$$\n##### 于是我基于这种组合，将6,2,1,0,0,0,1,0,0,0默认为上排函数，发现n=6,计算不出下排函数。百度以后发现，人家根本不是按照我的这种方式去计算。下面说一下正确的解题思路.\n\n## 解题：\n##### 它的原型跟八皇后有点类似，都是用回溯递归的方法去一次一次尝试，直到找出正确解。\n##### 具体的想法是：不断的去从下排数组中捉取在上排数组中对应位置中出现的个数，如果个数不对就更新下排数组中对应的值，只到找到正确值。（下排数组先初始为任意值）\n##### 如：\n##### 上排数组A：0,1,2,3,4,5,6,7,8,9\n##### 下排数组B：0,1,2,3,4,5,6,7,8,9\n##### 从上牌数组Index = 0开始，A[0] = 0，0在下排数组中的个数为1，那么下排数组B此时就要更新为：1,1,2,3,4,5,6,7,8,9\n##### Index = 1, A[1] = 1, 1在下排数组中的个数为2，那么下排数组B此时就要更新为：1,2,2,3,4,5,6,7,8,9，从此不断的往下进行，只要找不到正确值就一直往下进行，如果Index >= 数组长度时，那么重新恢复Index = 0再往下进行测试直到找出正确解。\n\n## 最后再说一些：\n##### 其实按照上面的这种解题思路，我的解题过程也不能算是错误的，只是排除了大部分的可能性。并且题目也理解有误，所以以后做题一定要看清楚题，理解题目的正真含义。\n","slug":"arithmetic/array","published":1,"updated":"2017-10-06T16:03:22.645Z","comments":1,"photos":[],"link":"","_id":"cj8jros6w000330s6opr5x2g4","content":"<h2 id=\"题目要求：\"><a href=\"#题目要求：\" class=\"headerlink\" title=\"题目要求：\"></a>题目要求：</h2><h5 id=\"给你10分钟时间，根据上排给出十个数，在其下排填出对应的十个数-要求下排每个数都是先前上排那十个数在下排出现的次数。\"><a href=\"#给你10分钟时间，根据上排给出十个数，在其下排填出对应的十个数-要求下排每个数都是先前上排那十个数在下排出现的次数。\" class=\"headerlink\" title=\"给你10分钟时间，根据上排给出十个数，在其下排填出对应的十个数,要求下排每个数都是先前上排那十个数在下排出现的次数。\"></a>给你10分钟时间，根据上排给出十个数，在其下排填出对应的十个数,要求下排每个数都是先前上排那十个数在下排出现的次数。</h5><h5 id=\"上排的十个数如下：【0，1，2，3，4，5，6，7，8，9】\"><a href=\"#上排的十个数如下：【0，1，2，3，4，5，6，7，8，9】\" class=\"headerlink\" title=\"上排的十个数如下：【0，1，2，3，4，5，6，7，8，9】\"></a>上排的十个数如下：【0，1，2，3，4，5，6，7，8，9】</h5><a id=\"more\"></a>\n<h3 id=\"举个例子，\"><a href=\"#举个例子，\" class=\"headerlink\" title=\"举个例子，\"></a>举个例子，</h3><h5 id=\"上排数值-0-1-2-3-4-5-6-7-8-9\"><a href=\"#上排数值-0-1-2-3-4-5-6-7-8-9\" class=\"headerlink\" title=\"上排数值: 0,1,2,3,4,5,6,7,8,9\"></a>上排数值: 0,1,2,3,4,5,6,7,8,9</h5><h5 id=\"下排数值-6-2-1-0-0-0-1-0-0-0\"><a href=\"#下排数值-6-2-1-0-0-0-1-0-0-0\" class=\"headerlink\" title=\"下排数值: 6,2,1,0,0,0,1,0,0,0\"></a>下排数值: 6,2,1,0,0,0,1,0,0,0</h5><h5 id=\"0在下排出现了6次，1在下排出现了2次，\"><a href=\"#0在下排出现了6次，1在下排出现了2次，\" class=\"headerlink\" title=\"0在下排出现了6次，1在下排出现了2次，\"></a>0在下排出现了6次，1在下排出现了2次，</h5><h5 id=\"2在下排出现了1次，3在下排出现了0次…\"><a href=\"#2在下排出现了1次，3在下排出现了0次…\" class=\"headerlink\" title=\"2在下排出现了1次，3在下排出现了0次…\"></a>2在下排出现了1次，3在下排出现了0次…</h5><h2 id=\"分析过程：\"><a href=\"#分析过程：\" class=\"headerlink\" title=\"分析过程：\"></a>分析过程：</h2><h5 id=\"看到题目的时候觉得有一点绕，切没有太理解题目，以为是一直循环输出下排数组，于是有了下面的解题过程。\"><a href=\"#看到题目的时候觉得有一点绕，切没有太理解题目，以为是一直循环输出下排数组，于是有了下面的解题过程。\" class=\"headerlink\" title=\"看到题目的时候觉得有一点绕，切没有太理解题目，以为是一直循环输出下排数组，于是有了下面的解题过程。\"></a>看到题目的时候觉得有一点绕，切没有太理解题目，以为是一直循环输出下排数组，于是有了下面的解题过程。</h5><h3 id=\"根据题目得到的一些条件：\"><a href=\"#根据题目得到的一些条件：\" class=\"headerlink\" title=\"根据题目得到的一些条件：\"></a>根据题目得到的一些条件：</h3><ol>\n<li>10个数，每个数都大于等于0；</li>\n<li>下排的数字为上排数字出现的次数；</li>\n<li>基于条件2，下排数字相加一定等于10；</li>\n<li>基于条件3，下排数字有0，要么下排全等于1，很明显全等于1就不符合条件2，所以下排数字一定有0；</li>\n<li>根据条件4，上排数字也有0；</li>\n</ol>\n<h4 id=\"基于上面几个条件，做出下面的一些假设：\"><a href=\"#基于上面几个条件，做出下面的一些假设：\" class=\"headerlink\" title=\"基于上面几个条件，做出下面的一些假设：\"></a>基于上面几个条件，做出下面的一些假设：</h4><h5 id=\"上排的10个数中，有n个数字为0，则非0的数有10-n：\"><a href=\"#上排的10个数中，有n个数字为0，则非0的数有10-n：\" class=\"headerlink\" title=\"上排的10个数中，有n个数字为0，则非0的数有10-n：\"></a>上排的10个数中，有n个数字为0，则非0的数有10-n：</h5><script type=\"math/tex; mode=display\">\\underbrace{0...0}_{\\text{n个0}},\\overbrace{v_1...v_i}^{\\text{10-n个非0数字}}</script><h5 id=\"如果上排为0的下排也为0，显然不符合条件2，所以0的下排数字为非0，切所有0的下排数字相等，假设为非0数x-则上排一定有一个数字为x-对应的下排数字为n：\"><a href=\"#如果上排为0的下排也为0，显然不符合条件2，所以0的下排数字为非0，切所有0的下排数字相等，假设为非0数x-则上排一定有一个数字为x-对应的下排数字为n：\" class=\"headerlink\" title=\"如果上排为0的下排也为0，显然不符合条件2，所以0的下排数字为非0，切所有0的下排数字相等，假设为非0数x,则上排一定有一个数字为x,对应的下排数字为n：\"></a>如果上排为0的下排也为0，显然不符合条件2，所以0的下排数字为非0，切所有0的下排数字相等，假设为非0数x,则上排一定有一个数字为x,对应的下排数字为n：</h5><script type=\"math/tex; mode=display\">上排：0...0,v_1...v_i,x</script><script type=\"math/tex; mode=display\">下排：\\underbrace{x...x}_{\\text{n个x}},i_1...i_i,n</script><h5 id=\"上排的0在下排为x，则说明下排有x个0-进一步得出下面的组合：\"><a href=\"#上排的0在下排为x，则说明下排有x个0-进一步得出下面的组合：\" class=\"headerlink\" title=\"上排的0在下排为x，则说明下排有x个0,进一步得出下面的组合：\"></a>上排的0在下排为x，则说明下排有x个0,进一步得出下面的组合：</h5><script type=\"math/tex; mode=display\">上排：0...0,v_1...v_i,v_j...v_k,x</script><script type=\"math/tex; mode=display\">下排：\\underbrace{x...x}_{\\text{n个x}},\\underbrace{0....0}_{\\text{x个0}},i_i....i_k,n</script><h5 id=\"根据条件1，下排一共10个数，所以：\"><a href=\"#根据条件1，下排一共10个数，所以：\" class=\"headerlink\" title=\"根据条件1，下排一共10个数，所以：\"></a>根据条件1，下排一共10个数，所以：</h5><script type=\"math/tex; mode=display\">n+x+1≤10</script><h5 id=\"根据条件3，下排数字相加等于10，所以：\"><a href=\"#根据条件3，下排数字相加等于10，所以：\" class=\"headerlink\" title=\"根据条件3，下排数字相加等于10，所以：\"></a>根据条件3，下排数字相加等于10，所以：</h5><script type=\"math/tex; mode=display\">nx+n≤10</script><h5 id=\"当vj到vk不存在，也就是个数为0时，上面两个不等式的等号成立，所以有以下两个函数：\"><a href=\"#当vj到vk不存在，也就是个数为0时，上面两个不等式的等号成立，所以有以下两个函数：\" class=\"headerlink\" title=\"当vj到vk不存在，也就是个数为0时，上面两个不等式的等号成立，所以有以下两个函数：\"></a>当v<sub>j</sub>到v<sub>k</sub>不存在，也就是个数为0时，上面两个不等式的等号成立，所以有以下两个函数：</h5><script type=\"math/tex; mode=display\">\\begin{cases}\nn+x+1=10 \\\\\\\\\nnx+n=10 \\\\\\\\\nx,n 为 正整数\n\\end{cases}\n\\implies\n\\begin{cases}\nn+x+1<10 \\\\\\\\\nnx+n<10 \\\\\\\\\nx,n 为 正整数\n\\end{cases}</script><h5 id=\"因为x，n均为正整数，所以枚举所有情况如下：\"><a href=\"#因为x，n均为正整数，所以枚举所有情况如下：\" class=\"headerlink\" title=\"因为x，n均为正整数，所以枚举所有情况如下：\"></a>因为x，n均为正整数，所以枚举所有情况如下：</h5><script type=\"math/tex; mode=display\">\nn=\\begin{cases}\n[1,2,3,4] &x=1 \\\\\\\\\n[1,2,3] &x=2 \\\\\\\\\n[1,2,] &x=3 \\\\\\\\\n[1] &x=4 \\\\\\\\\n[1] &x=5 \\\\\\\\\n[1] &x=6 \\\\\\\\\n[1] &x=7 \\\\\\\\\n[1] &x=8\n\\end{cases}</script><h5 id=\"于是我基于这种组合，将6-2-1-0-0-0-1-0-0-0默认为上排函数，发现n-6-计算不出下排函数。百度以后发现，人家根本不是按照我的这种方式去计算。下面说一下正确的解题思路\"><a href=\"#于是我基于这种组合，将6-2-1-0-0-0-1-0-0-0默认为上排函数，发现n-6-计算不出下排函数。百度以后发现，人家根本不是按照我的这种方式去计算。下面说一下正确的解题思路\" class=\"headerlink\" title=\"于是我基于这种组合，将6,2,1,0,0,0,1,0,0,0默认为上排函数，发现n=6,计算不出下排函数。百度以后发现，人家根本不是按照我的这种方式去计算。下面说一下正确的解题思路.\"></a>于是我基于这种组合，将6,2,1,0,0,0,1,0,0,0默认为上排函数，发现n=6,计算不出下排函数。百度以后发现，人家根本不是按照我的这种方式去计算。下面说一下正确的解题思路.</h5><h2 id=\"解题：\"><a href=\"#解题：\" class=\"headerlink\" title=\"解题：\"></a>解题：</h2><h5 id=\"它的原型跟八皇后有点类似，都是用回溯递归的方法去一次一次尝试，直到找出正确解。\"><a href=\"#它的原型跟八皇后有点类似，都是用回溯递归的方法去一次一次尝试，直到找出正确解。\" class=\"headerlink\" title=\"它的原型跟八皇后有点类似，都是用回溯递归的方法去一次一次尝试，直到找出正确解。\"></a>它的原型跟八皇后有点类似，都是用回溯递归的方法去一次一次尝试，直到找出正确解。</h5><h5 id=\"具体的想法是：不断的去从下排数组中捉取在上排数组中对应位置中出现的个数，如果个数不对就更新下排数组中对应的值，只到找到正确值。（下排数组先初始为任意值）\"><a href=\"#具体的想法是：不断的去从下排数组中捉取在上排数组中对应位置中出现的个数，如果个数不对就更新下排数组中对应的值，只到找到正确值。（下排数组先初始为任意值）\" class=\"headerlink\" title=\"具体的想法是：不断的去从下排数组中捉取在上排数组中对应位置中出现的个数，如果个数不对就更新下排数组中对应的值，只到找到正确值。（下排数组先初始为任意值）\"></a>具体的想法是：不断的去从下排数组中捉取在上排数组中对应位置中出现的个数，如果个数不对就更新下排数组中对应的值，只到找到正确值。（下排数组先初始为任意值）</h5><h5 id=\"如：\"><a href=\"#如：\" class=\"headerlink\" title=\"如：\"></a>如：</h5><h5 id=\"上排数组A：0-1-2-3-4-5-6-7-8-9\"><a href=\"#上排数组A：0-1-2-3-4-5-6-7-8-9\" class=\"headerlink\" title=\"上排数组A：0,1,2,3,4,5,6,7,8,9\"></a>上排数组A：0,1,2,3,4,5,6,7,8,9</h5><h5 id=\"下排数组B：0-1-2-3-4-5-6-7-8-9\"><a href=\"#下排数组B：0-1-2-3-4-5-6-7-8-9\" class=\"headerlink\" title=\"下排数组B：0,1,2,3,4,5,6,7,8,9\"></a>下排数组B：0,1,2,3,4,5,6,7,8,9</h5><h5 id=\"从上牌数组Index-0开始，A-0-0，0在下排数组中的个数为1，那么下排数组B此时就要更新为：1-1-2-3-4-5-6-7-8-9\"><a href=\"#从上牌数组Index-0开始，A-0-0，0在下排数组中的个数为1，那么下排数组B此时就要更新为：1-1-2-3-4-5-6-7-8-9\" class=\"headerlink\" title=\"从上牌数组Index = 0开始，A[0] = 0，0在下排数组中的个数为1，那么下排数组B此时就要更新为：1,1,2,3,4,5,6,7,8,9\"></a>从上牌数组Index = 0开始，A[0] = 0，0在下排数组中的个数为1，那么下排数组B此时就要更新为：1,1,2,3,4,5,6,7,8,9</h5><h5 id=\"Index-1-A-1-1-1在下排数组中的个数为2，那么下排数组B此时就要更新为：1-2-2-3-4-5-6-7-8-9，从此不断的往下进行，只要找不到正确值就一直往下进行，如果Index-gt-数组长度时，那么重新恢复Index-0再往下进行测试直到找出正确解。\"><a href=\"#Index-1-A-1-1-1在下排数组中的个数为2，那么下排数组B此时就要更新为：1-2-2-3-4-5-6-7-8-9，从此不断的往下进行，只要找不到正确值就一直往下进行，如果Index-gt-数组长度时，那么重新恢复Index-0再往下进行测试直到找出正确解。\" class=\"headerlink\" title=\"Index = 1, A[1] = 1, 1在下排数组中的个数为2，那么下排数组B此时就要更新为：1,2,2,3,4,5,6,7,8,9，从此不断的往下进行，只要找不到正确值就一直往下进行，如果Index &gt;= 数组长度时，那么重新恢复Index = 0再往下进行测试直到找出正确解。\"></a>Index = 1, A[1] = 1, 1在下排数组中的个数为2，那么下排数组B此时就要更新为：1,2,2,3,4,5,6,7,8,9，从此不断的往下进行，只要找不到正确值就一直往下进行，如果Index &gt;= 数组长度时，那么重新恢复Index = 0再往下进行测试直到找出正确解。</h5><h2 id=\"最后再说一些：\"><a href=\"#最后再说一些：\" class=\"headerlink\" title=\"最后再说一些：\"></a>最后再说一些：</h2><h5 id=\"其实按照上面的这种解题思路，我的解题过程也不能算是错误的，只是排除了大部分的可能性。并且题目也理解有误，所以以后做题一定要看清楚题，理解题目的正真含义。\"><a href=\"#其实按照上面的这种解题思路，我的解题过程也不能算是错误的，只是排除了大部分的可能性。并且题目也理解有误，所以以后做题一定要看清楚题，理解题目的正真含义。\" class=\"headerlink\" title=\"其实按照上面的这种解题思路，我的解题过程也不能算是错误的，只是排除了大部分的可能性。并且题目也理解有误，所以以后做题一定要看清楚题，理解题目的正真含义。\"></a>其实按照上面的这种解题思路，我的解题过程也不能算是错误的，只是排除了大部分的可能性。并且题目也理解有误，所以以后做题一定要看清楚题，理解题目的正真含义。</h5>","site":{"data":{}},"excerpt":"<h2 id=\"题目要求：\"><a href=\"#题目要求：\" class=\"headerlink\" title=\"题目要求：\"></a>题目要求：</h2><h5 id=\"给你10分钟时间，根据上排给出十个数，在其下排填出对应的十个数-要求下排每个数都是先前上排那十个数在下排出现的次数。\"><a href=\"#给你10分钟时间，根据上排给出十个数，在其下排填出对应的十个数-要求下排每个数都是先前上排那十个数在下排出现的次数。\" class=\"headerlink\" title=\"给你10分钟时间，根据上排给出十个数，在其下排填出对应的十个数,要求下排每个数都是先前上排那十个数在下排出现的次数。\"></a>给你10分钟时间，根据上排给出十个数，在其下排填出对应的十个数,要求下排每个数都是先前上排那十个数在下排出现的次数。</h5><h5 id=\"上排的十个数如下：【0，1，2，3，4，5，6，7，8，9】\"><a href=\"#上排的十个数如下：【0，1，2，3，4，5，6，7，8，9】\" class=\"headerlink\" title=\"上排的十个数如下：【0，1，2，3，4，5，6，7，8，9】\"></a>上排的十个数如下：【0，1，2，3，4，5，6，7，8，9】</h5>","more":"<h3 id=\"举个例子，\"><a href=\"#举个例子，\" class=\"headerlink\" title=\"举个例子，\"></a>举个例子，</h3><h5 id=\"上排数值-0-1-2-3-4-5-6-7-8-9\"><a href=\"#上排数值-0-1-2-3-4-5-6-7-8-9\" class=\"headerlink\" title=\"上排数值: 0,1,2,3,4,5,6,7,8,9\"></a>上排数值: 0,1,2,3,4,5,6,7,8,9</h5><h5 id=\"下排数值-6-2-1-0-0-0-1-0-0-0\"><a href=\"#下排数值-6-2-1-0-0-0-1-0-0-0\" class=\"headerlink\" title=\"下排数值: 6,2,1,0,0,0,1,0,0,0\"></a>下排数值: 6,2,1,0,0,0,1,0,0,0</h5><h5 id=\"0在下排出现了6次，1在下排出现了2次，\"><a href=\"#0在下排出现了6次，1在下排出现了2次，\" class=\"headerlink\" title=\"0在下排出现了6次，1在下排出现了2次，\"></a>0在下排出现了6次，1在下排出现了2次，</h5><h5 id=\"2在下排出现了1次，3在下排出现了0次…\"><a href=\"#2在下排出现了1次，3在下排出现了0次…\" class=\"headerlink\" title=\"2在下排出现了1次，3在下排出现了0次…\"></a>2在下排出现了1次，3在下排出现了0次…</h5><h2 id=\"分析过程：\"><a href=\"#分析过程：\" class=\"headerlink\" title=\"分析过程：\"></a>分析过程：</h2><h5 id=\"看到题目的时候觉得有一点绕，切没有太理解题目，以为是一直循环输出下排数组，于是有了下面的解题过程。\"><a href=\"#看到题目的时候觉得有一点绕，切没有太理解题目，以为是一直循环输出下排数组，于是有了下面的解题过程。\" class=\"headerlink\" title=\"看到题目的时候觉得有一点绕，切没有太理解题目，以为是一直循环输出下排数组，于是有了下面的解题过程。\"></a>看到题目的时候觉得有一点绕，切没有太理解题目，以为是一直循环输出下排数组，于是有了下面的解题过程。</h5><h3 id=\"根据题目得到的一些条件：\"><a href=\"#根据题目得到的一些条件：\" class=\"headerlink\" title=\"根据题目得到的一些条件：\"></a>根据题目得到的一些条件：</h3><ol>\n<li>10个数，每个数都大于等于0；</li>\n<li>下排的数字为上排数字出现的次数；</li>\n<li>基于条件2，下排数字相加一定等于10；</li>\n<li>基于条件3，下排数字有0，要么下排全等于1，很明显全等于1就不符合条件2，所以下排数字一定有0；</li>\n<li>根据条件4，上排数字也有0；</li>\n</ol>\n<h4 id=\"基于上面几个条件，做出下面的一些假设：\"><a href=\"#基于上面几个条件，做出下面的一些假设：\" class=\"headerlink\" title=\"基于上面几个条件，做出下面的一些假设：\"></a>基于上面几个条件，做出下面的一些假设：</h4><h5 id=\"上排的10个数中，有n个数字为0，则非0的数有10-n：\"><a href=\"#上排的10个数中，有n个数字为0，则非0的数有10-n：\" class=\"headerlink\" title=\"上排的10个数中，有n个数字为0，则非0的数有10-n：\"></a>上排的10个数中，有n个数字为0，则非0的数有10-n：</h5><script type=\"math/tex; mode=display\">\\underbrace{0...0}_{\\text{n个0}},\\overbrace{v_1...v_i}^{\\text{10-n个非0数字}}</script><h5 id=\"如果上排为0的下排也为0，显然不符合条件2，所以0的下排数字为非0，切所有0的下排数字相等，假设为非0数x-则上排一定有一个数字为x-对应的下排数字为n：\"><a href=\"#如果上排为0的下排也为0，显然不符合条件2，所以0的下排数字为非0，切所有0的下排数字相等，假设为非0数x-则上排一定有一个数字为x-对应的下排数字为n：\" class=\"headerlink\" title=\"如果上排为0的下排也为0，显然不符合条件2，所以0的下排数字为非0，切所有0的下排数字相等，假设为非0数x,则上排一定有一个数字为x,对应的下排数字为n：\"></a>如果上排为0的下排也为0，显然不符合条件2，所以0的下排数字为非0，切所有0的下排数字相等，假设为非0数x,则上排一定有一个数字为x,对应的下排数字为n：</h5><script type=\"math/tex; mode=display\">上排：0...0,v_1...v_i,x</script><script type=\"math/tex; mode=display\">下排：\\underbrace{x...x}_{\\text{n个x}},i_1...i_i,n</script><h5 id=\"上排的0在下排为x，则说明下排有x个0-进一步得出下面的组合：\"><a href=\"#上排的0在下排为x，则说明下排有x个0-进一步得出下面的组合：\" class=\"headerlink\" title=\"上排的0在下排为x，则说明下排有x个0,进一步得出下面的组合：\"></a>上排的0在下排为x，则说明下排有x个0,进一步得出下面的组合：</h5><script type=\"math/tex; mode=display\">上排：0...0,v_1...v_i,v_j...v_k,x</script><script type=\"math/tex; mode=display\">下排：\\underbrace{x...x}_{\\text{n个x}},\\underbrace{0....0}_{\\text{x个0}},i_i....i_k,n</script><h5 id=\"根据条件1，下排一共10个数，所以：\"><a href=\"#根据条件1，下排一共10个数，所以：\" class=\"headerlink\" title=\"根据条件1，下排一共10个数，所以：\"></a>根据条件1，下排一共10个数，所以：</h5><script type=\"math/tex; mode=display\">n+x+1≤10</script><h5 id=\"根据条件3，下排数字相加等于10，所以：\"><a href=\"#根据条件3，下排数字相加等于10，所以：\" class=\"headerlink\" title=\"根据条件3，下排数字相加等于10，所以：\"></a>根据条件3，下排数字相加等于10，所以：</h5><script type=\"math/tex; mode=display\">nx+n≤10</script><h5 id=\"当vj到vk不存在，也就是个数为0时，上面两个不等式的等号成立，所以有以下两个函数：\"><a href=\"#当vj到vk不存在，也就是个数为0时，上面两个不等式的等号成立，所以有以下两个函数：\" class=\"headerlink\" title=\"当vj到vk不存在，也就是个数为0时，上面两个不等式的等号成立，所以有以下两个函数：\"></a>当v<sub>j</sub>到v<sub>k</sub>不存在，也就是个数为0时，上面两个不等式的等号成立，所以有以下两个函数：</h5><script type=\"math/tex; mode=display\">\\begin{cases}\nn+x+1=10 \\\\\\\\\nnx+n=10 \\\\\\\\\nx,n 为 正整数\n\\end{cases}\n\\implies\n\\begin{cases}\nn+x+1<10 \\\\\\\\\nnx+n<10 \\\\\\\\\nx,n 为 正整数\n\\end{cases}</script><h5 id=\"因为x，n均为正整数，所以枚举所有情况如下：\"><a href=\"#因为x，n均为正整数，所以枚举所有情况如下：\" class=\"headerlink\" title=\"因为x，n均为正整数，所以枚举所有情况如下：\"></a>因为x，n均为正整数，所以枚举所有情况如下：</h5><script type=\"math/tex; mode=display\">\nn=\\begin{cases}\n[1,2,3,4] &x=1 \\\\\\\\\n[1,2,3] &x=2 \\\\\\\\\n[1,2,] &x=3 \\\\\\\\\n[1] &x=4 \\\\\\\\\n[1] &x=5 \\\\\\\\\n[1] &x=6 \\\\\\\\\n[1] &x=7 \\\\\\\\\n[1] &x=8\n\\end{cases}</script><h5 id=\"于是我基于这种组合，将6-2-1-0-0-0-1-0-0-0默认为上排函数，发现n-6-计算不出下排函数。百度以后发现，人家根本不是按照我的这种方式去计算。下面说一下正确的解题思路\"><a href=\"#于是我基于这种组合，将6-2-1-0-0-0-1-0-0-0默认为上排函数，发现n-6-计算不出下排函数。百度以后发现，人家根本不是按照我的这种方式去计算。下面说一下正确的解题思路\" class=\"headerlink\" title=\"于是我基于这种组合，将6,2,1,0,0,0,1,0,0,0默认为上排函数，发现n=6,计算不出下排函数。百度以后发现，人家根本不是按照我的这种方式去计算。下面说一下正确的解题思路.\"></a>于是我基于这种组合，将6,2,1,0,0,0,1,0,0,0默认为上排函数，发现n=6,计算不出下排函数。百度以后发现，人家根本不是按照我的这种方式去计算。下面说一下正确的解题思路.</h5><h2 id=\"解题：\"><a href=\"#解题：\" class=\"headerlink\" title=\"解题：\"></a>解题：</h2><h5 id=\"它的原型跟八皇后有点类似，都是用回溯递归的方法去一次一次尝试，直到找出正确解。\"><a href=\"#它的原型跟八皇后有点类似，都是用回溯递归的方法去一次一次尝试，直到找出正确解。\" class=\"headerlink\" title=\"它的原型跟八皇后有点类似，都是用回溯递归的方法去一次一次尝试，直到找出正确解。\"></a>它的原型跟八皇后有点类似，都是用回溯递归的方法去一次一次尝试，直到找出正确解。</h5><h5 id=\"具体的想法是：不断的去从下排数组中捉取在上排数组中对应位置中出现的个数，如果个数不对就更新下排数组中对应的值，只到找到正确值。（下排数组先初始为任意值）\"><a href=\"#具体的想法是：不断的去从下排数组中捉取在上排数组中对应位置中出现的个数，如果个数不对就更新下排数组中对应的值，只到找到正确值。（下排数组先初始为任意值）\" class=\"headerlink\" title=\"具体的想法是：不断的去从下排数组中捉取在上排数组中对应位置中出现的个数，如果个数不对就更新下排数组中对应的值，只到找到正确值。（下排数组先初始为任意值）\"></a>具体的想法是：不断的去从下排数组中捉取在上排数组中对应位置中出现的个数，如果个数不对就更新下排数组中对应的值，只到找到正确值。（下排数组先初始为任意值）</h5><h5 id=\"如：\"><a href=\"#如：\" class=\"headerlink\" title=\"如：\"></a>如：</h5><h5 id=\"上排数组A：0-1-2-3-4-5-6-7-8-9\"><a href=\"#上排数组A：0-1-2-3-4-5-6-7-8-9\" class=\"headerlink\" title=\"上排数组A：0,1,2,3,4,5,6,7,8,9\"></a>上排数组A：0,1,2,3,4,5,6,7,8,9</h5><h5 id=\"下排数组B：0-1-2-3-4-5-6-7-8-9\"><a href=\"#下排数组B：0-1-2-3-4-5-6-7-8-9\" class=\"headerlink\" title=\"下排数组B：0,1,2,3,4,5,6,7,8,9\"></a>下排数组B：0,1,2,3,4,5,6,7,8,9</h5><h5 id=\"从上牌数组Index-0开始，A-0-0，0在下排数组中的个数为1，那么下排数组B此时就要更新为：1-1-2-3-4-5-6-7-8-9\"><a href=\"#从上牌数组Index-0开始，A-0-0，0在下排数组中的个数为1，那么下排数组B此时就要更新为：1-1-2-3-4-5-6-7-8-9\" class=\"headerlink\" title=\"从上牌数组Index = 0开始，A[0] = 0，0在下排数组中的个数为1，那么下排数组B此时就要更新为：1,1,2,3,4,5,6,7,8,9\"></a>从上牌数组Index = 0开始，A[0] = 0，0在下排数组中的个数为1，那么下排数组B此时就要更新为：1,1,2,3,4,5,6,7,8,9</h5><h5 id=\"Index-1-A-1-1-1在下排数组中的个数为2，那么下排数组B此时就要更新为：1-2-2-3-4-5-6-7-8-9，从此不断的往下进行，只要找不到正确值就一直往下进行，如果Index-gt-数组长度时，那么重新恢复Index-0再往下进行测试直到找出正确解。\"><a href=\"#Index-1-A-1-1-1在下排数组中的个数为2，那么下排数组B此时就要更新为：1-2-2-3-4-5-6-7-8-9，从此不断的往下进行，只要找不到正确值就一直往下进行，如果Index-gt-数组长度时，那么重新恢复Index-0再往下进行测试直到找出正确解。\" class=\"headerlink\" title=\"Index = 1, A[1] = 1, 1在下排数组中的个数为2，那么下排数组B此时就要更新为：1,2,2,3,4,5,6,7,8,9，从此不断的往下进行，只要找不到正确值就一直往下进行，如果Index &gt;= 数组长度时，那么重新恢复Index = 0再往下进行测试直到找出正确解。\"></a>Index = 1, A[1] = 1, 1在下排数组中的个数为2，那么下排数组B此时就要更新为：1,2,2,3,4,5,6,7,8,9，从此不断的往下进行，只要找不到正确值就一直往下进行，如果Index &gt;= 数组长度时，那么重新恢复Index = 0再往下进行测试直到找出正确解。</h5><h2 id=\"最后再说一些：\"><a href=\"#最后再说一些：\" class=\"headerlink\" title=\"最后再说一些：\"></a>最后再说一些：</h2><h5 id=\"其实按照上面的这种解题思路，我的解题过程也不能算是错误的，只是排除了大部分的可能性。并且题目也理解有误，所以以后做题一定要看清楚题，理解题目的正真含义。\"><a href=\"#其实按照上面的这种解题思路，我的解题过程也不能算是错误的，只是排除了大部分的可能性。并且题目也理解有误，所以以后做题一定要看清楚题，理解题目的正真含义。\" class=\"headerlink\" title=\"其实按照上面的这种解题思路，我的解题过程也不能算是错误的，只是排除了大部分的可能性。并且题目也理解有误，所以以后做题一定要看清楚题，理解题目的正真含义。\"></a>其实按照上面的这种解题思路，我的解题过程也不能算是错误的，只是排除了大部分的可能性。并且题目也理解有误，所以以后做题一定要看清楚题，理解题目的正真含义。</h5>"},{"layout":"post","title":"将二元查找树转变成排序的双向链表","date":"2017-02-17T16:00:00.000Z","original":true,"tag":[["算法","arithmetic"]],"_content":"\n## 题目要求：\n##### 输入一棵二元查找树，将该二元查找树转换成一个排序的双向链表。\n##### 要求不能创建任何新的结点，只调整指针的指向。\n<!--more-->\n#### 举个例子\n![二元查找树](../../img/arithmetic/BinaryTree.png)\n##### 转换成双向链表\n##### 4=6=8=10=12=14=16\n#### 首先我们定义的二元查找树 节点的数据结构如下：\n``\nstruct BSTreeNode\n{\n  int m_nValue; // value of node\n  BSTreeNode *m_pLeft;\n  BSTreeNode *m_pRight; // right child of node\n};*\n``\n\n## 分析过程：\n##### 二元查找树的特征比较明显，每个节点最多有两个子节点，分别为左节点和右节点，左节点的所有值都小于该节点，右节点的值大于该节点。这个题目其实很简单，就是实现二叉树的中序遍历。中序遍历就是左中右遍历。\n\n### 遍历过程，利用数据结构——栈实现，从根节点开始遍历\n1. 判断是否有左节点，\n　　1.1 如果有，则将该节点如栈，然后左节点重复流程1\n　　1.2 如果没有，则将本节点写入链表尾部\n　　1.3 判断是否有右节点\n　　1.4 如果有，将右节点重复流程1\n　　1.5 如果没有，执行流程2\n2. 从栈顶拿出一个节点，如果没有节点，则遍历结束\n　　2.1 将节点插入链表尾部\n　　2.2 判断节点是否有右节点\n　　2.3 有右节点，将右节点重复流程1\n　　2.4 如果没有，执行流程2\n\n#### 实例查找树的遍历过程\n##### 1.根节点10开始遍历，判断有左节点，将10压入栈中\n|&nbsp;&nbsp;|\n| --- |\n|&nbsp;10&nbsp;|\n##### 2. 将左节点6重复流程1\n|&nbsp;&nbsp;|\n| --- |\n|&nbsp;6&nbsp;|\n|&nbsp;10&nbsp;|\n##### 3. 将左节点4重复流程1，因为4没有做子节点，所以将4插入链表\n|&nbsp;&nbsp;|\n| --- |\n|&nbsp;6&nbsp;|\n|&nbsp;10&nbsp;|\n　　　链表：4\n##### 4. 4没有右节点，所以从栈顶中取出节点6进行流程2\n|&nbsp;&nbsp;|\n| --- |\n|&nbsp;10&nbsp;|\n　　　链表：4=6\n##### 5. 6的右节点8执行流程1，8没有左节点，直接加入链表\n|&nbsp;&nbsp;|\n| --- |\n|&nbsp;10&nbsp;|\n　　　链表：4=6=8\n##### 6. 8没有右节点，进入流程2，从栈顶取出\n|&nbsp;&nbsp;|\n| --- |\n|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|\n　　　链表：4=6=8=10\n##### 7. 10有右节点，10的右节点14进入流程1，14有左节点，所以压入栈中\n|&nbsp;&nbsp;|\n| --- |\n|&nbsp;14&nbsp;|\n　　　链表：4=6=8=10\n##### 8. 14的左节点12进入流程1，12没有左节点，直接插入链表\n|&nbsp;&nbsp;|\n| --- |\n|&nbsp;14&nbsp;|\n　　　链表：4=6=8=10=12\n##### 9. 12没有右节点，所以进入流程2，从栈顶中取出14并加入链表，14有右节点16，所以16进入流程1\n|&nbsp;&nbsp;|\n| --- |\n|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|\n　　　链表：4=6=8=10=12=14=16\n##### 10. 16没有右节点，进入流程2，栈中没有元素，流程结束\n　　　最终链表：4=6=8=10=12=14=16\n\n## python实现：\n```python\n#!/usr/bin/env python\n# -*- coding:utf-8 -*-\n\n\"\"\"节点属性\"\"\"\nclass BSTreeNode (object):\n\n    def __init__(self, value, left, right):\n        self.value = value\n        self.left = left\n        self.right = right\n\nclass Stack:\n    \"\"\"模拟栈\"\"\"\n    def __init__(self):\n        self.items = []\n\n    def isEmpty(self):\n        return len(self.items)==0\n\n    def push(self, item):\n        self.items.append(item)\n\n    def pop(self):\n        return self.items.pop()\n\n    def size(self):\n        return len(self.items)\nnow = 0\n\n\"\"\"链表插入节点\"\"\"\ndef __addNode(node):\n    global now\n    if now != 0:\n        now.right = node\n        node.left = now\n    now = node\n\n\"\"\"初始化查找树\"\"\"\ndef __initTree():\n    t4 = BSTreeNode(4, None, None)\n    t8 = BSTreeNode(8, None, None)\n    t6 = BSTreeNode(6, t4, t8)\n    t12 = BSTreeNode(12, None, None)\n    t16 = BSTreeNode(16, None, None)\n    t14 = BSTreeNode(14, t12, t16)\n    t10 = BSTreeNode(10, t6, t14)\n    return t10\n\nstack = Stack()\n\n\"\"\"流程1\"\"\"\ndef __sort(tree):\n    global stack\n    if tree.left != None:\n        stack.push(tree)\n        return __sort(tree.left)\n    else:\n        __addNode(tree)\n    if tree.right != None:\n        __sort(tree.right)\n    else:\n        __fromStack()\n\n\"\"\"流程2\"\"\"\ndef __fromStack():\n    global stack\n    if stack.isEmpty():\n        return\n    node = stack.pop()\n    __addNode(node)\n    if node.right != None:\n        __sort(node.right)\n    else:\n        __fromStack()\n\ndef __print():\n    global now\n    while now.left != None:\n        print now.value\n        now = now.left\n    print now\n\n\nif __name__ == \"__main__\":\n    tree = __initTree()\n    __sort(tree)\n    __print()\n```\n## 最后再说一些：\n##### 本身题目不是很难，把大学学习的数据结构拿出来看一看就明白了，完成之后我也去网络中找了找这道题，其他人也基本是用中序遍历的方法，大多只有代码，没有解题思路，所以我也没有仔细去看，默认自己是对的。这题目比较麻烦的是代码的编写上面，需要用到递归和一些数据结构的代码实现。加上我之前python用的不多，在调试代码中还是花了一些功夫的（主要在语法的学习上）。所以今后还是要多用python写一写，多熟悉一下。\n","source":"_posts/arithmetic/binaryTree.md","raw":"---\nlayout: post\ntitle: 将二元查找树转变成排序的双向链表\ndate: 2017/02/18\ntags: [tech, arithmetic, index]\noriginal: true\ntag: [[算法, arithmetic]]\n---\n\n## 题目要求：\n##### 输入一棵二元查找树，将该二元查找树转换成一个排序的双向链表。\n##### 要求不能创建任何新的结点，只调整指针的指向。\n<!--more-->\n#### 举个例子\n![二元查找树](../../img/arithmetic/BinaryTree.png)\n##### 转换成双向链表\n##### 4=6=8=10=12=14=16\n#### 首先我们定义的二元查找树 节点的数据结构如下：\n``\nstruct BSTreeNode\n{\n  int m_nValue; // value of node\n  BSTreeNode *m_pLeft;\n  BSTreeNode *m_pRight; // right child of node\n};*\n``\n\n## 分析过程：\n##### 二元查找树的特征比较明显，每个节点最多有两个子节点，分别为左节点和右节点，左节点的所有值都小于该节点，右节点的值大于该节点。这个题目其实很简单，就是实现二叉树的中序遍历。中序遍历就是左中右遍历。\n\n### 遍历过程，利用数据结构——栈实现，从根节点开始遍历\n1. 判断是否有左节点，\n　　1.1 如果有，则将该节点如栈，然后左节点重复流程1\n　　1.2 如果没有，则将本节点写入链表尾部\n　　1.3 判断是否有右节点\n　　1.4 如果有，将右节点重复流程1\n　　1.5 如果没有，执行流程2\n2. 从栈顶拿出一个节点，如果没有节点，则遍历结束\n　　2.1 将节点插入链表尾部\n　　2.2 判断节点是否有右节点\n　　2.3 有右节点，将右节点重复流程1\n　　2.4 如果没有，执行流程2\n\n#### 实例查找树的遍历过程\n##### 1.根节点10开始遍历，判断有左节点，将10压入栈中\n|&nbsp;&nbsp;|\n| --- |\n|&nbsp;10&nbsp;|\n##### 2. 将左节点6重复流程1\n|&nbsp;&nbsp;|\n| --- |\n|&nbsp;6&nbsp;|\n|&nbsp;10&nbsp;|\n##### 3. 将左节点4重复流程1，因为4没有做子节点，所以将4插入链表\n|&nbsp;&nbsp;|\n| --- |\n|&nbsp;6&nbsp;|\n|&nbsp;10&nbsp;|\n　　　链表：4\n##### 4. 4没有右节点，所以从栈顶中取出节点6进行流程2\n|&nbsp;&nbsp;|\n| --- |\n|&nbsp;10&nbsp;|\n　　　链表：4=6\n##### 5. 6的右节点8执行流程1，8没有左节点，直接加入链表\n|&nbsp;&nbsp;|\n| --- |\n|&nbsp;10&nbsp;|\n　　　链表：4=6=8\n##### 6. 8没有右节点，进入流程2，从栈顶取出\n|&nbsp;&nbsp;|\n| --- |\n|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|\n　　　链表：4=6=8=10\n##### 7. 10有右节点，10的右节点14进入流程1，14有左节点，所以压入栈中\n|&nbsp;&nbsp;|\n| --- |\n|&nbsp;14&nbsp;|\n　　　链表：4=6=8=10\n##### 8. 14的左节点12进入流程1，12没有左节点，直接插入链表\n|&nbsp;&nbsp;|\n| --- |\n|&nbsp;14&nbsp;|\n　　　链表：4=6=8=10=12\n##### 9. 12没有右节点，所以进入流程2，从栈顶中取出14并加入链表，14有右节点16，所以16进入流程1\n|&nbsp;&nbsp;|\n| --- |\n|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|\n　　　链表：4=6=8=10=12=14=16\n##### 10. 16没有右节点，进入流程2，栈中没有元素，流程结束\n　　　最终链表：4=6=8=10=12=14=16\n\n## python实现：\n```python\n#!/usr/bin/env python\n# -*- coding:utf-8 -*-\n\n\"\"\"节点属性\"\"\"\nclass BSTreeNode (object):\n\n    def __init__(self, value, left, right):\n        self.value = value\n        self.left = left\n        self.right = right\n\nclass Stack:\n    \"\"\"模拟栈\"\"\"\n    def __init__(self):\n        self.items = []\n\n    def isEmpty(self):\n        return len(self.items)==0\n\n    def push(self, item):\n        self.items.append(item)\n\n    def pop(self):\n        return self.items.pop()\n\n    def size(self):\n        return len(self.items)\nnow = 0\n\n\"\"\"链表插入节点\"\"\"\ndef __addNode(node):\n    global now\n    if now != 0:\n        now.right = node\n        node.left = now\n    now = node\n\n\"\"\"初始化查找树\"\"\"\ndef __initTree():\n    t4 = BSTreeNode(4, None, None)\n    t8 = BSTreeNode(8, None, None)\n    t6 = BSTreeNode(6, t4, t8)\n    t12 = BSTreeNode(12, None, None)\n    t16 = BSTreeNode(16, None, None)\n    t14 = BSTreeNode(14, t12, t16)\n    t10 = BSTreeNode(10, t6, t14)\n    return t10\n\nstack = Stack()\n\n\"\"\"流程1\"\"\"\ndef __sort(tree):\n    global stack\n    if tree.left != None:\n        stack.push(tree)\n        return __sort(tree.left)\n    else:\n        __addNode(tree)\n    if tree.right != None:\n        __sort(tree.right)\n    else:\n        __fromStack()\n\n\"\"\"流程2\"\"\"\ndef __fromStack():\n    global stack\n    if stack.isEmpty():\n        return\n    node = stack.pop()\n    __addNode(node)\n    if node.right != None:\n        __sort(node.right)\n    else:\n        __fromStack()\n\ndef __print():\n    global now\n    while now.left != None:\n        print now.value\n        now = now.left\n    print now\n\n\nif __name__ == \"__main__\":\n    tree = __initTree()\n    __sort(tree)\n    __print()\n```\n## 最后再说一些：\n##### 本身题目不是很难，把大学学习的数据结构拿出来看一看就明白了，完成之后我也去网络中找了找这道题，其他人也基本是用中序遍历的方法，大多只有代码，没有解题思路，所以我也没有仔细去看，默认自己是对的。这题目比较麻烦的是代码的编写上面，需要用到递归和一些数据结构的代码实现。加上我之前python用的不多，在调试代码中还是花了一些功夫的（主要在语法的学习上）。所以今后还是要多用python写一写，多熟悉一下。\n","slug":"arithmetic/binaryTree","published":1,"updated":"2017-10-06T16:03:22.640Z","comments":1,"photos":[],"link":"","_id":"cj8jros6y000530s69egc7q0b","content":"<h2 id=\"题目要求：\"><a href=\"#题目要求：\" class=\"headerlink\" title=\"题目要求：\"></a>题目要求：</h2><h5 id=\"输入一棵二元查找树，将该二元查找树转换成一个排序的双向链表。\"><a href=\"#输入一棵二元查找树，将该二元查找树转换成一个排序的双向链表。\" class=\"headerlink\" title=\"输入一棵二元查找树，将该二元查找树转换成一个排序的双向链表。\"></a>输入一棵二元查找树，将该二元查找树转换成一个排序的双向链表。</h5><h5 id=\"要求不能创建任何新的结点，只调整指针的指向。\"><a href=\"#要求不能创建任何新的结点，只调整指针的指向。\" class=\"headerlink\" title=\"要求不能创建任何新的结点，只调整指针的指向。\"></a>要求不能创建任何新的结点，只调整指针的指向。</h5><a id=\"more\"></a>\n<h4 id=\"举个例子\"><a href=\"#举个例子\" class=\"headerlink\" title=\"举个例子\"></a>举个例子</h4><p><img src=\"../../img/arithmetic/BinaryTree.png\" alt=\"二元查找树\"></p>\n<h5 id=\"转换成双向链表\"><a href=\"#转换成双向链表\" class=\"headerlink\" title=\"转换成双向链表\"></a>转换成双向链表</h5><h5 id=\"4-6-8-10-12-14-16\"><a href=\"#4-6-8-10-12-14-16\" class=\"headerlink\" title=\"4=6=8=10=12=14=16\"></a>4=6=8=10=12=14=16</h5><h4 id=\"首先我们定义的二元查找树-节点的数据结构如下：\"><a href=\"#首先我们定义的二元查找树-节点的数据结构如下：\" class=\"headerlink\" title=\"首先我们定义的二元查找树 节点的数据结构如下：\"></a>首先我们定义的二元查找树 节点的数据结构如下：</h4><p><code>struct BSTreeNode\n{\n  int m_nValue; // value of node\n  BSTreeNode *m_pLeft;\n  BSTreeNode *m_pRight; // right child of node\n};*</code></p>\n<h2 id=\"分析过程：\"><a href=\"#分析过程：\" class=\"headerlink\" title=\"分析过程：\"></a>分析过程：</h2><h5 id=\"二元查找树的特征比较明显，每个节点最多有两个子节点，分别为左节点和右节点，左节点的所有值都小于该节点，右节点的值大于该节点。这个题目其实很简单，就是实现二叉树的中序遍历。中序遍历就是左中右遍历。\"><a href=\"#二元查找树的特征比较明显，每个节点最多有两个子节点，分别为左节点和右节点，左节点的所有值都小于该节点，右节点的值大于该节点。这个题目其实很简单，就是实现二叉树的中序遍历。中序遍历就是左中右遍历。\" class=\"headerlink\" title=\"二元查找树的特征比较明显，每个节点最多有两个子节点，分别为左节点和右节点，左节点的所有值都小于该节点，右节点的值大于该节点。这个题目其实很简单，就是实现二叉树的中序遍历。中序遍历就是左中右遍历。\"></a>二元查找树的特征比较明显，每个节点最多有两个子节点，分别为左节点和右节点，左节点的所有值都小于该节点，右节点的值大于该节点。这个题目其实很简单，就是实现二叉树的中序遍历。中序遍历就是左中右遍历。</h5><h3 id=\"遍历过程，利用数据结构——栈实现，从根节点开始遍历\"><a href=\"#遍历过程，利用数据结构——栈实现，从根节点开始遍历\" class=\"headerlink\" title=\"遍历过程，利用数据结构——栈实现，从根节点开始遍历\"></a>遍历过程，利用数据结构——栈实现，从根节点开始遍历</h3><ol>\n<li>判断是否有左节点，<br>　　1.1 如果有，则将该节点如栈，然后左节点重复流程1<br>　　1.2 如果没有，则将本节点写入链表尾部<br>　　1.3 判断是否有右节点<br>　　1.4 如果有，将右节点重复流程1<br>　　1.5 如果没有，执行流程2</li>\n<li>从栈顶拿出一个节点，如果没有节点，则遍历结束<br>　　2.1 将节点插入链表尾部<br>　　2.2 判断节点是否有右节点<br>　　2.3 有右节点，将右节点重复流程1<br>　　2.4 如果没有，执行流程2</li>\n</ol>\n<h4 id=\"实例查找树的遍历过程\"><a href=\"#实例查找树的遍历过程\" class=\"headerlink\" title=\"实例查找树的遍历过程\"></a>实例查找树的遍历过程</h4><h5 id=\"1-根节点10开始遍历，判断有左节点，将10压入栈中\"><a href=\"#1-根节点10开始遍历，判断有左节点，将10压入栈中\" class=\"headerlink\" title=\"1.根节点10开始遍历，判断有左节点，将10压入栈中\"></a>1.根节点10开始遍历，判断有左节点，将10压入栈中</h5><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>&nbsp;&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>&nbsp;10&nbsp;</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h5 id=\"2-将左节点6重复流程1\"><a href=\"#2-将左节点6重复流程1\" class=\"headerlink\" title=\"2. 将左节点6重复流程1\"></a>2. 将左节点6重复流程1</h5><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>&nbsp;&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>&nbsp;6&nbsp;</td>\n</tr>\n<tr>\n<td>&nbsp;10&nbsp;</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h5 id=\"3-将左节点4重复流程1，因为4没有做子节点，所以将4插入链表\"><a href=\"#3-将左节点4重复流程1，因为4没有做子节点，所以将4插入链表\" class=\"headerlink\" title=\"3. 将左节点4重复流程1，因为4没有做子节点，所以将4插入链表\"></a>3. 将左节点4重复流程1，因为4没有做子节点，所以将4插入链表</h5><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>&nbsp;&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>&nbsp;6&nbsp;</td>\n</tr>\n<tr>\n<td>&nbsp;10&nbsp;</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>　　　链表：4</p>\n<h5 id=\"4-4没有右节点，所以从栈顶中取出节点6进行流程2\"><a href=\"#4-4没有右节点，所以从栈顶中取出节点6进行流程2\" class=\"headerlink\" title=\"4. 4没有右节点，所以从栈顶中取出节点6进行流程2\"></a>4. 4没有右节点，所以从栈顶中取出节点6进行流程2</h5><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>&nbsp;&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>&nbsp;10&nbsp;</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>　　　链表：4=6</p>\n<h5 id=\"5-6的右节点8执行流程1，8没有左节点，直接加入链表\"><a href=\"#5-6的右节点8执行流程1，8没有左节点，直接加入链表\" class=\"headerlink\" title=\"5. 6的右节点8执行流程1，8没有左节点，直接加入链表\"></a>5. 6的右节点8执行流程1，8没有左节点，直接加入链表</h5><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>&nbsp;&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>&nbsp;10&nbsp;</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>　　　链表：4=6=8</p>\n<h5 id=\"6-8没有右节点，进入流程2，从栈顶取出\"><a href=\"#6-8没有右节点，进入流程2，从栈顶取出\" class=\"headerlink\" title=\"6. 8没有右节点，进入流程2，从栈顶取出\"></a>6. 8没有右节点，进入流程2，从栈顶取出</h5><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>&nbsp;&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>　　　链表：4=6=8=10</p>\n<h5 id=\"7-10有右节点，10的右节点14进入流程1，14有左节点，所以压入栈中\"><a href=\"#7-10有右节点，10的右节点14进入流程1，14有左节点，所以压入栈中\" class=\"headerlink\" title=\"7. 10有右节点，10的右节点14进入流程1，14有左节点，所以压入栈中\"></a>7. 10有右节点，10的右节点14进入流程1，14有左节点，所以压入栈中</h5><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>&nbsp;&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>&nbsp;14&nbsp;</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>　　　链表：4=6=8=10</p>\n<h5 id=\"8-14的左节点12进入流程1，12没有左节点，直接插入链表\"><a href=\"#8-14的左节点12进入流程1，12没有左节点，直接插入链表\" class=\"headerlink\" title=\"8. 14的左节点12进入流程1，12没有左节点，直接插入链表\"></a>8. 14的左节点12进入流程1，12没有左节点，直接插入链表</h5><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>&nbsp;&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>&nbsp;14&nbsp;</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>　　　链表：4=6=8=10=12</p>\n<h5 id=\"9-12没有右节点，所以进入流程2，从栈顶中取出14并加入链表，14有右节点16，所以16进入流程1\"><a href=\"#9-12没有右节点，所以进入流程2，从栈顶中取出14并加入链表，14有右节点16，所以16进入流程1\" class=\"headerlink\" title=\"9. 12没有右节点，所以进入流程2，从栈顶中取出14并加入链表，14有右节点16，所以16进入流程1\"></a>9. 12没有右节点，所以进入流程2，从栈顶中取出14并加入链表，14有右节点16，所以16进入流程1</h5><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>&nbsp;&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>　　　链表：4=6=8=10=12=14=16</p>\n<h5 id=\"10-16没有右节点，进入流程2，栈中没有元素，流程结束\"><a href=\"#10-16没有右节点，进入流程2，栈中没有元素，流程结束\" class=\"headerlink\" title=\"10. 16没有右节点，进入流程2，栈中没有元素，流程结束\"></a>10. 16没有右节点，进入流程2，栈中没有元素，流程结束</h5><p>　　　最终链表：4=6=8=10=12=14=16</p>\n<h2 id=\"python实现：\"><a href=\"#python实现：\" class=\"headerlink\" title=\"python实现：\"></a>python实现：</h2><pre><code class=\"lang-python\">#!/usr/bin/env python\n# -*- coding:utf-8 -*-\n\n&quot;&quot;&quot;节点属性&quot;&quot;&quot;\nclass BSTreeNode (object):\n\n    def __init__(self, value, left, right):\n        self.value = value\n        self.left = left\n        self.right = right\n\nclass Stack:\n    &quot;&quot;&quot;模拟栈&quot;&quot;&quot;\n    def __init__(self):\n        self.items = []\n\n    def isEmpty(self):\n        return len(self.items)==0\n\n    def push(self, item):\n        self.items.append(item)\n\n    def pop(self):\n        return self.items.pop()\n\n    def size(self):\n        return len(self.items)\nnow = 0\n\n&quot;&quot;&quot;链表插入节点&quot;&quot;&quot;\ndef __addNode(node):\n    global now\n    if now != 0:\n        now.right = node\n        node.left = now\n    now = node\n\n&quot;&quot;&quot;初始化查找树&quot;&quot;&quot;\ndef __initTree():\n    t4 = BSTreeNode(4, None, None)\n    t8 = BSTreeNode(8, None, None)\n    t6 = BSTreeNode(6, t4, t8)\n    t12 = BSTreeNode(12, None, None)\n    t16 = BSTreeNode(16, None, None)\n    t14 = BSTreeNode(14, t12, t16)\n    t10 = BSTreeNode(10, t6, t14)\n    return t10\n\nstack = Stack()\n\n&quot;&quot;&quot;流程1&quot;&quot;&quot;\ndef __sort(tree):\n    global stack\n    if tree.left != None:\n        stack.push(tree)\n        return __sort(tree.left)\n    else:\n        __addNode(tree)\n    if tree.right != None:\n        __sort(tree.right)\n    else:\n        __fromStack()\n\n&quot;&quot;&quot;流程2&quot;&quot;&quot;\ndef __fromStack():\n    global stack\n    if stack.isEmpty():\n        return\n    node = stack.pop()\n    __addNode(node)\n    if node.right != None:\n        __sort(node.right)\n    else:\n        __fromStack()\n\ndef __print():\n    global now\n    while now.left != None:\n        print now.value\n        now = now.left\n    print now\n\n\nif __name__ == &quot;__main__&quot;:\n    tree = __initTree()\n    __sort(tree)\n    __print()\n</code></pre>\n<h2 id=\"最后再说一些：\"><a href=\"#最后再说一些：\" class=\"headerlink\" title=\"最后再说一些：\"></a>最后再说一些：</h2><h5 id=\"本身题目不是很难，把大学学习的数据结构拿出来看一看就明白了，完成之后我也去网络中找了找这道题，其他人也基本是用中序遍历的方法，大多只有代码，没有解题思路，所以我也没有仔细去看，默认自己是对的。这题目比较麻烦的是代码的编写上面，需要用到递归和一些数据结构的代码实现。加上我之前python用的不多，在调试代码中还是花了一些功夫的（主要在语法的学习上）。所以今后还是要多用python写一写，多熟悉一下。\"><a href=\"#本身题目不是很难，把大学学习的数据结构拿出来看一看就明白了，完成之后我也去网络中找了找这道题，其他人也基本是用中序遍历的方法，大多只有代码，没有解题思路，所以我也没有仔细去看，默认自己是对的。这题目比较麻烦的是代码的编写上面，需要用到递归和一些数据结构的代码实现。加上我之前python用的不多，在调试代码中还是花了一些功夫的（主要在语法的学习上）。所以今后还是要多用python写一写，多熟悉一下。\" class=\"headerlink\" title=\"本身题目不是很难，把大学学习的数据结构拿出来看一看就明白了，完成之后我也去网络中找了找这道题，其他人也基本是用中序遍历的方法，大多只有代码，没有解题思路，所以我也没有仔细去看，默认自己是对的。这题目比较麻烦的是代码的编写上面，需要用到递归和一些数据结构的代码实现。加上我之前python用的不多，在调试代码中还是花了一些功夫的（主要在语法的学习上）。所以今后还是要多用python写一写，多熟悉一下。\"></a>本身题目不是很难，把大学学习的数据结构拿出来看一看就明白了，完成之后我也去网络中找了找这道题，其他人也基本是用中序遍历的方法，大多只有代码，没有解题思路，所以我也没有仔细去看，默认自己是对的。这题目比较麻烦的是代码的编写上面，需要用到递归和一些数据结构的代码实现。加上我之前python用的不多，在调试代码中还是花了一些功夫的（主要在语法的学习上）。所以今后还是要多用python写一写，多熟悉一下。</h5>","site":{"data":{}},"excerpt":"<h2 id=\"题目要求：\"><a href=\"#题目要求：\" class=\"headerlink\" title=\"题目要求：\"></a>题目要求：</h2><h5 id=\"输入一棵二元查找树，将该二元查找树转换成一个排序的双向链表。\"><a href=\"#输入一棵二元查找树，将该二元查找树转换成一个排序的双向链表。\" class=\"headerlink\" title=\"输入一棵二元查找树，将该二元查找树转换成一个排序的双向链表。\"></a>输入一棵二元查找树，将该二元查找树转换成一个排序的双向链表。</h5><h5 id=\"要求不能创建任何新的结点，只调整指针的指向。\"><a href=\"#要求不能创建任何新的结点，只调整指针的指向。\" class=\"headerlink\" title=\"要求不能创建任何新的结点，只调整指针的指向。\"></a>要求不能创建任何新的结点，只调整指针的指向。</h5>","more":"<h4 id=\"举个例子\"><a href=\"#举个例子\" class=\"headerlink\" title=\"举个例子\"></a>举个例子</h4><p><img src=\"../../img/arithmetic/BinaryTree.png\" alt=\"二元查找树\"></p>\n<h5 id=\"转换成双向链表\"><a href=\"#转换成双向链表\" class=\"headerlink\" title=\"转换成双向链表\"></a>转换成双向链表</h5><h5 id=\"4-6-8-10-12-14-16\"><a href=\"#4-6-8-10-12-14-16\" class=\"headerlink\" title=\"4=6=8=10=12=14=16\"></a>4=6=8=10=12=14=16</h5><h4 id=\"首先我们定义的二元查找树-节点的数据结构如下：\"><a href=\"#首先我们定义的二元查找树-节点的数据结构如下：\" class=\"headerlink\" title=\"首先我们定义的二元查找树 节点的数据结构如下：\"></a>首先我们定义的二元查找树 节点的数据结构如下：</h4><p><code>struct BSTreeNode\n{\n  int m_nValue; // value of node\n  BSTreeNode *m_pLeft;\n  BSTreeNode *m_pRight; // right child of node\n};*</code></p>\n<h2 id=\"分析过程：\"><a href=\"#分析过程：\" class=\"headerlink\" title=\"分析过程：\"></a>分析过程：</h2><h5 id=\"二元查找树的特征比较明显，每个节点最多有两个子节点，分别为左节点和右节点，左节点的所有值都小于该节点，右节点的值大于该节点。这个题目其实很简单，就是实现二叉树的中序遍历。中序遍历就是左中右遍历。\"><a href=\"#二元查找树的特征比较明显，每个节点最多有两个子节点，分别为左节点和右节点，左节点的所有值都小于该节点，右节点的值大于该节点。这个题目其实很简单，就是实现二叉树的中序遍历。中序遍历就是左中右遍历。\" class=\"headerlink\" title=\"二元查找树的特征比较明显，每个节点最多有两个子节点，分别为左节点和右节点，左节点的所有值都小于该节点，右节点的值大于该节点。这个题目其实很简单，就是实现二叉树的中序遍历。中序遍历就是左中右遍历。\"></a>二元查找树的特征比较明显，每个节点最多有两个子节点，分别为左节点和右节点，左节点的所有值都小于该节点，右节点的值大于该节点。这个题目其实很简单，就是实现二叉树的中序遍历。中序遍历就是左中右遍历。</h5><h3 id=\"遍历过程，利用数据结构——栈实现，从根节点开始遍历\"><a href=\"#遍历过程，利用数据结构——栈实现，从根节点开始遍历\" class=\"headerlink\" title=\"遍历过程，利用数据结构——栈实现，从根节点开始遍历\"></a>遍历过程，利用数据结构——栈实现，从根节点开始遍历</h3><ol>\n<li>判断是否有左节点，<br>　　1.1 如果有，则将该节点如栈，然后左节点重复流程1<br>　　1.2 如果没有，则将本节点写入链表尾部<br>　　1.3 判断是否有右节点<br>　　1.4 如果有，将右节点重复流程1<br>　　1.5 如果没有，执行流程2</li>\n<li>从栈顶拿出一个节点，如果没有节点，则遍历结束<br>　　2.1 将节点插入链表尾部<br>　　2.2 判断节点是否有右节点<br>　　2.3 有右节点，将右节点重复流程1<br>　　2.4 如果没有，执行流程2</li>\n</ol>\n<h4 id=\"实例查找树的遍历过程\"><a href=\"#实例查找树的遍历过程\" class=\"headerlink\" title=\"实例查找树的遍历过程\"></a>实例查找树的遍历过程</h4><h5 id=\"1-根节点10开始遍历，判断有左节点，将10压入栈中\"><a href=\"#1-根节点10开始遍历，判断有左节点，将10压入栈中\" class=\"headerlink\" title=\"1.根节点10开始遍历，判断有左节点，将10压入栈中\"></a>1.根节点10开始遍历，判断有左节点，将10压入栈中</h5><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>&nbsp;&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>&nbsp;10&nbsp;</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h5 id=\"2-将左节点6重复流程1\"><a href=\"#2-将左节点6重复流程1\" class=\"headerlink\" title=\"2. 将左节点6重复流程1\"></a>2. 将左节点6重复流程1</h5><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>&nbsp;&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>&nbsp;6&nbsp;</td>\n</tr>\n<tr>\n<td>&nbsp;10&nbsp;</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h5 id=\"3-将左节点4重复流程1，因为4没有做子节点，所以将4插入链表\"><a href=\"#3-将左节点4重复流程1，因为4没有做子节点，所以将4插入链表\" class=\"headerlink\" title=\"3. 将左节点4重复流程1，因为4没有做子节点，所以将4插入链表\"></a>3. 将左节点4重复流程1，因为4没有做子节点，所以将4插入链表</h5><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>&nbsp;&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>&nbsp;6&nbsp;</td>\n</tr>\n<tr>\n<td>&nbsp;10&nbsp;</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>　　　链表：4</p>\n<h5 id=\"4-4没有右节点，所以从栈顶中取出节点6进行流程2\"><a href=\"#4-4没有右节点，所以从栈顶中取出节点6进行流程2\" class=\"headerlink\" title=\"4. 4没有右节点，所以从栈顶中取出节点6进行流程2\"></a>4. 4没有右节点，所以从栈顶中取出节点6进行流程2</h5><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>&nbsp;&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>&nbsp;10&nbsp;</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>　　　链表：4=6</p>\n<h5 id=\"5-6的右节点8执行流程1，8没有左节点，直接加入链表\"><a href=\"#5-6的右节点8执行流程1，8没有左节点，直接加入链表\" class=\"headerlink\" title=\"5. 6的右节点8执行流程1，8没有左节点，直接加入链表\"></a>5. 6的右节点8执行流程1，8没有左节点，直接加入链表</h5><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>&nbsp;&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>&nbsp;10&nbsp;</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>　　　链表：4=6=8</p>\n<h5 id=\"6-8没有右节点，进入流程2，从栈顶取出\"><a href=\"#6-8没有右节点，进入流程2，从栈顶取出\" class=\"headerlink\" title=\"6. 8没有右节点，进入流程2，从栈顶取出\"></a>6. 8没有右节点，进入流程2，从栈顶取出</h5><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>&nbsp;&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>　　　链表：4=6=8=10</p>\n<h5 id=\"7-10有右节点，10的右节点14进入流程1，14有左节点，所以压入栈中\"><a href=\"#7-10有右节点，10的右节点14进入流程1，14有左节点，所以压入栈中\" class=\"headerlink\" title=\"7. 10有右节点，10的右节点14进入流程1，14有左节点，所以压入栈中\"></a>7. 10有右节点，10的右节点14进入流程1，14有左节点，所以压入栈中</h5><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>&nbsp;&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>&nbsp;14&nbsp;</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>　　　链表：4=6=8=10</p>\n<h5 id=\"8-14的左节点12进入流程1，12没有左节点，直接插入链表\"><a href=\"#8-14的左节点12进入流程1，12没有左节点，直接插入链表\" class=\"headerlink\" title=\"8. 14的左节点12进入流程1，12没有左节点，直接插入链表\"></a>8. 14的左节点12进入流程1，12没有左节点，直接插入链表</h5><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>&nbsp;&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>&nbsp;14&nbsp;</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>　　　链表：4=6=8=10=12</p>\n<h5 id=\"9-12没有右节点，所以进入流程2，从栈顶中取出14并加入链表，14有右节点16，所以16进入流程1\"><a href=\"#9-12没有右节点，所以进入流程2，从栈顶中取出14并加入链表，14有右节点16，所以16进入流程1\" class=\"headerlink\" title=\"9. 12没有右节点，所以进入流程2，从栈顶中取出14并加入链表，14有右节点16，所以16进入流程1\"></a>9. 12没有右节点，所以进入流程2，从栈顶中取出14并加入链表，14有右节点16，所以16进入流程1</h5><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>&nbsp;&nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>　　　链表：4=6=8=10=12=14=16</p>\n<h5 id=\"10-16没有右节点，进入流程2，栈中没有元素，流程结束\"><a href=\"#10-16没有右节点，进入流程2，栈中没有元素，流程结束\" class=\"headerlink\" title=\"10. 16没有右节点，进入流程2，栈中没有元素，流程结束\"></a>10. 16没有右节点，进入流程2，栈中没有元素，流程结束</h5><p>　　　最终链表：4=6=8=10=12=14=16</p>\n<h2 id=\"python实现：\"><a href=\"#python实现：\" class=\"headerlink\" title=\"python实现：\"></a>python实现：</h2><pre><code class=\"lang-python\">#!/usr/bin/env python\n# -*- coding:utf-8 -*-\n\n&quot;&quot;&quot;节点属性&quot;&quot;&quot;\nclass BSTreeNode (object):\n\n    def __init__(self, value, left, right):\n        self.value = value\n        self.left = left\n        self.right = right\n\nclass Stack:\n    &quot;&quot;&quot;模拟栈&quot;&quot;&quot;\n    def __init__(self):\n        self.items = []\n\n    def isEmpty(self):\n        return len(self.items)==0\n\n    def push(self, item):\n        self.items.append(item)\n\n    def pop(self):\n        return self.items.pop()\n\n    def size(self):\n        return len(self.items)\nnow = 0\n\n&quot;&quot;&quot;链表插入节点&quot;&quot;&quot;\ndef __addNode(node):\n    global now\n    if now != 0:\n        now.right = node\n        node.left = now\n    now = node\n\n&quot;&quot;&quot;初始化查找树&quot;&quot;&quot;\ndef __initTree():\n    t4 = BSTreeNode(4, None, None)\n    t8 = BSTreeNode(8, None, None)\n    t6 = BSTreeNode(6, t4, t8)\n    t12 = BSTreeNode(12, None, None)\n    t16 = BSTreeNode(16, None, None)\n    t14 = BSTreeNode(14, t12, t16)\n    t10 = BSTreeNode(10, t6, t14)\n    return t10\n\nstack = Stack()\n\n&quot;&quot;&quot;流程1&quot;&quot;&quot;\ndef __sort(tree):\n    global stack\n    if tree.left != None:\n        stack.push(tree)\n        return __sort(tree.left)\n    else:\n        __addNode(tree)\n    if tree.right != None:\n        __sort(tree.right)\n    else:\n        __fromStack()\n\n&quot;&quot;&quot;流程2&quot;&quot;&quot;\ndef __fromStack():\n    global stack\n    if stack.isEmpty():\n        return\n    node = stack.pop()\n    __addNode(node)\n    if node.right != None:\n        __sort(node.right)\n    else:\n        __fromStack()\n\ndef __print():\n    global now\n    while now.left != None:\n        print now.value\n        now = now.left\n    print now\n\n\nif __name__ == &quot;__main__&quot;:\n    tree = __initTree()\n    __sort(tree)\n    __print()\n</code></pre>\n<h2 id=\"最后再说一些：\"><a href=\"#最后再说一些：\" class=\"headerlink\" title=\"最后再说一些：\"></a>最后再说一些：</h2><h5 id=\"本身题目不是很难，把大学学习的数据结构拿出来看一看就明白了，完成之后我也去网络中找了找这道题，其他人也基本是用中序遍历的方法，大多只有代码，没有解题思路，所以我也没有仔细去看，默认自己是对的。这题目比较麻烦的是代码的编写上面，需要用到递归和一些数据结构的代码实现。加上我之前python用的不多，在调试代码中还是花了一些功夫的（主要在语法的学习上）。所以今后还是要多用python写一写，多熟悉一下。\"><a href=\"#本身题目不是很难，把大学学习的数据结构拿出来看一看就明白了，完成之后我也去网络中找了找这道题，其他人也基本是用中序遍历的方法，大多只有代码，没有解题思路，所以我也没有仔细去看，默认自己是对的。这题目比较麻烦的是代码的编写上面，需要用到递归和一些数据结构的代码实现。加上我之前python用的不多，在调试代码中还是花了一些功夫的（主要在语法的学习上）。所以今后还是要多用python写一写，多熟悉一下。\" class=\"headerlink\" title=\"本身题目不是很难，把大学学习的数据结构拿出来看一看就明白了，完成之后我也去网络中找了找这道题，其他人也基本是用中序遍历的方法，大多只有代码，没有解题思路，所以我也没有仔细去看，默认自己是对的。这题目比较麻烦的是代码的编写上面，需要用到递归和一些数据结构的代码实现。加上我之前python用的不多，在调试代码中还是花了一些功夫的（主要在语法的学习上）。所以今后还是要多用python写一写，多熟悉一下。\"></a>本身题目不是很难，把大学学习的数据结构拿出来看一看就明白了，完成之后我也去网络中找了找这道题，其他人也基本是用中序遍历的方法，大多只有代码，没有解题思路，所以我也没有仔细去看，默认自己是对的。这题目比较麻烦的是代码的编写上面，需要用到递归和一些数据结构的代码实现。加上我之前python用的不多，在调试代码中还是花了一些功夫的（主要在语法的学习上）。所以今后还是要多用python写一写，多熟悉一下。</h5>"},{"layout":"post","title":"切金条","date":"2017-02-22T16:00:00.000Z","original":true,"tag":[["算法","arithmetic"]],"_content":"\n## 题目要求：\n##### 你让一些人为你工作了七天，你要用一根金条作为报酬。金条被分成七小块，每天给出一块。如果你只能将金条切割两次，你怎样分给这些工人?\n<!--more-->\n\n## 分析过程：\n##### 这道题目一看就知道要按照二进制的方式去分割，因为切分的块数比较少，所以后面几次的报酬一定是需要将之前的报酬拿回才能做到的。\n##### 所以按照题目要求切割两次，要么把金条分成三份，要么分成四份（第二次两块叠在一起）。所以前三块部分一定是按照1：2：4来分，因为加起来已经等于7了，所以只需要分成三分就够了。这道题目就这么简单。\n\n##### 这让我想到了另外一道题，将1000个球，放在10个箱子里。需要达到一种效果，就是任取1至1000的数字，能够从10个箱子中取出n个箱子，这n个箱子里面的球加起来刚好等于这个数字。这题和上面那题其实是一样的，没接触过一些算法的人会觉得特别难喝复杂，稍微认真想一想的童鞋也可以通过下面的方式得出答案：\n#### 首先是取一个球的时候：\n##### 所以一定有一个箱子里面是1个球。\n#### 取两个球：\n##### 前面那个箱子里是1个球，当需要两个球的时候，再添加一个一个球的箱子明显是不理智的，所以再拿一个箱子放两个球。\n#### 三个球：\n##### 前面两个箱子加起来刚好就是三个球，所以这种情况就已经包含在前面的答案里面了。\n#### 四个球呢：\n##### 之前两个箱子加起来才3个球，所以再拿一个箱子放4个球。\n#### 五个球，六个球，七个球之后的所有情况都按照这种逻辑推演下去，就可以得出答案\n##### 按照1、2、4、8、16...这种规律放球，就能够做到题目的要求。切2<sup>10</sup> = 1024,所以10个箱子是能够支持这种放球的方式的。\n\n## 为什么这组数字这么神奇\n##### 1、2、4、8、16 可以组合成1到31之间的任意一个数，为什么会这么神奇。\n##### 任何一个10进制数都可以转换成相应的二进制数。\n$$8\\qquad4\\qquad\\quad2\\qquad1$$\n$$1000\\quad0100\\quad0010\\quad0001$$\n\n##### 所以4位的2进制每一位转换成10进制分别是8、4、2、1。就好像4位的10进制每一位分别表示为千、百、十、个。但是你要是说把9999个球放到4个箱子里，任取一个数都能拿出n个箱子，加起来刚好是这个数。但是按照二进制的方法，4位二进制转换成10进制最多为15，所以15个球是能够实现这种规律的。\n##### 能够达到这种神奇效果，是因为和二进制的特征有关，二进制只有0和1两个数字，这就表示二进制的每一位只有两种状态。我们可以简单的分为有（1）和没有（0）。所以4位的二进制，放到4个箱子里面，每个箱子分别放入对应的二进制位数表示的数，然后拿箱子表示为1，不拿表示为0，其实组合出来的结果就是一个二进制的数。而十进制的每一位则有10种状态之多，一个箱子要产生10种状态，以拿到不同的球数，在这道题里面是不存在的。\n\n## 题外话\n##### 其实计算机的计算依赖于二进制也和此有关，因为以前的计算机对信号的读取和产生并没有那么灵敏，它只能识别有或者没有，转换成二进制就是1和0，如果以16进制为基础，则需要区分信号的强弱，这对以前的系统灵敏度来说是比较难的。（意淫一下，如果现在重新以16进制为基础编写计算机底层，计算效率和传输效率是不是有质的飞越呢）。\n","source":"_posts/arithmetic/glodBars.md","raw":"---\nlayout: post\ntitle: 切金条\ndate: 2017/02/23\ntags: [tech, arithmetic, index]\noriginal: true\ntag: [[算法, arithmetic]]\n---\n\n## 题目要求：\n##### 你让一些人为你工作了七天，你要用一根金条作为报酬。金条被分成七小块，每天给出一块。如果你只能将金条切割两次，你怎样分给这些工人?\n<!--more-->\n\n## 分析过程：\n##### 这道题目一看就知道要按照二进制的方式去分割，因为切分的块数比较少，所以后面几次的报酬一定是需要将之前的报酬拿回才能做到的。\n##### 所以按照题目要求切割两次，要么把金条分成三份，要么分成四份（第二次两块叠在一起）。所以前三块部分一定是按照1：2：4来分，因为加起来已经等于7了，所以只需要分成三分就够了。这道题目就这么简单。\n\n##### 这让我想到了另外一道题，将1000个球，放在10个箱子里。需要达到一种效果，就是任取1至1000的数字，能够从10个箱子中取出n个箱子，这n个箱子里面的球加起来刚好等于这个数字。这题和上面那题其实是一样的，没接触过一些算法的人会觉得特别难喝复杂，稍微认真想一想的童鞋也可以通过下面的方式得出答案：\n#### 首先是取一个球的时候：\n##### 所以一定有一个箱子里面是1个球。\n#### 取两个球：\n##### 前面那个箱子里是1个球，当需要两个球的时候，再添加一个一个球的箱子明显是不理智的，所以再拿一个箱子放两个球。\n#### 三个球：\n##### 前面两个箱子加起来刚好就是三个球，所以这种情况就已经包含在前面的答案里面了。\n#### 四个球呢：\n##### 之前两个箱子加起来才3个球，所以再拿一个箱子放4个球。\n#### 五个球，六个球，七个球之后的所有情况都按照这种逻辑推演下去，就可以得出答案\n##### 按照1、2、4、8、16...这种规律放球，就能够做到题目的要求。切2<sup>10</sup> = 1024,所以10个箱子是能够支持这种放球的方式的。\n\n## 为什么这组数字这么神奇\n##### 1、2、4、8、16 可以组合成1到31之间的任意一个数，为什么会这么神奇。\n##### 任何一个10进制数都可以转换成相应的二进制数。\n$$8\\qquad4\\qquad\\quad2\\qquad1$$\n$$1000\\quad0100\\quad0010\\quad0001$$\n\n##### 所以4位的2进制每一位转换成10进制分别是8、4、2、1。就好像4位的10进制每一位分别表示为千、百、十、个。但是你要是说把9999个球放到4个箱子里，任取一个数都能拿出n个箱子，加起来刚好是这个数。但是按照二进制的方法，4位二进制转换成10进制最多为15，所以15个球是能够实现这种规律的。\n##### 能够达到这种神奇效果，是因为和二进制的特征有关，二进制只有0和1两个数字，这就表示二进制的每一位只有两种状态。我们可以简单的分为有（1）和没有（0）。所以4位的二进制，放到4个箱子里面，每个箱子分别放入对应的二进制位数表示的数，然后拿箱子表示为1，不拿表示为0，其实组合出来的结果就是一个二进制的数。而十进制的每一位则有10种状态之多，一个箱子要产生10种状态，以拿到不同的球数，在这道题里面是不存在的。\n\n## 题外话\n##### 其实计算机的计算依赖于二进制也和此有关，因为以前的计算机对信号的读取和产生并没有那么灵敏，它只能识别有或者没有，转换成二进制就是1和0，如果以16进制为基础，则需要区分信号的强弱，这对以前的系统灵敏度来说是比较难的。（意淫一下，如果现在重新以16进制为基础编写计算机底层，计算效率和传输效率是不是有质的飞越呢）。\n","slug":"arithmetic/glodBars","published":1,"updated":"2017-10-06T16:03:22.637Z","comments":1,"photos":[],"link":"","_id":"cj8jros6z000730s6dss3ly4l","content":"<h2 id=\"题目要求：\"><a href=\"#题目要求：\" class=\"headerlink\" title=\"题目要求：\"></a>题目要求：</h2><h5 id=\"你让一些人为你工作了七天，你要用一根金条作为报酬。金条被分成七小块，每天给出一块。如果你只能将金条切割两次，你怎样分给这些工人\"><a href=\"#你让一些人为你工作了七天，你要用一根金条作为报酬。金条被分成七小块，每天给出一块。如果你只能将金条切割两次，你怎样分给这些工人\" class=\"headerlink\" title=\"你让一些人为你工作了七天，你要用一根金条作为报酬。金条被分成七小块，每天给出一块。如果你只能将金条切割两次，你怎样分给这些工人?\"></a>你让一些人为你工作了七天，你要用一根金条作为报酬。金条被分成七小块，每天给出一块。如果你只能将金条切割两次，你怎样分给这些工人?</h5><a id=\"more\"></a>\n<h2 id=\"分析过程：\"><a href=\"#分析过程：\" class=\"headerlink\" title=\"分析过程：\"></a>分析过程：</h2><h5 id=\"这道题目一看就知道要按照二进制的方式去分割，因为切分的块数比较少，所以后面几次的报酬一定是需要将之前的报酬拿回才能做到的。\"><a href=\"#这道题目一看就知道要按照二进制的方式去分割，因为切分的块数比较少，所以后面几次的报酬一定是需要将之前的报酬拿回才能做到的。\" class=\"headerlink\" title=\"这道题目一看就知道要按照二进制的方式去分割，因为切分的块数比较少，所以后面几次的报酬一定是需要将之前的报酬拿回才能做到的。\"></a>这道题目一看就知道要按照二进制的方式去分割，因为切分的块数比较少，所以后面几次的报酬一定是需要将之前的报酬拿回才能做到的。</h5><h5 id=\"所以按照题目要求切割两次，要么把金条分成三份，要么分成四份（第二次两块叠在一起）。所以前三块部分一定是按照1：2：4来分，因为加起来已经等于7了，所以只需要分成三分就够了。这道题目就这么简单。\"><a href=\"#所以按照题目要求切割两次，要么把金条分成三份，要么分成四份（第二次两块叠在一起）。所以前三块部分一定是按照1：2：4来分，因为加起来已经等于7了，所以只需要分成三分就够了。这道题目就这么简单。\" class=\"headerlink\" title=\"所以按照题目要求切割两次，要么把金条分成三份，要么分成四份（第二次两块叠在一起）。所以前三块部分一定是按照1：2：4来分，因为加起来已经等于7了，所以只需要分成三分就够了。这道题目就这么简单。\"></a>所以按照题目要求切割两次，要么把金条分成三份，要么分成四份（第二次两块叠在一起）。所以前三块部分一定是按照1：2：4来分，因为加起来已经等于7了，所以只需要分成三分就够了。这道题目就这么简单。</h5><h5 id=\"这让我想到了另外一道题，将1000个球，放在10个箱子里。需要达到一种效果，就是任取1至1000的数字，能够从10个箱子中取出n个箱子，这n个箱子里面的球加起来刚好等于这个数字。这题和上面那题其实是一样的，没接触过一些算法的人会觉得特别难喝复杂，稍微认真想一想的童鞋也可以通过下面的方式得出答案：\"><a href=\"#这让我想到了另外一道题，将1000个球，放在10个箱子里。需要达到一种效果，就是任取1至1000的数字，能够从10个箱子中取出n个箱子，这n个箱子里面的球加起来刚好等于这个数字。这题和上面那题其实是一样的，没接触过一些算法的人会觉得特别难喝复杂，稍微认真想一想的童鞋也可以通过下面的方式得出答案：\" class=\"headerlink\" title=\"这让我想到了另外一道题，将1000个球，放在10个箱子里。需要达到一种效果，就是任取1至1000的数字，能够从10个箱子中取出n个箱子，这n个箱子里面的球加起来刚好等于这个数字。这题和上面那题其实是一样的，没接触过一些算法的人会觉得特别难喝复杂，稍微认真想一想的童鞋也可以通过下面的方式得出答案：\"></a>这让我想到了另外一道题，将1000个球，放在10个箱子里。需要达到一种效果，就是任取1至1000的数字，能够从10个箱子中取出n个箱子，这n个箱子里面的球加起来刚好等于这个数字。这题和上面那题其实是一样的，没接触过一些算法的人会觉得特别难喝复杂，稍微认真想一想的童鞋也可以通过下面的方式得出答案：</h5><h4 id=\"首先是取一个球的时候：\"><a href=\"#首先是取一个球的时候：\" class=\"headerlink\" title=\"首先是取一个球的时候：\"></a>首先是取一个球的时候：</h4><h5 id=\"所以一定有一个箱子里面是1个球。\"><a href=\"#所以一定有一个箱子里面是1个球。\" class=\"headerlink\" title=\"所以一定有一个箱子里面是1个球。\"></a>所以一定有一个箱子里面是1个球。</h5><h4 id=\"取两个球：\"><a href=\"#取两个球：\" class=\"headerlink\" title=\"取两个球：\"></a>取两个球：</h4><h5 id=\"前面那个箱子里是1个球，当需要两个球的时候，再添加一个一个球的箱子明显是不理智的，所以再拿一个箱子放两个球。\"><a href=\"#前面那个箱子里是1个球，当需要两个球的时候，再添加一个一个球的箱子明显是不理智的，所以再拿一个箱子放两个球。\" class=\"headerlink\" title=\"前面那个箱子里是1个球，当需要两个球的时候，再添加一个一个球的箱子明显是不理智的，所以再拿一个箱子放两个球。\"></a>前面那个箱子里是1个球，当需要两个球的时候，再添加一个一个球的箱子明显是不理智的，所以再拿一个箱子放两个球。</h5><h4 id=\"三个球：\"><a href=\"#三个球：\" class=\"headerlink\" title=\"三个球：\"></a>三个球：</h4><h5 id=\"前面两个箱子加起来刚好就是三个球，所以这种情况就已经包含在前面的答案里面了。\"><a href=\"#前面两个箱子加起来刚好就是三个球，所以这种情况就已经包含在前面的答案里面了。\" class=\"headerlink\" title=\"前面两个箱子加起来刚好就是三个球，所以这种情况就已经包含在前面的答案里面了。\"></a>前面两个箱子加起来刚好就是三个球，所以这种情况就已经包含在前面的答案里面了。</h5><h4 id=\"四个球呢：\"><a href=\"#四个球呢：\" class=\"headerlink\" title=\"四个球呢：\"></a>四个球呢：</h4><h5 id=\"之前两个箱子加起来才3个球，所以再拿一个箱子放4个球。\"><a href=\"#之前两个箱子加起来才3个球，所以再拿一个箱子放4个球。\" class=\"headerlink\" title=\"之前两个箱子加起来才3个球，所以再拿一个箱子放4个球。\"></a>之前两个箱子加起来才3个球，所以再拿一个箱子放4个球。</h5><h4 id=\"五个球，六个球，七个球之后的所有情况都按照这种逻辑推演下去，就可以得出答案\"><a href=\"#五个球，六个球，七个球之后的所有情况都按照这种逻辑推演下去，就可以得出答案\" class=\"headerlink\" title=\"五个球，六个球，七个球之后的所有情况都按照这种逻辑推演下去，就可以得出答案\"></a>五个球，六个球，七个球之后的所有情况都按照这种逻辑推演下去，就可以得出答案</h4><h5 id=\"按照1、2、4、8、16…这种规律放球，就能够做到题目的要求。切210-1024-所以10个箱子是能够支持这种放球的方式的。\"><a href=\"#按照1、2、4、8、16…这种规律放球，就能够做到题目的要求。切210-1024-所以10个箱子是能够支持这种放球的方式的。\" class=\"headerlink\" title=\"按照1、2、4、8、16…这种规律放球，就能够做到题目的要求。切210 = 1024,所以10个箱子是能够支持这种放球的方式的。\"></a>按照1、2、4、8、16…这种规律放球，就能够做到题目的要求。切2<sup>10</sup> = 1024,所以10个箱子是能够支持这种放球的方式的。</h5><h2 id=\"为什么这组数字这么神奇\"><a href=\"#为什么这组数字这么神奇\" class=\"headerlink\" title=\"为什么这组数字这么神奇\"></a>为什么这组数字这么神奇</h2><h5 id=\"1、2、4、8、16-可以组合成1到31之间的任意一个数，为什么会这么神奇。\"><a href=\"#1、2、4、8、16-可以组合成1到31之间的任意一个数，为什么会这么神奇。\" class=\"headerlink\" title=\"1、2、4、8、16 可以组合成1到31之间的任意一个数，为什么会这么神奇。\"></a>1、2、4、8、16 可以组合成1到31之间的任意一个数，为什么会这么神奇。</h5><h5 id=\"任何一个10进制数都可以转换成相应的二进制数。\"><a href=\"#任何一个10进制数都可以转换成相应的二进制数。\" class=\"headerlink\" title=\"任何一个10进制数都可以转换成相应的二进制数。\"></a>任何一个10进制数都可以转换成相应的二进制数。</h5><script type=\"math/tex; mode=display\">8\\qquad4\\qquad\\quad2\\qquad1</script><script type=\"math/tex; mode=display\">1000\\quad0100\\quad0010\\quad0001</script><h5 id=\"所以4位的2进制每一位转换成10进制分别是8、4、2、1。就好像4位的10进制每一位分别表示为千、百、十、个。但是你要是说把9999个球放到4个箱子里，任取一个数都能拿出n个箱子，加起来刚好是这个数。但是按照二进制的方法，4位二进制转换成10进制最多为15，所以15个球是能够实现这种规律的。\"><a href=\"#所以4位的2进制每一位转换成10进制分别是8、4、2、1。就好像4位的10进制每一位分别表示为千、百、十、个。但是你要是说把9999个球放到4个箱子里，任取一个数都能拿出n个箱子，加起来刚好是这个数。但是按照二进制的方法，4位二进制转换成10进制最多为15，所以15个球是能够实现这种规律的。\" class=\"headerlink\" title=\"所以4位的2进制每一位转换成10进制分别是8、4、2、1。就好像4位的10进制每一位分别表示为千、百、十、个。但是你要是说把9999个球放到4个箱子里，任取一个数都能拿出n个箱子，加起来刚好是这个数。但是按照二进制的方法，4位二进制转换成10进制最多为15，所以15个球是能够实现这种规律的。\"></a>所以4位的2进制每一位转换成10进制分别是8、4、2、1。就好像4位的10进制每一位分别表示为千、百、十、个。但是你要是说把9999个球放到4个箱子里，任取一个数都能拿出n个箱子，加起来刚好是这个数。但是按照二进制的方法，4位二进制转换成10进制最多为15，所以15个球是能够实现这种规律的。</h5><h5 id=\"能够达到这种神奇效果，是因为和二进制的特征有关，二进制只有0和1两个数字，这就表示二进制的每一位只有两种状态。我们可以简单的分为有（1）和没有（0）。所以4位的二进制，放到4个箱子里面，每个箱子分别放入对应的二进制位数表示的数，然后拿箱子表示为1，不拿表示为0，其实组合出来的结果就是一个二进制的数。而十进制的每一位则有10种状态之多，一个箱子要产生10种状态，以拿到不同的球数，在这道题里面是不存在的。\"><a href=\"#能够达到这种神奇效果，是因为和二进制的特征有关，二进制只有0和1两个数字，这就表示二进制的每一位只有两种状态。我们可以简单的分为有（1）和没有（0）。所以4位的二进制，放到4个箱子里面，每个箱子分别放入对应的二进制位数表示的数，然后拿箱子表示为1，不拿表示为0，其实组合出来的结果就是一个二进制的数。而十进制的每一位则有10种状态之多，一个箱子要产生10种状态，以拿到不同的球数，在这道题里面是不存在的。\" class=\"headerlink\" title=\"能够达到这种神奇效果，是因为和二进制的特征有关，二进制只有0和1两个数字，这就表示二进制的每一位只有两种状态。我们可以简单的分为有（1）和没有（0）。所以4位的二进制，放到4个箱子里面，每个箱子分别放入对应的二进制位数表示的数，然后拿箱子表示为1，不拿表示为0，其实组合出来的结果就是一个二进制的数。而十进制的每一位则有10种状态之多，一个箱子要产生10种状态，以拿到不同的球数，在这道题里面是不存在的。\"></a>能够达到这种神奇效果，是因为和二进制的特征有关，二进制只有0和1两个数字，这就表示二进制的每一位只有两种状态。我们可以简单的分为有（1）和没有（0）。所以4位的二进制，放到4个箱子里面，每个箱子分别放入对应的二进制位数表示的数，然后拿箱子表示为1，不拿表示为0，其实组合出来的结果就是一个二进制的数。而十进制的每一位则有10种状态之多，一个箱子要产生10种状态，以拿到不同的球数，在这道题里面是不存在的。</h5><h2 id=\"题外话\"><a href=\"#题外话\" class=\"headerlink\" title=\"题外话\"></a>题外话</h2><h5 id=\"其实计算机的计算依赖于二进制也和此有关，因为以前的计算机对信号的读取和产生并没有那么灵敏，它只能识别有或者没有，转换成二进制就是1和0，如果以16进制为基础，则需要区分信号的强弱，这对以前的系统灵敏度来说是比较难的。（意淫一下，如果现在重新以16进制为基础编写计算机底层，计算效率和传输效率是不是有质的飞越呢）。\"><a href=\"#其实计算机的计算依赖于二进制也和此有关，因为以前的计算机对信号的读取和产生并没有那么灵敏，它只能识别有或者没有，转换成二进制就是1和0，如果以16进制为基础，则需要区分信号的强弱，这对以前的系统灵敏度来说是比较难的。（意淫一下，如果现在重新以16进制为基础编写计算机底层，计算效率和传输效率是不是有质的飞越呢）。\" class=\"headerlink\" title=\"其实计算机的计算依赖于二进制也和此有关，因为以前的计算机对信号的读取和产生并没有那么灵敏，它只能识别有或者没有，转换成二进制就是1和0，如果以16进制为基础，则需要区分信号的强弱，这对以前的系统灵敏度来说是比较难的。（意淫一下，如果现在重新以16进制为基础编写计算机底层，计算效率和传输效率是不是有质的飞越呢）。\"></a>其实计算机的计算依赖于二进制也和此有关，因为以前的计算机对信号的读取和产生并没有那么灵敏，它只能识别有或者没有，转换成二进制就是1和0，如果以16进制为基础，则需要区分信号的强弱，这对以前的系统灵敏度来说是比较难的。（意淫一下，如果现在重新以16进制为基础编写计算机底层，计算效率和传输效率是不是有质的飞越呢）。</h5>","site":{"data":{}},"excerpt":"<h2 id=\"题目要求：\"><a href=\"#题目要求：\" class=\"headerlink\" title=\"题目要求：\"></a>题目要求：</h2><h5 id=\"你让一些人为你工作了七天，你要用一根金条作为报酬。金条被分成七小块，每天给出一块。如果你只能将金条切割两次，你怎样分给这些工人\"><a href=\"#你让一些人为你工作了七天，你要用一根金条作为报酬。金条被分成七小块，每天给出一块。如果你只能将金条切割两次，你怎样分给这些工人\" class=\"headerlink\" title=\"你让一些人为你工作了七天，你要用一根金条作为报酬。金条被分成七小块，每天给出一块。如果你只能将金条切割两次，你怎样分给这些工人?\"></a>你让一些人为你工作了七天，你要用一根金条作为报酬。金条被分成七小块，每天给出一块。如果你只能将金条切割两次，你怎样分给这些工人?</h5>","more":"<h2 id=\"分析过程：\"><a href=\"#分析过程：\" class=\"headerlink\" title=\"分析过程：\"></a>分析过程：</h2><h5 id=\"这道题目一看就知道要按照二进制的方式去分割，因为切分的块数比较少，所以后面几次的报酬一定是需要将之前的报酬拿回才能做到的。\"><a href=\"#这道题目一看就知道要按照二进制的方式去分割，因为切分的块数比较少，所以后面几次的报酬一定是需要将之前的报酬拿回才能做到的。\" class=\"headerlink\" title=\"这道题目一看就知道要按照二进制的方式去分割，因为切分的块数比较少，所以后面几次的报酬一定是需要将之前的报酬拿回才能做到的。\"></a>这道题目一看就知道要按照二进制的方式去分割，因为切分的块数比较少，所以后面几次的报酬一定是需要将之前的报酬拿回才能做到的。</h5><h5 id=\"所以按照题目要求切割两次，要么把金条分成三份，要么分成四份（第二次两块叠在一起）。所以前三块部分一定是按照1：2：4来分，因为加起来已经等于7了，所以只需要分成三分就够了。这道题目就这么简单。\"><a href=\"#所以按照题目要求切割两次，要么把金条分成三份，要么分成四份（第二次两块叠在一起）。所以前三块部分一定是按照1：2：4来分，因为加起来已经等于7了，所以只需要分成三分就够了。这道题目就这么简单。\" class=\"headerlink\" title=\"所以按照题目要求切割两次，要么把金条分成三份，要么分成四份（第二次两块叠在一起）。所以前三块部分一定是按照1：2：4来分，因为加起来已经等于7了，所以只需要分成三分就够了。这道题目就这么简单。\"></a>所以按照题目要求切割两次，要么把金条分成三份，要么分成四份（第二次两块叠在一起）。所以前三块部分一定是按照1：2：4来分，因为加起来已经等于7了，所以只需要分成三分就够了。这道题目就这么简单。</h5><h5 id=\"这让我想到了另外一道题，将1000个球，放在10个箱子里。需要达到一种效果，就是任取1至1000的数字，能够从10个箱子中取出n个箱子，这n个箱子里面的球加起来刚好等于这个数字。这题和上面那题其实是一样的，没接触过一些算法的人会觉得特别难喝复杂，稍微认真想一想的童鞋也可以通过下面的方式得出答案：\"><a href=\"#这让我想到了另外一道题，将1000个球，放在10个箱子里。需要达到一种效果，就是任取1至1000的数字，能够从10个箱子中取出n个箱子，这n个箱子里面的球加起来刚好等于这个数字。这题和上面那题其实是一样的，没接触过一些算法的人会觉得特别难喝复杂，稍微认真想一想的童鞋也可以通过下面的方式得出答案：\" class=\"headerlink\" title=\"这让我想到了另外一道题，将1000个球，放在10个箱子里。需要达到一种效果，就是任取1至1000的数字，能够从10个箱子中取出n个箱子，这n个箱子里面的球加起来刚好等于这个数字。这题和上面那题其实是一样的，没接触过一些算法的人会觉得特别难喝复杂，稍微认真想一想的童鞋也可以通过下面的方式得出答案：\"></a>这让我想到了另外一道题，将1000个球，放在10个箱子里。需要达到一种效果，就是任取1至1000的数字，能够从10个箱子中取出n个箱子，这n个箱子里面的球加起来刚好等于这个数字。这题和上面那题其实是一样的，没接触过一些算法的人会觉得特别难喝复杂，稍微认真想一想的童鞋也可以通过下面的方式得出答案：</h5><h4 id=\"首先是取一个球的时候：\"><a href=\"#首先是取一个球的时候：\" class=\"headerlink\" title=\"首先是取一个球的时候：\"></a>首先是取一个球的时候：</h4><h5 id=\"所以一定有一个箱子里面是1个球。\"><a href=\"#所以一定有一个箱子里面是1个球。\" class=\"headerlink\" title=\"所以一定有一个箱子里面是1个球。\"></a>所以一定有一个箱子里面是1个球。</h5><h4 id=\"取两个球：\"><a href=\"#取两个球：\" class=\"headerlink\" title=\"取两个球：\"></a>取两个球：</h4><h5 id=\"前面那个箱子里是1个球，当需要两个球的时候，再添加一个一个球的箱子明显是不理智的，所以再拿一个箱子放两个球。\"><a href=\"#前面那个箱子里是1个球，当需要两个球的时候，再添加一个一个球的箱子明显是不理智的，所以再拿一个箱子放两个球。\" class=\"headerlink\" title=\"前面那个箱子里是1个球，当需要两个球的时候，再添加一个一个球的箱子明显是不理智的，所以再拿一个箱子放两个球。\"></a>前面那个箱子里是1个球，当需要两个球的时候，再添加一个一个球的箱子明显是不理智的，所以再拿一个箱子放两个球。</h5><h4 id=\"三个球：\"><a href=\"#三个球：\" class=\"headerlink\" title=\"三个球：\"></a>三个球：</h4><h5 id=\"前面两个箱子加起来刚好就是三个球，所以这种情况就已经包含在前面的答案里面了。\"><a href=\"#前面两个箱子加起来刚好就是三个球，所以这种情况就已经包含在前面的答案里面了。\" class=\"headerlink\" title=\"前面两个箱子加起来刚好就是三个球，所以这种情况就已经包含在前面的答案里面了。\"></a>前面两个箱子加起来刚好就是三个球，所以这种情况就已经包含在前面的答案里面了。</h5><h4 id=\"四个球呢：\"><a href=\"#四个球呢：\" class=\"headerlink\" title=\"四个球呢：\"></a>四个球呢：</h4><h5 id=\"之前两个箱子加起来才3个球，所以再拿一个箱子放4个球。\"><a href=\"#之前两个箱子加起来才3个球，所以再拿一个箱子放4个球。\" class=\"headerlink\" title=\"之前两个箱子加起来才3个球，所以再拿一个箱子放4个球。\"></a>之前两个箱子加起来才3个球，所以再拿一个箱子放4个球。</h5><h4 id=\"五个球，六个球，七个球之后的所有情况都按照这种逻辑推演下去，就可以得出答案\"><a href=\"#五个球，六个球，七个球之后的所有情况都按照这种逻辑推演下去，就可以得出答案\" class=\"headerlink\" title=\"五个球，六个球，七个球之后的所有情况都按照这种逻辑推演下去，就可以得出答案\"></a>五个球，六个球，七个球之后的所有情况都按照这种逻辑推演下去，就可以得出答案</h4><h5 id=\"按照1、2、4、8、16…这种规律放球，就能够做到题目的要求。切210-1024-所以10个箱子是能够支持这种放球的方式的。\"><a href=\"#按照1、2、4、8、16…这种规律放球，就能够做到题目的要求。切210-1024-所以10个箱子是能够支持这种放球的方式的。\" class=\"headerlink\" title=\"按照1、2、4、8、16…这种规律放球，就能够做到题目的要求。切210 = 1024,所以10个箱子是能够支持这种放球的方式的。\"></a>按照1、2、4、8、16…这种规律放球，就能够做到题目的要求。切2<sup>10</sup> = 1024,所以10个箱子是能够支持这种放球的方式的。</h5><h2 id=\"为什么这组数字这么神奇\"><a href=\"#为什么这组数字这么神奇\" class=\"headerlink\" title=\"为什么这组数字这么神奇\"></a>为什么这组数字这么神奇</h2><h5 id=\"1、2、4、8、16-可以组合成1到31之间的任意一个数，为什么会这么神奇。\"><a href=\"#1、2、4、8、16-可以组合成1到31之间的任意一个数，为什么会这么神奇。\" class=\"headerlink\" title=\"1、2、4、8、16 可以组合成1到31之间的任意一个数，为什么会这么神奇。\"></a>1、2、4、8、16 可以组合成1到31之间的任意一个数，为什么会这么神奇。</h5><h5 id=\"任何一个10进制数都可以转换成相应的二进制数。\"><a href=\"#任何一个10进制数都可以转换成相应的二进制数。\" class=\"headerlink\" title=\"任何一个10进制数都可以转换成相应的二进制数。\"></a>任何一个10进制数都可以转换成相应的二进制数。</h5><script type=\"math/tex; mode=display\">8\\qquad4\\qquad\\quad2\\qquad1</script><script type=\"math/tex; mode=display\">1000\\quad0100\\quad0010\\quad0001</script><h5 id=\"所以4位的2进制每一位转换成10进制分别是8、4、2、1。就好像4位的10进制每一位分别表示为千、百、十、个。但是你要是说把9999个球放到4个箱子里，任取一个数都能拿出n个箱子，加起来刚好是这个数。但是按照二进制的方法，4位二进制转换成10进制最多为15，所以15个球是能够实现这种规律的。\"><a href=\"#所以4位的2进制每一位转换成10进制分别是8、4、2、1。就好像4位的10进制每一位分别表示为千、百、十、个。但是你要是说把9999个球放到4个箱子里，任取一个数都能拿出n个箱子，加起来刚好是这个数。但是按照二进制的方法，4位二进制转换成10进制最多为15，所以15个球是能够实现这种规律的。\" class=\"headerlink\" title=\"所以4位的2进制每一位转换成10进制分别是8、4、2、1。就好像4位的10进制每一位分别表示为千、百、十、个。但是你要是说把9999个球放到4个箱子里，任取一个数都能拿出n个箱子，加起来刚好是这个数。但是按照二进制的方法，4位二进制转换成10进制最多为15，所以15个球是能够实现这种规律的。\"></a>所以4位的2进制每一位转换成10进制分别是8、4、2、1。就好像4位的10进制每一位分别表示为千、百、十、个。但是你要是说把9999个球放到4个箱子里，任取一个数都能拿出n个箱子，加起来刚好是这个数。但是按照二进制的方法，4位二进制转换成10进制最多为15，所以15个球是能够实现这种规律的。</h5><h5 id=\"能够达到这种神奇效果，是因为和二进制的特征有关，二进制只有0和1两个数字，这就表示二进制的每一位只有两种状态。我们可以简单的分为有（1）和没有（0）。所以4位的二进制，放到4个箱子里面，每个箱子分别放入对应的二进制位数表示的数，然后拿箱子表示为1，不拿表示为0，其实组合出来的结果就是一个二进制的数。而十进制的每一位则有10种状态之多，一个箱子要产生10种状态，以拿到不同的球数，在这道题里面是不存在的。\"><a href=\"#能够达到这种神奇效果，是因为和二进制的特征有关，二进制只有0和1两个数字，这就表示二进制的每一位只有两种状态。我们可以简单的分为有（1）和没有（0）。所以4位的二进制，放到4个箱子里面，每个箱子分别放入对应的二进制位数表示的数，然后拿箱子表示为1，不拿表示为0，其实组合出来的结果就是一个二进制的数。而十进制的每一位则有10种状态之多，一个箱子要产生10种状态，以拿到不同的球数，在这道题里面是不存在的。\" class=\"headerlink\" title=\"能够达到这种神奇效果，是因为和二进制的特征有关，二进制只有0和1两个数字，这就表示二进制的每一位只有两种状态。我们可以简单的分为有（1）和没有（0）。所以4位的二进制，放到4个箱子里面，每个箱子分别放入对应的二进制位数表示的数，然后拿箱子表示为1，不拿表示为0，其实组合出来的结果就是一个二进制的数。而十进制的每一位则有10种状态之多，一个箱子要产生10种状态，以拿到不同的球数，在这道题里面是不存在的。\"></a>能够达到这种神奇效果，是因为和二进制的特征有关，二进制只有0和1两个数字，这就表示二进制的每一位只有两种状态。我们可以简单的分为有（1）和没有（0）。所以4位的二进制，放到4个箱子里面，每个箱子分别放入对应的二进制位数表示的数，然后拿箱子表示为1，不拿表示为0，其实组合出来的结果就是一个二进制的数。而十进制的每一位则有10种状态之多，一个箱子要产生10种状态，以拿到不同的球数，在这道题里面是不存在的。</h5><h2 id=\"题外话\"><a href=\"#题外话\" class=\"headerlink\" title=\"题外话\"></a>题外话</h2><h5 id=\"其实计算机的计算依赖于二进制也和此有关，因为以前的计算机对信号的读取和产生并没有那么灵敏，它只能识别有或者没有，转换成二进制就是1和0，如果以16进制为基础，则需要区分信号的强弱，这对以前的系统灵敏度来说是比较难的。（意淫一下，如果现在重新以16进制为基础编写计算机底层，计算效率和传输效率是不是有质的飞越呢）。\"><a href=\"#其实计算机的计算依赖于二进制也和此有关，因为以前的计算机对信号的读取和产生并没有那么灵敏，它只能识别有或者没有，转换成二进制就是1和0，如果以16进制为基础，则需要区分信号的强弱，这对以前的系统灵敏度来说是比较难的。（意淫一下，如果现在重新以16进制为基础编写计算机底层，计算效率和传输效率是不是有质的飞越呢）。\" class=\"headerlink\" title=\"其实计算机的计算依赖于二进制也和此有关，因为以前的计算机对信号的读取和产生并没有那么灵敏，它只能识别有或者没有，转换成二进制就是1和0，如果以16进制为基础，则需要区分信号的强弱，这对以前的系统灵敏度来说是比较难的。（意淫一下，如果现在重新以16进制为基础编写计算机底层，计算效率和传输效率是不是有质的飞越呢）。\"></a>其实计算机的计算依赖于二进制也和此有关，因为以前的计算机对信号的读取和产生并没有那么灵敏，它只能识别有或者没有，转换成二进制就是1和0，如果以16进制为基础，则需要区分信号的强弱，这对以前的系统灵敏度来说是比较难的。（意淫一下，如果现在重新以16进制为基础编写计算机底层，计算效率和传输效率是不是有质的飞越呢）。</h5>"},{"layout":"post","title":"左旋转字符串","date":"2017-03-05T16:00:00.000Z","original":true,"tag":[["算法","arithmetic"]],"_content":"\n## 题目要求：\n##### 定义字符串的左旋转操作：把字符串前面的若干个字符移动到字符串的尾部。\n##### 如把字符串abcdef左旋转2位得到字符串cdefab。请实现字符串左旋转的函数。\n##### 要求时间对长度为n的字符串操作的复杂度为O(n)，辅助内存为O(1)。\n<!--more-->\n\n## 分析过程：\n#####  题目要求很简单，其实就是字符串的位置交换，一个长度为n的字符串，将字符串的前面m个字符的子串和后面的字符进行位置交换。如果用普通的java代码进行编写的话，会非常简单\n\n```JAVA\nString result = start.substring(m,n) + start.substring(0, m);\n```\n\n##### java对数组的复制使用System.arraycopy的本地方法， 以这种方式实现的话，时间复杂度是符合O(n)要求的，但是空间复杂度却要大于O(1)。这明显是不符合题意的。\n##### 首先，能够想到的是，字符串的左旋转，其实就是对字符数组的左旋转。既然是对数组的位置交换，则数组的每个位置的字符在交换之后的位置是已经确定的，并且能够找到一定的规律的。比如题目中的例子，把字符串abcdef左旋转2位得到字符串cdefab；\n##### 假设字符串的数组为arry,字符串的长度为6（n=6），左旋转2位（m=2），则数组中每一位的位置相应的转换为\n###### a:array[0] -> array[0+4] -> array[4]\n###### b:array[1] -> array[1+4] -> array[5]\n###### c:array[2] -> array[2-2] -> array[0]\n###### d:array[3] -> array[3-2] -> array[1]\n###### e:array[4] -> array[4-2] -> array[2]\n###### f:array[5] -> array[5-2] -> array[3]\n##### 可以看出，字符位置的交换是很有规律的，对于字符长度为n，左旋m位的数组\n1. 前面m个字符，左旋后的位置为i+(n-m)\n2. 后面n-m个字符，左旋后的位置为j-m\n\n#### 基于这套交换逻辑，想要实现如下算法，却发现不符合题目要求：\n##### 1. 初始字符串为abcdef，左旋转2位得到字符串cdefab\n<table><tr>\n<td>&nbsp;a&nbsp;</td>\n<td>&nbsp;b&nbsp;</td>\n<td>&nbsp;c&nbsp;</td>\n<td>&nbsp;d&nbsp;</td>\n<td>&nbsp;e&nbsp;</td>\n<td>&nbsp;f&nbsp;</td>\n</tr></table>\n\n##### 2. 将array[0]写入到到array[4]， 用tmp记录array[4]\n<table><tr>\n<td>&nbsp;a&nbsp;</td>\n<td>&nbsp;b&nbsp;</td>\n<td>&nbsp;c&nbsp;</td>\n<td>&nbsp;d&nbsp;</td>\n<td>&nbsp;<font color='red'>a</font>&nbsp;</td>\n<td>&nbsp;f&nbsp;</td>\n</tr></table>\n\n　　　tmp = e\n\n##### 3. 将array[4]写入到到array[2]， 用tmp记录array[2]\n<table><tr>\n<td>&nbsp;a&nbsp;</td>\n<td>&nbsp;b&nbsp;</td>\n<td>&nbsp;<font color='red'>e</font>&nbsp;</td>\n<td>&nbsp;d&nbsp;</td>\n<td>&nbsp;a&nbsp;</td>\n<td>&nbsp;f&nbsp;</td>\n</tr></table>\n\n　　　tmp = c\n\n##### 4. 将array[2]写入到到array[0]， 用tmp记录array[0]\n<table><tr>\n<td>&nbsp;<font color='red'>c</font>&nbsp;</td>\n<td>&nbsp;b&nbsp;</td>\n<td>&nbsp;e&nbsp;</td>\n<td>&nbsp;d&nbsp;</td>\n<td>&nbsp;a&nbsp;</td>\n<td>&nbsp;f&nbsp;</td>\n</tr></table>\n\n　　　tmp = a\n\n##### 问题就出在第四步，回到起点后，继续交换显然是错误的，这就需要额外的空间去记录那些位置是已经交换的，并且需要的额外空间随着原始字符串长度的增加而线性增长，所以这种方式的空间复杂度为O(n),不符合O(1)的要求。\n\n#### 于是想到的另外一种解题方式，依次将数组元素与之后的第m位交换：\n##### 1. 初始字符串为abcdef，\n<table><tr>\n<td>&nbsp;a&nbsp;</td>\n<td>&nbsp;b&nbsp;</td>\n<td>&nbsp;c&nbsp;</td>\n<td>&nbsp;d&nbsp;</td>\n<td>&nbsp;e&nbsp;</td>\n<td>&nbsp;f&nbsp;</td>\n</tr></table>\n\n##### 2. 将array[0]与array[2]交换\n\n<table><tr>\n<td>&nbsp;<font color='red'>c</font>&nbsp;</td>\n<td>&nbsp;b&nbsp;</td>\n<td>&nbsp;<font color='red'>a</font>&nbsp;</td>\n<td>&nbsp;d&nbsp;</td>\n<td>&nbsp;e&nbsp;</td>\n<td>&nbsp;f&nbsp;</td>\n</tr></table>\n\n##### 3.  将array[1]与array[3]交换\n<table><tr>\n<td>&nbsp;c&nbsp;</td>\n<td>&nbsp;<font color='red'>d</font>&nbsp;</td>\n<td>&nbsp;a&nbsp;</td>\n<td>&nbsp;<font color='red'>b</font>&nbsp;</td>\n<td>&nbsp;e&nbsp;</td>\n<td>&nbsp;f&nbsp;</td>\n</tr></table>\n\n##### 4. 将array[2]与array[4]交换\n<table><tr>\n<td>&nbsp;c&nbsp;</td>\n<td>&nbsp;d&nbsp;</td>\n<td>&nbsp;<font color='red'>e</font>&nbsp;</td>\n<td>&nbsp;b&nbsp;</td>\n<td>&nbsp;<font color='red'>a</font>&nbsp;</td>\n<td>&nbsp;f&nbsp;</td>\n</tr></table>\n\n##### 5. 将array[3]与array[5]交换\n<table><tr>\n<td>&nbsp;c&nbsp;</td>\n<td>&nbsp;d&nbsp;</td>\n<td>&nbsp;e&nbsp;</td>\n<td>&nbsp;<font color='red'>f</font>&nbsp;</td>\n<td>&nbsp;a&nbsp;</td>\n<td>&nbsp;<font color='red'>b</font>&nbsp;</td>\n</tr></table>\n\n##### 这种实现方式需要进行n-m次交换，时间复杂度为O(n),需要两个额外空间，分别是交换数组元素的tmp指针，和记录当前交换位置的指针，这也符合常数空间复杂度O(1)。\n\n## 解题：\n#### 看了网络上的一些其他解法，也比较巧妙:\n1. 首先将原字符串分为两个部分，即X:ab，Y:cdef；\n2. 将X反转，X->X^T，即得：ab->ba；将Y反转，Y->Y^T，即得：cdef->fedc。\n3. 反转上述步骤得到的结果字符串X^TY^T，即反转字符串bafedc的两部分（ba和fedc）给予反转，bafedc得到cdefab，形式化表示为(X^TY^T)^T=YX，这就实现了整个反转。\n\n```C\nvoid ReverseString(char* s,int from,int to)\n{\n    while (from < to)\n    {\n        char t = s[from];\n        s[from++] = s[to];\n        s[to--] = t;\n    }\n}\n\nvoid LeftRotateString(char* s,int n,int m)\n{\n    m %= n;               //若要左移动大于n位，那么和%n 是等价的\n    ReverseString(s, 0, m - 1); //反转[0..m - 1]，套用到上面举的例子中，就是X->X^T，即 abc->cba\n    ReverseString(s, m, n - 1); //反转[m..n - 1]，例如Y->Y^T，即 def->fed\n    ReverseString(s, 0, n - 1); //反转[0..n - 1]，即如整个反转，(X^TY^T)^T=YX，即 cbafed->defabc。\n}\n```\n\n##### 调用3次此方法即可左旋字符串\n\n## 最后再说一些：\n##### 对于时间复杂度和空间复杂度的计算，需要去低阶项，去掉常数项，去掉高阶项，T(n)=(2n<sup>2</sup>+n+1)=O(n<sup>2</sup>);若执行时间是一个与问题规模n无关的常数，算法的时间复杂度为常数阶，记作T(n)=O(1)。\n\n### 参考链接：\n[http://taop.marchtea.com/01.01.html](http://taop.marchtea.com/01.01.html)","source":"_posts/arithmetic/leftString.md","raw":"---\nlayout: post\ntitle: 左旋转字符串\ndate: 2017/03/06\ntags: [tech, arithmetic, index]\noriginal: true\ntag: [[算法, arithmetic]]\n---\n\n## 题目要求：\n##### 定义字符串的左旋转操作：把字符串前面的若干个字符移动到字符串的尾部。\n##### 如把字符串abcdef左旋转2位得到字符串cdefab。请实现字符串左旋转的函数。\n##### 要求时间对长度为n的字符串操作的复杂度为O(n)，辅助内存为O(1)。\n<!--more-->\n\n## 分析过程：\n#####  题目要求很简单，其实就是字符串的位置交换，一个长度为n的字符串，将字符串的前面m个字符的子串和后面的字符进行位置交换。如果用普通的java代码进行编写的话，会非常简单\n\n```JAVA\nString result = start.substring(m,n) + start.substring(0, m);\n```\n\n##### java对数组的复制使用System.arraycopy的本地方法， 以这种方式实现的话，时间复杂度是符合O(n)要求的，但是空间复杂度却要大于O(1)。这明显是不符合题意的。\n##### 首先，能够想到的是，字符串的左旋转，其实就是对字符数组的左旋转。既然是对数组的位置交换，则数组的每个位置的字符在交换之后的位置是已经确定的，并且能够找到一定的规律的。比如题目中的例子，把字符串abcdef左旋转2位得到字符串cdefab；\n##### 假设字符串的数组为arry,字符串的长度为6（n=6），左旋转2位（m=2），则数组中每一位的位置相应的转换为\n###### a:array[0] -> array[0+4] -> array[4]\n###### b:array[1] -> array[1+4] -> array[5]\n###### c:array[2] -> array[2-2] -> array[0]\n###### d:array[3] -> array[3-2] -> array[1]\n###### e:array[4] -> array[4-2] -> array[2]\n###### f:array[5] -> array[5-2] -> array[3]\n##### 可以看出，字符位置的交换是很有规律的，对于字符长度为n，左旋m位的数组\n1. 前面m个字符，左旋后的位置为i+(n-m)\n2. 后面n-m个字符，左旋后的位置为j-m\n\n#### 基于这套交换逻辑，想要实现如下算法，却发现不符合题目要求：\n##### 1. 初始字符串为abcdef，左旋转2位得到字符串cdefab\n<table><tr>\n<td>&nbsp;a&nbsp;</td>\n<td>&nbsp;b&nbsp;</td>\n<td>&nbsp;c&nbsp;</td>\n<td>&nbsp;d&nbsp;</td>\n<td>&nbsp;e&nbsp;</td>\n<td>&nbsp;f&nbsp;</td>\n</tr></table>\n\n##### 2. 将array[0]写入到到array[4]， 用tmp记录array[4]\n<table><tr>\n<td>&nbsp;a&nbsp;</td>\n<td>&nbsp;b&nbsp;</td>\n<td>&nbsp;c&nbsp;</td>\n<td>&nbsp;d&nbsp;</td>\n<td>&nbsp;<font color='red'>a</font>&nbsp;</td>\n<td>&nbsp;f&nbsp;</td>\n</tr></table>\n\n　　　tmp = e\n\n##### 3. 将array[4]写入到到array[2]， 用tmp记录array[2]\n<table><tr>\n<td>&nbsp;a&nbsp;</td>\n<td>&nbsp;b&nbsp;</td>\n<td>&nbsp;<font color='red'>e</font>&nbsp;</td>\n<td>&nbsp;d&nbsp;</td>\n<td>&nbsp;a&nbsp;</td>\n<td>&nbsp;f&nbsp;</td>\n</tr></table>\n\n　　　tmp = c\n\n##### 4. 将array[2]写入到到array[0]， 用tmp记录array[0]\n<table><tr>\n<td>&nbsp;<font color='red'>c</font>&nbsp;</td>\n<td>&nbsp;b&nbsp;</td>\n<td>&nbsp;e&nbsp;</td>\n<td>&nbsp;d&nbsp;</td>\n<td>&nbsp;a&nbsp;</td>\n<td>&nbsp;f&nbsp;</td>\n</tr></table>\n\n　　　tmp = a\n\n##### 问题就出在第四步，回到起点后，继续交换显然是错误的，这就需要额外的空间去记录那些位置是已经交换的，并且需要的额外空间随着原始字符串长度的增加而线性增长，所以这种方式的空间复杂度为O(n),不符合O(1)的要求。\n\n#### 于是想到的另外一种解题方式，依次将数组元素与之后的第m位交换：\n##### 1. 初始字符串为abcdef，\n<table><tr>\n<td>&nbsp;a&nbsp;</td>\n<td>&nbsp;b&nbsp;</td>\n<td>&nbsp;c&nbsp;</td>\n<td>&nbsp;d&nbsp;</td>\n<td>&nbsp;e&nbsp;</td>\n<td>&nbsp;f&nbsp;</td>\n</tr></table>\n\n##### 2. 将array[0]与array[2]交换\n\n<table><tr>\n<td>&nbsp;<font color='red'>c</font>&nbsp;</td>\n<td>&nbsp;b&nbsp;</td>\n<td>&nbsp;<font color='red'>a</font>&nbsp;</td>\n<td>&nbsp;d&nbsp;</td>\n<td>&nbsp;e&nbsp;</td>\n<td>&nbsp;f&nbsp;</td>\n</tr></table>\n\n##### 3.  将array[1]与array[3]交换\n<table><tr>\n<td>&nbsp;c&nbsp;</td>\n<td>&nbsp;<font color='red'>d</font>&nbsp;</td>\n<td>&nbsp;a&nbsp;</td>\n<td>&nbsp;<font color='red'>b</font>&nbsp;</td>\n<td>&nbsp;e&nbsp;</td>\n<td>&nbsp;f&nbsp;</td>\n</tr></table>\n\n##### 4. 将array[2]与array[4]交换\n<table><tr>\n<td>&nbsp;c&nbsp;</td>\n<td>&nbsp;d&nbsp;</td>\n<td>&nbsp;<font color='red'>e</font>&nbsp;</td>\n<td>&nbsp;b&nbsp;</td>\n<td>&nbsp;<font color='red'>a</font>&nbsp;</td>\n<td>&nbsp;f&nbsp;</td>\n</tr></table>\n\n##### 5. 将array[3]与array[5]交换\n<table><tr>\n<td>&nbsp;c&nbsp;</td>\n<td>&nbsp;d&nbsp;</td>\n<td>&nbsp;e&nbsp;</td>\n<td>&nbsp;<font color='red'>f</font>&nbsp;</td>\n<td>&nbsp;a&nbsp;</td>\n<td>&nbsp;<font color='red'>b</font>&nbsp;</td>\n</tr></table>\n\n##### 这种实现方式需要进行n-m次交换，时间复杂度为O(n),需要两个额外空间，分别是交换数组元素的tmp指针，和记录当前交换位置的指针，这也符合常数空间复杂度O(1)。\n\n## 解题：\n#### 看了网络上的一些其他解法，也比较巧妙:\n1. 首先将原字符串分为两个部分，即X:ab，Y:cdef；\n2. 将X反转，X->X^T，即得：ab->ba；将Y反转，Y->Y^T，即得：cdef->fedc。\n3. 反转上述步骤得到的结果字符串X^TY^T，即反转字符串bafedc的两部分（ba和fedc）给予反转，bafedc得到cdefab，形式化表示为(X^TY^T)^T=YX，这就实现了整个反转。\n\n```C\nvoid ReverseString(char* s,int from,int to)\n{\n    while (from < to)\n    {\n        char t = s[from];\n        s[from++] = s[to];\n        s[to--] = t;\n    }\n}\n\nvoid LeftRotateString(char* s,int n,int m)\n{\n    m %= n;               //若要左移动大于n位，那么和%n 是等价的\n    ReverseString(s, 0, m - 1); //反转[0..m - 1]，套用到上面举的例子中，就是X->X^T，即 abc->cba\n    ReverseString(s, m, n - 1); //反转[m..n - 1]，例如Y->Y^T，即 def->fed\n    ReverseString(s, 0, n - 1); //反转[0..n - 1]，即如整个反转，(X^TY^T)^T=YX，即 cbafed->defabc。\n}\n```\n\n##### 调用3次此方法即可左旋字符串\n\n## 最后再说一些：\n##### 对于时间复杂度和空间复杂度的计算，需要去低阶项，去掉常数项，去掉高阶项，T(n)=(2n<sup>2</sup>+n+1)=O(n<sup>2</sup>);若执行时间是一个与问题规模n无关的常数，算法的时间复杂度为常数阶，记作T(n)=O(1)。\n\n### 参考链接：\n[http://taop.marchtea.com/01.01.html](http://taop.marchtea.com/01.01.html)","slug":"arithmetic/leftString","published":1,"updated":"2017-10-06T16:03:22.654Z","comments":1,"photos":[],"link":"","_id":"cj8jros73000930s6twknjkqb","content":"<h2 id=\"题目要求：\"><a href=\"#题目要求：\" class=\"headerlink\" title=\"题目要求：\"></a>题目要求：</h2><h5 id=\"定义字符串的左旋转操作：把字符串前面的若干个字符移动到字符串的尾部。\"><a href=\"#定义字符串的左旋转操作：把字符串前面的若干个字符移动到字符串的尾部。\" class=\"headerlink\" title=\"定义字符串的左旋转操作：把字符串前面的若干个字符移动到字符串的尾部。\"></a>定义字符串的左旋转操作：把字符串前面的若干个字符移动到字符串的尾部。</h5><h5 id=\"如把字符串abcdef左旋转2位得到字符串cdefab。请实现字符串左旋转的函数。\"><a href=\"#如把字符串abcdef左旋转2位得到字符串cdefab。请实现字符串左旋转的函数。\" class=\"headerlink\" title=\"如把字符串abcdef左旋转2位得到字符串cdefab。请实现字符串左旋转的函数。\"></a>如把字符串abcdef左旋转2位得到字符串cdefab。请实现字符串左旋转的函数。</h5><h5 id=\"要求时间对长度为n的字符串操作的复杂度为O-n-，辅助内存为O-1-。\"><a href=\"#要求时间对长度为n的字符串操作的复杂度为O-n-，辅助内存为O-1-。\" class=\"headerlink\" title=\"要求时间对长度为n的字符串操作的复杂度为O(n)，辅助内存为O(1)。\"></a>要求时间对长度为n的字符串操作的复杂度为O(n)，辅助内存为O(1)。</h5><a id=\"more\"></a>\n<h2 id=\"分析过程：\"><a href=\"#分析过程：\" class=\"headerlink\" title=\"分析过程：\"></a>分析过程：</h2><h5 id=\"题目要求很简单，其实就是字符串的位置交换，一个长度为n的字符串，将字符串的前面m个字符的子串和后面的字符进行位置交换。如果用普通的java代码进行编写的话，会非常简单\"><a href=\"#题目要求很简单，其实就是字符串的位置交换，一个长度为n的字符串，将字符串的前面m个字符的子串和后面的字符进行位置交换。如果用普通的java代码进行编写的话，会非常简单\" class=\"headerlink\" title=\"题目要求很简单，其实就是字符串的位置交换，一个长度为n的字符串，将字符串的前面m个字符的子串和后面的字符进行位置交换。如果用普通的java代码进行编写的话，会非常简单\"></a>题目要求很简单，其实就是字符串的位置交换，一个长度为n的字符串，将字符串的前面m个字符的子串和后面的字符进行位置交换。如果用普通的java代码进行编写的话，会非常简单</h5><pre><code class=\"lang-JAVA\">String result = start.substring(m,n) + start.substring(0, m);\n</code></pre>\n<h5 id=\"java对数组的复制使用System-arraycopy的本地方法，-以这种方式实现的话，时间复杂度是符合O-n-要求的，但是空间复杂度却要大于O-1-。这明显是不符合题意的。\"><a href=\"#java对数组的复制使用System-arraycopy的本地方法，-以这种方式实现的话，时间复杂度是符合O-n-要求的，但是空间复杂度却要大于O-1-。这明显是不符合题意的。\" class=\"headerlink\" title=\"java对数组的复制使用System.arraycopy的本地方法， 以这种方式实现的话，时间复杂度是符合O(n)要求的，但是空间复杂度却要大于O(1)。这明显是不符合题意的。\"></a>java对数组的复制使用System.arraycopy的本地方法， 以这种方式实现的话，时间复杂度是符合O(n)要求的，但是空间复杂度却要大于O(1)。这明显是不符合题意的。</h5><h5 id=\"首先，能够想到的是，字符串的左旋转，其实就是对字符数组的左旋转。既然是对数组的位置交换，则数组的每个位置的字符在交换之后的位置是已经确定的，并且能够找到一定的规律的。比如题目中的例子，把字符串abcdef左旋转2位得到字符串cdefab；\"><a href=\"#首先，能够想到的是，字符串的左旋转，其实就是对字符数组的左旋转。既然是对数组的位置交换，则数组的每个位置的字符在交换之后的位置是已经确定的，并且能够找到一定的规律的。比如题目中的例子，把字符串abcdef左旋转2位得到字符串cdefab；\" class=\"headerlink\" title=\"首先，能够想到的是，字符串的左旋转，其实就是对字符数组的左旋转。既然是对数组的位置交换，则数组的每个位置的字符在交换之后的位置是已经确定的，并且能够找到一定的规律的。比如题目中的例子，把字符串abcdef左旋转2位得到字符串cdefab；\"></a>首先，能够想到的是，字符串的左旋转，其实就是对字符数组的左旋转。既然是对数组的位置交换，则数组的每个位置的字符在交换之后的位置是已经确定的，并且能够找到一定的规律的。比如题目中的例子，把字符串abcdef左旋转2位得到字符串cdefab；</h5><h5 id=\"假设字符串的数组为arry-字符串的长度为6（n-6），左旋转2位（m-2），则数组中每一位的位置相应的转换为\"><a href=\"#假设字符串的数组为arry-字符串的长度为6（n-6），左旋转2位（m-2），则数组中每一位的位置相应的转换为\" class=\"headerlink\" title=\"假设字符串的数组为arry,字符串的长度为6（n=6），左旋转2位（m=2），则数组中每一位的位置相应的转换为\"></a>假设字符串的数组为arry,字符串的长度为6（n=6），左旋转2位（m=2），则数组中每一位的位置相应的转换为</h5><h6 id=\"a-array-0-gt-array-0-4-gt-array-4\"><a href=\"#a-array-0-gt-array-0-4-gt-array-4\" class=\"headerlink\" title=\"a:array[0] -&gt; array[0+4] -&gt; array[4]\"></a>a:array[0] -&gt; array[0+4] -&gt; array[4]</h6><h6 id=\"b-array-1-gt-array-1-4-gt-array-5\"><a href=\"#b-array-1-gt-array-1-4-gt-array-5\" class=\"headerlink\" title=\"b:array[1] -&gt; array[1+4] -&gt; array[5]\"></a>b:array[1] -&gt; array[1+4] -&gt; array[5]</h6><h6 id=\"c-array-2-gt-array-2-2-gt-array-0\"><a href=\"#c-array-2-gt-array-2-2-gt-array-0\" class=\"headerlink\" title=\"c:array[2] -&gt; array[2-2] -&gt; array[0]\"></a>c:array[2] -&gt; array[2-2] -&gt; array[0]</h6><h6 id=\"d-array-3-gt-array-3-2-gt-array-1\"><a href=\"#d-array-3-gt-array-3-2-gt-array-1\" class=\"headerlink\" title=\"d:array[3] -&gt; array[3-2] -&gt; array[1]\"></a>d:array[3] -&gt; array[3-2] -&gt; array[1]</h6><h6 id=\"e-array-4-gt-array-4-2-gt-array-2\"><a href=\"#e-array-4-gt-array-4-2-gt-array-2\" class=\"headerlink\" title=\"e:array[4] -&gt; array[4-2] -&gt; array[2]\"></a>e:array[4] -&gt; array[4-2] -&gt; array[2]</h6><h6 id=\"f-array-5-gt-array-5-2-gt-array-3\"><a href=\"#f-array-5-gt-array-5-2-gt-array-3\" class=\"headerlink\" title=\"f:array[5] -&gt; array[5-2] -&gt; array[3]\"></a>f:array[5] -&gt; array[5-2] -&gt; array[3]</h6><h5 id=\"可以看出，字符位置的交换是很有规律的，对于字符长度为n，左旋m位的数组\"><a href=\"#可以看出，字符位置的交换是很有规律的，对于字符长度为n，左旋m位的数组\" class=\"headerlink\" title=\"可以看出，字符位置的交换是很有规律的，对于字符长度为n，左旋m位的数组\"></a>可以看出，字符位置的交换是很有规律的，对于字符长度为n，左旋m位的数组</h5><ol>\n<li>前面m个字符，左旋后的位置为i+(n-m)</li>\n<li>后面n-m个字符，左旋后的位置为j-m</li>\n</ol>\n<h4 id=\"基于这套交换逻辑，想要实现如下算法，却发现不符合题目要求：\"><a href=\"#基于这套交换逻辑，想要实现如下算法，却发现不符合题目要求：\" class=\"headerlink\" title=\"基于这套交换逻辑，想要实现如下算法，却发现不符合题目要求：\"></a>基于这套交换逻辑，想要实现如下算法，却发现不符合题目要求：</h4><h5 id=\"1-初始字符串为abcdef，左旋转2位得到字符串cdefab\"><a href=\"#1-初始字符串为abcdef，左旋转2位得到字符串cdefab\" class=\"headerlink\" title=\"1. 初始字符串为abcdef，左旋转2位得到字符串cdefab\"></a>1. 初始字符串为abcdef，左旋转2位得到字符串cdefab</h5><table><tr>\n<td>&nbsp;a&nbsp;</td>\n<td>&nbsp;b&nbsp;</td>\n<td>&nbsp;c&nbsp;</td>\n<td>&nbsp;d&nbsp;</td>\n<td>&nbsp;e&nbsp;</td>\n<td>&nbsp;f&nbsp;</td>\n</tr></table>\n\n<h5 id=\"2-将array-0-写入到到array-4-，-用tmp记录array-4\"><a href=\"#2-将array-0-写入到到array-4-，-用tmp记录array-4\" class=\"headerlink\" title=\"2. 将array[0]写入到到array[4]， 用tmp记录array[4]\"></a>2. 将array[0]写入到到array[4]， 用tmp记录array[4]</h5><table><tr>\n<td>&nbsp;a&nbsp;</td>\n<td>&nbsp;b&nbsp;</td>\n<td>&nbsp;c&nbsp;</td>\n<td>&nbsp;d&nbsp;</td>\n<td>&nbsp;<font color=\"red\">a</font>&nbsp;</td>\n<td>&nbsp;f&nbsp;</td>\n</tr></table>\n\n<p>　　　tmp = e</p>\n<h5 id=\"3-将array-4-写入到到array-2-，-用tmp记录array-2\"><a href=\"#3-将array-4-写入到到array-2-，-用tmp记录array-2\" class=\"headerlink\" title=\"3. 将array[4]写入到到array[2]， 用tmp记录array[2]\"></a>3. 将array[4]写入到到array[2]， 用tmp记录array[2]</h5><table><tr>\n<td>&nbsp;a&nbsp;</td>\n<td>&nbsp;b&nbsp;</td>\n<td>&nbsp;<font color=\"red\">e</font>&nbsp;</td>\n<td>&nbsp;d&nbsp;</td>\n<td>&nbsp;a&nbsp;</td>\n<td>&nbsp;f&nbsp;</td>\n</tr></table>\n\n<p>　　　tmp = c</p>\n<h5 id=\"4-将array-2-写入到到array-0-，-用tmp记录array-0\"><a href=\"#4-将array-2-写入到到array-0-，-用tmp记录array-0\" class=\"headerlink\" title=\"4. 将array[2]写入到到array[0]， 用tmp记录array[0]\"></a>4. 将array[2]写入到到array[0]， 用tmp记录array[0]</h5><table><tr>\n<td>&nbsp;<font color=\"red\">c</font>&nbsp;</td>\n<td>&nbsp;b&nbsp;</td>\n<td>&nbsp;e&nbsp;</td>\n<td>&nbsp;d&nbsp;</td>\n<td>&nbsp;a&nbsp;</td>\n<td>&nbsp;f&nbsp;</td>\n</tr></table>\n\n<p>　　　tmp = a</p>\n<h5 id=\"问题就出在第四步，回到起点后，继续交换显然是错误的，这就需要额外的空间去记录那些位置是已经交换的，并且需要的额外空间随着原始字符串长度的增加而线性增长，所以这种方式的空间复杂度为O-n-不符合O-1-的要求。\"><a href=\"#问题就出在第四步，回到起点后，继续交换显然是错误的，这就需要额外的空间去记录那些位置是已经交换的，并且需要的额外空间随着原始字符串长度的增加而线性增长，所以这种方式的空间复杂度为O-n-不符合O-1-的要求。\" class=\"headerlink\" title=\"问题就出在第四步，回到起点后，继续交换显然是错误的，这就需要额外的空间去记录那些位置是已经交换的，并且需要的额外空间随着原始字符串长度的增加而线性增长，所以这种方式的空间复杂度为O(n),不符合O(1)的要求。\"></a>问题就出在第四步，回到起点后，继续交换显然是错误的，这就需要额外的空间去记录那些位置是已经交换的，并且需要的额外空间随着原始字符串长度的增加而线性增长，所以这种方式的空间复杂度为O(n),不符合O(1)的要求。</h5><h4 id=\"于是想到的另外一种解题方式，依次将数组元素与之后的第m位交换：\"><a href=\"#于是想到的另外一种解题方式，依次将数组元素与之后的第m位交换：\" class=\"headerlink\" title=\"于是想到的另外一种解题方式，依次将数组元素与之后的第m位交换：\"></a>于是想到的另外一种解题方式，依次将数组元素与之后的第m位交换：</h4><h5 id=\"1-初始字符串为abcdef，\"><a href=\"#1-初始字符串为abcdef，\" class=\"headerlink\" title=\"1. 初始字符串为abcdef，\"></a>1. 初始字符串为abcdef，</h5><table><tr>\n<td>&nbsp;a&nbsp;</td>\n<td>&nbsp;b&nbsp;</td>\n<td>&nbsp;c&nbsp;</td>\n<td>&nbsp;d&nbsp;</td>\n<td>&nbsp;e&nbsp;</td>\n<td>&nbsp;f&nbsp;</td>\n</tr></table>\n\n<h5 id=\"2-将array-0-与array-2-交换\"><a href=\"#2-将array-0-与array-2-交换\" class=\"headerlink\" title=\"2. 将array[0]与array[2]交换\"></a>2. 将array[0]与array[2]交换</h5><table><tr>\n<td>&nbsp;<font color=\"red\">c</font>&nbsp;</td>\n<td>&nbsp;b&nbsp;</td>\n<td>&nbsp;<font color=\"red\">a</font>&nbsp;</td>\n<td>&nbsp;d&nbsp;</td>\n<td>&nbsp;e&nbsp;</td>\n<td>&nbsp;f&nbsp;</td>\n</tr></table>\n\n<h5 id=\"3-将array-1-与array-3-交换\"><a href=\"#3-将array-1-与array-3-交换\" class=\"headerlink\" title=\"3.  将array[1]与array[3]交换\"></a>3.  将array[1]与array[3]交换</h5><table><tr>\n<td>&nbsp;c&nbsp;</td>\n<td>&nbsp;<font color=\"red\">d</font>&nbsp;</td>\n<td>&nbsp;a&nbsp;</td>\n<td>&nbsp;<font color=\"red\">b</font>&nbsp;</td>\n<td>&nbsp;e&nbsp;</td>\n<td>&nbsp;f&nbsp;</td>\n</tr></table>\n\n<h5 id=\"4-将array-2-与array-4-交换\"><a href=\"#4-将array-2-与array-4-交换\" class=\"headerlink\" title=\"4. 将array[2]与array[4]交换\"></a>4. 将array[2]与array[4]交换</h5><table><tr>\n<td>&nbsp;c&nbsp;</td>\n<td>&nbsp;d&nbsp;</td>\n<td>&nbsp;<font color=\"red\">e</font>&nbsp;</td>\n<td>&nbsp;b&nbsp;</td>\n<td>&nbsp;<font color=\"red\">a</font>&nbsp;</td>\n<td>&nbsp;f&nbsp;</td>\n</tr></table>\n\n<h5 id=\"5-将array-3-与array-5-交换\"><a href=\"#5-将array-3-与array-5-交换\" class=\"headerlink\" title=\"5. 将array[3]与array[5]交换\"></a>5. 将array[3]与array[5]交换</h5><table><tr>\n<td>&nbsp;c&nbsp;</td>\n<td>&nbsp;d&nbsp;</td>\n<td>&nbsp;e&nbsp;</td>\n<td>&nbsp;<font color=\"red\">f</font>&nbsp;</td>\n<td>&nbsp;a&nbsp;</td>\n<td>&nbsp;<font color=\"red\">b</font>&nbsp;</td>\n</tr></table>\n\n<h5 id=\"这种实现方式需要进行n-m次交换，时间复杂度为O-n-需要两个额外空间，分别是交换数组元素的tmp指针，和记录当前交换位置的指针，这也符合常数空间复杂度O-1-。\"><a href=\"#这种实现方式需要进行n-m次交换，时间复杂度为O-n-需要两个额外空间，分别是交换数组元素的tmp指针，和记录当前交换位置的指针，这也符合常数空间复杂度O-1-。\" class=\"headerlink\" title=\"这种实现方式需要进行n-m次交换，时间复杂度为O(n),需要两个额外空间，分别是交换数组元素的tmp指针，和记录当前交换位置的指针，这也符合常数空间复杂度O(1)。\"></a>这种实现方式需要进行n-m次交换，时间复杂度为O(n),需要两个额外空间，分别是交换数组元素的tmp指针，和记录当前交换位置的指针，这也符合常数空间复杂度O(1)。</h5><h2 id=\"解题：\"><a href=\"#解题：\" class=\"headerlink\" title=\"解题：\"></a>解题：</h2><h4 id=\"看了网络上的一些其他解法，也比较巧妙\"><a href=\"#看了网络上的一些其他解法，也比较巧妙\" class=\"headerlink\" title=\"看了网络上的一些其他解法，也比较巧妙:\"></a>看了网络上的一些其他解法，也比较巧妙:</h4><ol>\n<li>首先将原字符串分为两个部分，即X:ab，Y:cdef；</li>\n<li>将X反转，X-&gt;X^T，即得：ab-&gt;ba；将Y反转，Y-&gt;Y^T，即得：cdef-&gt;fedc。</li>\n<li>反转上述步骤得到的结果字符串X^TY^T，即反转字符串bafedc的两部分（ba和fedc）给予反转，bafedc得到cdefab，形式化表示为(X^TY^T)^T=YX，这就实现了整个反转。</li>\n</ol>\n<pre><code class=\"lang-C\">void ReverseString(char* s,int from,int to)\n{\n    while (from &lt; to)\n    {\n        char t = s[from];\n        s[from++] = s[to];\n        s[to--] = t;\n    }\n}\n\nvoid LeftRotateString(char* s,int n,int m)\n{\n    m %= n;               //若要左移动大于n位，那么和%n 是等价的\n    ReverseString(s, 0, m - 1); //反转[0..m - 1]，套用到上面举的例子中，就是X-&gt;X^T，即 abc-&gt;cba\n    ReverseString(s, m, n - 1); //反转[m..n - 1]，例如Y-&gt;Y^T，即 def-&gt;fed\n    ReverseString(s, 0, n - 1); //反转[0..n - 1]，即如整个反转，(X^TY^T)^T=YX，即 cbafed-&gt;defabc。\n}\n</code></pre>\n<h5 id=\"调用3次此方法即可左旋字符串\"><a href=\"#调用3次此方法即可左旋字符串\" class=\"headerlink\" title=\"调用3次此方法即可左旋字符串\"></a>调用3次此方法即可左旋字符串</h5><h2 id=\"最后再说一些：\"><a href=\"#最后再说一些：\" class=\"headerlink\" title=\"最后再说一些：\"></a>最后再说一些：</h2><h5 id=\"对于时间复杂度和空间复杂度的计算，需要去低阶项，去掉常数项，去掉高阶项，T-n-2n2-n-1-O-n2-若执行时间是一个与问题规模n无关的常数，算法的时间复杂度为常数阶，记作T-n-O-1-。\"><a href=\"#对于时间复杂度和空间复杂度的计算，需要去低阶项，去掉常数项，去掉高阶项，T-n-2n2-n-1-O-n2-若执行时间是一个与问题规模n无关的常数，算法的时间复杂度为常数阶，记作T-n-O-1-。\" class=\"headerlink\" title=\"对于时间复杂度和空间复杂度的计算，需要去低阶项，去掉常数项，去掉高阶项，T(n)=(2n2+n+1)=O(n2);若执行时间是一个与问题规模n无关的常数，算法的时间复杂度为常数阶，记作T(n)=O(1)。\"></a>对于时间复杂度和空间复杂度的计算，需要去低阶项，去掉常数项，去掉高阶项，T(n)=(2n<sup>2</sup>+n+1)=O(n<sup>2</sup>);若执行时间是一个与问题规模n无关的常数，算法的时间复杂度为常数阶，记作T(n)=O(1)。</h5><h3 id=\"参考链接：\"><a href=\"#参考链接：\" class=\"headerlink\" title=\"参考链接：\"></a>参考链接：</h3><p><a href=\"http://taop.marchtea.com/01.01.html\" target=\"_blank\" rel=\"external\">http://taop.marchtea.com/01.01.html</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"题目要求：\"><a href=\"#题目要求：\" class=\"headerlink\" title=\"题目要求：\"></a>题目要求：</h2><h5 id=\"定义字符串的左旋转操作：把字符串前面的若干个字符移动到字符串的尾部。\"><a href=\"#定义字符串的左旋转操作：把字符串前面的若干个字符移动到字符串的尾部。\" class=\"headerlink\" title=\"定义字符串的左旋转操作：把字符串前面的若干个字符移动到字符串的尾部。\"></a>定义字符串的左旋转操作：把字符串前面的若干个字符移动到字符串的尾部。</h5><h5 id=\"如把字符串abcdef左旋转2位得到字符串cdefab。请实现字符串左旋转的函数。\"><a href=\"#如把字符串abcdef左旋转2位得到字符串cdefab。请实现字符串左旋转的函数。\" class=\"headerlink\" title=\"如把字符串abcdef左旋转2位得到字符串cdefab。请实现字符串左旋转的函数。\"></a>如把字符串abcdef左旋转2位得到字符串cdefab。请实现字符串左旋转的函数。</h5><h5 id=\"要求时间对长度为n的字符串操作的复杂度为O-n-，辅助内存为O-1-。\"><a href=\"#要求时间对长度为n的字符串操作的复杂度为O-n-，辅助内存为O-1-。\" class=\"headerlink\" title=\"要求时间对长度为n的字符串操作的复杂度为O(n)，辅助内存为O(1)。\"></a>要求时间对长度为n的字符串操作的复杂度为O(n)，辅助内存为O(1)。</h5>","more":"<h2 id=\"分析过程：\"><a href=\"#分析过程：\" class=\"headerlink\" title=\"分析过程：\"></a>分析过程：</h2><h5 id=\"题目要求很简单，其实就是字符串的位置交换，一个长度为n的字符串，将字符串的前面m个字符的子串和后面的字符进行位置交换。如果用普通的java代码进行编写的话，会非常简单\"><a href=\"#题目要求很简单，其实就是字符串的位置交换，一个长度为n的字符串，将字符串的前面m个字符的子串和后面的字符进行位置交换。如果用普通的java代码进行编写的话，会非常简单\" class=\"headerlink\" title=\"题目要求很简单，其实就是字符串的位置交换，一个长度为n的字符串，将字符串的前面m个字符的子串和后面的字符进行位置交换。如果用普通的java代码进行编写的话，会非常简单\"></a>题目要求很简单，其实就是字符串的位置交换，一个长度为n的字符串，将字符串的前面m个字符的子串和后面的字符进行位置交换。如果用普通的java代码进行编写的话，会非常简单</h5><pre><code class=\"lang-JAVA\">String result = start.substring(m,n) + start.substring(0, m);\n</code></pre>\n<h5 id=\"java对数组的复制使用System-arraycopy的本地方法，-以这种方式实现的话，时间复杂度是符合O-n-要求的，但是空间复杂度却要大于O-1-。这明显是不符合题意的。\"><a href=\"#java对数组的复制使用System-arraycopy的本地方法，-以这种方式实现的话，时间复杂度是符合O-n-要求的，但是空间复杂度却要大于O-1-。这明显是不符合题意的。\" class=\"headerlink\" title=\"java对数组的复制使用System.arraycopy的本地方法， 以这种方式实现的话，时间复杂度是符合O(n)要求的，但是空间复杂度却要大于O(1)。这明显是不符合题意的。\"></a>java对数组的复制使用System.arraycopy的本地方法， 以这种方式实现的话，时间复杂度是符合O(n)要求的，但是空间复杂度却要大于O(1)。这明显是不符合题意的。</h5><h5 id=\"首先，能够想到的是，字符串的左旋转，其实就是对字符数组的左旋转。既然是对数组的位置交换，则数组的每个位置的字符在交换之后的位置是已经确定的，并且能够找到一定的规律的。比如题目中的例子，把字符串abcdef左旋转2位得到字符串cdefab；\"><a href=\"#首先，能够想到的是，字符串的左旋转，其实就是对字符数组的左旋转。既然是对数组的位置交换，则数组的每个位置的字符在交换之后的位置是已经确定的，并且能够找到一定的规律的。比如题目中的例子，把字符串abcdef左旋转2位得到字符串cdefab；\" class=\"headerlink\" title=\"首先，能够想到的是，字符串的左旋转，其实就是对字符数组的左旋转。既然是对数组的位置交换，则数组的每个位置的字符在交换之后的位置是已经确定的，并且能够找到一定的规律的。比如题目中的例子，把字符串abcdef左旋转2位得到字符串cdefab；\"></a>首先，能够想到的是，字符串的左旋转，其实就是对字符数组的左旋转。既然是对数组的位置交换，则数组的每个位置的字符在交换之后的位置是已经确定的，并且能够找到一定的规律的。比如题目中的例子，把字符串abcdef左旋转2位得到字符串cdefab；</h5><h5 id=\"假设字符串的数组为arry-字符串的长度为6（n-6），左旋转2位（m-2），则数组中每一位的位置相应的转换为\"><a href=\"#假设字符串的数组为arry-字符串的长度为6（n-6），左旋转2位（m-2），则数组中每一位的位置相应的转换为\" class=\"headerlink\" title=\"假设字符串的数组为arry,字符串的长度为6（n=6），左旋转2位（m=2），则数组中每一位的位置相应的转换为\"></a>假设字符串的数组为arry,字符串的长度为6（n=6），左旋转2位（m=2），则数组中每一位的位置相应的转换为</h5><h6 id=\"a-array-0-gt-array-0-4-gt-array-4\"><a href=\"#a-array-0-gt-array-0-4-gt-array-4\" class=\"headerlink\" title=\"a:array[0] -&gt; array[0+4] -&gt; array[4]\"></a>a:array[0] -&gt; array[0+4] -&gt; array[4]</h6><h6 id=\"b-array-1-gt-array-1-4-gt-array-5\"><a href=\"#b-array-1-gt-array-1-4-gt-array-5\" class=\"headerlink\" title=\"b:array[1] -&gt; array[1+4] -&gt; array[5]\"></a>b:array[1] -&gt; array[1+4] -&gt; array[5]</h6><h6 id=\"c-array-2-gt-array-2-2-gt-array-0\"><a href=\"#c-array-2-gt-array-2-2-gt-array-0\" class=\"headerlink\" title=\"c:array[2] -&gt; array[2-2] -&gt; array[0]\"></a>c:array[2] -&gt; array[2-2] -&gt; array[0]</h6><h6 id=\"d-array-3-gt-array-3-2-gt-array-1\"><a href=\"#d-array-3-gt-array-3-2-gt-array-1\" class=\"headerlink\" title=\"d:array[3] -&gt; array[3-2] -&gt; array[1]\"></a>d:array[3] -&gt; array[3-2] -&gt; array[1]</h6><h6 id=\"e-array-4-gt-array-4-2-gt-array-2\"><a href=\"#e-array-4-gt-array-4-2-gt-array-2\" class=\"headerlink\" title=\"e:array[4] -&gt; array[4-2] -&gt; array[2]\"></a>e:array[4] -&gt; array[4-2] -&gt; array[2]</h6><h6 id=\"f-array-5-gt-array-5-2-gt-array-3\"><a href=\"#f-array-5-gt-array-5-2-gt-array-3\" class=\"headerlink\" title=\"f:array[5] -&gt; array[5-2] -&gt; array[3]\"></a>f:array[5] -&gt; array[5-2] -&gt; array[3]</h6><h5 id=\"可以看出，字符位置的交换是很有规律的，对于字符长度为n，左旋m位的数组\"><a href=\"#可以看出，字符位置的交换是很有规律的，对于字符长度为n，左旋m位的数组\" class=\"headerlink\" title=\"可以看出，字符位置的交换是很有规律的，对于字符长度为n，左旋m位的数组\"></a>可以看出，字符位置的交换是很有规律的，对于字符长度为n，左旋m位的数组</h5><ol>\n<li>前面m个字符，左旋后的位置为i+(n-m)</li>\n<li>后面n-m个字符，左旋后的位置为j-m</li>\n</ol>\n<h4 id=\"基于这套交换逻辑，想要实现如下算法，却发现不符合题目要求：\"><a href=\"#基于这套交换逻辑，想要实现如下算法，却发现不符合题目要求：\" class=\"headerlink\" title=\"基于这套交换逻辑，想要实现如下算法，却发现不符合题目要求：\"></a>基于这套交换逻辑，想要实现如下算法，却发现不符合题目要求：</h4><h5 id=\"1-初始字符串为abcdef，左旋转2位得到字符串cdefab\"><a href=\"#1-初始字符串为abcdef，左旋转2位得到字符串cdefab\" class=\"headerlink\" title=\"1. 初始字符串为abcdef，左旋转2位得到字符串cdefab\"></a>1. 初始字符串为abcdef，左旋转2位得到字符串cdefab</h5><table><tr>\n<td>&nbsp;a&nbsp;</td>\n<td>&nbsp;b&nbsp;</td>\n<td>&nbsp;c&nbsp;</td>\n<td>&nbsp;d&nbsp;</td>\n<td>&nbsp;e&nbsp;</td>\n<td>&nbsp;f&nbsp;</td>\n</tr></table>\n\n<h5 id=\"2-将array-0-写入到到array-4-，-用tmp记录array-4\"><a href=\"#2-将array-0-写入到到array-4-，-用tmp记录array-4\" class=\"headerlink\" title=\"2. 将array[0]写入到到array[4]， 用tmp记录array[4]\"></a>2. 将array[0]写入到到array[4]， 用tmp记录array[4]</h5><table><tr>\n<td>&nbsp;a&nbsp;</td>\n<td>&nbsp;b&nbsp;</td>\n<td>&nbsp;c&nbsp;</td>\n<td>&nbsp;d&nbsp;</td>\n<td>&nbsp;<font color=\"red\">a</font>&nbsp;</td>\n<td>&nbsp;f&nbsp;</td>\n</tr></table>\n\n<p>　　　tmp = e</p>\n<h5 id=\"3-将array-4-写入到到array-2-，-用tmp记录array-2\"><a href=\"#3-将array-4-写入到到array-2-，-用tmp记录array-2\" class=\"headerlink\" title=\"3. 将array[4]写入到到array[2]， 用tmp记录array[2]\"></a>3. 将array[4]写入到到array[2]， 用tmp记录array[2]</h5><table><tr>\n<td>&nbsp;a&nbsp;</td>\n<td>&nbsp;b&nbsp;</td>\n<td>&nbsp;<font color=\"red\">e</font>&nbsp;</td>\n<td>&nbsp;d&nbsp;</td>\n<td>&nbsp;a&nbsp;</td>\n<td>&nbsp;f&nbsp;</td>\n</tr></table>\n\n<p>　　　tmp = c</p>\n<h5 id=\"4-将array-2-写入到到array-0-，-用tmp记录array-0\"><a href=\"#4-将array-2-写入到到array-0-，-用tmp记录array-0\" class=\"headerlink\" title=\"4. 将array[2]写入到到array[0]， 用tmp记录array[0]\"></a>4. 将array[2]写入到到array[0]， 用tmp记录array[0]</h5><table><tr>\n<td>&nbsp;<font color=\"red\">c</font>&nbsp;</td>\n<td>&nbsp;b&nbsp;</td>\n<td>&nbsp;e&nbsp;</td>\n<td>&nbsp;d&nbsp;</td>\n<td>&nbsp;a&nbsp;</td>\n<td>&nbsp;f&nbsp;</td>\n</tr></table>\n\n<p>　　　tmp = a</p>\n<h5 id=\"问题就出在第四步，回到起点后，继续交换显然是错误的，这就需要额外的空间去记录那些位置是已经交换的，并且需要的额外空间随着原始字符串长度的增加而线性增长，所以这种方式的空间复杂度为O-n-不符合O-1-的要求。\"><a href=\"#问题就出在第四步，回到起点后，继续交换显然是错误的，这就需要额外的空间去记录那些位置是已经交换的，并且需要的额外空间随着原始字符串长度的增加而线性增长，所以这种方式的空间复杂度为O-n-不符合O-1-的要求。\" class=\"headerlink\" title=\"问题就出在第四步，回到起点后，继续交换显然是错误的，这就需要额外的空间去记录那些位置是已经交换的，并且需要的额外空间随着原始字符串长度的增加而线性增长，所以这种方式的空间复杂度为O(n),不符合O(1)的要求。\"></a>问题就出在第四步，回到起点后，继续交换显然是错误的，这就需要额外的空间去记录那些位置是已经交换的，并且需要的额外空间随着原始字符串长度的增加而线性增长，所以这种方式的空间复杂度为O(n),不符合O(1)的要求。</h5><h4 id=\"于是想到的另外一种解题方式，依次将数组元素与之后的第m位交换：\"><a href=\"#于是想到的另外一种解题方式，依次将数组元素与之后的第m位交换：\" class=\"headerlink\" title=\"于是想到的另外一种解题方式，依次将数组元素与之后的第m位交换：\"></a>于是想到的另外一种解题方式，依次将数组元素与之后的第m位交换：</h4><h5 id=\"1-初始字符串为abcdef，\"><a href=\"#1-初始字符串为abcdef，\" class=\"headerlink\" title=\"1. 初始字符串为abcdef，\"></a>1. 初始字符串为abcdef，</h5><table><tr>\n<td>&nbsp;a&nbsp;</td>\n<td>&nbsp;b&nbsp;</td>\n<td>&nbsp;c&nbsp;</td>\n<td>&nbsp;d&nbsp;</td>\n<td>&nbsp;e&nbsp;</td>\n<td>&nbsp;f&nbsp;</td>\n</tr></table>\n\n<h5 id=\"2-将array-0-与array-2-交换\"><a href=\"#2-将array-0-与array-2-交换\" class=\"headerlink\" title=\"2. 将array[0]与array[2]交换\"></a>2. 将array[0]与array[2]交换</h5><table><tr>\n<td>&nbsp;<font color=\"red\">c</font>&nbsp;</td>\n<td>&nbsp;b&nbsp;</td>\n<td>&nbsp;<font color=\"red\">a</font>&nbsp;</td>\n<td>&nbsp;d&nbsp;</td>\n<td>&nbsp;e&nbsp;</td>\n<td>&nbsp;f&nbsp;</td>\n</tr></table>\n\n<h5 id=\"3-将array-1-与array-3-交换\"><a href=\"#3-将array-1-与array-3-交换\" class=\"headerlink\" title=\"3.  将array[1]与array[3]交换\"></a>3.  将array[1]与array[3]交换</h5><table><tr>\n<td>&nbsp;c&nbsp;</td>\n<td>&nbsp;<font color=\"red\">d</font>&nbsp;</td>\n<td>&nbsp;a&nbsp;</td>\n<td>&nbsp;<font color=\"red\">b</font>&nbsp;</td>\n<td>&nbsp;e&nbsp;</td>\n<td>&nbsp;f&nbsp;</td>\n</tr></table>\n\n<h5 id=\"4-将array-2-与array-4-交换\"><a href=\"#4-将array-2-与array-4-交换\" class=\"headerlink\" title=\"4. 将array[2]与array[4]交换\"></a>4. 将array[2]与array[4]交换</h5><table><tr>\n<td>&nbsp;c&nbsp;</td>\n<td>&nbsp;d&nbsp;</td>\n<td>&nbsp;<font color=\"red\">e</font>&nbsp;</td>\n<td>&nbsp;b&nbsp;</td>\n<td>&nbsp;<font color=\"red\">a</font>&nbsp;</td>\n<td>&nbsp;f&nbsp;</td>\n</tr></table>\n\n<h5 id=\"5-将array-3-与array-5-交换\"><a href=\"#5-将array-3-与array-5-交换\" class=\"headerlink\" title=\"5. 将array[3]与array[5]交换\"></a>5. 将array[3]与array[5]交换</h5><table><tr>\n<td>&nbsp;c&nbsp;</td>\n<td>&nbsp;d&nbsp;</td>\n<td>&nbsp;e&nbsp;</td>\n<td>&nbsp;<font color=\"red\">f</font>&nbsp;</td>\n<td>&nbsp;a&nbsp;</td>\n<td>&nbsp;<font color=\"red\">b</font>&nbsp;</td>\n</tr></table>\n\n<h5 id=\"这种实现方式需要进行n-m次交换，时间复杂度为O-n-需要两个额外空间，分别是交换数组元素的tmp指针，和记录当前交换位置的指针，这也符合常数空间复杂度O-1-。\"><a href=\"#这种实现方式需要进行n-m次交换，时间复杂度为O-n-需要两个额外空间，分别是交换数组元素的tmp指针，和记录当前交换位置的指针，这也符合常数空间复杂度O-1-。\" class=\"headerlink\" title=\"这种实现方式需要进行n-m次交换，时间复杂度为O(n),需要两个额外空间，分别是交换数组元素的tmp指针，和记录当前交换位置的指针，这也符合常数空间复杂度O(1)。\"></a>这种实现方式需要进行n-m次交换，时间复杂度为O(n),需要两个额外空间，分别是交换数组元素的tmp指针，和记录当前交换位置的指针，这也符合常数空间复杂度O(1)。</h5><h2 id=\"解题：\"><a href=\"#解题：\" class=\"headerlink\" title=\"解题：\"></a>解题：</h2><h4 id=\"看了网络上的一些其他解法，也比较巧妙\"><a href=\"#看了网络上的一些其他解法，也比较巧妙\" class=\"headerlink\" title=\"看了网络上的一些其他解法，也比较巧妙:\"></a>看了网络上的一些其他解法，也比较巧妙:</h4><ol>\n<li>首先将原字符串分为两个部分，即X:ab，Y:cdef；</li>\n<li>将X反转，X-&gt;X^T，即得：ab-&gt;ba；将Y反转，Y-&gt;Y^T，即得：cdef-&gt;fedc。</li>\n<li>反转上述步骤得到的结果字符串X^TY^T，即反转字符串bafedc的两部分（ba和fedc）给予反转，bafedc得到cdefab，形式化表示为(X^TY^T)^T=YX，这就实现了整个反转。</li>\n</ol>\n<pre><code class=\"lang-C\">void ReverseString(char* s,int from,int to)\n{\n    while (from &lt; to)\n    {\n        char t = s[from];\n        s[from++] = s[to];\n        s[to--] = t;\n    }\n}\n\nvoid LeftRotateString(char* s,int n,int m)\n{\n    m %= n;               //若要左移动大于n位，那么和%n 是等价的\n    ReverseString(s, 0, m - 1); //反转[0..m - 1]，套用到上面举的例子中，就是X-&gt;X^T，即 abc-&gt;cba\n    ReverseString(s, m, n - 1); //反转[m..n - 1]，例如Y-&gt;Y^T，即 def-&gt;fed\n    ReverseString(s, 0, n - 1); //反转[0..n - 1]，即如整个反转，(X^TY^T)^T=YX，即 cbafed-&gt;defabc。\n}\n</code></pre>\n<h5 id=\"调用3次此方法即可左旋字符串\"><a href=\"#调用3次此方法即可左旋字符串\" class=\"headerlink\" title=\"调用3次此方法即可左旋字符串\"></a>调用3次此方法即可左旋字符串</h5><h2 id=\"最后再说一些：\"><a href=\"#最后再说一些：\" class=\"headerlink\" title=\"最后再说一些：\"></a>最后再说一些：</h2><h5 id=\"对于时间复杂度和空间复杂度的计算，需要去低阶项，去掉常数项，去掉高阶项，T-n-2n2-n-1-O-n2-若执行时间是一个与问题规模n无关的常数，算法的时间复杂度为常数阶，记作T-n-O-1-。\"><a href=\"#对于时间复杂度和空间复杂度的计算，需要去低阶项，去掉常数项，去掉高阶项，T-n-2n2-n-1-O-n2-若执行时间是一个与问题规模n无关的常数，算法的时间复杂度为常数阶，记作T-n-O-1-。\" class=\"headerlink\" title=\"对于时间复杂度和空间复杂度的计算，需要去低阶项，去掉常数项，去掉高阶项，T(n)=(2n2+n+1)=O(n2);若执行时间是一个与问题规模n无关的常数，算法的时间复杂度为常数阶，记作T(n)=O(1)。\"></a>对于时间复杂度和空间复杂度的计算，需要去低阶项，去掉常数项，去掉高阶项，T(n)=(2n<sup>2</sup>+n+1)=O(n<sup>2</sup>);若执行时间是一个与问题规模n无关的常数，算法的时间复杂度为常数阶，记作T(n)=O(1)。</h5><h3 id=\"参考链接：\"><a href=\"#参考链接：\" class=\"headerlink\" title=\"参考链接：\"></a>参考链接：</h3><p><a href=\"http://taop.marchtea.com/01.01.html\" target=\"_blank\" rel=\"external\">http://taop.marchtea.com/01.01.html</a></p>"},{"layout":"post","title":"判断两个链表是否相交","date":"2017-02-24T16:00:00.000Z","original":true,"tag":[["算法","arithmetic"]],"_content":"\n## 题目要求：\n##### 给出俩个单向链表的头指针，比如h1，h2，判断这俩个链表是否相交。\n##### 这个题目可以扩展成很多问题，每个子问题都值得学习。\n<!--more-->\n## 题目扩展（均为单链表）：\n1. 判断这俩个链表是否相交（无环）\n2. 判断链表是否有环\n3. 如何知道环的长度？\n4. 如何找出环的连接点在哪里？\n5. 带环链表的长度是多少？\n6. 链表有环，判断相交\n7. 判断两个链表相交的第一个节点\n##### 下面我们一个一个的来解决这些问题\n\n### 问题1：判断这俩个链表是否相交（无环）\n##### 两个无环链表的相交问题，如果两个链表相交，则他们一定存在公共节点，且公共节点之后的节点全部都是相交的。则他们的结构为：\n![二元查找树](../../img/arithmetic/linked.jpg)\n##### 如果两个链表相交，则他们的尾节点一定是同一个节点，所以可以直接对比两个链表的尾部节点是否相。时间复杂度为两个链表的长度之和O(m+n)。\n##### 这种解法比较简单，只要想到最后一个节点相等就可以，后面还会有一些其他的解法介绍。\n\n### 问题2：判断链表是否有环\n##### 对于这个问题，可以使用一种追赶的方法。设定两个指针slow、fast，从头指针开始，每次分别前进1步、2步。如存在环，则两者相遇；如不存在环，fast遇到NULL退出。\n##### 这个过程比较好理解，如果存在环，所以fast指针则会在环内循环，直至slow指针进入环内，并且追赶上slow指针。因为fast每次两部，slow每次一步，试验后发现fast指针不会跳过slow指针，因此如果有换，则必定会在一个节点相交。\n\n### 问题3：如何知道环的长度？\n##### 基于上一步，我们已经判断一个链表是否有环，如果有环的话，如何判断环的长度呢。\n##### 还是一样的方法，在上一个问题中，fast和slow将相交于环内一点，fast的速度是slow的两倍，则只需要fast和slow继续以原速度前进，当他们再次相交时，slow所走了步数为环的长度。\n\n### 问题4：如何找出环的连接点在哪里？\n##### 相对于上面两个问题，这个问题相对更复杂一些。回到问题\"判断链表是否有环\"。\n##### 当fast指针和slow指针相交时，slow指针必定未走完一圈，因为在slow进入环入口时，fast指针已经在环内，这就成了一个fast追赶slow的问题，除了fast和slow已经相交，否则fast追赶上slow，slow用不了一周。因此此时slow还未第二次经过入口节点。\n1. 假设slow进过的节点数量为r，则fast为2r\n2. 假设环的长度为s，因为slow和fast已经在同一点，而fast比slow多走了r个节点，所以r = ns。n为常数，大于等于1，代表的是fast绕环的次数。\n3. 假设头节点为点a，入口节点为b，fast和slow相遇节点为c，则ac = r = ns = ab + bc；bc + cb = s；（bc表示从入口节点至相遇节点，cb表示从相遇节点至入口节点） ab = r - bc；所以，ab - cb = (n-1)s；\n![单链表带环](../../img/arithmetic/linked2.jpg)\n##### 因此，从头节点a和相遇节点c重新开始走，第一次相遇的节点为入口节点b。从a节点走的指针步数为1，从c节点走的指针步数则大于等于1,因为大于1时，无非就是n大一些，多走了几圈。\n\n### 问题5：带环链表的长度是多少？\n##### 问题4可以求出头节点到入口节点的长度，加上问题3的环长度，等于链表长度。或者问题4求出入口节点，以及问题2的相遇节点。都可以求出链表长度。\n\n### 问题6：链表有环，判断相交\n##### 一个链表有环，一个链表无环的情况下。两个链表不可能相交。\n##### 两个链表均有环，则两个链表的环一定是共有的。则可以判断一个链表的相遇点，相遇点一定处于环内，再判断该点是否存在于另一个链表当中。","source":"_posts/arithmetic/linkedList.md","raw":"---\nlayout: post\ntitle: 判断两个链表是否相交\ndate: 2017/02/25\ntags: [tech, arithmetic, index]\noriginal: true\ntag: [[算法, arithmetic]]\n---\n\n## 题目要求：\n##### 给出俩个单向链表的头指针，比如h1，h2，判断这俩个链表是否相交。\n##### 这个题目可以扩展成很多问题，每个子问题都值得学习。\n<!--more-->\n## 题目扩展（均为单链表）：\n1. 判断这俩个链表是否相交（无环）\n2. 判断链表是否有环\n3. 如何知道环的长度？\n4. 如何找出环的连接点在哪里？\n5. 带环链表的长度是多少？\n6. 链表有环，判断相交\n7. 判断两个链表相交的第一个节点\n##### 下面我们一个一个的来解决这些问题\n\n### 问题1：判断这俩个链表是否相交（无环）\n##### 两个无环链表的相交问题，如果两个链表相交，则他们一定存在公共节点，且公共节点之后的节点全部都是相交的。则他们的结构为：\n![二元查找树](../../img/arithmetic/linked.jpg)\n##### 如果两个链表相交，则他们的尾节点一定是同一个节点，所以可以直接对比两个链表的尾部节点是否相。时间复杂度为两个链表的长度之和O(m+n)。\n##### 这种解法比较简单，只要想到最后一个节点相等就可以，后面还会有一些其他的解法介绍。\n\n### 问题2：判断链表是否有环\n##### 对于这个问题，可以使用一种追赶的方法。设定两个指针slow、fast，从头指针开始，每次分别前进1步、2步。如存在环，则两者相遇；如不存在环，fast遇到NULL退出。\n##### 这个过程比较好理解，如果存在环，所以fast指针则会在环内循环，直至slow指针进入环内，并且追赶上slow指针。因为fast每次两部，slow每次一步，试验后发现fast指针不会跳过slow指针，因此如果有换，则必定会在一个节点相交。\n\n### 问题3：如何知道环的长度？\n##### 基于上一步，我们已经判断一个链表是否有环，如果有环的话，如何判断环的长度呢。\n##### 还是一样的方法，在上一个问题中，fast和slow将相交于环内一点，fast的速度是slow的两倍，则只需要fast和slow继续以原速度前进，当他们再次相交时，slow所走了步数为环的长度。\n\n### 问题4：如何找出环的连接点在哪里？\n##### 相对于上面两个问题，这个问题相对更复杂一些。回到问题\"判断链表是否有环\"。\n##### 当fast指针和slow指针相交时，slow指针必定未走完一圈，因为在slow进入环入口时，fast指针已经在环内，这就成了一个fast追赶slow的问题，除了fast和slow已经相交，否则fast追赶上slow，slow用不了一周。因此此时slow还未第二次经过入口节点。\n1. 假设slow进过的节点数量为r，则fast为2r\n2. 假设环的长度为s，因为slow和fast已经在同一点，而fast比slow多走了r个节点，所以r = ns。n为常数，大于等于1，代表的是fast绕环的次数。\n3. 假设头节点为点a，入口节点为b，fast和slow相遇节点为c，则ac = r = ns = ab + bc；bc + cb = s；（bc表示从入口节点至相遇节点，cb表示从相遇节点至入口节点） ab = r - bc；所以，ab - cb = (n-1)s；\n![单链表带环](../../img/arithmetic/linked2.jpg)\n##### 因此，从头节点a和相遇节点c重新开始走，第一次相遇的节点为入口节点b。从a节点走的指针步数为1，从c节点走的指针步数则大于等于1,因为大于1时，无非就是n大一些，多走了几圈。\n\n### 问题5：带环链表的长度是多少？\n##### 问题4可以求出头节点到入口节点的长度，加上问题3的环长度，等于链表长度。或者问题4求出入口节点，以及问题2的相遇节点。都可以求出链表长度。\n\n### 问题6：链表有环，判断相交\n##### 一个链表有环，一个链表无环的情况下。两个链表不可能相交。\n##### 两个链表均有环，则两个链表的环一定是共有的。则可以判断一个链表的相遇点，相遇点一定处于环内，再判断该点是否存在于另一个链表当中。","slug":"arithmetic/linkedList","published":1,"updated":"2017-10-06T16:03:22.648Z","comments":1,"photos":[],"link":"","_id":"cj8jros74000b30s69lvrys09","content":"<h2 id=\"题目要求：\"><a href=\"#题目要求：\" class=\"headerlink\" title=\"题目要求：\"></a>题目要求：</h2><h5 id=\"给出俩个单向链表的头指针，比如h1，h2，判断这俩个链表是否相交。\"><a href=\"#给出俩个单向链表的头指针，比如h1，h2，判断这俩个链表是否相交。\" class=\"headerlink\" title=\"给出俩个单向链表的头指针，比如h1，h2，判断这俩个链表是否相交。\"></a>给出俩个单向链表的头指针，比如h1，h2，判断这俩个链表是否相交。</h5><h5 id=\"这个题目可以扩展成很多问题，每个子问题都值得学习。\"><a href=\"#这个题目可以扩展成很多问题，每个子问题都值得学习。\" class=\"headerlink\" title=\"这个题目可以扩展成很多问题，每个子问题都值得学习。\"></a>这个题目可以扩展成很多问题，每个子问题都值得学习。</h5><a id=\"more\"></a>\n<h2 id=\"题目扩展（均为单链表）：\"><a href=\"#题目扩展（均为单链表）：\" class=\"headerlink\" title=\"题目扩展（均为单链表）：\"></a>题目扩展（均为单链表）：</h2><ol>\n<li>判断这俩个链表是否相交（无环）</li>\n<li>判断链表是否有环</li>\n<li>如何知道环的长度？</li>\n<li>如何找出环的连接点在哪里？</li>\n<li>带环链表的长度是多少？</li>\n<li>链表有环，判断相交</li>\n<li>判断两个链表相交的第一个节点<h5 id=\"下面我们一个一个的来解决这些问题\"><a href=\"#下面我们一个一个的来解决这些问题\" class=\"headerlink\" title=\"下面我们一个一个的来解决这些问题\"></a>下面我们一个一个的来解决这些问题</h5></li>\n</ol>\n<h3 id=\"问题1：判断这俩个链表是否相交（无环）\"><a href=\"#问题1：判断这俩个链表是否相交（无环）\" class=\"headerlink\" title=\"问题1：判断这俩个链表是否相交（无环）\"></a>问题1：判断这俩个链表是否相交（无环）</h3><h5 id=\"两个无环链表的相交问题，如果两个链表相交，则他们一定存在公共节点，且公共节点之后的节点全部都是相交的。则他们的结构为：\"><a href=\"#两个无环链表的相交问题，如果两个链表相交，则他们一定存在公共节点，且公共节点之后的节点全部都是相交的。则他们的结构为：\" class=\"headerlink\" title=\"两个无环链表的相交问题，如果两个链表相交，则他们一定存在公共节点，且公共节点之后的节点全部都是相交的。则他们的结构为：\"></a>两个无环链表的相交问题，如果两个链表相交，则他们一定存在公共节点，且公共节点之后的节点全部都是相交的。则他们的结构为：</h5><p><img src=\"../../img/arithmetic/linked.jpg\" alt=\"二元查找树\"></p>\n<h5 id=\"如果两个链表相交，则他们的尾节点一定是同一个节点，所以可以直接对比两个链表的尾部节点是否相。时间复杂度为两个链表的长度之和O-m-n-。\"><a href=\"#如果两个链表相交，则他们的尾节点一定是同一个节点，所以可以直接对比两个链表的尾部节点是否相。时间复杂度为两个链表的长度之和O-m-n-。\" class=\"headerlink\" title=\"如果两个链表相交，则他们的尾节点一定是同一个节点，所以可以直接对比两个链表的尾部节点是否相。时间复杂度为两个链表的长度之和O(m+n)。\"></a>如果两个链表相交，则他们的尾节点一定是同一个节点，所以可以直接对比两个链表的尾部节点是否相。时间复杂度为两个链表的长度之和O(m+n)。</h5><h5 id=\"这种解法比较简单，只要想到最后一个节点相等就可以，后面还会有一些其他的解法介绍。\"><a href=\"#这种解法比较简单，只要想到最后一个节点相等就可以，后面还会有一些其他的解法介绍。\" class=\"headerlink\" title=\"这种解法比较简单，只要想到最后一个节点相等就可以，后面还会有一些其他的解法介绍。\"></a>这种解法比较简单，只要想到最后一个节点相等就可以，后面还会有一些其他的解法介绍。</h5><h3 id=\"问题2：判断链表是否有环\"><a href=\"#问题2：判断链表是否有环\" class=\"headerlink\" title=\"问题2：判断链表是否有环\"></a>问题2：判断链表是否有环</h3><h5 id=\"对于这个问题，可以使用一种追赶的方法。设定两个指针slow、fast，从头指针开始，每次分别前进1步、2步。如存在环，则两者相遇；如不存在环，fast遇到NULL退出。\"><a href=\"#对于这个问题，可以使用一种追赶的方法。设定两个指针slow、fast，从头指针开始，每次分别前进1步、2步。如存在环，则两者相遇；如不存在环，fast遇到NULL退出。\" class=\"headerlink\" title=\"对于这个问题，可以使用一种追赶的方法。设定两个指针slow、fast，从头指针开始，每次分别前进1步、2步。如存在环，则两者相遇；如不存在环，fast遇到NULL退出。\"></a>对于这个问题，可以使用一种追赶的方法。设定两个指针slow、fast，从头指针开始，每次分别前进1步、2步。如存在环，则两者相遇；如不存在环，fast遇到NULL退出。</h5><h5 id=\"这个过程比较好理解，如果存在环，所以fast指针则会在环内循环，直至slow指针进入环内，并且追赶上slow指针。因为fast每次两部，slow每次一步，试验后发现fast指针不会跳过slow指针，因此如果有换，则必定会在一个节点相交。\"><a href=\"#这个过程比较好理解，如果存在环，所以fast指针则会在环内循环，直至slow指针进入环内，并且追赶上slow指针。因为fast每次两部，slow每次一步，试验后发现fast指针不会跳过slow指针，因此如果有换，则必定会在一个节点相交。\" class=\"headerlink\" title=\"这个过程比较好理解，如果存在环，所以fast指针则会在环内循环，直至slow指针进入环内，并且追赶上slow指针。因为fast每次两部，slow每次一步，试验后发现fast指针不会跳过slow指针，因此如果有换，则必定会在一个节点相交。\"></a>这个过程比较好理解，如果存在环，所以fast指针则会在环内循环，直至slow指针进入环内，并且追赶上slow指针。因为fast每次两部，slow每次一步，试验后发现fast指针不会跳过slow指针，因此如果有换，则必定会在一个节点相交。</h5><h3 id=\"问题3：如何知道环的长度？\"><a href=\"#问题3：如何知道环的长度？\" class=\"headerlink\" title=\"问题3：如何知道环的长度？\"></a>问题3：如何知道环的长度？</h3><h5 id=\"基于上一步，我们已经判断一个链表是否有环，如果有环的话，如何判断环的长度呢。\"><a href=\"#基于上一步，我们已经判断一个链表是否有环，如果有环的话，如何判断环的长度呢。\" class=\"headerlink\" title=\"基于上一步，我们已经判断一个链表是否有环，如果有环的话，如何判断环的长度呢。\"></a>基于上一步，我们已经判断一个链表是否有环，如果有环的话，如何判断环的长度呢。</h5><h5 id=\"还是一样的方法，在上一个问题中，fast和slow将相交于环内一点，fast的速度是slow的两倍，则只需要fast和slow继续以原速度前进，当他们再次相交时，slow所走了步数为环的长度。\"><a href=\"#还是一样的方法，在上一个问题中，fast和slow将相交于环内一点，fast的速度是slow的两倍，则只需要fast和slow继续以原速度前进，当他们再次相交时，slow所走了步数为环的长度。\" class=\"headerlink\" title=\"还是一样的方法，在上一个问题中，fast和slow将相交于环内一点，fast的速度是slow的两倍，则只需要fast和slow继续以原速度前进，当他们再次相交时，slow所走了步数为环的长度。\"></a>还是一样的方法，在上一个问题中，fast和slow将相交于环内一点，fast的速度是slow的两倍，则只需要fast和slow继续以原速度前进，当他们再次相交时，slow所走了步数为环的长度。</h5><h3 id=\"问题4：如何找出环的连接点在哪里？\"><a href=\"#问题4：如何找出环的连接点在哪里？\" class=\"headerlink\" title=\"问题4：如何找出环的连接点在哪里？\"></a>问题4：如何找出环的连接点在哪里？</h3><h5 id=\"相对于上面两个问题，这个问题相对更复杂一些。回到问题”判断链表是否有环”。\"><a href=\"#相对于上面两个问题，这个问题相对更复杂一些。回到问题”判断链表是否有环”。\" class=\"headerlink\" title=\"相对于上面两个问题，这个问题相对更复杂一些。回到问题”判断链表是否有环”。\"></a>相对于上面两个问题，这个问题相对更复杂一些。回到问题”判断链表是否有环”。</h5><h5 id=\"当fast指针和slow指针相交时，slow指针必定未走完一圈，因为在slow进入环入口时，fast指针已经在环内，这就成了一个fast追赶slow的问题，除了fast和slow已经相交，否则fast追赶上slow，slow用不了一周。因此此时slow还未第二次经过入口节点。\"><a href=\"#当fast指针和slow指针相交时，slow指针必定未走完一圈，因为在slow进入环入口时，fast指针已经在环内，这就成了一个fast追赶slow的问题，除了fast和slow已经相交，否则fast追赶上slow，slow用不了一周。因此此时slow还未第二次经过入口节点。\" class=\"headerlink\" title=\"当fast指针和slow指针相交时，slow指针必定未走完一圈，因为在slow进入环入口时，fast指针已经在环内，这就成了一个fast追赶slow的问题，除了fast和slow已经相交，否则fast追赶上slow，slow用不了一周。因此此时slow还未第二次经过入口节点。\"></a>当fast指针和slow指针相交时，slow指针必定未走完一圈，因为在slow进入环入口时，fast指针已经在环内，这就成了一个fast追赶slow的问题，除了fast和slow已经相交，否则fast追赶上slow，slow用不了一周。因此此时slow还未第二次经过入口节点。</h5><ol>\n<li>假设slow进过的节点数量为r，则fast为2r</li>\n<li>假设环的长度为s，因为slow和fast已经在同一点，而fast比slow多走了r个节点，所以r = ns。n为常数，大于等于1，代表的是fast绕环的次数。</li>\n<li>假设头节点为点a，入口节点为b，fast和slow相遇节点为c，则ac = r = ns = ab + bc；bc + cb = s；（bc表示从入口节点至相遇节点，cb表示从相遇节点至入口节点） ab = r - bc；所以，ab - cb = (n-1)s；<br><img src=\"../../img/arithmetic/linked2.jpg\" alt=\"单链表带环\"><h5 id=\"因此，从头节点a和相遇节点c重新开始走，第一次相遇的节点为入口节点b。从a节点走的指针步数为1，从c节点走的指针步数则大于等于1-因为大于1时，无非就是n大一些，多走了几圈。\"><a href=\"#因此，从头节点a和相遇节点c重新开始走，第一次相遇的节点为入口节点b。从a节点走的指针步数为1，从c节点走的指针步数则大于等于1-因为大于1时，无非就是n大一些，多走了几圈。\" class=\"headerlink\" title=\"因此，从头节点a和相遇节点c重新开始走，第一次相遇的节点为入口节点b。从a节点走的指针步数为1，从c节点走的指针步数则大于等于1,因为大于1时，无非就是n大一些，多走了几圈。\"></a>因此，从头节点a和相遇节点c重新开始走，第一次相遇的节点为入口节点b。从a节点走的指针步数为1，从c节点走的指针步数则大于等于1,因为大于1时，无非就是n大一些，多走了几圈。</h5></li>\n</ol>\n<h3 id=\"问题5：带环链表的长度是多少？\"><a href=\"#问题5：带环链表的长度是多少？\" class=\"headerlink\" title=\"问题5：带环链表的长度是多少？\"></a>问题5：带环链表的长度是多少？</h3><h5 id=\"问题4可以求出头节点到入口节点的长度，加上问题3的环长度，等于链表长度。或者问题4求出入口节点，以及问题2的相遇节点。都可以求出链表长度。\"><a href=\"#问题4可以求出头节点到入口节点的长度，加上问题3的环长度，等于链表长度。或者问题4求出入口节点，以及问题2的相遇节点。都可以求出链表长度。\" class=\"headerlink\" title=\"问题4可以求出头节点到入口节点的长度，加上问题3的环长度，等于链表长度。或者问题4求出入口节点，以及问题2的相遇节点。都可以求出链表长度。\"></a>问题4可以求出头节点到入口节点的长度，加上问题3的环长度，等于链表长度。或者问题4求出入口节点，以及问题2的相遇节点。都可以求出链表长度。</h5><h3 id=\"问题6：链表有环，判断相交\"><a href=\"#问题6：链表有环，判断相交\" class=\"headerlink\" title=\"问题6：链表有环，判断相交\"></a>问题6：链表有环，判断相交</h3><h5 id=\"一个链表有环，一个链表无环的情况下。两个链表不可能相交。\"><a href=\"#一个链表有环，一个链表无环的情况下。两个链表不可能相交。\" class=\"headerlink\" title=\"一个链表有环，一个链表无环的情况下。两个链表不可能相交。\"></a>一个链表有环，一个链表无环的情况下。两个链表不可能相交。</h5><h5 id=\"两个链表均有环，则两个链表的环一定是共有的。则可以判断一个链表的相遇点，相遇点一定处于环内，再判断该点是否存在于另一个链表当中。\"><a href=\"#两个链表均有环，则两个链表的环一定是共有的。则可以判断一个链表的相遇点，相遇点一定处于环内，再判断该点是否存在于另一个链表当中。\" class=\"headerlink\" title=\"两个链表均有环，则两个链表的环一定是共有的。则可以判断一个链表的相遇点，相遇点一定处于环内，再判断该点是否存在于另一个链表当中。\"></a>两个链表均有环，则两个链表的环一定是共有的。则可以判断一个链表的相遇点，相遇点一定处于环内，再判断该点是否存在于另一个链表当中。</h5>","site":{"data":{}},"excerpt":"<h2 id=\"题目要求：\"><a href=\"#题目要求：\" class=\"headerlink\" title=\"题目要求：\"></a>题目要求：</h2><h5 id=\"给出俩个单向链表的头指针，比如h1，h2，判断这俩个链表是否相交。\"><a href=\"#给出俩个单向链表的头指针，比如h1，h2，判断这俩个链表是否相交。\" class=\"headerlink\" title=\"给出俩个单向链表的头指针，比如h1，h2，判断这俩个链表是否相交。\"></a>给出俩个单向链表的头指针，比如h1，h2，判断这俩个链表是否相交。</h5><h5 id=\"这个题目可以扩展成很多问题，每个子问题都值得学习。\"><a href=\"#这个题目可以扩展成很多问题，每个子问题都值得学习。\" class=\"headerlink\" title=\"这个题目可以扩展成很多问题，每个子问题都值得学习。\"></a>这个题目可以扩展成很多问题，每个子问题都值得学习。</h5>","more":"<h2 id=\"题目扩展（均为单链表）：\"><a href=\"#题目扩展（均为单链表）：\" class=\"headerlink\" title=\"题目扩展（均为单链表）：\"></a>题目扩展（均为单链表）：</h2><ol>\n<li>判断这俩个链表是否相交（无环）</li>\n<li>判断链表是否有环</li>\n<li>如何知道环的长度？</li>\n<li>如何找出环的连接点在哪里？</li>\n<li>带环链表的长度是多少？</li>\n<li>链表有环，判断相交</li>\n<li>判断两个链表相交的第一个节点<h5 id=\"下面我们一个一个的来解决这些问题\"><a href=\"#下面我们一个一个的来解决这些问题\" class=\"headerlink\" title=\"下面我们一个一个的来解决这些问题\"></a>下面我们一个一个的来解决这些问题</h5></li>\n</ol>\n<h3 id=\"问题1：判断这俩个链表是否相交（无环）\"><a href=\"#问题1：判断这俩个链表是否相交（无环）\" class=\"headerlink\" title=\"问题1：判断这俩个链表是否相交（无环）\"></a>问题1：判断这俩个链表是否相交（无环）</h3><h5 id=\"两个无环链表的相交问题，如果两个链表相交，则他们一定存在公共节点，且公共节点之后的节点全部都是相交的。则他们的结构为：\"><a href=\"#两个无环链表的相交问题，如果两个链表相交，则他们一定存在公共节点，且公共节点之后的节点全部都是相交的。则他们的结构为：\" class=\"headerlink\" title=\"两个无环链表的相交问题，如果两个链表相交，则他们一定存在公共节点，且公共节点之后的节点全部都是相交的。则他们的结构为：\"></a>两个无环链表的相交问题，如果两个链表相交，则他们一定存在公共节点，且公共节点之后的节点全部都是相交的。则他们的结构为：</h5><p><img src=\"../../img/arithmetic/linked.jpg\" alt=\"二元查找树\"></p>\n<h5 id=\"如果两个链表相交，则他们的尾节点一定是同一个节点，所以可以直接对比两个链表的尾部节点是否相。时间复杂度为两个链表的长度之和O-m-n-。\"><a href=\"#如果两个链表相交，则他们的尾节点一定是同一个节点，所以可以直接对比两个链表的尾部节点是否相。时间复杂度为两个链表的长度之和O-m-n-。\" class=\"headerlink\" title=\"如果两个链表相交，则他们的尾节点一定是同一个节点，所以可以直接对比两个链表的尾部节点是否相。时间复杂度为两个链表的长度之和O(m+n)。\"></a>如果两个链表相交，则他们的尾节点一定是同一个节点，所以可以直接对比两个链表的尾部节点是否相。时间复杂度为两个链表的长度之和O(m+n)。</h5><h5 id=\"这种解法比较简单，只要想到最后一个节点相等就可以，后面还会有一些其他的解法介绍。\"><a href=\"#这种解法比较简单，只要想到最后一个节点相等就可以，后面还会有一些其他的解法介绍。\" class=\"headerlink\" title=\"这种解法比较简单，只要想到最后一个节点相等就可以，后面还会有一些其他的解法介绍。\"></a>这种解法比较简单，只要想到最后一个节点相等就可以，后面还会有一些其他的解法介绍。</h5><h3 id=\"问题2：判断链表是否有环\"><a href=\"#问题2：判断链表是否有环\" class=\"headerlink\" title=\"问题2：判断链表是否有环\"></a>问题2：判断链表是否有环</h3><h5 id=\"对于这个问题，可以使用一种追赶的方法。设定两个指针slow、fast，从头指针开始，每次分别前进1步、2步。如存在环，则两者相遇；如不存在环，fast遇到NULL退出。\"><a href=\"#对于这个问题，可以使用一种追赶的方法。设定两个指针slow、fast，从头指针开始，每次分别前进1步、2步。如存在环，则两者相遇；如不存在环，fast遇到NULL退出。\" class=\"headerlink\" title=\"对于这个问题，可以使用一种追赶的方法。设定两个指针slow、fast，从头指针开始，每次分别前进1步、2步。如存在环，则两者相遇；如不存在环，fast遇到NULL退出。\"></a>对于这个问题，可以使用一种追赶的方法。设定两个指针slow、fast，从头指针开始，每次分别前进1步、2步。如存在环，则两者相遇；如不存在环，fast遇到NULL退出。</h5><h5 id=\"这个过程比较好理解，如果存在环，所以fast指针则会在环内循环，直至slow指针进入环内，并且追赶上slow指针。因为fast每次两部，slow每次一步，试验后发现fast指针不会跳过slow指针，因此如果有换，则必定会在一个节点相交。\"><a href=\"#这个过程比较好理解，如果存在环，所以fast指针则会在环内循环，直至slow指针进入环内，并且追赶上slow指针。因为fast每次两部，slow每次一步，试验后发现fast指针不会跳过slow指针，因此如果有换，则必定会在一个节点相交。\" class=\"headerlink\" title=\"这个过程比较好理解，如果存在环，所以fast指针则会在环内循环，直至slow指针进入环内，并且追赶上slow指针。因为fast每次两部，slow每次一步，试验后发现fast指针不会跳过slow指针，因此如果有换，则必定会在一个节点相交。\"></a>这个过程比较好理解，如果存在环，所以fast指针则会在环内循环，直至slow指针进入环内，并且追赶上slow指针。因为fast每次两部，slow每次一步，试验后发现fast指针不会跳过slow指针，因此如果有换，则必定会在一个节点相交。</h5><h3 id=\"问题3：如何知道环的长度？\"><a href=\"#问题3：如何知道环的长度？\" class=\"headerlink\" title=\"问题3：如何知道环的长度？\"></a>问题3：如何知道环的长度？</h3><h5 id=\"基于上一步，我们已经判断一个链表是否有环，如果有环的话，如何判断环的长度呢。\"><a href=\"#基于上一步，我们已经判断一个链表是否有环，如果有环的话，如何判断环的长度呢。\" class=\"headerlink\" title=\"基于上一步，我们已经判断一个链表是否有环，如果有环的话，如何判断环的长度呢。\"></a>基于上一步，我们已经判断一个链表是否有环，如果有环的话，如何判断环的长度呢。</h5><h5 id=\"还是一样的方法，在上一个问题中，fast和slow将相交于环内一点，fast的速度是slow的两倍，则只需要fast和slow继续以原速度前进，当他们再次相交时，slow所走了步数为环的长度。\"><a href=\"#还是一样的方法，在上一个问题中，fast和slow将相交于环内一点，fast的速度是slow的两倍，则只需要fast和slow继续以原速度前进，当他们再次相交时，slow所走了步数为环的长度。\" class=\"headerlink\" title=\"还是一样的方法，在上一个问题中，fast和slow将相交于环内一点，fast的速度是slow的两倍，则只需要fast和slow继续以原速度前进，当他们再次相交时，slow所走了步数为环的长度。\"></a>还是一样的方法，在上一个问题中，fast和slow将相交于环内一点，fast的速度是slow的两倍，则只需要fast和slow继续以原速度前进，当他们再次相交时，slow所走了步数为环的长度。</h5><h3 id=\"问题4：如何找出环的连接点在哪里？\"><a href=\"#问题4：如何找出环的连接点在哪里？\" class=\"headerlink\" title=\"问题4：如何找出环的连接点在哪里？\"></a>问题4：如何找出环的连接点在哪里？</h3><h5 id=\"相对于上面两个问题，这个问题相对更复杂一些。回到问题”判断链表是否有环”。\"><a href=\"#相对于上面两个问题，这个问题相对更复杂一些。回到问题”判断链表是否有环”。\" class=\"headerlink\" title=\"相对于上面两个问题，这个问题相对更复杂一些。回到问题”判断链表是否有环”。\"></a>相对于上面两个问题，这个问题相对更复杂一些。回到问题”判断链表是否有环”。</h5><h5 id=\"当fast指针和slow指针相交时，slow指针必定未走完一圈，因为在slow进入环入口时，fast指针已经在环内，这就成了一个fast追赶slow的问题，除了fast和slow已经相交，否则fast追赶上slow，slow用不了一周。因此此时slow还未第二次经过入口节点。\"><a href=\"#当fast指针和slow指针相交时，slow指针必定未走完一圈，因为在slow进入环入口时，fast指针已经在环内，这就成了一个fast追赶slow的问题，除了fast和slow已经相交，否则fast追赶上slow，slow用不了一周。因此此时slow还未第二次经过入口节点。\" class=\"headerlink\" title=\"当fast指针和slow指针相交时，slow指针必定未走完一圈，因为在slow进入环入口时，fast指针已经在环内，这就成了一个fast追赶slow的问题，除了fast和slow已经相交，否则fast追赶上slow，slow用不了一周。因此此时slow还未第二次经过入口节点。\"></a>当fast指针和slow指针相交时，slow指针必定未走完一圈，因为在slow进入环入口时，fast指针已经在环内，这就成了一个fast追赶slow的问题，除了fast和slow已经相交，否则fast追赶上slow，slow用不了一周。因此此时slow还未第二次经过入口节点。</h5><ol>\n<li>假设slow进过的节点数量为r，则fast为2r</li>\n<li>假设环的长度为s，因为slow和fast已经在同一点，而fast比slow多走了r个节点，所以r = ns。n为常数，大于等于1，代表的是fast绕环的次数。</li>\n<li>假设头节点为点a，入口节点为b，fast和slow相遇节点为c，则ac = r = ns = ab + bc；bc + cb = s；（bc表示从入口节点至相遇节点，cb表示从相遇节点至入口节点） ab = r - bc；所以，ab - cb = (n-1)s；<br><img src=\"../../img/arithmetic/linked2.jpg\" alt=\"单链表带环\"><h5 id=\"因此，从头节点a和相遇节点c重新开始走，第一次相遇的节点为入口节点b。从a节点走的指针步数为1，从c节点走的指针步数则大于等于1-因为大于1时，无非就是n大一些，多走了几圈。\"><a href=\"#因此，从头节点a和相遇节点c重新开始走，第一次相遇的节点为入口节点b。从a节点走的指针步数为1，从c节点走的指针步数则大于等于1-因为大于1时，无非就是n大一些，多走了几圈。\" class=\"headerlink\" title=\"因此，从头节点a和相遇节点c重新开始走，第一次相遇的节点为入口节点b。从a节点走的指针步数为1，从c节点走的指针步数则大于等于1,因为大于1时，无非就是n大一些，多走了几圈。\"></a>因此，从头节点a和相遇节点c重新开始走，第一次相遇的节点为入口节点b。从a节点走的指针步数为1，从c节点走的指针步数则大于等于1,因为大于1时，无非就是n大一些，多走了几圈。</h5></li>\n</ol>\n<h3 id=\"问题5：带环链表的长度是多少？\"><a href=\"#问题5：带环链表的长度是多少？\" class=\"headerlink\" title=\"问题5：带环链表的长度是多少？\"></a>问题5：带环链表的长度是多少？</h3><h5 id=\"问题4可以求出头节点到入口节点的长度，加上问题3的环长度，等于链表长度。或者问题4求出入口节点，以及问题2的相遇节点。都可以求出链表长度。\"><a href=\"#问题4可以求出头节点到入口节点的长度，加上问题3的环长度，等于链表长度。或者问题4求出入口节点，以及问题2的相遇节点。都可以求出链表长度。\" class=\"headerlink\" title=\"问题4可以求出头节点到入口节点的长度，加上问题3的环长度，等于链表长度。或者问题4求出入口节点，以及问题2的相遇节点。都可以求出链表长度。\"></a>问题4可以求出头节点到入口节点的长度，加上问题3的环长度，等于链表长度。或者问题4求出入口节点，以及问题2的相遇节点。都可以求出链表长度。</h5><h3 id=\"问题6：链表有环，判断相交\"><a href=\"#问题6：链表有环，判断相交\" class=\"headerlink\" title=\"问题6：链表有环，判断相交\"></a>问题6：链表有环，判断相交</h3><h5 id=\"一个链表有环，一个链表无环的情况下。两个链表不可能相交。\"><a href=\"#一个链表有环，一个链表无环的情况下。两个链表不可能相交。\" class=\"headerlink\" title=\"一个链表有环，一个链表无环的情况下。两个链表不可能相交。\"></a>一个链表有环，一个链表无环的情况下。两个链表不可能相交。</h5><h5 id=\"两个链表均有环，则两个链表的环一定是共有的。则可以判断一个链表的相遇点，相遇点一定处于环内，再判断该点是否存在于另一个链表当中。\"><a href=\"#两个链表均有环，则两个链表的环一定是共有的。则可以判断一个链表的相遇点，相遇点一定处于环内，再判断该点是否存在于另一个链表当中。\" class=\"headerlink\" title=\"两个链表均有环，则两个链表的环一定是共有的。则可以判断一个链表的相遇点，相遇点一定处于环内，再判断该点是否存在于另一个链表当中。\"></a>两个链表均有环，则两个链表的环一定是共有的。则可以判断一个链表的相遇点，相遇点一定处于环内，再判断该点是否存在于另一个链表当中。</h5>"},{"layout":"post","title":"妇女节快乐，字符串包含","date":"2017-03-07T16:00:00.000Z","original":true,"tag":[["算法","arithmetic"]],"_content":"\n## 题目要求：\n##### 给定两个分别由字母组成的字符串A和字符串B，字符串B的长度比字符串A短。请问，如何最快地判断字符串B中所有字母是否都在字符串A里？\n##### 为了简单起见，我们规定输入的字符串只包含大写英文字母\n<!--more-->\n\n#### 比如\n##### String 1：ABCD\n##### String 2：BAD\n##### 答案是true，即String2里的字母在String1里也都有，或者说String2是String1的真子集。\n##### 如果是下面两个字符串：\n##### String 1：ABCD\n##### String 2：BCE\n##### 答案是false，因为字符串String2里的E字母不在字符串String1里。\n\n\n## 分析过程：\n##### 题目可以简单理解成集合A，集合B。判断集合B是否为集合A的真子集。只是与集合不同的是，在本题中，字符串中是允许存在相同的字符的，这无疑是增加了题目的难度。\n\n### 最简单的解法\n##### 最容易想到的也就是最简单的解决方法当然是依次比较。利用两层循环，遍历字符串B，将字符串B中每一个字符在字符串A中依次比较，看是否存在于字符串A中。\n##### 假设字符串A的长度为n，字符串B的长度为m，则该方法的时间复杂度为O(n*m)。\n\n### 利用排序优化算法时间\n##### 上一种解法的时间复杂度无疑是最长的。我们当然可以利用排序对算法进行优化。方法是先将字符串A进行堆排序，其时间复杂度为O(n log n)。之后再将字符串B中的每个字符在排序后的堆中查找，则时间复杂度为O(m log n)。相加后的时间复杂度O((m+n) log n)\n\n### 最优解法，时间复杂度O(m+n)\n##### 题目到这好像没有办法解决下去，两个字符串的长度分别为n和m。只遍历一遍就得出结果，这种算法真的存在吗？其实这个题目就可以简化成集合元素存在的判断。\n##### 这里又要用到二进制的概念，二进制的一些属性完美的解决了题目中的一些问题。\n#### 1.相同字符的处理\n##### \"或\"操作指的是，两个相应的二进位中只要有一个为1，该位的结果值为1。\n##### 0101 OR 0011 = 0111\n##### 所以当两个相同字符存在时，用或操作，还是得到一个字符的值。\n#### 2.字符的存在问题，如何判断一个字符存在于字符集\n##### \"与\"操作指的是，两个相应的二进位都为1，该位的结果值才为1\n##### 0101 AND 0011 = 0001\n##### 也就是只有两边都存在同一个字符时，才会得出1\n\n##### 因此我们可以将所有字符都进行二进制的编码，因为每一个字符都有两种状态（存在和不存在），所以对应在二进制中，每一个字符都占用一位。\n```c\nbool StringContain(string &a,string &b)\n{\n    int hash = 0;\n    for (int i = 0; i < a.length(); ++i)\n    {\n        hash |= (1 << (a[i] - 'A'));\n    }\n    for (int i = 0; i < b.length(); ++i)\n    {\n        if ((hash & (1 << (b[i] - 'A'))) == 0)\n        {\n            return false;\n        }\n    }\n    return true;\n}\n```\n\n\n## 最后再说一些：\n##### 最后的算法和之前的[切金条](http://localhost:4000/arithmetic/glodBars/)算法有一些相似之处。这是这里对二进制的理解和运用更加灵活。只有对此很熟悉，才能想到这种方法。否则会比较困难。\n","source":"_posts/arithmetic/stringContains.md","raw":"---\nlayout: post\ntitle: 妇女节快乐，字符串包含\ndate: 2017/03/08\noriginal: true\ntags: [tech, arithmetic, index]\ntag: [[算法, arithmetic]]\n---\n\n## 题目要求：\n##### 给定两个分别由字母组成的字符串A和字符串B，字符串B的长度比字符串A短。请问，如何最快地判断字符串B中所有字母是否都在字符串A里？\n##### 为了简单起见，我们规定输入的字符串只包含大写英文字母\n<!--more-->\n\n#### 比如\n##### String 1：ABCD\n##### String 2：BAD\n##### 答案是true，即String2里的字母在String1里也都有，或者说String2是String1的真子集。\n##### 如果是下面两个字符串：\n##### String 1：ABCD\n##### String 2：BCE\n##### 答案是false，因为字符串String2里的E字母不在字符串String1里。\n\n\n## 分析过程：\n##### 题目可以简单理解成集合A，集合B。判断集合B是否为集合A的真子集。只是与集合不同的是，在本题中，字符串中是允许存在相同的字符的，这无疑是增加了题目的难度。\n\n### 最简单的解法\n##### 最容易想到的也就是最简单的解决方法当然是依次比较。利用两层循环，遍历字符串B，将字符串B中每一个字符在字符串A中依次比较，看是否存在于字符串A中。\n##### 假设字符串A的长度为n，字符串B的长度为m，则该方法的时间复杂度为O(n*m)。\n\n### 利用排序优化算法时间\n##### 上一种解法的时间复杂度无疑是最长的。我们当然可以利用排序对算法进行优化。方法是先将字符串A进行堆排序，其时间复杂度为O(n log n)。之后再将字符串B中的每个字符在排序后的堆中查找，则时间复杂度为O(m log n)。相加后的时间复杂度O((m+n) log n)\n\n### 最优解法，时间复杂度O(m+n)\n##### 题目到这好像没有办法解决下去，两个字符串的长度分别为n和m。只遍历一遍就得出结果，这种算法真的存在吗？其实这个题目就可以简化成集合元素存在的判断。\n##### 这里又要用到二进制的概念，二进制的一些属性完美的解决了题目中的一些问题。\n#### 1.相同字符的处理\n##### \"或\"操作指的是，两个相应的二进位中只要有一个为1，该位的结果值为1。\n##### 0101 OR 0011 = 0111\n##### 所以当两个相同字符存在时，用或操作，还是得到一个字符的值。\n#### 2.字符的存在问题，如何判断一个字符存在于字符集\n##### \"与\"操作指的是，两个相应的二进位都为1，该位的结果值才为1\n##### 0101 AND 0011 = 0001\n##### 也就是只有两边都存在同一个字符时，才会得出1\n\n##### 因此我们可以将所有字符都进行二进制的编码，因为每一个字符都有两种状态（存在和不存在），所以对应在二进制中，每一个字符都占用一位。\n```c\nbool StringContain(string &a,string &b)\n{\n    int hash = 0;\n    for (int i = 0; i < a.length(); ++i)\n    {\n        hash |= (1 << (a[i] - 'A'));\n    }\n    for (int i = 0; i < b.length(); ++i)\n    {\n        if ((hash & (1 << (b[i] - 'A'))) == 0)\n        {\n            return false;\n        }\n    }\n    return true;\n}\n```\n\n\n## 最后再说一些：\n##### 最后的算法和之前的[切金条](http://localhost:4000/arithmetic/glodBars/)算法有一些相似之处。这是这里对二进制的理解和运用更加灵活。只有对此很熟悉，才能想到这种方法。否则会比较困难。\n","slug":"arithmetic/stringContains","published":1,"updated":"2017-10-06T16:03:22.634Z","comments":1,"photos":[],"link":"","_id":"cj8jros76000d30s655rdl9gr","content":"<h2 id=\"题目要求：\"><a href=\"#题目要求：\" class=\"headerlink\" title=\"题目要求：\"></a>题目要求：</h2><h5 id=\"给定两个分别由字母组成的字符串A和字符串B，字符串B的长度比字符串A短。请问，如何最快地判断字符串B中所有字母是否都在字符串A里？\"><a href=\"#给定两个分别由字母组成的字符串A和字符串B，字符串B的长度比字符串A短。请问，如何最快地判断字符串B中所有字母是否都在字符串A里？\" class=\"headerlink\" title=\"给定两个分别由字母组成的字符串A和字符串B，字符串B的长度比字符串A短。请问，如何最快地判断字符串B中所有字母是否都在字符串A里？\"></a>给定两个分别由字母组成的字符串A和字符串B，字符串B的长度比字符串A短。请问，如何最快地判断字符串B中所有字母是否都在字符串A里？</h5><h5 id=\"为了简单起见，我们规定输入的字符串只包含大写英文字母\"><a href=\"#为了简单起见，我们规定输入的字符串只包含大写英文字母\" class=\"headerlink\" title=\"为了简单起见，我们规定输入的字符串只包含大写英文字母\"></a>为了简单起见，我们规定输入的字符串只包含大写英文字母</h5><a id=\"more\"></a>\n<h4 id=\"比如\"><a href=\"#比如\" class=\"headerlink\" title=\"比如\"></a>比如</h4><h5 id=\"String-1：ABCD\"><a href=\"#String-1：ABCD\" class=\"headerlink\" title=\"String 1：ABCD\"></a>String 1：ABCD</h5><h5 id=\"String-2：BAD\"><a href=\"#String-2：BAD\" class=\"headerlink\" title=\"String 2：BAD\"></a>String 2：BAD</h5><h5 id=\"答案是true，即String2里的字母在String1里也都有，或者说String2是String1的真子集。\"><a href=\"#答案是true，即String2里的字母在String1里也都有，或者说String2是String1的真子集。\" class=\"headerlink\" title=\"答案是true，即String2里的字母在String1里也都有，或者说String2是String1的真子集。\"></a>答案是true，即String2里的字母在String1里也都有，或者说String2是String1的真子集。</h5><h5 id=\"如果是下面两个字符串：\"><a href=\"#如果是下面两个字符串：\" class=\"headerlink\" title=\"如果是下面两个字符串：\"></a>如果是下面两个字符串：</h5><h5 id=\"String-1：ABCD-1\"><a href=\"#String-1：ABCD-1\" class=\"headerlink\" title=\"String 1：ABCD\"></a>String 1：ABCD</h5><h5 id=\"String-2：BCE\"><a href=\"#String-2：BCE\" class=\"headerlink\" title=\"String 2：BCE\"></a>String 2：BCE</h5><h5 id=\"答案是false，因为字符串String2里的E字母不在字符串String1里。\"><a href=\"#答案是false，因为字符串String2里的E字母不在字符串String1里。\" class=\"headerlink\" title=\"答案是false，因为字符串String2里的E字母不在字符串String1里。\"></a>答案是false，因为字符串String2里的E字母不在字符串String1里。</h5><h2 id=\"分析过程：\"><a href=\"#分析过程：\" class=\"headerlink\" title=\"分析过程：\"></a>分析过程：</h2><h5 id=\"题目可以简单理解成集合A，集合B。判断集合B是否为集合A的真子集。只是与集合不同的是，在本题中，字符串中是允许存在相同的字符的，这无疑是增加了题目的难度。\"><a href=\"#题目可以简单理解成集合A，集合B。判断集合B是否为集合A的真子集。只是与集合不同的是，在本题中，字符串中是允许存在相同的字符的，这无疑是增加了题目的难度。\" class=\"headerlink\" title=\"题目可以简单理解成集合A，集合B。判断集合B是否为集合A的真子集。只是与集合不同的是，在本题中，字符串中是允许存在相同的字符的，这无疑是增加了题目的难度。\"></a>题目可以简单理解成集合A，集合B。判断集合B是否为集合A的真子集。只是与集合不同的是，在本题中，字符串中是允许存在相同的字符的，这无疑是增加了题目的难度。</h5><h3 id=\"最简单的解法\"><a href=\"#最简单的解法\" class=\"headerlink\" title=\"最简单的解法\"></a>最简单的解法</h3><h5 id=\"最容易想到的也就是最简单的解决方法当然是依次比较。利用两层循环，遍历字符串B，将字符串B中每一个字符在字符串A中依次比较，看是否存在于字符串A中。\"><a href=\"#最容易想到的也就是最简单的解决方法当然是依次比较。利用两层循环，遍历字符串B，将字符串B中每一个字符在字符串A中依次比较，看是否存在于字符串A中。\" class=\"headerlink\" title=\"最容易想到的也就是最简单的解决方法当然是依次比较。利用两层循环，遍历字符串B，将字符串B中每一个字符在字符串A中依次比较，看是否存在于字符串A中。\"></a>最容易想到的也就是最简单的解决方法当然是依次比较。利用两层循环，遍历字符串B，将字符串B中每一个字符在字符串A中依次比较，看是否存在于字符串A中。</h5><h5 id=\"假设字符串A的长度为n，字符串B的长度为m，则该方法的时间复杂度为O-n-m-。\"><a href=\"#假设字符串A的长度为n，字符串B的长度为m，则该方法的时间复杂度为O-n-m-。\" class=\"headerlink\" title=\"假设字符串A的长度为n，字符串B的长度为m，则该方法的时间复杂度为O(n*m)。\"></a>假设字符串A的长度为n，字符串B的长度为m，则该方法的时间复杂度为O(n*m)。</h5><h3 id=\"利用排序优化算法时间\"><a href=\"#利用排序优化算法时间\" class=\"headerlink\" title=\"利用排序优化算法时间\"></a>利用排序优化算法时间</h3><h5 id=\"上一种解法的时间复杂度无疑是最长的。我们当然可以利用排序对算法进行优化。方法是先将字符串A进行堆排序，其时间复杂度为O-n-log-n-。之后再将字符串B中的每个字符在排序后的堆中查找，则时间复杂度为O-m-log-n-。相加后的时间复杂度O-m-n-log-n\"><a href=\"#上一种解法的时间复杂度无疑是最长的。我们当然可以利用排序对算法进行优化。方法是先将字符串A进行堆排序，其时间复杂度为O-n-log-n-。之后再将字符串B中的每个字符在排序后的堆中查找，则时间复杂度为O-m-log-n-。相加后的时间复杂度O-m-n-log-n\" class=\"headerlink\" title=\"上一种解法的时间复杂度无疑是最长的。我们当然可以利用排序对算法进行优化。方法是先将字符串A进行堆排序，其时间复杂度为O(n log n)。之后再将字符串B中的每个字符在排序后的堆中查找，则时间复杂度为O(m log n)。相加后的时间复杂度O((m+n) log n)\"></a>上一种解法的时间复杂度无疑是最长的。我们当然可以利用排序对算法进行优化。方法是先将字符串A进行堆排序，其时间复杂度为O(n log n)。之后再将字符串B中的每个字符在排序后的堆中查找，则时间复杂度为O(m log n)。相加后的时间复杂度O((m+n) log n)</h5><h3 id=\"最优解法，时间复杂度O-m-n\"><a href=\"#最优解法，时间复杂度O-m-n\" class=\"headerlink\" title=\"最优解法，时间复杂度O(m+n)\"></a>最优解法，时间复杂度O(m+n)</h3><h5 id=\"题目到这好像没有办法解决下去，两个字符串的长度分别为n和m。只遍历一遍就得出结果，这种算法真的存在吗？其实这个题目就可以简化成集合元素存在的判断。\"><a href=\"#题目到这好像没有办法解决下去，两个字符串的长度分别为n和m。只遍历一遍就得出结果，这种算法真的存在吗？其实这个题目就可以简化成集合元素存在的判断。\" class=\"headerlink\" title=\"题目到这好像没有办法解决下去，两个字符串的长度分别为n和m。只遍历一遍就得出结果，这种算法真的存在吗？其实这个题目就可以简化成集合元素存在的判断。\"></a>题目到这好像没有办法解决下去，两个字符串的长度分别为n和m。只遍历一遍就得出结果，这种算法真的存在吗？其实这个题目就可以简化成集合元素存在的判断。</h5><h5 id=\"这里又要用到二进制的概念，二进制的一些属性完美的解决了题目中的一些问题。\"><a href=\"#这里又要用到二进制的概念，二进制的一些属性完美的解决了题目中的一些问题。\" class=\"headerlink\" title=\"这里又要用到二进制的概念，二进制的一些属性完美的解决了题目中的一些问题。\"></a>这里又要用到二进制的概念，二进制的一些属性完美的解决了题目中的一些问题。</h5><h4 id=\"1-相同字符的处理\"><a href=\"#1-相同字符的处理\" class=\"headerlink\" title=\"1.相同字符的处理\"></a>1.相同字符的处理</h4><h5 id=\"“或”操作指的是，两个相应的二进位中只要有一个为1，该位的结果值为1。\"><a href=\"#“或”操作指的是，两个相应的二进位中只要有一个为1，该位的结果值为1。\" class=\"headerlink\" title=\"“或”操作指的是，两个相应的二进位中只要有一个为1，该位的结果值为1。\"></a>“或”操作指的是，两个相应的二进位中只要有一个为1，该位的结果值为1。</h5><h5 id=\"0101-OR-0011-0111\"><a href=\"#0101-OR-0011-0111\" class=\"headerlink\" title=\"0101 OR 0011 = 0111\"></a>0101 OR 0011 = 0111</h5><h5 id=\"所以当两个相同字符存在时，用或操作，还是得到一个字符的值。\"><a href=\"#所以当两个相同字符存在时，用或操作，还是得到一个字符的值。\" class=\"headerlink\" title=\"所以当两个相同字符存在时，用或操作，还是得到一个字符的值。\"></a>所以当两个相同字符存在时，用或操作，还是得到一个字符的值。</h5><h4 id=\"2-字符的存在问题，如何判断一个字符存在于字符集\"><a href=\"#2-字符的存在问题，如何判断一个字符存在于字符集\" class=\"headerlink\" title=\"2.字符的存在问题，如何判断一个字符存在于字符集\"></a>2.字符的存在问题，如何判断一个字符存在于字符集</h4><h5 id=\"“与”操作指的是，两个相应的二进位都为1，该位的结果值才为1\"><a href=\"#“与”操作指的是，两个相应的二进位都为1，该位的结果值才为1\" class=\"headerlink\" title=\"“与”操作指的是，两个相应的二进位都为1，该位的结果值才为1\"></a>“与”操作指的是，两个相应的二进位都为1，该位的结果值才为1</h5><h5 id=\"0101-AND-0011-0001\"><a href=\"#0101-AND-0011-0001\" class=\"headerlink\" title=\"0101 AND 0011 = 0001\"></a>0101 AND 0011 = 0001</h5><h5 id=\"也就是只有两边都存在同一个字符时，才会得出1\"><a href=\"#也就是只有两边都存在同一个字符时，才会得出1\" class=\"headerlink\" title=\"也就是只有两边都存在同一个字符时，才会得出1\"></a>也就是只有两边都存在同一个字符时，才会得出1</h5><h5 id=\"因此我们可以将所有字符都进行二进制的编码，因为每一个字符都有两种状态（存在和不存在），所以对应在二进制中，每一个字符都占用一位。\"><a href=\"#因此我们可以将所有字符都进行二进制的编码，因为每一个字符都有两种状态（存在和不存在），所以对应在二进制中，每一个字符都占用一位。\" class=\"headerlink\" title=\"因此我们可以将所有字符都进行二进制的编码，因为每一个字符都有两种状态（存在和不存在），所以对应在二进制中，每一个字符都占用一位。\"></a>因此我们可以将所有字符都进行二进制的编码，因为每一个字符都有两种状态（存在和不存在），所以对应在二进制中，每一个字符都占用一位。</h5><pre><code class=\"lang-c\">bool StringContain(string &amp;a,string &amp;b)\n{\n    int hash = 0;\n    for (int i = 0; i &lt; a.length(); ++i)\n    {\n        hash |= (1 &lt;&lt; (a[i] - &#39;A&#39;));\n    }\n    for (int i = 0; i &lt; b.length(); ++i)\n    {\n        if ((hash &amp; (1 &lt;&lt; (b[i] - &#39;A&#39;))) == 0)\n        {\n            return false;\n        }\n    }\n    return true;\n}\n</code></pre>\n<h2 id=\"最后再说一些：\"><a href=\"#最后再说一些：\" class=\"headerlink\" title=\"最后再说一些：\"></a>最后再说一些：</h2><h5 id=\"最后的算法和之前的切金条算法有一些相似之处。这是这里对二进制的理解和运用更加灵活。只有对此很熟悉，才能想到这种方法。否则会比较困难。\"><a href=\"#最后的算法和之前的切金条算法有一些相似之处。这是这里对二进制的理解和运用更加灵活。只有对此很熟悉，才能想到这种方法。否则会比较困难。\" class=\"headerlink\" title=\"最后的算法和之前的切金条算法有一些相似之处。这是这里对二进制的理解和运用更加灵活。只有对此很熟悉，才能想到这种方法。否则会比较困难。\"></a>最后的算法和之前的<a href=\"http://localhost:4000/arithmetic/glodBars/\" target=\"_blank\" rel=\"external\">切金条</a>算法有一些相似之处。这是这里对二进制的理解和运用更加灵活。只有对此很熟悉，才能想到这种方法。否则会比较困难。</h5>","site":{"data":{}},"excerpt":"<h2 id=\"题目要求：\"><a href=\"#题目要求：\" class=\"headerlink\" title=\"题目要求：\"></a>题目要求：</h2><h5 id=\"给定两个分别由字母组成的字符串A和字符串B，字符串B的长度比字符串A短。请问，如何最快地判断字符串B中所有字母是否都在字符串A里？\"><a href=\"#给定两个分别由字母组成的字符串A和字符串B，字符串B的长度比字符串A短。请问，如何最快地判断字符串B中所有字母是否都在字符串A里？\" class=\"headerlink\" title=\"给定两个分别由字母组成的字符串A和字符串B，字符串B的长度比字符串A短。请问，如何最快地判断字符串B中所有字母是否都在字符串A里？\"></a>给定两个分别由字母组成的字符串A和字符串B，字符串B的长度比字符串A短。请问，如何最快地判断字符串B中所有字母是否都在字符串A里？</h5><h5 id=\"为了简单起见，我们规定输入的字符串只包含大写英文字母\"><a href=\"#为了简单起见，我们规定输入的字符串只包含大写英文字母\" class=\"headerlink\" title=\"为了简单起见，我们规定输入的字符串只包含大写英文字母\"></a>为了简单起见，我们规定输入的字符串只包含大写英文字母</h5>","more":"<h4 id=\"比如\"><a href=\"#比如\" class=\"headerlink\" title=\"比如\"></a>比如</h4><h5 id=\"String-1：ABCD\"><a href=\"#String-1：ABCD\" class=\"headerlink\" title=\"String 1：ABCD\"></a>String 1：ABCD</h5><h5 id=\"String-2：BAD\"><a href=\"#String-2：BAD\" class=\"headerlink\" title=\"String 2：BAD\"></a>String 2：BAD</h5><h5 id=\"答案是true，即String2里的字母在String1里也都有，或者说String2是String1的真子集。\"><a href=\"#答案是true，即String2里的字母在String1里也都有，或者说String2是String1的真子集。\" class=\"headerlink\" title=\"答案是true，即String2里的字母在String1里也都有，或者说String2是String1的真子集。\"></a>答案是true，即String2里的字母在String1里也都有，或者说String2是String1的真子集。</h5><h5 id=\"如果是下面两个字符串：\"><a href=\"#如果是下面两个字符串：\" class=\"headerlink\" title=\"如果是下面两个字符串：\"></a>如果是下面两个字符串：</h5><h5 id=\"String-1：ABCD-1\"><a href=\"#String-1：ABCD-1\" class=\"headerlink\" title=\"String 1：ABCD\"></a>String 1：ABCD</h5><h5 id=\"String-2：BCE\"><a href=\"#String-2：BCE\" class=\"headerlink\" title=\"String 2：BCE\"></a>String 2：BCE</h5><h5 id=\"答案是false，因为字符串String2里的E字母不在字符串String1里。\"><a href=\"#答案是false，因为字符串String2里的E字母不在字符串String1里。\" class=\"headerlink\" title=\"答案是false，因为字符串String2里的E字母不在字符串String1里。\"></a>答案是false，因为字符串String2里的E字母不在字符串String1里。</h5><h2 id=\"分析过程：\"><a href=\"#分析过程：\" class=\"headerlink\" title=\"分析过程：\"></a>分析过程：</h2><h5 id=\"题目可以简单理解成集合A，集合B。判断集合B是否为集合A的真子集。只是与集合不同的是，在本题中，字符串中是允许存在相同的字符的，这无疑是增加了题目的难度。\"><a href=\"#题目可以简单理解成集合A，集合B。判断集合B是否为集合A的真子集。只是与集合不同的是，在本题中，字符串中是允许存在相同的字符的，这无疑是增加了题目的难度。\" class=\"headerlink\" title=\"题目可以简单理解成集合A，集合B。判断集合B是否为集合A的真子集。只是与集合不同的是，在本题中，字符串中是允许存在相同的字符的，这无疑是增加了题目的难度。\"></a>题目可以简单理解成集合A，集合B。判断集合B是否为集合A的真子集。只是与集合不同的是，在本题中，字符串中是允许存在相同的字符的，这无疑是增加了题目的难度。</h5><h3 id=\"最简单的解法\"><a href=\"#最简单的解法\" class=\"headerlink\" title=\"最简单的解法\"></a>最简单的解法</h3><h5 id=\"最容易想到的也就是最简单的解决方法当然是依次比较。利用两层循环，遍历字符串B，将字符串B中每一个字符在字符串A中依次比较，看是否存在于字符串A中。\"><a href=\"#最容易想到的也就是最简单的解决方法当然是依次比较。利用两层循环，遍历字符串B，将字符串B中每一个字符在字符串A中依次比较，看是否存在于字符串A中。\" class=\"headerlink\" title=\"最容易想到的也就是最简单的解决方法当然是依次比较。利用两层循环，遍历字符串B，将字符串B中每一个字符在字符串A中依次比较，看是否存在于字符串A中。\"></a>最容易想到的也就是最简单的解决方法当然是依次比较。利用两层循环，遍历字符串B，将字符串B中每一个字符在字符串A中依次比较，看是否存在于字符串A中。</h5><h5 id=\"假设字符串A的长度为n，字符串B的长度为m，则该方法的时间复杂度为O-n-m-。\"><a href=\"#假设字符串A的长度为n，字符串B的长度为m，则该方法的时间复杂度为O-n-m-。\" class=\"headerlink\" title=\"假设字符串A的长度为n，字符串B的长度为m，则该方法的时间复杂度为O(n*m)。\"></a>假设字符串A的长度为n，字符串B的长度为m，则该方法的时间复杂度为O(n*m)。</h5><h3 id=\"利用排序优化算法时间\"><a href=\"#利用排序优化算法时间\" class=\"headerlink\" title=\"利用排序优化算法时间\"></a>利用排序优化算法时间</h3><h5 id=\"上一种解法的时间复杂度无疑是最长的。我们当然可以利用排序对算法进行优化。方法是先将字符串A进行堆排序，其时间复杂度为O-n-log-n-。之后再将字符串B中的每个字符在排序后的堆中查找，则时间复杂度为O-m-log-n-。相加后的时间复杂度O-m-n-log-n\"><a href=\"#上一种解法的时间复杂度无疑是最长的。我们当然可以利用排序对算法进行优化。方法是先将字符串A进行堆排序，其时间复杂度为O-n-log-n-。之后再将字符串B中的每个字符在排序后的堆中查找，则时间复杂度为O-m-log-n-。相加后的时间复杂度O-m-n-log-n\" class=\"headerlink\" title=\"上一种解法的时间复杂度无疑是最长的。我们当然可以利用排序对算法进行优化。方法是先将字符串A进行堆排序，其时间复杂度为O(n log n)。之后再将字符串B中的每个字符在排序后的堆中查找，则时间复杂度为O(m log n)。相加后的时间复杂度O((m+n) log n)\"></a>上一种解法的时间复杂度无疑是最长的。我们当然可以利用排序对算法进行优化。方法是先将字符串A进行堆排序，其时间复杂度为O(n log n)。之后再将字符串B中的每个字符在排序后的堆中查找，则时间复杂度为O(m log n)。相加后的时间复杂度O((m+n) log n)</h5><h3 id=\"最优解法，时间复杂度O-m-n\"><a href=\"#最优解法，时间复杂度O-m-n\" class=\"headerlink\" title=\"最优解法，时间复杂度O(m+n)\"></a>最优解法，时间复杂度O(m+n)</h3><h5 id=\"题目到这好像没有办法解决下去，两个字符串的长度分别为n和m。只遍历一遍就得出结果，这种算法真的存在吗？其实这个题目就可以简化成集合元素存在的判断。\"><a href=\"#题目到这好像没有办法解决下去，两个字符串的长度分别为n和m。只遍历一遍就得出结果，这种算法真的存在吗？其实这个题目就可以简化成集合元素存在的判断。\" class=\"headerlink\" title=\"题目到这好像没有办法解决下去，两个字符串的长度分别为n和m。只遍历一遍就得出结果，这种算法真的存在吗？其实这个题目就可以简化成集合元素存在的判断。\"></a>题目到这好像没有办法解决下去，两个字符串的长度分别为n和m。只遍历一遍就得出结果，这种算法真的存在吗？其实这个题目就可以简化成集合元素存在的判断。</h5><h5 id=\"这里又要用到二进制的概念，二进制的一些属性完美的解决了题目中的一些问题。\"><a href=\"#这里又要用到二进制的概念，二进制的一些属性完美的解决了题目中的一些问题。\" class=\"headerlink\" title=\"这里又要用到二进制的概念，二进制的一些属性完美的解决了题目中的一些问题。\"></a>这里又要用到二进制的概念，二进制的一些属性完美的解决了题目中的一些问题。</h5><h4 id=\"1-相同字符的处理\"><a href=\"#1-相同字符的处理\" class=\"headerlink\" title=\"1.相同字符的处理\"></a>1.相同字符的处理</h4><h5 id=\"“或”操作指的是，两个相应的二进位中只要有一个为1，该位的结果值为1。\"><a href=\"#“或”操作指的是，两个相应的二进位中只要有一个为1，该位的结果值为1。\" class=\"headerlink\" title=\"“或”操作指的是，两个相应的二进位中只要有一个为1，该位的结果值为1。\"></a>“或”操作指的是，两个相应的二进位中只要有一个为1，该位的结果值为1。</h5><h5 id=\"0101-OR-0011-0111\"><a href=\"#0101-OR-0011-0111\" class=\"headerlink\" title=\"0101 OR 0011 = 0111\"></a>0101 OR 0011 = 0111</h5><h5 id=\"所以当两个相同字符存在时，用或操作，还是得到一个字符的值。\"><a href=\"#所以当两个相同字符存在时，用或操作，还是得到一个字符的值。\" class=\"headerlink\" title=\"所以当两个相同字符存在时，用或操作，还是得到一个字符的值。\"></a>所以当两个相同字符存在时，用或操作，还是得到一个字符的值。</h5><h4 id=\"2-字符的存在问题，如何判断一个字符存在于字符集\"><a href=\"#2-字符的存在问题，如何判断一个字符存在于字符集\" class=\"headerlink\" title=\"2.字符的存在问题，如何判断一个字符存在于字符集\"></a>2.字符的存在问题，如何判断一个字符存在于字符集</h4><h5 id=\"“与”操作指的是，两个相应的二进位都为1，该位的结果值才为1\"><a href=\"#“与”操作指的是，两个相应的二进位都为1，该位的结果值才为1\" class=\"headerlink\" title=\"“与”操作指的是，两个相应的二进位都为1，该位的结果值才为1\"></a>“与”操作指的是，两个相应的二进位都为1，该位的结果值才为1</h5><h5 id=\"0101-AND-0011-0001\"><a href=\"#0101-AND-0011-0001\" class=\"headerlink\" title=\"0101 AND 0011 = 0001\"></a>0101 AND 0011 = 0001</h5><h5 id=\"也就是只有两边都存在同一个字符时，才会得出1\"><a href=\"#也就是只有两边都存在同一个字符时，才会得出1\" class=\"headerlink\" title=\"也就是只有两边都存在同一个字符时，才会得出1\"></a>也就是只有两边都存在同一个字符时，才会得出1</h5><h5 id=\"因此我们可以将所有字符都进行二进制的编码，因为每一个字符都有两种状态（存在和不存在），所以对应在二进制中，每一个字符都占用一位。\"><a href=\"#因此我们可以将所有字符都进行二进制的编码，因为每一个字符都有两种状态（存在和不存在），所以对应在二进制中，每一个字符都占用一位。\" class=\"headerlink\" title=\"因此我们可以将所有字符都进行二进制的编码，因为每一个字符都有两种状态（存在和不存在），所以对应在二进制中，每一个字符都占用一位。\"></a>因此我们可以将所有字符都进行二进制的编码，因为每一个字符都有两种状态（存在和不存在），所以对应在二进制中，每一个字符都占用一位。</h5><pre><code class=\"lang-c\">bool StringContain(string &amp;a,string &amp;b)\n{\n    int hash = 0;\n    for (int i = 0; i &lt; a.length(); ++i)\n    {\n        hash |= (1 &lt;&lt; (a[i] - &#39;A&#39;));\n    }\n    for (int i = 0; i &lt; b.length(); ++i)\n    {\n        if ((hash &amp; (1 &lt;&lt; (b[i] - &#39;A&#39;))) == 0)\n        {\n            return false;\n        }\n    }\n    return true;\n}\n</code></pre>\n<h2 id=\"最后再说一些：\"><a href=\"#最后再说一些：\" class=\"headerlink\" title=\"最后再说一些：\"></a>最后再说一些：</h2><h5 id=\"最后的算法和之前的切金条算法有一些相似之处。这是这里对二进制的理解和运用更加灵活。只有对此很熟悉，才能想到这种方法。否则会比较困难。\"><a href=\"#最后的算法和之前的切金条算法有一些相似之处。这是这里对二进制的理解和运用更加灵活。只有对此很熟悉，才能想到这种方法。否则会比较困难。\" class=\"headerlink\" title=\"最后的算法和之前的切金条算法有一些相似之处。这是这里对二进制的理解和运用更加灵活。只有对此很熟悉，才能想到这种方法。否则会比较困难。\"></a>最后的算法和之前的<a href=\"http://localhost:4000/arithmetic/glodBars/\" target=\"_blank\" rel=\"external\">切金条</a>算法有一些相似之处。这是这里对二进制的理解和运用更加灵活。只有对此很熟悉，才能想到这种方法。否则会比较困难。</h5>"},{"layout":"post","title":"redis字符串数据结构","date":"2017-07-04T16:00:00.000Z","tag":[["redis","redis"]],"_content":"\n##### redis是基于C语言的，但是redis没有直接使用C语言的传统字符串，而是自己构建了一种简单动态字符串的抽象类型。简称SDS；\n<!--more-->\n### SDS数据结构\n##### 每个sds.h/sdshdr结构表示一个SDS值：\n```C\nstruct sdshdr{\n\n    //记录buf数组汇总已使用字节的数量，等于SDS所保存字符串的长度\n    int len;\n\n    //记录buf数组中未使用字节的数量\n    int free;\n\n    //字节数组，用于保存字符串\n    char buf[];\n}\n```\n##### SDS结构实例：\n![SDS实例](../../img/note/redisString.png) <div class='img-note'>SDS实例</div>\n\n1. free属性的值为0，表示SDS没有未使用空间。\n2. len的属性值为5，表示这个SDS保存了一个5字节长的字符串。\n3. buf属性是一个char数组，保存了redis五个字符\n\n##### SDS遵循C字符串以空字符结尾的惯例，该空字符的1字节空间不计算在SDS的len属性里面。并且添加空字符到字符串末尾的操作，是由SDS函数自动完成的。之所以保留这空字符结尾的好处是，SDS可以重用一部分C字符串函数库里面的函数。\n\n### SDS与C字符串的区别\n#### 常数复杂度获取字符串长度\n##### 因为C字符串不记录自身的长度，所以获取一个C字符串的长度，需要遍历整个字符串，直到遇到空字符为止，复杂度为O(N)。而redis的SDS只需要读取len字段就可以知道其字符串长度，复杂度为O(1)。更新和设置SDS的长度是API自动完成的。\n##### 虽然这种操作SDS的数据结构能够很好的提高效率，但是作为代价，SDS维护这些信息的时候也是需要成本的。只是这种代价所带来的好处是值得的。\n\n","source":"_posts/note/redisString.md","raw":"---\nlayout: post\ntitle: redis字符串数据结构\ndate: 2017/07/05\ntags: [tech, note, index, redis]\ntag: [[redis, redis]]\n---\n\n##### redis是基于C语言的，但是redis没有直接使用C语言的传统字符串，而是自己构建了一种简单动态字符串的抽象类型。简称SDS；\n<!--more-->\n### SDS数据结构\n##### 每个sds.h/sdshdr结构表示一个SDS值：\n```C\nstruct sdshdr{\n\n    //记录buf数组汇总已使用字节的数量，等于SDS所保存字符串的长度\n    int len;\n\n    //记录buf数组中未使用字节的数量\n    int free;\n\n    //字节数组，用于保存字符串\n    char buf[];\n}\n```\n##### SDS结构实例：\n![SDS实例](../../img/note/redisString.png) <div class='img-note'>SDS实例</div>\n\n1. free属性的值为0，表示SDS没有未使用空间。\n2. len的属性值为5，表示这个SDS保存了一个5字节长的字符串。\n3. buf属性是一个char数组，保存了redis五个字符\n\n##### SDS遵循C字符串以空字符结尾的惯例，该空字符的1字节空间不计算在SDS的len属性里面。并且添加空字符到字符串末尾的操作，是由SDS函数自动完成的。之所以保留这空字符结尾的好处是，SDS可以重用一部分C字符串函数库里面的函数。\n\n### SDS与C字符串的区别\n#### 常数复杂度获取字符串长度\n##### 因为C字符串不记录自身的长度，所以获取一个C字符串的长度，需要遍历整个字符串，直到遇到空字符为止，复杂度为O(N)。而redis的SDS只需要读取len字段就可以知道其字符串长度，复杂度为O(1)。更新和设置SDS的长度是API自动完成的。\n##### 虽然这种操作SDS的数据结构能够很好的提高效率，但是作为代价，SDS维护这些信息的时候也是需要成本的。只是这种代价所带来的好处是值得的。\n\n","slug":"note/redisString","published":1,"updated":"2017-10-06T16:04:09.052Z","comments":1,"photos":[],"link":"","_id":"cj8jros78000f30s6plny8nkv","content":"<h5 id=\"redis是基于C语言的，但是redis没有直接使用C语言的传统字符串，而是自己构建了一种简单动态字符串的抽象类型。简称SDS；\"><a href=\"#redis是基于C语言的，但是redis没有直接使用C语言的传统字符串，而是自己构建了一种简单动态字符串的抽象类型。简称SDS；\" class=\"headerlink\" title=\"redis是基于C语言的，但是redis没有直接使用C语言的传统字符串，而是自己构建了一种简单动态字符串的抽象类型。简称SDS；\"></a>redis是基于C语言的，但是redis没有直接使用C语言的传统字符串，而是自己构建了一种简单动态字符串的抽象类型。简称SDS；</h5><a id=\"more\"></a>\n<h3 id=\"SDS数据结构\"><a href=\"#SDS数据结构\" class=\"headerlink\" title=\"SDS数据结构\"></a>SDS数据结构</h3><h5 id=\"每个sds-h-sdshdr结构表示一个SDS值：\"><a href=\"#每个sds-h-sdshdr结构表示一个SDS值：\" class=\"headerlink\" title=\"每个sds.h/sdshdr结构表示一个SDS值：\"></a>每个sds.h/sdshdr结构表示一个SDS值：</h5><pre><code class=\"lang-C\">struct sdshdr{\n\n    //记录buf数组汇总已使用字节的数量，等于SDS所保存字符串的长度\n    int len;\n\n    //记录buf数组中未使用字节的数量\n    int free;\n\n    //字节数组，用于保存字符串\n    char buf[];\n}\n</code></pre>\n<h5 id=\"SDS结构实例：\"><a href=\"#SDS结构实例：\" class=\"headerlink\" title=\"SDS结构实例：\"></a>SDS结构实例：</h5><p><img src=\"../../img/note/redisString.png\" alt=\"SDS实例\"> <div class=\"img-note\">SDS实例</div></p>\n<ol>\n<li>free属性的值为0，表示SDS没有未使用空间。</li>\n<li>len的属性值为5，表示这个SDS保存了一个5字节长的字符串。</li>\n<li>buf属性是一个char数组，保存了redis五个字符</li>\n</ol>\n<h5 id=\"SDS遵循C字符串以空字符结尾的惯例，该空字符的1字节空间不计算在SDS的len属性里面。并且添加空字符到字符串末尾的操作，是由SDS函数自动完成的。之所以保留这空字符结尾的好处是，SDS可以重用一部分C字符串函数库里面的函数。\"><a href=\"#SDS遵循C字符串以空字符结尾的惯例，该空字符的1字节空间不计算在SDS的len属性里面。并且添加空字符到字符串末尾的操作，是由SDS函数自动完成的。之所以保留这空字符结尾的好处是，SDS可以重用一部分C字符串函数库里面的函数。\" class=\"headerlink\" title=\"SDS遵循C字符串以空字符结尾的惯例，该空字符的1字节空间不计算在SDS的len属性里面。并且添加空字符到字符串末尾的操作，是由SDS函数自动完成的。之所以保留这空字符结尾的好处是，SDS可以重用一部分C字符串函数库里面的函数。\"></a>SDS遵循C字符串以空字符结尾的惯例，该空字符的1字节空间不计算在SDS的len属性里面。并且添加空字符到字符串末尾的操作，是由SDS函数自动完成的。之所以保留这空字符结尾的好处是，SDS可以重用一部分C字符串函数库里面的函数。</h5><h3 id=\"SDS与C字符串的区别\"><a href=\"#SDS与C字符串的区别\" class=\"headerlink\" title=\"SDS与C字符串的区别\"></a>SDS与C字符串的区别</h3><h4 id=\"常数复杂度获取字符串长度\"><a href=\"#常数复杂度获取字符串长度\" class=\"headerlink\" title=\"常数复杂度获取字符串长度\"></a>常数复杂度获取字符串长度</h4><h5 id=\"因为C字符串不记录自身的长度，所以获取一个C字符串的长度，需要遍历整个字符串，直到遇到空字符为止，复杂度为O-N-。而redis的SDS只需要读取len字段就可以知道其字符串长度，复杂度为O-1-。更新和设置SDS的长度是API自动完成的。\"><a href=\"#因为C字符串不记录自身的长度，所以获取一个C字符串的长度，需要遍历整个字符串，直到遇到空字符为止，复杂度为O-N-。而redis的SDS只需要读取len字段就可以知道其字符串长度，复杂度为O-1-。更新和设置SDS的长度是API自动完成的。\" class=\"headerlink\" title=\"因为C字符串不记录自身的长度，所以获取一个C字符串的长度，需要遍历整个字符串，直到遇到空字符为止，复杂度为O(N)。而redis的SDS只需要读取len字段就可以知道其字符串长度，复杂度为O(1)。更新和设置SDS的长度是API自动完成的。\"></a>因为C字符串不记录自身的长度，所以获取一个C字符串的长度，需要遍历整个字符串，直到遇到空字符为止，复杂度为O(N)。而redis的SDS只需要读取len字段就可以知道其字符串长度，复杂度为O(1)。更新和设置SDS的长度是API自动完成的。</h5><h5 id=\"虽然这种操作SDS的数据结构能够很好的提高效率，但是作为代价，SDS维护这些信息的时候也是需要成本的。只是这种代价所带来的好处是值得的。\"><a href=\"#虽然这种操作SDS的数据结构能够很好的提高效率，但是作为代价，SDS维护这些信息的时候也是需要成本的。只是这种代价所带来的好处是值得的。\" class=\"headerlink\" title=\"虽然这种操作SDS的数据结构能够很好的提高效率，但是作为代价，SDS维护这些信息的时候也是需要成本的。只是这种代价所带来的好处是值得的。\"></a>虽然这种操作SDS的数据结构能够很好的提高效率，但是作为代价，SDS维护这些信息的时候也是需要成本的。只是这种代价所带来的好处是值得的。</h5>","site":{"data":{}},"excerpt":"<h5 id=\"redis是基于C语言的，但是redis没有直接使用C语言的传统字符串，而是自己构建了一种简单动态字符串的抽象类型。简称SDS；\"><a href=\"#redis是基于C语言的，但是redis没有直接使用C语言的传统字符串，而是自己构建了一种简单动态字符串的抽象类型。简称SDS；\" class=\"headerlink\" title=\"redis是基于C语言的，但是redis没有直接使用C语言的传统字符串，而是自己构建了一种简单动态字符串的抽象类型。简称SDS；\"></a>redis是基于C语言的，但是redis没有直接使用C语言的传统字符串，而是自己构建了一种简单动态字符串的抽象类型。简称SDS；</h5>","more":"<h3 id=\"SDS数据结构\"><a href=\"#SDS数据结构\" class=\"headerlink\" title=\"SDS数据结构\"></a>SDS数据结构</h3><h5 id=\"每个sds-h-sdshdr结构表示一个SDS值：\"><a href=\"#每个sds-h-sdshdr结构表示一个SDS值：\" class=\"headerlink\" title=\"每个sds.h/sdshdr结构表示一个SDS值：\"></a>每个sds.h/sdshdr结构表示一个SDS值：</h5><pre><code class=\"lang-C\">struct sdshdr{\n\n    //记录buf数组汇总已使用字节的数量，等于SDS所保存字符串的长度\n    int len;\n\n    //记录buf数组中未使用字节的数量\n    int free;\n\n    //字节数组，用于保存字符串\n    char buf[];\n}\n</code></pre>\n<h5 id=\"SDS结构实例：\"><a href=\"#SDS结构实例：\" class=\"headerlink\" title=\"SDS结构实例：\"></a>SDS结构实例：</h5><p><img src=\"../../img/note/redisString.png\" alt=\"SDS实例\"> <div class=\"img-note\">SDS实例</div></p>\n<ol>\n<li>free属性的值为0，表示SDS没有未使用空间。</li>\n<li>len的属性值为5，表示这个SDS保存了一个5字节长的字符串。</li>\n<li>buf属性是一个char数组，保存了redis五个字符</li>\n</ol>\n<h5 id=\"SDS遵循C字符串以空字符结尾的惯例，该空字符的1字节空间不计算在SDS的len属性里面。并且添加空字符到字符串末尾的操作，是由SDS函数自动完成的。之所以保留这空字符结尾的好处是，SDS可以重用一部分C字符串函数库里面的函数。\"><a href=\"#SDS遵循C字符串以空字符结尾的惯例，该空字符的1字节空间不计算在SDS的len属性里面。并且添加空字符到字符串末尾的操作，是由SDS函数自动完成的。之所以保留这空字符结尾的好处是，SDS可以重用一部分C字符串函数库里面的函数。\" class=\"headerlink\" title=\"SDS遵循C字符串以空字符结尾的惯例，该空字符的1字节空间不计算在SDS的len属性里面。并且添加空字符到字符串末尾的操作，是由SDS函数自动完成的。之所以保留这空字符结尾的好处是，SDS可以重用一部分C字符串函数库里面的函数。\"></a>SDS遵循C字符串以空字符结尾的惯例，该空字符的1字节空间不计算在SDS的len属性里面。并且添加空字符到字符串末尾的操作，是由SDS函数自动完成的。之所以保留这空字符结尾的好处是，SDS可以重用一部分C字符串函数库里面的函数。</h5><h3 id=\"SDS与C字符串的区别\"><a href=\"#SDS与C字符串的区别\" class=\"headerlink\" title=\"SDS与C字符串的区别\"></a>SDS与C字符串的区别</h3><h4 id=\"常数复杂度获取字符串长度\"><a href=\"#常数复杂度获取字符串长度\" class=\"headerlink\" title=\"常数复杂度获取字符串长度\"></a>常数复杂度获取字符串长度</h4><h5 id=\"因为C字符串不记录自身的长度，所以获取一个C字符串的长度，需要遍历整个字符串，直到遇到空字符为止，复杂度为O-N-。而redis的SDS只需要读取len字段就可以知道其字符串长度，复杂度为O-1-。更新和设置SDS的长度是API自动完成的。\"><a href=\"#因为C字符串不记录自身的长度，所以获取一个C字符串的长度，需要遍历整个字符串，直到遇到空字符为止，复杂度为O-N-。而redis的SDS只需要读取len字段就可以知道其字符串长度，复杂度为O-1-。更新和设置SDS的长度是API自动完成的。\" class=\"headerlink\" title=\"因为C字符串不记录自身的长度，所以获取一个C字符串的长度，需要遍历整个字符串，直到遇到空字符为止，复杂度为O(N)。而redis的SDS只需要读取len字段就可以知道其字符串长度，复杂度为O(1)。更新和设置SDS的长度是API自动完成的。\"></a>因为C字符串不记录自身的长度，所以获取一个C字符串的长度，需要遍历整个字符串，直到遇到空字符为止，复杂度为O(N)。而redis的SDS只需要读取len字段就可以知道其字符串长度，复杂度为O(1)。更新和设置SDS的长度是API自动完成的。</h5><h5 id=\"虽然这种操作SDS的数据结构能够很好的提高效率，但是作为代价，SDS维护这些信息的时候也是需要成本的。只是这种代价所带来的好处是值得的。\"><a href=\"#虽然这种操作SDS的数据结构能够很好的提高效率，但是作为代价，SDS维护这些信息的时候也是需要成本的。只是这种代价所带来的好处是值得的。\" class=\"headerlink\" title=\"虽然这种操作SDS的数据结构能够很好的提高效率，但是作为代价，SDS维护这些信息的时候也是需要成本的。只是这种代价所带来的好处是值得的。\"></a>虽然这种操作SDS的数据结构能够很好的提高效率，但是作为代价，SDS维护这些信息的时候也是需要成本的。只是这种代价所带来的好处是值得的。</h5>"},{"layout":"post","title":"密钥和数字证书","date":"2017-08-31T16:00:00.000Z","_content":"\n##### 最近因为项目要求，需要在本地环境为项目部署https服务。之前对https的密钥和证书过程都不是很清楚，所以最近恶补了一些基础知识。这是一篇对数字证书很形象的解释，所以决定记录下来，加深记忆。\n<!--more-->\n\n#### 1.鲍勃有两把钥匙，一把是公钥，另一把是私钥。\n![](../../img/note/secretkey1.png)\n\n#### 2.鲍勃把公钥送给他的朋友们—-帕蒂、道格、苏珊—-每人一把。\n![](../../img/note/secretkey2.png)\n\n#### 3.苏珊给鲍勃写信，写完后用鲍勃的公钥加密，达到保密的效果。\n![](../../img/note/secretkey3.png)\n\n#### 4.鲍勃收信后，用私钥解密，看到信件内容。\n![](../../img/note/secretkey4.png)\n\n#### 5.鲍勃给苏珊回信，写完后用Hash函数，生成信件的摘要（digest）。\n![](../../img/note/secretkey5.png)\n\n#### 6.然后，鲍勃使用私钥，对这个摘要加密，生成”数字签名”（signature）。\n![](../../img/note/secretkey6.png)\n\n#### 7.鲍勃将这个签名，附在信件下面，一起发给苏珊。\n![](../../img/note/secretkey7.png)\n\n#### 8.苏珊收信后，取下数字签名，用鲍勃的公钥解密，得到信件的摘要。由此证明，这封信确实是鲍勃发出的。\n![](../../img/note/secretkey8.png)\n\n#### 9.苏珊再对信件本身使用Hash函数，将得到的结果，与上一步得到的摘要进行对比。如果两者一致，就证明这封信未被修改过。\n![](../../img/note/secretkey9.png)\n\n#### 10.复杂的情况出现了。道格想欺骗苏珊，他偷偷使用了苏珊的电脑，用自己的公钥换走了鲍勃的公钥。因此，他就可以冒充鲍勃，写信给苏珊。\n![](../../img/note/secretkey10.png)\n\n#### 11.苏珊发现，自己无法确定公钥是否真的属于鲍勃。她想到了一个办法，要求鲍勃去找”证书中心”（certificate authority，简称CA），为公钥做认证。证书中心用自己的私钥，对鲍勃的公钥和一些相关信息一起加密，生成”数字证书”（Digital Certificate）。\n![](../../img/note/secretkey11.png)\n\n#### 12.鲍勃拿到数字证书以后，就可以放心了。以后再给苏珊写信，只要在签名的同时，再附上数字证书就行了。\n![](../../img/note/secretkey12.png)\n\n#### 13.苏珊收信后，用CA的公钥解开数字证书，就可以拿到鲍勃真实的公钥了，然后就能证明”数字签名”是否真的是鲍勃签的。\n![](../../img/note/secretkey13.png)\n\n#### 14.下面，我们看一个应用”数字证书”的实例：https协议。这个协议主要用于网页加密。\n![](../../img/note/secretkey14.jpg)\n\n#### 15.首先，客户端向服务器发出加密请求。\n![](../../img/note/secretkey15.png)\n\n#### 16.服务器用自己的私钥加密网页以后，连同本身的数字证书，一起发送给客户端。\n![](../../img/note/secretkey16.png)\n\n#### 17.客户端（浏览器）的”证书管理器”，有”受信任的根证书颁发机构”列表。客户端会根据这张列表，查看解开数字证书的公钥是否在列表之内。\n![](../../img/note/secretkey17.png)\n\n#### 18.如果数字证书记载的网址，与你正在浏览的网址不一致，就说明这张证书可能被冒用，浏览器会发出警告。\n![](../../img/note/secretkey18.png)\n\n#### 19.如果这张数字证书不是由受信任的机构颁发的，浏览器会发出另一种警告。\n![](../../img/note/secretkey19.jpg)\n\n#### 20.如果数字证书是可靠的，客户端就可以使用证书中的服务器公钥，对信息进行加密，然后与服务器交换加密信息。\n![](../../img/note/secretkey20.png)\n\n### 想更好地理解上面这篇形象生动的技术文章，你还需要理解一些概念和术语\n#### 公钥密码体制(public-key cryptography)\n##### 公钥密码体制分为三个部分，公钥、私钥、加密解密算法，它的加密解密过程如下：\n* 加密：通过加密算法和公钥对内容(或者说明文)进行加密，得到密文。加密过程需要用到公钥。\n* 解密：通过解密算法和私钥对密文进行解密，得到明文。解密过程需要用到解密算法和私钥。注意，由公钥加密的内容，只能由私钥进行解密，也就是说，由公钥加密的内容，如果不知道私钥，是无法解密的。\n##### 公钥密码体制的公钥和算法都是公开的(这是为什么叫公钥密码体制的原因)，私钥是保密的。大家都以使用公钥进行加密，但是只有私钥的持有者才能解密。在实际的使用中，有需要的人会生成一对公钥和私钥，把公钥发布出去给别人使用，自己保留私钥。\n\n#### 对称加密算法(symmetric key algorithms)\n##### 在对称加密算法中，加密使用的密钥和解密使用的密钥是相同的。也就是说，加密和解密都是使用的同一个密钥。因此对称加密算法要保证安全性的话，密钥要做好保密，只能让使用的人知道，不能对外公开。这个和上面的公钥密码体制有所不同，公钥密码体制中加密是用公钥，解密使用私钥，而对称加密算法中，加密和解密都是使用同一个密钥，不区分公钥和私钥。\n##### 密钥，一般就是一个字符串或数字，在加密或者解密时传递给加密/解密算法。前面在公钥密码体制中说到的公钥、私钥就是密钥，公钥是加密使用的密钥，私钥是解密使用的密钥\n\n\n[原文连接](http://www.youdzone.com/signature.html)\n","source":"_posts/note/secretKey.md","raw":"---\nlayout: post\ntitle: 密钥和数字证书\ndate: 2017/09/01\ntags: [tech, note, index, network]\n---\n\n##### 最近因为项目要求，需要在本地环境为项目部署https服务。之前对https的密钥和证书过程都不是很清楚，所以最近恶补了一些基础知识。这是一篇对数字证书很形象的解释，所以决定记录下来，加深记忆。\n<!--more-->\n\n#### 1.鲍勃有两把钥匙，一把是公钥，另一把是私钥。\n![](../../img/note/secretkey1.png)\n\n#### 2.鲍勃把公钥送给他的朋友们—-帕蒂、道格、苏珊—-每人一把。\n![](../../img/note/secretkey2.png)\n\n#### 3.苏珊给鲍勃写信，写完后用鲍勃的公钥加密，达到保密的效果。\n![](../../img/note/secretkey3.png)\n\n#### 4.鲍勃收信后，用私钥解密，看到信件内容。\n![](../../img/note/secretkey4.png)\n\n#### 5.鲍勃给苏珊回信，写完后用Hash函数，生成信件的摘要（digest）。\n![](../../img/note/secretkey5.png)\n\n#### 6.然后，鲍勃使用私钥，对这个摘要加密，生成”数字签名”（signature）。\n![](../../img/note/secretkey6.png)\n\n#### 7.鲍勃将这个签名，附在信件下面，一起发给苏珊。\n![](../../img/note/secretkey7.png)\n\n#### 8.苏珊收信后，取下数字签名，用鲍勃的公钥解密，得到信件的摘要。由此证明，这封信确实是鲍勃发出的。\n![](../../img/note/secretkey8.png)\n\n#### 9.苏珊再对信件本身使用Hash函数，将得到的结果，与上一步得到的摘要进行对比。如果两者一致，就证明这封信未被修改过。\n![](../../img/note/secretkey9.png)\n\n#### 10.复杂的情况出现了。道格想欺骗苏珊，他偷偷使用了苏珊的电脑，用自己的公钥换走了鲍勃的公钥。因此，他就可以冒充鲍勃，写信给苏珊。\n![](../../img/note/secretkey10.png)\n\n#### 11.苏珊发现，自己无法确定公钥是否真的属于鲍勃。她想到了一个办法，要求鲍勃去找”证书中心”（certificate authority，简称CA），为公钥做认证。证书中心用自己的私钥，对鲍勃的公钥和一些相关信息一起加密，生成”数字证书”（Digital Certificate）。\n![](../../img/note/secretkey11.png)\n\n#### 12.鲍勃拿到数字证书以后，就可以放心了。以后再给苏珊写信，只要在签名的同时，再附上数字证书就行了。\n![](../../img/note/secretkey12.png)\n\n#### 13.苏珊收信后，用CA的公钥解开数字证书，就可以拿到鲍勃真实的公钥了，然后就能证明”数字签名”是否真的是鲍勃签的。\n![](../../img/note/secretkey13.png)\n\n#### 14.下面，我们看一个应用”数字证书”的实例：https协议。这个协议主要用于网页加密。\n![](../../img/note/secretkey14.jpg)\n\n#### 15.首先，客户端向服务器发出加密请求。\n![](../../img/note/secretkey15.png)\n\n#### 16.服务器用自己的私钥加密网页以后，连同本身的数字证书，一起发送给客户端。\n![](../../img/note/secretkey16.png)\n\n#### 17.客户端（浏览器）的”证书管理器”，有”受信任的根证书颁发机构”列表。客户端会根据这张列表，查看解开数字证书的公钥是否在列表之内。\n![](../../img/note/secretkey17.png)\n\n#### 18.如果数字证书记载的网址，与你正在浏览的网址不一致，就说明这张证书可能被冒用，浏览器会发出警告。\n![](../../img/note/secretkey18.png)\n\n#### 19.如果这张数字证书不是由受信任的机构颁发的，浏览器会发出另一种警告。\n![](../../img/note/secretkey19.jpg)\n\n#### 20.如果数字证书是可靠的，客户端就可以使用证书中的服务器公钥，对信息进行加密，然后与服务器交换加密信息。\n![](../../img/note/secretkey20.png)\n\n### 想更好地理解上面这篇形象生动的技术文章，你还需要理解一些概念和术语\n#### 公钥密码体制(public-key cryptography)\n##### 公钥密码体制分为三个部分，公钥、私钥、加密解密算法，它的加密解密过程如下：\n* 加密：通过加密算法和公钥对内容(或者说明文)进行加密，得到密文。加密过程需要用到公钥。\n* 解密：通过解密算法和私钥对密文进行解密，得到明文。解密过程需要用到解密算法和私钥。注意，由公钥加密的内容，只能由私钥进行解密，也就是说，由公钥加密的内容，如果不知道私钥，是无法解密的。\n##### 公钥密码体制的公钥和算法都是公开的(这是为什么叫公钥密码体制的原因)，私钥是保密的。大家都以使用公钥进行加密，但是只有私钥的持有者才能解密。在实际的使用中，有需要的人会生成一对公钥和私钥，把公钥发布出去给别人使用，自己保留私钥。\n\n#### 对称加密算法(symmetric key algorithms)\n##### 在对称加密算法中，加密使用的密钥和解密使用的密钥是相同的。也就是说，加密和解密都是使用的同一个密钥。因此对称加密算法要保证安全性的话，密钥要做好保密，只能让使用的人知道，不能对外公开。这个和上面的公钥密码体制有所不同，公钥密码体制中加密是用公钥，解密使用私钥，而对称加密算法中，加密和解密都是使用同一个密钥，不区分公钥和私钥。\n##### 密钥，一般就是一个字符串或数字，在加密或者解密时传递给加密/解密算法。前面在公钥密码体制中说到的公钥、私钥就是密钥，公钥是加密使用的密钥，私钥是解密使用的密钥\n\n\n[原文连接](http://www.youdzone.com/signature.html)\n","slug":"note/secretKey","published":1,"updated":"2017-09-01T07:16:08.000Z","comments":1,"photos":[],"link":"","_id":"cj8jros7a000h30s698jqf0ss","content":"<h5 id=\"最近因为项目要求，需要在本地环境为项目部署https服务。之前对https的密钥和证书过程都不是很清楚，所以最近恶补了一些基础知识。这是一篇对数字证书很形象的解释，所以决定记录下来，加深记忆。\"><a href=\"#最近因为项目要求，需要在本地环境为项目部署https服务。之前对https的密钥和证书过程都不是很清楚，所以最近恶补了一些基础知识。这是一篇对数字证书很形象的解释，所以决定记录下来，加深记忆。\" class=\"headerlink\" title=\"最近因为项目要求，需要在本地环境为项目部署https服务。之前对https的密钥和证书过程都不是很清楚，所以最近恶补了一些基础知识。这是一篇对数字证书很形象的解释，所以决定记录下来，加深记忆。\"></a>最近因为项目要求，需要在本地环境为项目部署https服务。之前对https的密钥和证书过程都不是很清楚，所以最近恶补了一些基础知识。这是一篇对数字证书很形象的解释，所以决定记录下来，加深记忆。</h5><a id=\"more\"></a>\n<h4 id=\"1-鲍勃有两把钥匙，一把是公钥，另一把是私钥。\"><a href=\"#1-鲍勃有两把钥匙，一把是公钥，另一把是私钥。\" class=\"headerlink\" title=\"1.鲍勃有两把钥匙，一把是公钥，另一把是私钥。\"></a>1.鲍勃有两把钥匙，一把是公钥，另一把是私钥。</h4><p><img src=\"../../img/note/secretkey1.png\" alt=\"\"></p>\n<h4 id=\"2-鲍勃把公钥送给他的朋友们—-帕蒂、道格、苏珊—-每人一把。\"><a href=\"#2-鲍勃把公钥送给他的朋友们—-帕蒂、道格、苏珊—-每人一把。\" class=\"headerlink\" title=\"2.鲍勃把公钥送给他的朋友们—-帕蒂、道格、苏珊—-每人一把。\"></a>2.鲍勃把公钥送给他的朋友们—-帕蒂、道格、苏珊—-每人一把。</h4><p><img src=\"../../img/note/secretkey2.png\" alt=\"\"></p>\n<h4 id=\"3-苏珊给鲍勃写信，写完后用鲍勃的公钥加密，达到保密的效果。\"><a href=\"#3-苏珊给鲍勃写信，写完后用鲍勃的公钥加密，达到保密的效果。\" class=\"headerlink\" title=\"3.苏珊给鲍勃写信，写完后用鲍勃的公钥加密，达到保密的效果。\"></a>3.苏珊给鲍勃写信，写完后用鲍勃的公钥加密，达到保密的效果。</h4><p><img src=\"../../img/note/secretkey3.png\" alt=\"\"></p>\n<h4 id=\"4-鲍勃收信后，用私钥解密，看到信件内容。\"><a href=\"#4-鲍勃收信后，用私钥解密，看到信件内容。\" class=\"headerlink\" title=\"4.鲍勃收信后，用私钥解密，看到信件内容。\"></a>4.鲍勃收信后，用私钥解密，看到信件内容。</h4><p><img src=\"../../img/note/secretkey4.png\" alt=\"\"></p>\n<h4 id=\"5-鲍勃给苏珊回信，写完后用Hash函数，生成信件的摘要（digest）。\"><a href=\"#5-鲍勃给苏珊回信，写完后用Hash函数，生成信件的摘要（digest）。\" class=\"headerlink\" title=\"5.鲍勃给苏珊回信，写完后用Hash函数，生成信件的摘要（digest）。\"></a>5.鲍勃给苏珊回信，写完后用Hash函数，生成信件的摘要（digest）。</h4><p><img src=\"../../img/note/secretkey5.png\" alt=\"\"></p>\n<h4 id=\"6-然后，鲍勃使用私钥，对这个摘要加密，生成”数字签名”（signature）。\"><a href=\"#6-然后，鲍勃使用私钥，对这个摘要加密，生成”数字签名”（signature）。\" class=\"headerlink\" title=\"6.然后，鲍勃使用私钥，对这个摘要加密，生成”数字签名”（signature）。\"></a>6.然后，鲍勃使用私钥，对这个摘要加密，生成”数字签名”（signature）。</h4><p><img src=\"../../img/note/secretkey6.png\" alt=\"\"></p>\n<h4 id=\"7-鲍勃将这个签名，附在信件下面，一起发给苏珊。\"><a href=\"#7-鲍勃将这个签名，附在信件下面，一起发给苏珊。\" class=\"headerlink\" title=\"7.鲍勃将这个签名，附在信件下面，一起发给苏珊。\"></a>7.鲍勃将这个签名，附在信件下面，一起发给苏珊。</h4><p><img src=\"../../img/note/secretkey7.png\" alt=\"\"></p>\n<h4 id=\"8-苏珊收信后，取下数字签名，用鲍勃的公钥解密，得到信件的摘要。由此证明，这封信确实是鲍勃发出的。\"><a href=\"#8-苏珊收信后，取下数字签名，用鲍勃的公钥解密，得到信件的摘要。由此证明，这封信确实是鲍勃发出的。\" class=\"headerlink\" title=\"8.苏珊收信后，取下数字签名，用鲍勃的公钥解密，得到信件的摘要。由此证明，这封信确实是鲍勃发出的。\"></a>8.苏珊收信后，取下数字签名，用鲍勃的公钥解密，得到信件的摘要。由此证明，这封信确实是鲍勃发出的。</h4><p><img src=\"../../img/note/secretkey8.png\" alt=\"\"></p>\n<h4 id=\"9-苏珊再对信件本身使用Hash函数，将得到的结果，与上一步得到的摘要进行对比。如果两者一致，就证明这封信未被修改过。\"><a href=\"#9-苏珊再对信件本身使用Hash函数，将得到的结果，与上一步得到的摘要进行对比。如果两者一致，就证明这封信未被修改过。\" class=\"headerlink\" title=\"9.苏珊再对信件本身使用Hash函数，将得到的结果，与上一步得到的摘要进行对比。如果两者一致，就证明这封信未被修改过。\"></a>9.苏珊再对信件本身使用Hash函数，将得到的结果，与上一步得到的摘要进行对比。如果两者一致，就证明这封信未被修改过。</h4><p><img src=\"../../img/note/secretkey9.png\" alt=\"\"></p>\n<h4 id=\"10-复杂的情况出现了。道格想欺骗苏珊，他偷偷使用了苏珊的电脑，用自己的公钥换走了鲍勃的公钥。因此，他就可以冒充鲍勃，写信给苏珊。\"><a href=\"#10-复杂的情况出现了。道格想欺骗苏珊，他偷偷使用了苏珊的电脑，用自己的公钥换走了鲍勃的公钥。因此，他就可以冒充鲍勃，写信给苏珊。\" class=\"headerlink\" title=\"10.复杂的情况出现了。道格想欺骗苏珊，他偷偷使用了苏珊的电脑，用自己的公钥换走了鲍勃的公钥。因此，他就可以冒充鲍勃，写信给苏珊。\"></a>10.复杂的情况出现了。道格想欺骗苏珊，他偷偷使用了苏珊的电脑，用自己的公钥换走了鲍勃的公钥。因此，他就可以冒充鲍勃，写信给苏珊。</h4><p><img src=\"../../img/note/secretkey10.png\" alt=\"\"></p>\n<h4 id=\"11-苏珊发现，自己无法确定公钥是否真的属于鲍勃。她想到了一个办法，要求鲍勃去找”证书中心”（certificate-authority，简称CA），为公钥做认证。证书中心用自己的私钥，对鲍勃的公钥和一些相关信息一起加密，生成”数字证书”（Digital-Certificate）。\"><a href=\"#11-苏珊发现，自己无法确定公钥是否真的属于鲍勃。她想到了一个办法，要求鲍勃去找”证书中心”（certificate-authority，简称CA），为公钥做认证。证书中心用自己的私钥，对鲍勃的公钥和一些相关信息一起加密，生成”数字证书”（Digital-Certificate）。\" class=\"headerlink\" title=\"11.苏珊发现，自己无法确定公钥是否真的属于鲍勃。她想到了一个办法，要求鲍勃去找”证书中心”（certificate authority，简称CA），为公钥做认证。证书中心用自己的私钥，对鲍勃的公钥和一些相关信息一起加密，生成”数字证书”（Digital Certificate）。\"></a>11.苏珊发现，自己无法确定公钥是否真的属于鲍勃。她想到了一个办法，要求鲍勃去找”证书中心”（certificate authority，简称CA），为公钥做认证。证书中心用自己的私钥，对鲍勃的公钥和一些相关信息一起加密，生成”数字证书”（Digital Certificate）。</h4><p><img src=\"../../img/note/secretkey11.png\" alt=\"\"></p>\n<h4 id=\"12-鲍勃拿到数字证书以后，就可以放心了。以后再给苏珊写信，只要在签名的同时，再附上数字证书就行了。\"><a href=\"#12-鲍勃拿到数字证书以后，就可以放心了。以后再给苏珊写信，只要在签名的同时，再附上数字证书就行了。\" class=\"headerlink\" title=\"12.鲍勃拿到数字证书以后，就可以放心了。以后再给苏珊写信，只要在签名的同时，再附上数字证书就行了。\"></a>12.鲍勃拿到数字证书以后，就可以放心了。以后再给苏珊写信，只要在签名的同时，再附上数字证书就行了。</h4><p><img src=\"../../img/note/secretkey12.png\" alt=\"\"></p>\n<h4 id=\"13-苏珊收信后，用CA的公钥解开数字证书，就可以拿到鲍勃真实的公钥了，然后就能证明”数字签名”是否真的是鲍勃签的。\"><a href=\"#13-苏珊收信后，用CA的公钥解开数字证书，就可以拿到鲍勃真实的公钥了，然后就能证明”数字签名”是否真的是鲍勃签的。\" class=\"headerlink\" title=\"13.苏珊收信后，用CA的公钥解开数字证书，就可以拿到鲍勃真实的公钥了，然后就能证明”数字签名”是否真的是鲍勃签的。\"></a>13.苏珊收信后，用CA的公钥解开数字证书，就可以拿到鲍勃真实的公钥了，然后就能证明”数字签名”是否真的是鲍勃签的。</h4><p><img src=\"../../img/note/secretkey13.png\" alt=\"\"></p>\n<h4 id=\"14-下面，我们看一个应用”数字证书”的实例：https协议。这个协议主要用于网页加密。\"><a href=\"#14-下面，我们看一个应用”数字证书”的实例：https协议。这个协议主要用于网页加密。\" class=\"headerlink\" title=\"14.下面，我们看一个应用”数字证书”的实例：https协议。这个协议主要用于网页加密。\"></a>14.下面，我们看一个应用”数字证书”的实例：https协议。这个协议主要用于网页加密。</h4><p><img src=\"../../img/note/secretkey14.jpg\" alt=\"\"></p>\n<h4 id=\"15-首先，客户端向服务器发出加密请求。\"><a href=\"#15-首先，客户端向服务器发出加密请求。\" class=\"headerlink\" title=\"15.首先，客户端向服务器发出加密请求。\"></a>15.首先，客户端向服务器发出加密请求。</h4><p><img src=\"../../img/note/secretkey15.png\" alt=\"\"></p>\n<h4 id=\"16-服务器用自己的私钥加密网页以后，连同本身的数字证书，一起发送给客户端。\"><a href=\"#16-服务器用自己的私钥加密网页以后，连同本身的数字证书，一起发送给客户端。\" class=\"headerlink\" title=\"16.服务器用自己的私钥加密网页以后，连同本身的数字证书，一起发送给客户端。\"></a>16.服务器用自己的私钥加密网页以后，连同本身的数字证书，一起发送给客户端。</h4><p><img src=\"../../img/note/secretkey16.png\" alt=\"\"></p>\n<h4 id=\"17-客户端（浏览器）的”证书管理器”，有”受信任的根证书颁发机构”列表。客户端会根据这张列表，查看解开数字证书的公钥是否在列表之内。\"><a href=\"#17-客户端（浏览器）的”证书管理器”，有”受信任的根证书颁发机构”列表。客户端会根据这张列表，查看解开数字证书的公钥是否在列表之内。\" class=\"headerlink\" title=\"17.客户端（浏览器）的”证书管理器”，有”受信任的根证书颁发机构”列表。客户端会根据这张列表，查看解开数字证书的公钥是否在列表之内。\"></a>17.客户端（浏览器）的”证书管理器”，有”受信任的根证书颁发机构”列表。客户端会根据这张列表，查看解开数字证书的公钥是否在列表之内。</h4><p><img src=\"../../img/note/secretkey17.png\" alt=\"\"></p>\n<h4 id=\"18-如果数字证书记载的网址，与你正在浏览的网址不一致，就说明这张证书可能被冒用，浏览器会发出警告。\"><a href=\"#18-如果数字证书记载的网址，与你正在浏览的网址不一致，就说明这张证书可能被冒用，浏览器会发出警告。\" class=\"headerlink\" title=\"18.如果数字证书记载的网址，与你正在浏览的网址不一致，就说明这张证书可能被冒用，浏览器会发出警告。\"></a>18.如果数字证书记载的网址，与你正在浏览的网址不一致，就说明这张证书可能被冒用，浏览器会发出警告。</h4><p><img src=\"../../img/note/secretkey18.png\" alt=\"\"></p>\n<h4 id=\"19-如果这张数字证书不是由受信任的机构颁发的，浏览器会发出另一种警告。\"><a href=\"#19-如果这张数字证书不是由受信任的机构颁发的，浏览器会发出另一种警告。\" class=\"headerlink\" title=\"19.如果这张数字证书不是由受信任的机构颁发的，浏览器会发出另一种警告。\"></a>19.如果这张数字证书不是由受信任的机构颁发的，浏览器会发出另一种警告。</h4><p><img src=\"../../img/note/secretkey19.jpg\" alt=\"\"></p>\n<h4 id=\"20-如果数字证书是可靠的，客户端就可以使用证书中的服务器公钥，对信息进行加密，然后与服务器交换加密信息。\"><a href=\"#20-如果数字证书是可靠的，客户端就可以使用证书中的服务器公钥，对信息进行加密，然后与服务器交换加密信息。\" class=\"headerlink\" title=\"20.如果数字证书是可靠的，客户端就可以使用证书中的服务器公钥，对信息进行加密，然后与服务器交换加密信息。\"></a>20.如果数字证书是可靠的，客户端就可以使用证书中的服务器公钥，对信息进行加密，然后与服务器交换加密信息。</h4><p><img src=\"../../img/note/secretkey20.png\" alt=\"\"></p>\n<h3 id=\"想更好地理解上面这篇形象生动的技术文章，你还需要理解一些概念和术语\"><a href=\"#想更好地理解上面这篇形象生动的技术文章，你还需要理解一些概念和术语\" class=\"headerlink\" title=\"想更好地理解上面这篇形象生动的技术文章，你还需要理解一些概念和术语\"></a>想更好地理解上面这篇形象生动的技术文章，你还需要理解一些概念和术语</h3><h4 id=\"公钥密码体制-public-key-cryptography\"><a href=\"#公钥密码体制-public-key-cryptography\" class=\"headerlink\" title=\"公钥密码体制(public-key cryptography)\"></a>公钥密码体制(public-key cryptography)</h4><h5 id=\"公钥密码体制分为三个部分，公钥、私钥、加密解密算法，它的加密解密过程如下：\"><a href=\"#公钥密码体制分为三个部分，公钥、私钥、加密解密算法，它的加密解密过程如下：\" class=\"headerlink\" title=\"公钥密码体制分为三个部分，公钥、私钥、加密解密算法，它的加密解密过程如下：\"></a>公钥密码体制分为三个部分，公钥、私钥、加密解密算法，它的加密解密过程如下：</h5><ul>\n<li>加密：通过加密算法和公钥对内容(或者说明文)进行加密，得到密文。加密过程需要用到公钥。</li>\n<li>解密：通过解密算法和私钥对密文进行解密，得到明文。解密过程需要用到解密算法和私钥。注意，由公钥加密的内容，只能由私钥进行解密，也就是说，由公钥加密的内容，如果不知道私钥，是无法解密的。<h5 id=\"公钥密码体制的公钥和算法都是公开的-这是为什么叫公钥密码体制的原因-，私钥是保密的。大家都以使用公钥进行加密，但是只有私钥的持有者才能解密。在实际的使用中，有需要的人会生成一对公钥和私钥，把公钥发布出去给别人使用，自己保留私钥。\"><a href=\"#公钥密码体制的公钥和算法都是公开的-这是为什么叫公钥密码体制的原因-，私钥是保密的。大家都以使用公钥进行加密，但是只有私钥的持有者才能解密。在实际的使用中，有需要的人会生成一对公钥和私钥，把公钥发布出去给别人使用，自己保留私钥。\" class=\"headerlink\" title=\"公钥密码体制的公钥和算法都是公开的(这是为什么叫公钥密码体制的原因)，私钥是保密的。大家都以使用公钥进行加密，但是只有私钥的持有者才能解密。在实际的使用中，有需要的人会生成一对公钥和私钥，把公钥发布出去给别人使用，自己保留私钥。\"></a>公钥密码体制的公钥和算法都是公开的(这是为什么叫公钥密码体制的原因)，私钥是保密的。大家都以使用公钥进行加密，但是只有私钥的持有者才能解密。在实际的使用中，有需要的人会生成一对公钥和私钥，把公钥发布出去给别人使用，自己保留私钥。</h5></li>\n</ul>\n<h4 id=\"对称加密算法-symmetric-key-algorithms\"><a href=\"#对称加密算法-symmetric-key-algorithms\" class=\"headerlink\" title=\"对称加密算法(symmetric key algorithms)\"></a>对称加密算法(symmetric key algorithms)</h4><h5 id=\"在对称加密算法中，加密使用的密钥和解密使用的密钥是相同的。也就是说，加密和解密都是使用的同一个密钥。因此对称加密算法要保证安全性的话，密钥要做好保密，只能让使用的人知道，不能对外公开。这个和上面的公钥密码体制有所不同，公钥密码体制中加密是用公钥，解密使用私钥，而对称加密算法中，加密和解密都是使用同一个密钥，不区分公钥和私钥。\"><a href=\"#在对称加密算法中，加密使用的密钥和解密使用的密钥是相同的。也就是说，加密和解密都是使用的同一个密钥。因此对称加密算法要保证安全性的话，密钥要做好保密，只能让使用的人知道，不能对外公开。这个和上面的公钥密码体制有所不同，公钥密码体制中加密是用公钥，解密使用私钥，而对称加密算法中，加密和解密都是使用同一个密钥，不区分公钥和私钥。\" class=\"headerlink\" title=\"在对称加密算法中，加密使用的密钥和解密使用的密钥是相同的。也就是说，加密和解密都是使用的同一个密钥。因此对称加密算法要保证安全性的话，密钥要做好保密，只能让使用的人知道，不能对外公开。这个和上面的公钥密码体制有所不同，公钥密码体制中加密是用公钥，解密使用私钥，而对称加密算法中，加密和解密都是使用同一个密钥，不区分公钥和私钥。\"></a>在对称加密算法中，加密使用的密钥和解密使用的密钥是相同的。也就是说，加密和解密都是使用的同一个密钥。因此对称加密算法要保证安全性的话，密钥要做好保密，只能让使用的人知道，不能对外公开。这个和上面的公钥密码体制有所不同，公钥密码体制中加密是用公钥，解密使用私钥，而对称加密算法中，加密和解密都是使用同一个密钥，不区分公钥和私钥。</h5><h5 id=\"密钥，一般就是一个字符串或数字，在加密或者解密时传递给加密-解密算法。前面在公钥密码体制中说到的公钥、私钥就是密钥，公钥是加密使用的密钥，私钥是解密使用的密钥\"><a href=\"#密钥，一般就是一个字符串或数字，在加密或者解密时传递给加密-解密算法。前面在公钥密码体制中说到的公钥、私钥就是密钥，公钥是加密使用的密钥，私钥是解密使用的密钥\" class=\"headerlink\" title=\"密钥，一般就是一个字符串或数字，在加密或者解密时传递给加密/解密算法。前面在公钥密码体制中说到的公钥、私钥就是密钥，公钥是加密使用的密钥，私钥是解密使用的密钥\"></a>密钥，一般就是一个字符串或数字，在加密或者解密时传递给加密/解密算法。前面在公钥密码体制中说到的公钥、私钥就是密钥，公钥是加密使用的密钥，私钥是解密使用的密钥</h5><p><a href=\"http://www.youdzone.com/signature.html\" target=\"_blank\" rel=\"external\">原文连接</a></p>\n","site":{"data":{}},"excerpt":"<h5 id=\"最近因为项目要求，需要在本地环境为项目部署https服务。之前对https的密钥和证书过程都不是很清楚，所以最近恶补了一些基础知识。这是一篇对数字证书很形象的解释，所以决定记录下来，加深记忆。\"><a href=\"#最近因为项目要求，需要在本地环境为项目部署https服务。之前对https的密钥和证书过程都不是很清楚，所以最近恶补了一些基础知识。这是一篇对数字证书很形象的解释，所以决定记录下来，加深记忆。\" class=\"headerlink\" title=\"最近因为项目要求，需要在本地环境为项目部署https服务。之前对https的密钥和证书过程都不是很清楚，所以最近恶补了一些基础知识。这是一篇对数字证书很形象的解释，所以决定记录下来，加深记忆。\"></a>最近因为项目要求，需要在本地环境为项目部署https服务。之前对https的密钥和证书过程都不是很清楚，所以最近恶补了一些基础知识。这是一篇对数字证书很形象的解释，所以决定记录下来，加深记忆。</h5>","more":"<h4 id=\"1-鲍勃有两把钥匙，一把是公钥，另一把是私钥。\"><a href=\"#1-鲍勃有两把钥匙，一把是公钥，另一把是私钥。\" class=\"headerlink\" title=\"1.鲍勃有两把钥匙，一把是公钥，另一把是私钥。\"></a>1.鲍勃有两把钥匙，一把是公钥，另一把是私钥。</h4><p><img src=\"../../img/note/secretkey1.png\" alt=\"\"></p>\n<h4 id=\"2-鲍勃把公钥送给他的朋友们—-帕蒂、道格、苏珊—-每人一把。\"><a href=\"#2-鲍勃把公钥送给他的朋友们—-帕蒂、道格、苏珊—-每人一把。\" class=\"headerlink\" title=\"2.鲍勃把公钥送给他的朋友们—-帕蒂、道格、苏珊—-每人一把。\"></a>2.鲍勃把公钥送给他的朋友们—-帕蒂、道格、苏珊—-每人一把。</h4><p><img src=\"../../img/note/secretkey2.png\" alt=\"\"></p>\n<h4 id=\"3-苏珊给鲍勃写信，写完后用鲍勃的公钥加密，达到保密的效果。\"><a href=\"#3-苏珊给鲍勃写信，写完后用鲍勃的公钥加密，达到保密的效果。\" class=\"headerlink\" title=\"3.苏珊给鲍勃写信，写完后用鲍勃的公钥加密，达到保密的效果。\"></a>3.苏珊给鲍勃写信，写完后用鲍勃的公钥加密，达到保密的效果。</h4><p><img src=\"../../img/note/secretkey3.png\" alt=\"\"></p>\n<h4 id=\"4-鲍勃收信后，用私钥解密，看到信件内容。\"><a href=\"#4-鲍勃收信后，用私钥解密，看到信件内容。\" class=\"headerlink\" title=\"4.鲍勃收信后，用私钥解密，看到信件内容。\"></a>4.鲍勃收信后，用私钥解密，看到信件内容。</h4><p><img src=\"../../img/note/secretkey4.png\" alt=\"\"></p>\n<h4 id=\"5-鲍勃给苏珊回信，写完后用Hash函数，生成信件的摘要（digest）。\"><a href=\"#5-鲍勃给苏珊回信，写完后用Hash函数，生成信件的摘要（digest）。\" class=\"headerlink\" title=\"5.鲍勃给苏珊回信，写完后用Hash函数，生成信件的摘要（digest）。\"></a>5.鲍勃给苏珊回信，写完后用Hash函数，生成信件的摘要（digest）。</h4><p><img src=\"../../img/note/secretkey5.png\" alt=\"\"></p>\n<h4 id=\"6-然后，鲍勃使用私钥，对这个摘要加密，生成”数字签名”（signature）。\"><a href=\"#6-然后，鲍勃使用私钥，对这个摘要加密，生成”数字签名”（signature）。\" class=\"headerlink\" title=\"6.然后，鲍勃使用私钥，对这个摘要加密，生成”数字签名”（signature）。\"></a>6.然后，鲍勃使用私钥，对这个摘要加密，生成”数字签名”（signature）。</h4><p><img src=\"../../img/note/secretkey6.png\" alt=\"\"></p>\n<h4 id=\"7-鲍勃将这个签名，附在信件下面，一起发给苏珊。\"><a href=\"#7-鲍勃将这个签名，附在信件下面，一起发给苏珊。\" class=\"headerlink\" title=\"7.鲍勃将这个签名，附在信件下面，一起发给苏珊。\"></a>7.鲍勃将这个签名，附在信件下面，一起发给苏珊。</h4><p><img src=\"../../img/note/secretkey7.png\" alt=\"\"></p>\n<h4 id=\"8-苏珊收信后，取下数字签名，用鲍勃的公钥解密，得到信件的摘要。由此证明，这封信确实是鲍勃发出的。\"><a href=\"#8-苏珊收信后，取下数字签名，用鲍勃的公钥解密，得到信件的摘要。由此证明，这封信确实是鲍勃发出的。\" class=\"headerlink\" title=\"8.苏珊收信后，取下数字签名，用鲍勃的公钥解密，得到信件的摘要。由此证明，这封信确实是鲍勃发出的。\"></a>8.苏珊收信后，取下数字签名，用鲍勃的公钥解密，得到信件的摘要。由此证明，这封信确实是鲍勃发出的。</h4><p><img src=\"../../img/note/secretkey8.png\" alt=\"\"></p>\n<h4 id=\"9-苏珊再对信件本身使用Hash函数，将得到的结果，与上一步得到的摘要进行对比。如果两者一致，就证明这封信未被修改过。\"><a href=\"#9-苏珊再对信件本身使用Hash函数，将得到的结果，与上一步得到的摘要进行对比。如果两者一致，就证明这封信未被修改过。\" class=\"headerlink\" title=\"9.苏珊再对信件本身使用Hash函数，将得到的结果，与上一步得到的摘要进行对比。如果两者一致，就证明这封信未被修改过。\"></a>9.苏珊再对信件本身使用Hash函数，将得到的结果，与上一步得到的摘要进行对比。如果两者一致，就证明这封信未被修改过。</h4><p><img src=\"../../img/note/secretkey9.png\" alt=\"\"></p>\n<h4 id=\"10-复杂的情况出现了。道格想欺骗苏珊，他偷偷使用了苏珊的电脑，用自己的公钥换走了鲍勃的公钥。因此，他就可以冒充鲍勃，写信给苏珊。\"><a href=\"#10-复杂的情况出现了。道格想欺骗苏珊，他偷偷使用了苏珊的电脑，用自己的公钥换走了鲍勃的公钥。因此，他就可以冒充鲍勃，写信给苏珊。\" class=\"headerlink\" title=\"10.复杂的情况出现了。道格想欺骗苏珊，他偷偷使用了苏珊的电脑，用自己的公钥换走了鲍勃的公钥。因此，他就可以冒充鲍勃，写信给苏珊。\"></a>10.复杂的情况出现了。道格想欺骗苏珊，他偷偷使用了苏珊的电脑，用自己的公钥换走了鲍勃的公钥。因此，他就可以冒充鲍勃，写信给苏珊。</h4><p><img src=\"../../img/note/secretkey10.png\" alt=\"\"></p>\n<h4 id=\"11-苏珊发现，自己无法确定公钥是否真的属于鲍勃。她想到了一个办法，要求鲍勃去找”证书中心”（certificate-authority，简称CA），为公钥做认证。证书中心用自己的私钥，对鲍勃的公钥和一些相关信息一起加密，生成”数字证书”（Digital-Certificate）。\"><a href=\"#11-苏珊发现，自己无法确定公钥是否真的属于鲍勃。她想到了一个办法，要求鲍勃去找”证书中心”（certificate-authority，简称CA），为公钥做认证。证书中心用自己的私钥，对鲍勃的公钥和一些相关信息一起加密，生成”数字证书”（Digital-Certificate）。\" class=\"headerlink\" title=\"11.苏珊发现，自己无法确定公钥是否真的属于鲍勃。她想到了一个办法，要求鲍勃去找”证书中心”（certificate authority，简称CA），为公钥做认证。证书中心用自己的私钥，对鲍勃的公钥和一些相关信息一起加密，生成”数字证书”（Digital Certificate）。\"></a>11.苏珊发现，自己无法确定公钥是否真的属于鲍勃。她想到了一个办法，要求鲍勃去找”证书中心”（certificate authority，简称CA），为公钥做认证。证书中心用自己的私钥，对鲍勃的公钥和一些相关信息一起加密，生成”数字证书”（Digital Certificate）。</h4><p><img src=\"../../img/note/secretkey11.png\" alt=\"\"></p>\n<h4 id=\"12-鲍勃拿到数字证书以后，就可以放心了。以后再给苏珊写信，只要在签名的同时，再附上数字证书就行了。\"><a href=\"#12-鲍勃拿到数字证书以后，就可以放心了。以后再给苏珊写信，只要在签名的同时，再附上数字证书就行了。\" class=\"headerlink\" title=\"12.鲍勃拿到数字证书以后，就可以放心了。以后再给苏珊写信，只要在签名的同时，再附上数字证书就行了。\"></a>12.鲍勃拿到数字证书以后，就可以放心了。以后再给苏珊写信，只要在签名的同时，再附上数字证书就行了。</h4><p><img src=\"../../img/note/secretkey12.png\" alt=\"\"></p>\n<h4 id=\"13-苏珊收信后，用CA的公钥解开数字证书，就可以拿到鲍勃真实的公钥了，然后就能证明”数字签名”是否真的是鲍勃签的。\"><a href=\"#13-苏珊收信后，用CA的公钥解开数字证书，就可以拿到鲍勃真实的公钥了，然后就能证明”数字签名”是否真的是鲍勃签的。\" class=\"headerlink\" title=\"13.苏珊收信后，用CA的公钥解开数字证书，就可以拿到鲍勃真实的公钥了，然后就能证明”数字签名”是否真的是鲍勃签的。\"></a>13.苏珊收信后，用CA的公钥解开数字证书，就可以拿到鲍勃真实的公钥了，然后就能证明”数字签名”是否真的是鲍勃签的。</h4><p><img src=\"../../img/note/secretkey13.png\" alt=\"\"></p>\n<h4 id=\"14-下面，我们看一个应用”数字证书”的实例：https协议。这个协议主要用于网页加密。\"><a href=\"#14-下面，我们看一个应用”数字证书”的实例：https协议。这个协议主要用于网页加密。\" class=\"headerlink\" title=\"14.下面，我们看一个应用”数字证书”的实例：https协议。这个协议主要用于网页加密。\"></a>14.下面，我们看一个应用”数字证书”的实例：https协议。这个协议主要用于网页加密。</h4><p><img src=\"../../img/note/secretkey14.jpg\" alt=\"\"></p>\n<h4 id=\"15-首先，客户端向服务器发出加密请求。\"><a href=\"#15-首先，客户端向服务器发出加密请求。\" class=\"headerlink\" title=\"15.首先，客户端向服务器发出加密请求。\"></a>15.首先，客户端向服务器发出加密请求。</h4><p><img src=\"../../img/note/secretkey15.png\" alt=\"\"></p>\n<h4 id=\"16-服务器用自己的私钥加密网页以后，连同本身的数字证书，一起发送给客户端。\"><a href=\"#16-服务器用自己的私钥加密网页以后，连同本身的数字证书，一起发送给客户端。\" class=\"headerlink\" title=\"16.服务器用自己的私钥加密网页以后，连同本身的数字证书，一起发送给客户端。\"></a>16.服务器用自己的私钥加密网页以后，连同本身的数字证书，一起发送给客户端。</h4><p><img src=\"../../img/note/secretkey16.png\" alt=\"\"></p>\n<h4 id=\"17-客户端（浏览器）的”证书管理器”，有”受信任的根证书颁发机构”列表。客户端会根据这张列表，查看解开数字证书的公钥是否在列表之内。\"><a href=\"#17-客户端（浏览器）的”证书管理器”，有”受信任的根证书颁发机构”列表。客户端会根据这张列表，查看解开数字证书的公钥是否在列表之内。\" class=\"headerlink\" title=\"17.客户端（浏览器）的”证书管理器”，有”受信任的根证书颁发机构”列表。客户端会根据这张列表，查看解开数字证书的公钥是否在列表之内。\"></a>17.客户端（浏览器）的”证书管理器”，有”受信任的根证书颁发机构”列表。客户端会根据这张列表，查看解开数字证书的公钥是否在列表之内。</h4><p><img src=\"../../img/note/secretkey17.png\" alt=\"\"></p>\n<h4 id=\"18-如果数字证书记载的网址，与你正在浏览的网址不一致，就说明这张证书可能被冒用，浏览器会发出警告。\"><a href=\"#18-如果数字证书记载的网址，与你正在浏览的网址不一致，就说明这张证书可能被冒用，浏览器会发出警告。\" class=\"headerlink\" title=\"18.如果数字证书记载的网址，与你正在浏览的网址不一致，就说明这张证书可能被冒用，浏览器会发出警告。\"></a>18.如果数字证书记载的网址，与你正在浏览的网址不一致，就说明这张证书可能被冒用，浏览器会发出警告。</h4><p><img src=\"../../img/note/secretkey18.png\" alt=\"\"></p>\n<h4 id=\"19-如果这张数字证书不是由受信任的机构颁发的，浏览器会发出另一种警告。\"><a href=\"#19-如果这张数字证书不是由受信任的机构颁发的，浏览器会发出另一种警告。\" class=\"headerlink\" title=\"19.如果这张数字证书不是由受信任的机构颁发的，浏览器会发出另一种警告。\"></a>19.如果这张数字证书不是由受信任的机构颁发的，浏览器会发出另一种警告。</h4><p><img src=\"../../img/note/secretkey19.jpg\" alt=\"\"></p>\n<h4 id=\"20-如果数字证书是可靠的，客户端就可以使用证书中的服务器公钥，对信息进行加密，然后与服务器交换加密信息。\"><a href=\"#20-如果数字证书是可靠的，客户端就可以使用证书中的服务器公钥，对信息进行加密，然后与服务器交换加密信息。\" class=\"headerlink\" title=\"20.如果数字证书是可靠的，客户端就可以使用证书中的服务器公钥，对信息进行加密，然后与服务器交换加密信息。\"></a>20.如果数字证书是可靠的，客户端就可以使用证书中的服务器公钥，对信息进行加密，然后与服务器交换加密信息。</h4><p><img src=\"../../img/note/secretkey20.png\" alt=\"\"></p>\n<h3 id=\"想更好地理解上面这篇形象生动的技术文章，你还需要理解一些概念和术语\"><a href=\"#想更好地理解上面这篇形象生动的技术文章，你还需要理解一些概念和术语\" class=\"headerlink\" title=\"想更好地理解上面这篇形象生动的技术文章，你还需要理解一些概念和术语\"></a>想更好地理解上面这篇形象生动的技术文章，你还需要理解一些概念和术语</h3><h4 id=\"公钥密码体制-public-key-cryptography\"><a href=\"#公钥密码体制-public-key-cryptography\" class=\"headerlink\" title=\"公钥密码体制(public-key cryptography)\"></a>公钥密码体制(public-key cryptography)</h4><h5 id=\"公钥密码体制分为三个部分，公钥、私钥、加密解密算法，它的加密解密过程如下：\"><a href=\"#公钥密码体制分为三个部分，公钥、私钥、加密解密算法，它的加密解密过程如下：\" class=\"headerlink\" title=\"公钥密码体制分为三个部分，公钥、私钥、加密解密算法，它的加密解密过程如下：\"></a>公钥密码体制分为三个部分，公钥、私钥、加密解密算法，它的加密解密过程如下：</h5><ul>\n<li>加密：通过加密算法和公钥对内容(或者说明文)进行加密，得到密文。加密过程需要用到公钥。</li>\n<li>解密：通过解密算法和私钥对密文进行解密，得到明文。解密过程需要用到解密算法和私钥。注意，由公钥加密的内容，只能由私钥进行解密，也就是说，由公钥加密的内容，如果不知道私钥，是无法解密的。<h5 id=\"公钥密码体制的公钥和算法都是公开的-这是为什么叫公钥密码体制的原因-，私钥是保密的。大家都以使用公钥进行加密，但是只有私钥的持有者才能解密。在实际的使用中，有需要的人会生成一对公钥和私钥，把公钥发布出去给别人使用，自己保留私钥。\"><a href=\"#公钥密码体制的公钥和算法都是公开的-这是为什么叫公钥密码体制的原因-，私钥是保密的。大家都以使用公钥进行加密，但是只有私钥的持有者才能解密。在实际的使用中，有需要的人会生成一对公钥和私钥，把公钥发布出去给别人使用，自己保留私钥。\" class=\"headerlink\" title=\"公钥密码体制的公钥和算法都是公开的(这是为什么叫公钥密码体制的原因)，私钥是保密的。大家都以使用公钥进行加密，但是只有私钥的持有者才能解密。在实际的使用中，有需要的人会生成一对公钥和私钥，把公钥发布出去给别人使用，自己保留私钥。\"></a>公钥密码体制的公钥和算法都是公开的(这是为什么叫公钥密码体制的原因)，私钥是保密的。大家都以使用公钥进行加密，但是只有私钥的持有者才能解密。在实际的使用中，有需要的人会生成一对公钥和私钥，把公钥发布出去给别人使用，自己保留私钥。</h5></li>\n</ul>\n<h4 id=\"对称加密算法-symmetric-key-algorithms\"><a href=\"#对称加密算法-symmetric-key-algorithms\" class=\"headerlink\" title=\"对称加密算法(symmetric key algorithms)\"></a>对称加密算法(symmetric key algorithms)</h4><h5 id=\"在对称加密算法中，加密使用的密钥和解密使用的密钥是相同的。也就是说，加密和解密都是使用的同一个密钥。因此对称加密算法要保证安全性的话，密钥要做好保密，只能让使用的人知道，不能对外公开。这个和上面的公钥密码体制有所不同，公钥密码体制中加密是用公钥，解密使用私钥，而对称加密算法中，加密和解密都是使用同一个密钥，不区分公钥和私钥。\"><a href=\"#在对称加密算法中，加密使用的密钥和解密使用的密钥是相同的。也就是说，加密和解密都是使用的同一个密钥。因此对称加密算法要保证安全性的话，密钥要做好保密，只能让使用的人知道，不能对外公开。这个和上面的公钥密码体制有所不同，公钥密码体制中加密是用公钥，解密使用私钥，而对称加密算法中，加密和解密都是使用同一个密钥，不区分公钥和私钥。\" class=\"headerlink\" title=\"在对称加密算法中，加密使用的密钥和解密使用的密钥是相同的。也就是说，加密和解密都是使用的同一个密钥。因此对称加密算法要保证安全性的话，密钥要做好保密，只能让使用的人知道，不能对外公开。这个和上面的公钥密码体制有所不同，公钥密码体制中加密是用公钥，解密使用私钥，而对称加密算法中，加密和解密都是使用同一个密钥，不区分公钥和私钥。\"></a>在对称加密算法中，加密使用的密钥和解密使用的密钥是相同的。也就是说，加密和解密都是使用的同一个密钥。因此对称加密算法要保证安全性的话，密钥要做好保密，只能让使用的人知道，不能对外公开。这个和上面的公钥密码体制有所不同，公钥密码体制中加密是用公钥，解密使用私钥，而对称加密算法中，加密和解密都是使用同一个密钥，不区分公钥和私钥。</h5><h5 id=\"密钥，一般就是一个字符串或数字，在加密或者解密时传递给加密-解密算法。前面在公钥密码体制中说到的公钥、私钥就是密钥，公钥是加密使用的密钥，私钥是解密使用的密钥\"><a href=\"#密钥，一般就是一个字符串或数字，在加密或者解密时传递给加密-解密算法。前面在公钥密码体制中说到的公钥、私钥就是密钥，公钥是加密使用的密钥，私钥是解密使用的密钥\" class=\"headerlink\" title=\"密钥，一般就是一个字符串或数字，在加密或者解密时传递给加密/解密算法。前面在公钥密码体制中说到的公钥、私钥就是密钥，公钥是加密使用的密钥，私钥是解密使用的密钥\"></a>密钥，一般就是一个字符串或数字，在加密或者解密时传递给加密/解密算法。前面在公钥密码体制中说到的公钥、私钥就是密钥，公钥是加密使用的密钥，私钥是解密使用的密钥</h5><p><a href=\"http://www.youdzone.com/signature.html\" target=\"_blank\" rel=\"external\">原文连接</a></p>"},{"layout":"post","title":"vim快捷键笔记","date":"2016-10-13T16:00:00.000Z","_content":"\n## 一. 移动光标\n1. 左移h. 右移l. 下移j. 上移k\n2. 向下翻页ctrl + f，向上翻页ctrl + b    \n3. 向下翻半页ctrl + d，向上翻半页ctrl + u\n4. 移动到行尾$，移动到行首0（数字），移动到行首第一个字符处^\n5. 移动光标到下一个句子 ），移动光标到上一个句子（\n6. 移动到段首{，移动到段尾}\n7. 移动到下一个词w，移动到上一个词b\n8. 移动到文档开始gg，移动到文档结束G\n9. 移动到匹配的{}.().[]处%\n10. 跳到第n行 ngg 或 nG 或 :n\n11. 移动光标到屏幕顶端H，移动到屏幕中间M，移动到底部L\n12. 读取当前字符，并移动到本屏幕内下一次出现的地方*\n13. 读取当前字符，并移动到本屏幕内上一次出现的地方#\n\n<!--more-->\n\n## 二. 查找替换\n1. 光标向后查找关键字 #或者g#\n2. 光标向前查找关键字 *或者g*\n3. 当前行查找字符 fx, Fx, tx, Tx\n4. 基本替换 :s/s1/s2 （将下一个s1替换为s2）\n5. 全部替换 :%s/s1/s2\n6. 只替换当前行 :s/s1/s2/g\n7. 替换某些行 :n1,n2 s/s1/s2/g\n8. 搜索模式为 /string，搜索下一处为n，搜索上一处为N\n9. 制定书签 mx, 但是看不到书签标记，而且只能用小写字母\n10. 移动到某标签处 `x，1旁边的键\n11. 移动到上次编辑文件的位置 `.\n\n##### PS：.代表一个任意字符 \\*代表一个或多个字符的重复\n\n## 三. 编辑操作\n1. 光标后插入a, 行尾插入A\n2. 后插一行插入o，前插一行插入O\n3. 删除字符插入s， 删除正行插入S\n4. 光标前插入i，行首插入I\n5. 删除一行dd，删除后进入插入模式cc或者S\n6. 删除一个单词dw，删除一个单词进入插入模式cw\n7. 删除一个字符x或者dl，删除一个字符进入插入模式s或者cl\n8. 粘贴p，交换两个字符xp，交换两行ddp\n9. 复制y，复制一行yy\n10. 撤销u，重做ctrl + r，重复.\n11. 智能提示 ctrl + n 或者 ctrl + p\n12. 删除motion跨过的字符，删除并进入插入模式 c{motion}\n13. 删除到下一个字符跨过的字符，删除并进入插入模式，不包括x字符 ctx\n14. 删除当前字符到下一个字符处的所有字符，并进入插入模式，包括x字符，cfx\n15. 删除motion跨过的字符，删除但不进入插入模式 d{motion}\n16. 删除motion跨过的字符，删除但不进入插入模式，不包括x字符 dtx\n17. 删除当前字符到下一个字符处的所有字符，包括x字符 dfx\n18. 如果只是复制的情况时，将12-17条中的c或d改为y\n19. 删除到行尾可以使用D或C\n20. 拷贝当前行 yy或者Y\n21. 删除当前字符 x\n22. 粘贴 p\n23. 可以使用多重剪切板，查看状态使用:reg，使用剪切板使用”，例如复制到w寄存器，”wyy，或者使用可视模式v”wy\n24. 重复执行上一个作用使用.\n25. 使用数字可以跨过n个区域，如y3x，会拷贝光标到第三个x之间的区域，3j向下移动3行\n26. 在编写代码的时候可以使用]p粘贴，这样可以自动进行代码缩进\n27. \\>> 缩进所有选择的代码\n28. << 反缩进所有选择的代码\n29. gd 移动到光标所处的函数或变量的定义处\n30. K 在man里搜索光标所在的词\n31. 合并两行 J\n32. 若不想保存文件，而重新打开 :e!\n33. 若想打开新文件 :e filename，然后使用ctrl + ^进行文件切换\n\n## 四. 窗口操作\n1. 分隔一个窗口:split或者:vsplit\n2. 创建一个窗口:new或者:vnew\n3. 在新窗口打开文件:sf {filename}\n4. 关闭当前窗口:close\n5. 仅保留当前窗口:only\n6. 到左边窗口 ctrl + w, h\n7. 到右边窗口 ctrl + w, l\n8. 到上边窗口 ctrl + w, k\n9. 到下边窗口 ctrl + w, j\n10. 到顶部窗口 ctrl + w, t\n11. 到底部窗口 ctrl + w, b\n\n## 五. 宏操作\n1. 开始记录宏操作q[a-z]，按q结束，保存操作到寄存器[a-z]中\n2. @[a-z]执行寄存器[a-z]中的操作\n3. @@执行最近一次记录的宏操作\n\n## 六. 可视操作\n1. 进入块可视模式 ctrl + v\n2. 进入字符可视模式 v\n3. 进入行可视模式 V\n4. 删除选定的块 d\n5. 删除选定的块然后进入插入模式 c\n6. 在选中的块同是插入相同的字符 IESC\n\n## 七. 跳到声明\n1. [[ 向前跳到顶格第一个{  \n2. [] 向前跳到顶格第一个}\n3. ]] 向后跳到顶格的第一个{\n4. ]] 向后跳到顶格的第一个}\n5. [{ 跳到本代码块的开头\n6. ]} 跳到本代码块的结尾\n\n## 八. 挂起操作\n1. 挂起Vim ctrl + z 或者 :suspend\n2. 查看任务 在shell中输入 jobs\n3. 恢复任务 fg [job number]（将后台程序放到前台）或者 bg [job number]（将前台程序放到后台）\n4. 执行shell命令 :!command\n5. 开启shell命令 :shell，退出该shell exit\n6. 保存vim状态 :mksession name.vim\n7. 恢复vim状态 :source name.vim\n8. 启动vim时恢复状态 vim -S name.vim\n","source":"_posts/note/vimNotes.md","raw":"---\nlayout: post\ntitle: vim快捷键笔记\ndate: 2016/10/14\ntags: [tech, note, index]\n---\n\n## 一. 移动光标\n1. 左移h. 右移l. 下移j. 上移k\n2. 向下翻页ctrl + f，向上翻页ctrl + b    \n3. 向下翻半页ctrl + d，向上翻半页ctrl + u\n4. 移动到行尾$，移动到行首0（数字），移动到行首第一个字符处^\n5. 移动光标到下一个句子 ），移动光标到上一个句子（\n6. 移动到段首{，移动到段尾}\n7. 移动到下一个词w，移动到上一个词b\n8. 移动到文档开始gg，移动到文档结束G\n9. 移动到匹配的{}.().[]处%\n10. 跳到第n行 ngg 或 nG 或 :n\n11. 移动光标到屏幕顶端H，移动到屏幕中间M，移动到底部L\n12. 读取当前字符，并移动到本屏幕内下一次出现的地方*\n13. 读取当前字符，并移动到本屏幕内上一次出现的地方#\n\n<!--more-->\n\n## 二. 查找替换\n1. 光标向后查找关键字 #或者g#\n2. 光标向前查找关键字 *或者g*\n3. 当前行查找字符 fx, Fx, tx, Tx\n4. 基本替换 :s/s1/s2 （将下一个s1替换为s2）\n5. 全部替换 :%s/s1/s2\n6. 只替换当前行 :s/s1/s2/g\n7. 替换某些行 :n1,n2 s/s1/s2/g\n8. 搜索模式为 /string，搜索下一处为n，搜索上一处为N\n9. 制定书签 mx, 但是看不到书签标记，而且只能用小写字母\n10. 移动到某标签处 `x，1旁边的键\n11. 移动到上次编辑文件的位置 `.\n\n##### PS：.代表一个任意字符 \\*代表一个或多个字符的重复\n\n## 三. 编辑操作\n1. 光标后插入a, 行尾插入A\n2. 后插一行插入o，前插一行插入O\n3. 删除字符插入s， 删除正行插入S\n4. 光标前插入i，行首插入I\n5. 删除一行dd，删除后进入插入模式cc或者S\n6. 删除一个单词dw，删除一个单词进入插入模式cw\n7. 删除一个字符x或者dl，删除一个字符进入插入模式s或者cl\n8. 粘贴p，交换两个字符xp，交换两行ddp\n9. 复制y，复制一行yy\n10. 撤销u，重做ctrl + r，重复.\n11. 智能提示 ctrl + n 或者 ctrl + p\n12. 删除motion跨过的字符，删除并进入插入模式 c{motion}\n13. 删除到下一个字符跨过的字符，删除并进入插入模式，不包括x字符 ctx\n14. 删除当前字符到下一个字符处的所有字符，并进入插入模式，包括x字符，cfx\n15. 删除motion跨过的字符，删除但不进入插入模式 d{motion}\n16. 删除motion跨过的字符，删除但不进入插入模式，不包括x字符 dtx\n17. 删除当前字符到下一个字符处的所有字符，包括x字符 dfx\n18. 如果只是复制的情况时，将12-17条中的c或d改为y\n19. 删除到行尾可以使用D或C\n20. 拷贝当前行 yy或者Y\n21. 删除当前字符 x\n22. 粘贴 p\n23. 可以使用多重剪切板，查看状态使用:reg，使用剪切板使用”，例如复制到w寄存器，”wyy，或者使用可视模式v”wy\n24. 重复执行上一个作用使用.\n25. 使用数字可以跨过n个区域，如y3x，会拷贝光标到第三个x之间的区域，3j向下移动3行\n26. 在编写代码的时候可以使用]p粘贴，这样可以自动进行代码缩进\n27. \\>> 缩进所有选择的代码\n28. << 反缩进所有选择的代码\n29. gd 移动到光标所处的函数或变量的定义处\n30. K 在man里搜索光标所在的词\n31. 合并两行 J\n32. 若不想保存文件，而重新打开 :e!\n33. 若想打开新文件 :e filename，然后使用ctrl + ^进行文件切换\n\n## 四. 窗口操作\n1. 分隔一个窗口:split或者:vsplit\n2. 创建一个窗口:new或者:vnew\n3. 在新窗口打开文件:sf {filename}\n4. 关闭当前窗口:close\n5. 仅保留当前窗口:only\n6. 到左边窗口 ctrl + w, h\n7. 到右边窗口 ctrl + w, l\n8. 到上边窗口 ctrl + w, k\n9. 到下边窗口 ctrl + w, j\n10. 到顶部窗口 ctrl + w, t\n11. 到底部窗口 ctrl + w, b\n\n## 五. 宏操作\n1. 开始记录宏操作q[a-z]，按q结束，保存操作到寄存器[a-z]中\n2. @[a-z]执行寄存器[a-z]中的操作\n3. @@执行最近一次记录的宏操作\n\n## 六. 可视操作\n1. 进入块可视模式 ctrl + v\n2. 进入字符可视模式 v\n3. 进入行可视模式 V\n4. 删除选定的块 d\n5. 删除选定的块然后进入插入模式 c\n6. 在选中的块同是插入相同的字符 IESC\n\n## 七. 跳到声明\n1. [[ 向前跳到顶格第一个{  \n2. [] 向前跳到顶格第一个}\n3. ]] 向后跳到顶格的第一个{\n4. ]] 向后跳到顶格的第一个}\n5. [{ 跳到本代码块的开头\n6. ]} 跳到本代码块的结尾\n\n## 八. 挂起操作\n1. 挂起Vim ctrl + z 或者 :suspend\n2. 查看任务 在shell中输入 jobs\n3. 恢复任务 fg [job number]（将后台程序放到前台）或者 bg [job number]（将前台程序放到后台）\n4. 执行shell命令 :!command\n5. 开启shell命令 :shell，退出该shell exit\n6. 保存vim状态 :mksession name.vim\n7. 恢复vim状态 :source name.vim\n8. 启动vim时恢复状态 vim -S name.vim\n","slug":"note/vimNotes","published":1,"updated":"2017-08-15T11:31:46.000Z","comments":1,"photos":[],"link":"","_id":"cj8jros7b000j30s6ak5w6c2t","content":"<h2 id=\"一-移动光标\"><a href=\"#一-移动光标\" class=\"headerlink\" title=\"一. 移动光标\"></a>一. 移动光标</h2><ol>\n<li>左移h. 右移l. 下移j. 上移k</li>\n<li>向下翻页ctrl + f，向上翻页ctrl + b    </li>\n<li>向下翻半页ctrl + d，向上翻半页ctrl + u</li>\n<li>移动到行尾$，移动到行首0（数字），移动到行首第一个字符处^</li>\n<li>移动光标到下一个句子 ），移动光标到上一个句子（</li>\n<li>移动到段首{，移动到段尾}</li>\n<li>移动到下一个词w，移动到上一个词b</li>\n<li>移动到文档开始gg，移动到文档结束G</li>\n<li>移动到匹配的{}.().[]处%</li>\n<li>跳到第n行 ngg 或 nG 或 :n</li>\n<li>移动光标到屏幕顶端H，移动到屏幕中间M，移动到底部L</li>\n<li>读取当前字符，并移动到本屏幕内下一次出现的地方*</li>\n<li>读取当前字符，并移动到本屏幕内上一次出现的地方#</li>\n</ol>\n<a id=\"more\"></a>\n<h2 id=\"二-查找替换\"><a href=\"#二-查找替换\" class=\"headerlink\" title=\"二. 查找替换\"></a>二. 查找替换</h2><ol>\n<li>光标向后查找关键字 #或者g#</li>\n<li>光标向前查找关键字 <em>或者g</em></li>\n<li>当前行查找字符 fx, Fx, tx, Tx</li>\n<li>基本替换 :s/s1/s2 （将下一个s1替换为s2）</li>\n<li>全部替换 :%s/s1/s2</li>\n<li>只替换当前行 :s/s1/s2/g</li>\n<li>替换某些行 :n1,n2 s/s1/s2/g</li>\n<li>搜索模式为 /string，搜索下一处为n，搜索上一处为N</li>\n<li>制定书签 mx, 但是看不到书签标记，而且只能用小写字母</li>\n<li>移动到某标签处 `x，1旁边的键</li>\n<li>移动到上次编辑文件的位置 `.</li>\n</ol>\n<h5 id=\"PS：-代表一个任意字符-代表一个或多个字符的重复\"><a href=\"#PS：-代表一个任意字符-代表一个或多个字符的重复\" class=\"headerlink\" title=\"PS：.代表一个任意字符 *代表一个或多个字符的重复\"></a>PS：.代表一个任意字符 *代表一个或多个字符的重复</h5><h2 id=\"三-编辑操作\"><a href=\"#三-编辑操作\" class=\"headerlink\" title=\"三. 编辑操作\"></a>三. 编辑操作</h2><ol>\n<li>光标后插入a, 行尾插入A</li>\n<li>后插一行插入o，前插一行插入O</li>\n<li>删除字符插入s， 删除正行插入S</li>\n<li>光标前插入i，行首插入I</li>\n<li>删除一行dd，删除后进入插入模式cc或者S</li>\n<li>删除一个单词dw，删除一个单词进入插入模式cw</li>\n<li>删除一个字符x或者dl，删除一个字符进入插入模式s或者cl</li>\n<li>粘贴p，交换两个字符xp，交换两行ddp</li>\n<li>复制y，复制一行yy</li>\n<li>撤销u，重做ctrl + r，重复.</li>\n<li>智能提示 ctrl + n 或者 ctrl + p</li>\n<li>删除motion跨过的字符，删除并进入插入模式 c{motion}</li>\n<li>删除到下一个字符跨过的字符，删除并进入插入模式，不包括x字符 ctx</li>\n<li>删除当前字符到下一个字符处的所有字符，并进入插入模式，包括x字符，cfx</li>\n<li>删除motion跨过的字符，删除但不进入插入模式 d{motion}</li>\n<li>删除motion跨过的字符，删除但不进入插入模式，不包括x字符 dtx</li>\n<li>删除当前字符到下一个字符处的所有字符，包括x字符 dfx</li>\n<li>如果只是复制的情况时，将12-17条中的c或d改为y</li>\n<li>删除到行尾可以使用D或C</li>\n<li>拷贝当前行 yy或者Y</li>\n<li>删除当前字符 x</li>\n<li>粘贴 p</li>\n<li>可以使用多重剪切板，查看状态使用:reg，使用剪切板使用”，例如复制到w寄存器，”wyy，或者使用可视模式v”wy</li>\n<li>重复执行上一个作用使用.</li>\n<li>使用数字可以跨过n个区域，如y3x，会拷贝光标到第三个x之间的区域，3j向下移动3行</li>\n<li>在编写代码的时候可以使用]p粘贴，这样可以自动进行代码缩进</li>\n<li>>&gt; 缩进所有选择的代码</li>\n<li>&lt;&lt; 反缩进所有选择的代码</li>\n<li>gd 移动到光标所处的函数或变量的定义处</li>\n<li>K 在man里搜索光标所在的词</li>\n<li>合并两行 J</li>\n<li>若不想保存文件，而重新打开 :e!</li>\n<li>若想打开新文件 :e filename，然后使用ctrl + ^进行文件切换</li>\n</ol>\n<h2 id=\"四-窗口操作\"><a href=\"#四-窗口操作\" class=\"headerlink\" title=\"四. 窗口操作\"></a>四. 窗口操作</h2><ol>\n<li>分隔一个窗口:split或者:vsplit</li>\n<li>创建一个窗口:new或者:vnew</li>\n<li>在新窗口打开文件:sf {filename}</li>\n<li>关闭当前窗口:close</li>\n<li>仅保留当前窗口:only</li>\n<li>到左边窗口 ctrl + w, h</li>\n<li>到右边窗口 ctrl + w, l</li>\n<li>到上边窗口 ctrl + w, k</li>\n<li>到下边窗口 ctrl + w, j</li>\n<li>到顶部窗口 ctrl + w, t</li>\n<li>到底部窗口 ctrl + w, b</li>\n</ol>\n<h2 id=\"五-宏操作\"><a href=\"#五-宏操作\" class=\"headerlink\" title=\"五. 宏操作\"></a>五. 宏操作</h2><ol>\n<li>开始记录宏操作q[a-z]，按q结束，保存操作到寄存器[a-z]中</li>\n<li>@[a-z]执行寄存器[a-z]中的操作</li>\n<li>@@执行最近一次记录的宏操作</li>\n</ol>\n<h2 id=\"六-可视操作\"><a href=\"#六-可视操作\" class=\"headerlink\" title=\"六. 可视操作\"></a>六. 可视操作</h2><ol>\n<li>进入块可视模式 ctrl + v</li>\n<li>进入字符可视模式 v</li>\n<li>进入行可视模式 V</li>\n<li>删除选定的块 d</li>\n<li>删除选定的块然后进入插入模式 c</li>\n<li>在选中的块同是插入相同的字符 IESC</li>\n</ol>\n<h2 id=\"七-跳到声明\"><a href=\"#七-跳到声明\" class=\"headerlink\" title=\"七. 跳到声明\"></a>七. 跳到声明</h2><ol>\n<li>[[ 向前跳到顶格第一个{  </li>\n<li>[] 向前跳到顶格第一个}</li>\n<li>]] 向后跳到顶格的第一个{</li>\n<li>]] 向后跳到顶格的第一个}</li>\n<li>[{ 跳到本代码块的开头</li>\n<li>]} 跳到本代码块的结尾</li>\n</ol>\n<h2 id=\"八-挂起操作\"><a href=\"#八-挂起操作\" class=\"headerlink\" title=\"八. 挂起操作\"></a>八. 挂起操作</h2><ol>\n<li>挂起Vim ctrl + z 或者 :suspend</li>\n<li>查看任务 在shell中输入 jobs</li>\n<li>恢复任务 fg [job number]（将后台程序放到前台）或者 bg [job number]（将前台程序放到后台）</li>\n<li>执行shell命令 :!command</li>\n<li>开启shell命令 :shell，退出该shell exit</li>\n<li>保存vim状态 :mksession name.vim</li>\n<li>恢复vim状态 :source name.vim</li>\n<li>启动vim时恢复状态 vim -S name.vim</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h2 id=\"一-移动光标\"><a href=\"#一-移动光标\" class=\"headerlink\" title=\"一. 移动光标\"></a>一. 移动光标</h2><ol>\n<li>左移h. 右移l. 下移j. 上移k</li>\n<li>向下翻页ctrl + f，向上翻页ctrl + b    </li>\n<li>向下翻半页ctrl + d，向上翻半页ctrl + u</li>\n<li>移动到行尾$，移动到行首0（数字），移动到行首第一个字符处^</li>\n<li>移动光标到下一个句子 ），移动光标到上一个句子（</li>\n<li>移动到段首{，移动到段尾}</li>\n<li>移动到下一个词w，移动到上一个词b</li>\n<li>移动到文档开始gg，移动到文档结束G</li>\n<li>移动到匹配的{}.().[]处%</li>\n<li>跳到第n行 ngg 或 nG 或 :n</li>\n<li>移动光标到屏幕顶端H，移动到屏幕中间M，移动到底部L</li>\n<li>读取当前字符，并移动到本屏幕内下一次出现的地方*</li>\n<li>读取当前字符，并移动到本屏幕内上一次出现的地方#</li>\n</ol>","more":"<h2 id=\"二-查找替换\"><a href=\"#二-查找替换\" class=\"headerlink\" title=\"二. 查找替换\"></a>二. 查找替换</h2><ol>\n<li>光标向后查找关键字 #或者g#</li>\n<li>光标向前查找关键字 <em>或者g</em></li>\n<li>当前行查找字符 fx, Fx, tx, Tx</li>\n<li>基本替换 :s/s1/s2 （将下一个s1替换为s2）</li>\n<li>全部替换 :%s/s1/s2</li>\n<li>只替换当前行 :s/s1/s2/g</li>\n<li>替换某些行 :n1,n2 s/s1/s2/g</li>\n<li>搜索模式为 /string，搜索下一处为n，搜索上一处为N</li>\n<li>制定书签 mx, 但是看不到书签标记，而且只能用小写字母</li>\n<li>移动到某标签处 `x，1旁边的键</li>\n<li>移动到上次编辑文件的位置 `.</li>\n</ol>\n<h5 id=\"PS：-代表一个任意字符-代表一个或多个字符的重复\"><a href=\"#PS：-代表一个任意字符-代表一个或多个字符的重复\" class=\"headerlink\" title=\"PS：.代表一个任意字符 *代表一个或多个字符的重复\"></a>PS：.代表一个任意字符 *代表一个或多个字符的重复</h5><h2 id=\"三-编辑操作\"><a href=\"#三-编辑操作\" class=\"headerlink\" title=\"三. 编辑操作\"></a>三. 编辑操作</h2><ol>\n<li>光标后插入a, 行尾插入A</li>\n<li>后插一行插入o，前插一行插入O</li>\n<li>删除字符插入s， 删除正行插入S</li>\n<li>光标前插入i，行首插入I</li>\n<li>删除一行dd，删除后进入插入模式cc或者S</li>\n<li>删除一个单词dw，删除一个单词进入插入模式cw</li>\n<li>删除一个字符x或者dl，删除一个字符进入插入模式s或者cl</li>\n<li>粘贴p，交换两个字符xp，交换两行ddp</li>\n<li>复制y，复制一行yy</li>\n<li>撤销u，重做ctrl + r，重复.</li>\n<li>智能提示 ctrl + n 或者 ctrl + p</li>\n<li>删除motion跨过的字符，删除并进入插入模式 c{motion}</li>\n<li>删除到下一个字符跨过的字符，删除并进入插入模式，不包括x字符 ctx</li>\n<li>删除当前字符到下一个字符处的所有字符，并进入插入模式，包括x字符，cfx</li>\n<li>删除motion跨过的字符，删除但不进入插入模式 d{motion}</li>\n<li>删除motion跨过的字符，删除但不进入插入模式，不包括x字符 dtx</li>\n<li>删除当前字符到下一个字符处的所有字符，包括x字符 dfx</li>\n<li>如果只是复制的情况时，将12-17条中的c或d改为y</li>\n<li>删除到行尾可以使用D或C</li>\n<li>拷贝当前行 yy或者Y</li>\n<li>删除当前字符 x</li>\n<li>粘贴 p</li>\n<li>可以使用多重剪切板，查看状态使用:reg，使用剪切板使用”，例如复制到w寄存器，”wyy，或者使用可视模式v”wy</li>\n<li>重复执行上一个作用使用.</li>\n<li>使用数字可以跨过n个区域，如y3x，会拷贝光标到第三个x之间的区域，3j向下移动3行</li>\n<li>在编写代码的时候可以使用]p粘贴，这样可以自动进行代码缩进</li>\n<li>>&gt; 缩进所有选择的代码</li>\n<li>&lt;&lt; 反缩进所有选择的代码</li>\n<li>gd 移动到光标所处的函数或变量的定义处</li>\n<li>K 在man里搜索光标所在的词</li>\n<li>合并两行 J</li>\n<li>若不想保存文件，而重新打开 :e!</li>\n<li>若想打开新文件 :e filename，然后使用ctrl + ^进行文件切换</li>\n</ol>\n<h2 id=\"四-窗口操作\"><a href=\"#四-窗口操作\" class=\"headerlink\" title=\"四. 窗口操作\"></a>四. 窗口操作</h2><ol>\n<li>分隔一个窗口:split或者:vsplit</li>\n<li>创建一个窗口:new或者:vnew</li>\n<li>在新窗口打开文件:sf {filename}</li>\n<li>关闭当前窗口:close</li>\n<li>仅保留当前窗口:only</li>\n<li>到左边窗口 ctrl + w, h</li>\n<li>到右边窗口 ctrl + w, l</li>\n<li>到上边窗口 ctrl + w, k</li>\n<li>到下边窗口 ctrl + w, j</li>\n<li>到顶部窗口 ctrl + w, t</li>\n<li>到底部窗口 ctrl + w, b</li>\n</ol>\n<h2 id=\"五-宏操作\"><a href=\"#五-宏操作\" class=\"headerlink\" title=\"五. 宏操作\"></a>五. 宏操作</h2><ol>\n<li>开始记录宏操作q[a-z]，按q结束，保存操作到寄存器[a-z]中</li>\n<li>@[a-z]执行寄存器[a-z]中的操作</li>\n<li>@@执行最近一次记录的宏操作</li>\n</ol>\n<h2 id=\"六-可视操作\"><a href=\"#六-可视操作\" class=\"headerlink\" title=\"六. 可视操作\"></a>六. 可视操作</h2><ol>\n<li>进入块可视模式 ctrl + v</li>\n<li>进入字符可视模式 v</li>\n<li>进入行可视模式 V</li>\n<li>删除选定的块 d</li>\n<li>删除选定的块然后进入插入模式 c</li>\n<li>在选中的块同是插入相同的字符 IESC</li>\n</ol>\n<h2 id=\"七-跳到声明\"><a href=\"#七-跳到声明\" class=\"headerlink\" title=\"七. 跳到声明\"></a>七. 跳到声明</h2><ol>\n<li>[[ 向前跳到顶格第一个{  </li>\n<li>[] 向前跳到顶格第一个}</li>\n<li>]] 向后跳到顶格的第一个{</li>\n<li>]] 向后跳到顶格的第一个}</li>\n<li>[{ 跳到本代码块的开头</li>\n<li>]} 跳到本代码块的结尾</li>\n</ol>\n<h2 id=\"八-挂起操作\"><a href=\"#八-挂起操作\" class=\"headerlink\" title=\"八. 挂起操作\"></a>八. 挂起操作</h2><ol>\n<li>挂起Vim ctrl + z 或者 :suspend</li>\n<li>查看任务 在shell中输入 jobs</li>\n<li>恢复任务 fg [job number]（将后台程序放到前台）或者 bg [job number]（将前台程序放到后台）</li>\n<li>执行shell命令 :!command</li>\n<li>开启shell命令 :shell，退出该shell exit</li>\n<li>保存vim状态 :mksession name.vim</li>\n<li>恢复vim状态 :source name.vim</li>\n<li>启动vim时恢复状态 vim -S name.vim</li>\n</ol>"},{"layout":"post","title":"ThreadLocal源码解析","date":"2017-03-08T16:00:00.000Z","original":true,"tag":[["java","java"]],"_content":"\n## ThreadLocal是什么\n##### This class provides thread-local variables.  These variables differ from their normal counterparts in that each thread that accesses one (via its <tt>get</tt> or <tt>set</tt> method) has its own, independently initialized copy of the variable.  <tt>ThreadLocal</tt> instances are typically private static fields in classes that wish to associate state with a thread (e.g., a user ID or Transaction ID).\n<!--more-->\n\n### 这是ThreadLocal源码中一段介绍，翻译过来的大概意思是：\n##### ThreadLocal类用来提供线程内部的局部变量。这种变量在多线程环境下访问(通过get或set方法访问)时能保证各个线程里的变量相对独立于其他线程内的变量。ThreadLocal实例通常来说都是private static类型的，用于关联线程和线程的上下文。\n\n##### 这种解释和网络上所说的解决多线程的并发问题不太一样，当你把一个变量复制成了多份，我觉得这种方式并不叫解决多线程访问资源时的共享问题。本质上来说资源已经变成了多份，没有共享之说，当然这也是一种解决方式，但是如果资源不必线程共享，又何必要用ThreadLocal去实现呢。\n\n#### 总结来说：ThreadLocal的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。\n##### 举一个例子，一个请求需要按照1、2、3这个顺序执行3个函数。但是其中有一个参数是需要函数1提供给函数3使用的，但是这个参数对于函数2来说并没有作用（实际情况可能比这要复杂的多）。同时我们又不希望污染函数2，那么如何将该参数通过函数1传递到函数3呢？ThreadLocal是一个比较合理的解决方法。\n\n## ThreadLocal代码演示\n\n```JAVA\n/**\n * Created BY wangwenxiang on 2017/3/15.\n */\npublic class ThreadLocalTest {\n    private static ThreadLocal<Integer> integerThreadLocal = new ThreadLocal<Integer>();\n\n    /**\n     * 初始化并输出每个线程的ThreadLocal\n     * Runnable\n     * name\n     */\n    private static Thread[] initThread(){\n        Thread[] threads = new Thread[10];\n        for (int i=0;i<10;i++){\n            final int finalI = i;\n            threads[i] = new Thread(new Runnable() {\n                public void run() {\n                    integerThreadLocal.set(finalI);\n                    System.out.println(Thread.currentThread().getName()+\": \"+integerThreadLocal.get());\n                }\n            },\"thread-\" + i);\n        }\n        return threads;\n    }\n\n\n    public static void main(String[] args) {\n        Thread[] threads = initThread();\n        for (Thread thread : threads){\n            thread.start();\n        }\n    }\n}\n```\n\n##### ThreadLocal的操作非常简单，基本上没有太多的过程。\n\n##### 执行结果：\n```\nthread-0: 0\nthread-1: 1\nthread-2: 2\nthread-3: 3\nthread-4: 4\nthread-5: 5\nthread-6: 6\nthread-7: 7\nthread-8: 8\nthread-9: 9\n```\n\n##### 可以看出虽然只创建了一个ThreadLocal对象，但是每个线程的初始化之后，得出来的结果并不一样。各个线程之间的值是相互独立的。\n\n## ThreadLocal源码\n### 构造函数\n```java\n/**\n * Creates a thread local variable.\n */\npublic ThreadLocal() {\n}\n```\n##### 这是ThreadLocal唯一的构造函数，什么也没做\n\n### set方法\n```JAVA\n/**\n * Sets the current thread's copy of this thread-local variable\n * to the specified value.  Most subclasses will have no need to\n * override this method, relying solely on the {@link #initialValue}\n * method to set the values of thread-locals.\n *\n * @param value the value to be stored in the current thread's copy of\n *        this thread-local.\n */\npublic void set(T value) {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null)\n            map.set(this, value);\n        else\n            createMap(t, value);\n    }\n```\n##### 代码比较简单\n\n1. 获取当前线程 `Thread t = Thread.currentThread();`\n2. 获取当前线程的ThreadLocalMap，使得每个线程的本地数据相互隔离的原因也在于这里，因为每个线程都有自己的ThreadLocalMap；\n3. 判断ThreadLocalMap是否为空，直接插入或者创建map并插入；\n\n#### ThreadLocalMap的set方法\n```JAVA\n/**\n * Set the value associated with key.\n * @param value the value to be set\n *\n * @param key the thread local object\n */\nprivate void set(ThreadLocal key, Object value) {\n\n    // We don't use a fast path as with get() because it is at\n    // least as common to use set() to create new entries as\n    // it is to replace existing ones, in which case, a fast\n    // path would fail more often than not.\n\n    Entry[] tab = table;\n    int len = tab.length;\n    int i = key.threadLocalHashCode & (len-1);\n\n    for (Entry e = tab[i];\n         e != null;\n         e = tab[i = nextIndex(i, len)]) {\n        ThreadLocal k = e.get();\n\n        if (k == key) {\n            e.value = value;\n            return;\n        }\n\n        if (k == null) {\n            replaceStaleEntry(key, value, i);\n            return;\n        }\n    }\n\n    tab[i] = new Entry(key, value);\n    int sz = ++size;\n    if (!cleanSomeSlots(i, sz) && sz >= threshold)\n        rehash();\n}\n```\n##### map的key和value分别对应的是ThreadLocal本身和往ThreadLocal中set的值。\n\n1. 首先根据ThreadLocal元素的hashCode计算出其数组下标；由于数组的长度用于等于2<sup>n</sup>个，所以下表的取值范围在0到2<sup>n</sup>-1；\n2. for循环，从数组位置i开始以步长1向后循环遍历，直到找到一个空位，每次循环将该位置的值赋值给e；\n3. 当数组位置不为空时执行方法体：\n    1. 获得该数组位置的ThreadLocal，判断是否与当前ThreadLocal相等，如果相等，则将value更新，set方法结束；\n    2. 如果该ThreadLocal为空，则替换，然后结束方法。\n4. 在位置i插入新值，计数加1\n\n### get方法\n```JAVA\n/**\n  * Returns the value in the current thread's copy of this\n  * thread-local variable.  If the variable has no value for the\n  * current thread, it is first initialized to the value returned\n  * by an invocation of the {@link #initialValue} method.\n  *\n  * @return the current thread's value of this thread-local\n  */\npublic T get() {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null) {\n            ThreadLocalMap.Entry e = map.getEntry(this);\n            if (e != null)\n                return (T)e.value;\n        }\n        return setInitialValue();\n    }\n```\n##### get方法和set方法比较类似，首先获取当前线程，并获取线程的ThreadLocalMap，以当前的ThreadLocal作为key在map中获取value，判断value是否为null，如果为null，则将当前的ThreadLocal中设置初始值，并返回改值。\n#### setInitialValue()\n```JAVA\n/**\n * Variant of set() to establish initialValue. Used instead\n * of set() in case user has overridden the set() method.\n *\n * @return the initial value\n */\nprivate T setInitialValue() {\n    T value = initialValue();\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n    if (map != null)\n        map.set(this, value);\n    else\n        createMap(t, value);\n    return value;\n}\n```\n##### 该方法和set方法基本一样\n#### initialValue()\n```JAVA\n/**\n * Returns the current thread's \"initial value\" for this\n * thread-local variable.  This method will be invoked the first\n * time a thread accesses the variable with the {@link #get}\n * method, unless the thread previously invoked the {@link #set}\n * method, in which case the <tt>initialValue</tt> method will not\n * be invoked for the thread.  Normally, this method is invoked at\n * most once per thread, but it may be invoked again in case of\n * subsequent invocations of {@link #remove} followed by {@link #get}.\n *\n * <p>This implementation simply returns <tt>null</tt>; if the\n * programmer desires thread-local variables to have an initial\n * value other than <tt>null</tt>, <tt>ThreadLocal</tt> must be\n * subclassed, and this method overridden.  Typically, an\n * anonymous inner class will be used.\n *\n * @return the initial value for this thread-local\n */\n protected T initialValue() {\n     return null;\n }\n```\n##### 该方法只在get方法中被调用，当ThreadLocal中没有设置value时。默认返回null，protected的访问权限表示该方法支持被覆盖。\n\n### ThreadLocalMap\n##### ThreadLocalMap是使用ThreadLocal的弱引用作为Key的\n```JAVA\nstatic class ThreadLocalMap {\n        /**\n         * The entries in this hash map extend WeakReference, using\n         * its main ref field as the key (which is always a\n         * ThreadLocal object).  Note that null keys (i.e. entry.get()\n         * == null) mean that the key is no longer referenced, so the\n         * entry can be expunged from table.  Such entries are referred to\n         * as \"stale entries\" in the code that follows.\n         */\n        static class Entry extends WeakReference<ThreadLocal> {\n            /** The value associated with this ThreadLocal. */\n            Object value;\n\n            Entry(ThreadLocal k, Object v) {\n                super(k);\n                value = v;\n            }\n        }\n        ...\n        ...\n}\n```\n\n##### 下图是本文介绍到的一些对象之间的引用关系图，实线表示强引用，虚线表示弱引用：\n![ThreadLocal](../../img/note/ThreadLocal.png) <div class='img-note'>ThreadLocal对象引用</div>\n\n##### 如上图，ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用引用他，那么系统gc的时候，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：\n#### Thread Ref -> Thread -> ThreaLocalMap -> Entry -> value\n##### 永远无法回收，造成内存泄露。\n\n##### 其实，在JDK的ThreadLocalMap的设计中已经考虑到这种情况，也加上了一些防护措施，下面是ThreadLocalMap的`getEntry`方法的源码：\n```JAVA\nprivate Entry getEntry(ThreadLocal key) {\n    int i = key.threadLocalHashCode & (table.length - 1);\n    Entry e = table[i];\n    if (e != null && e.get() == key)\n        return e;\n    else\n        return getEntryAfterMiss(key, i, e);\n}\n```\n#### 当Entry为null时，getEntryAfterMiss方法\n```java\nprivate Entry getEntryAfterMiss(ThreadLocal key, int i, Entry e) {\n    Entry[] tab = table;\n    int len = tab.length;\n    while (e != null) {\n        ThreadLocal k = e.get();\n        if (k == key)\n            return e;\n        if (k == null)\n            expungeStaleEntry(i);\n        else\n            i = nextIndex(i, len);\n        e = tab[i];\n    }\n    return null;\n}\n```\n\n#### `expungeStaleEntry`函数的源码：\n```java\nprivate int expungeStaleEntry(int staleSlot) {\n    Entry[] tab = table;\n    int len = tab.length;\n\n    // expunge entry at staleSlot\n    tab[staleSlot].value = null;\n    tab[staleSlot] = null;\n    size--;\n\n    // Rehash until we encounter null\n    Entry e;\n    int i;\n    for (i = nextIndex(staleSlot, len);\n         (e = tab[i]) != null;\n         i = nextIndex(i, len)) {\n        ThreadLocal k = e.get();\n        if (k == null) {\n            e.value = null;\n            tab[i] = null;\n            size--;\n        } else {\n            int h = k.threadLocalHashCode & (len - 1);\n            if (h != i) {\n                tab[i] = null;\n\n                // Unlike Knuth 6.4 Algorithm R, we must scan until\n                // null because multiple entries could have been stale.\n                while (tab[h] != null)\n                    h = nextIndex(h, len);\n                tab[h] = e;\n            }\n        }\n    }\n    return i;\n}\n```\n\n##### 整理一下ThreadLocalMap的`getEntry`函数的流程：\n\n1. 首先从ThreadLocal的直接索引位置(通过ThreadLocal.threadLocalHashCode & (len-1)运算得到)获取Entry e，如果e不为null并且key相同则返回e；\n2. 如果e为null或者key不一致则向下一个位置查询，如果下一个位置的key和当前需要查询的key相等，则返回对应的Entry，否则，如果key值为null，则擦除该位置的Entry，否则继续向下一个位置查询\n\n##### 在这个过程中遇到的key为null的Entry都会被擦除，那么Entry内的value也就没有强引用链，自然会被回收。仔细研究代码可以发现，`set`操作也有类似的思想，将key为null的这些Entry都删除，防止内存泄露。\n##### 但是光这样还是不够的，上面的设计思路依赖一个前提条件： 要调用ThreadLocalMap的`getEntry`函数或者`set`函数。 这当然是不可能任何情况都成立的，所以很多情况下需要使用者手动调用ThreadLocal的`remove`函数，手动删除不再需要的ThreadLocal，防止内存泄露。所以JDK建议将ThreadLocal变量定义成`private static`的，这样的话ThreadLocal的生命周期就更长，由于一直存在ThreadLocal的强引用，所以ThreadLocal也就不会被回收，也就能保证任何时候都能根据ThreadLocal的弱引用访问到Entry的value值，然后remove它，防止内存泄露。","source":"_posts/note/threadLocal.md","raw":"---\nlayout: post\ntitle: ThreadLocal源码解析\ndate: 2017/03/09\noriginal: true\ntags: [tech, note, index, java]\ntag: [[java, java]]\n---\n\n## ThreadLocal是什么\n##### This class provides thread-local variables.  These variables differ from their normal counterparts in that each thread that accesses one (via its <tt>get</tt> or <tt>set</tt> method) has its own, independently initialized copy of the variable.  <tt>ThreadLocal</tt> instances are typically private static fields in classes that wish to associate state with a thread (e.g., a user ID or Transaction ID).\n<!--more-->\n\n### 这是ThreadLocal源码中一段介绍，翻译过来的大概意思是：\n##### ThreadLocal类用来提供线程内部的局部变量。这种变量在多线程环境下访问(通过get或set方法访问)时能保证各个线程里的变量相对独立于其他线程内的变量。ThreadLocal实例通常来说都是private static类型的，用于关联线程和线程的上下文。\n\n##### 这种解释和网络上所说的解决多线程的并发问题不太一样，当你把一个变量复制成了多份，我觉得这种方式并不叫解决多线程访问资源时的共享问题。本质上来说资源已经变成了多份，没有共享之说，当然这也是一种解决方式，但是如果资源不必线程共享，又何必要用ThreadLocal去实现呢。\n\n#### 总结来说：ThreadLocal的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。\n##### 举一个例子，一个请求需要按照1、2、3这个顺序执行3个函数。但是其中有一个参数是需要函数1提供给函数3使用的，但是这个参数对于函数2来说并没有作用（实际情况可能比这要复杂的多）。同时我们又不希望污染函数2，那么如何将该参数通过函数1传递到函数3呢？ThreadLocal是一个比较合理的解决方法。\n\n## ThreadLocal代码演示\n\n```JAVA\n/**\n * Created BY wangwenxiang on 2017/3/15.\n */\npublic class ThreadLocalTest {\n    private static ThreadLocal<Integer> integerThreadLocal = new ThreadLocal<Integer>();\n\n    /**\n     * 初始化并输出每个线程的ThreadLocal\n     * Runnable\n     * name\n     */\n    private static Thread[] initThread(){\n        Thread[] threads = new Thread[10];\n        for (int i=0;i<10;i++){\n            final int finalI = i;\n            threads[i] = new Thread(new Runnable() {\n                public void run() {\n                    integerThreadLocal.set(finalI);\n                    System.out.println(Thread.currentThread().getName()+\": \"+integerThreadLocal.get());\n                }\n            },\"thread-\" + i);\n        }\n        return threads;\n    }\n\n\n    public static void main(String[] args) {\n        Thread[] threads = initThread();\n        for (Thread thread : threads){\n            thread.start();\n        }\n    }\n}\n```\n\n##### ThreadLocal的操作非常简单，基本上没有太多的过程。\n\n##### 执行结果：\n```\nthread-0: 0\nthread-1: 1\nthread-2: 2\nthread-3: 3\nthread-4: 4\nthread-5: 5\nthread-6: 6\nthread-7: 7\nthread-8: 8\nthread-9: 9\n```\n\n##### 可以看出虽然只创建了一个ThreadLocal对象，但是每个线程的初始化之后，得出来的结果并不一样。各个线程之间的值是相互独立的。\n\n## ThreadLocal源码\n### 构造函数\n```java\n/**\n * Creates a thread local variable.\n */\npublic ThreadLocal() {\n}\n```\n##### 这是ThreadLocal唯一的构造函数，什么也没做\n\n### set方法\n```JAVA\n/**\n * Sets the current thread's copy of this thread-local variable\n * to the specified value.  Most subclasses will have no need to\n * override this method, relying solely on the {@link #initialValue}\n * method to set the values of thread-locals.\n *\n * @param value the value to be stored in the current thread's copy of\n *        this thread-local.\n */\npublic void set(T value) {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null)\n            map.set(this, value);\n        else\n            createMap(t, value);\n    }\n```\n##### 代码比较简单\n\n1. 获取当前线程 `Thread t = Thread.currentThread();`\n2. 获取当前线程的ThreadLocalMap，使得每个线程的本地数据相互隔离的原因也在于这里，因为每个线程都有自己的ThreadLocalMap；\n3. 判断ThreadLocalMap是否为空，直接插入或者创建map并插入；\n\n#### ThreadLocalMap的set方法\n```JAVA\n/**\n * Set the value associated with key.\n * @param value the value to be set\n *\n * @param key the thread local object\n */\nprivate void set(ThreadLocal key, Object value) {\n\n    // We don't use a fast path as with get() because it is at\n    // least as common to use set() to create new entries as\n    // it is to replace existing ones, in which case, a fast\n    // path would fail more often than not.\n\n    Entry[] tab = table;\n    int len = tab.length;\n    int i = key.threadLocalHashCode & (len-1);\n\n    for (Entry e = tab[i];\n         e != null;\n         e = tab[i = nextIndex(i, len)]) {\n        ThreadLocal k = e.get();\n\n        if (k == key) {\n            e.value = value;\n            return;\n        }\n\n        if (k == null) {\n            replaceStaleEntry(key, value, i);\n            return;\n        }\n    }\n\n    tab[i] = new Entry(key, value);\n    int sz = ++size;\n    if (!cleanSomeSlots(i, sz) && sz >= threshold)\n        rehash();\n}\n```\n##### map的key和value分别对应的是ThreadLocal本身和往ThreadLocal中set的值。\n\n1. 首先根据ThreadLocal元素的hashCode计算出其数组下标；由于数组的长度用于等于2<sup>n</sup>个，所以下表的取值范围在0到2<sup>n</sup>-1；\n2. for循环，从数组位置i开始以步长1向后循环遍历，直到找到一个空位，每次循环将该位置的值赋值给e；\n3. 当数组位置不为空时执行方法体：\n    1. 获得该数组位置的ThreadLocal，判断是否与当前ThreadLocal相等，如果相等，则将value更新，set方法结束；\n    2. 如果该ThreadLocal为空，则替换，然后结束方法。\n4. 在位置i插入新值，计数加1\n\n### get方法\n```JAVA\n/**\n  * Returns the value in the current thread's copy of this\n  * thread-local variable.  If the variable has no value for the\n  * current thread, it is first initialized to the value returned\n  * by an invocation of the {@link #initialValue} method.\n  *\n  * @return the current thread's value of this thread-local\n  */\npublic T get() {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null) {\n            ThreadLocalMap.Entry e = map.getEntry(this);\n            if (e != null)\n                return (T)e.value;\n        }\n        return setInitialValue();\n    }\n```\n##### get方法和set方法比较类似，首先获取当前线程，并获取线程的ThreadLocalMap，以当前的ThreadLocal作为key在map中获取value，判断value是否为null，如果为null，则将当前的ThreadLocal中设置初始值，并返回改值。\n#### setInitialValue()\n```JAVA\n/**\n * Variant of set() to establish initialValue. Used instead\n * of set() in case user has overridden the set() method.\n *\n * @return the initial value\n */\nprivate T setInitialValue() {\n    T value = initialValue();\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n    if (map != null)\n        map.set(this, value);\n    else\n        createMap(t, value);\n    return value;\n}\n```\n##### 该方法和set方法基本一样\n#### initialValue()\n```JAVA\n/**\n * Returns the current thread's \"initial value\" for this\n * thread-local variable.  This method will be invoked the first\n * time a thread accesses the variable with the {@link #get}\n * method, unless the thread previously invoked the {@link #set}\n * method, in which case the <tt>initialValue</tt> method will not\n * be invoked for the thread.  Normally, this method is invoked at\n * most once per thread, but it may be invoked again in case of\n * subsequent invocations of {@link #remove} followed by {@link #get}.\n *\n * <p>This implementation simply returns <tt>null</tt>; if the\n * programmer desires thread-local variables to have an initial\n * value other than <tt>null</tt>, <tt>ThreadLocal</tt> must be\n * subclassed, and this method overridden.  Typically, an\n * anonymous inner class will be used.\n *\n * @return the initial value for this thread-local\n */\n protected T initialValue() {\n     return null;\n }\n```\n##### 该方法只在get方法中被调用，当ThreadLocal中没有设置value时。默认返回null，protected的访问权限表示该方法支持被覆盖。\n\n### ThreadLocalMap\n##### ThreadLocalMap是使用ThreadLocal的弱引用作为Key的\n```JAVA\nstatic class ThreadLocalMap {\n        /**\n         * The entries in this hash map extend WeakReference, using\n         * its main ref field as the key (which is always a\n         * ThreadLocal object).  Note that null keys (i.e. entry.get()\n         * == null) mean that the key is no longer referenced, so the\n         * entry can be expunged from table.  Such entries are referred to\n         * as \"stale entries\" in the code that follows.\n         */\n        static class Entry extends WeakReference<ThreadLocal> {\n            /** The value associated with this ThreadLocal. */\n            Object value;\n\n            Entry(ThreadLocal k, Object v) {\n                super(k);\n                value = v;\n            }\n        }\n        ...\n        ...\n}\n```\n\n##### 下图是本文介绍到的一些对象之间的引用关系图，实线表示强引用，虚线表示弱引用：\n![ThreadLocal](../../img/note/ThreadLocal.png) <div class='img-note'>ThreadLocal对象引用</div>\n\n##### 如上图，ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用引用他，那么系统gc的时候，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：\n#### Thread Ref -> Thread -> ThreaLocalMap -> Entry -> value\n##### 永远无法回收，造成内存泄露。\n\n##### 其实，在JDK的ThreadLocalMap的设计中已经考虑到这种情况，也加上了一些防护措施，下面是ThreadLocalMap的`getEntry`方法的源码：\n```JAVA\nprivate Entry getEntry(ThreadLocal key) {\n    int i = key.threadLocalHashCode & (table.length - 1);\n    Entry e = table[i];\n    if (e != null && e.get() == key)\n        return e;\n    else\n        return getEntryAfterMiss(key, i, e);\n}\n```\n#### 当Entry为null时，getEntryAfterMiss方法\n```java\nprivate Entry getEntryAfterMiss(ThreadLocal key, int i, Entry e) {\n    Entry[] tab = table;\n    int len = tab.length;\n    while (e != null) {\n        ThreadLocal k = e.get();\n        if (k == key)\n            return e;\n        if (k == null)\n            expungeStaleEntry(i);\n        else\n            i = nextIndex(i, len);\n        e = tab[i];\n    }\n    return null;\n}\n```\n\n#### `expungeStaleEntry`函数的源码：\n```java\nprivate int expungeStaleEntry(int staleSlot) {\n    Entry[] tab = table;\n    int len = tab.length;\n\n    // expunge entry at staleSlot\n    tab[staleSlot].value = null;\n    tab[staleSlot] = null;\n    size--;\n\n    // Rehash until we encounter null\n    Entry e;\n    int i;\n    for (i = nextIndex(staleSlot, len);\n         (e = tab[i]) != null;\n         i = nextIndex(i, len)) {\n        ThreadLocal k = e.get();\n        if (k == null) {\n            e.value = null;\n            tab[i] = null;\n            size--;\n        } else {\n            int h = k.threadLocalHashCode & (len - 1);\n            if (h != i) {\n                tab[i] = null;\n\n                // Unlike Knuth 6.4 Algorithm R, we must scan until\n                // null because multiple entries could have been stale.\n                while (tab[h] != null)\n                    h = nextIndex(h, len);\n                tab[h] = e;\n            }\n        }\n    }\n    return i;\n}\n```\n\n##### 整理一下ThreadLocalMap的`getEntry`函数的流程：\n\n1. 首先从ThreadLocal的直接索引位置(通过ThreadLocal.threadLocalHashCode & (len-1)运算得到)获取Entry e，如果e不为null并且key相同则返回e；\n2. 如果e为null或者key不一致则向下一个位置查询，如果下一个位置的key和当前需要查询的key相等，则返回对应的Entry，否则，如果key值为null，则擦除该位置的Entry，否则继续向下一个位置查询\n\n##### 在这个过程中遇到的key为null的Entry都会被擦除，那么Entry内的value也就没有强引用链，自然会被回收。仔细研究代码可以发现，`set`操作也有类似的思想，将key为null的这些Entry都删除，防止内存泄露。\n##### 但是光这样还是不够的，上面的设计思路依赖一个前提条件： 要调用ThreadLocalMap的`getEntry`函数或者`set`函数。 这当然是不可能任何情况都成立的，所以很多情况下需要使用者手动调用ThreadLocal的`remove`函数，手动删除不再需要的ThreadLocal，防止内存泄露。所以JDK建议将ThreadLocal变量定义成`private static`的，这样的话ThreadLocal的生命周期就更长，由于一直存在ThreadLocal的强引用，所以ThreadLocal也就不会被回收，也就能保证任何时候都能根据ThreadLocal的弱引用访问到Entry的value值，然后remove它，防止内存泄露。","slug":"note/threadLocal","published":1,"updated":"2017-10-06T16:14:17.150Z","comments":1,"photos":[],"link":"","_id":"cj8jros7c000l30s61ssyjfjd","content":"<h2 id=\"ThreadLocal是什么\"><a href=\"#ThreadLocal是什么\" class=\"headerlink\" title=\"ThreadLocal是什么\"></a>ThreadLocal是什么</h2><h5 id=\"This-class-provides-thread-local-variables-These-variables-differ-from-their-normal-counterparts-in-that-each-thread-that-accesses-one-via-its-get-or-set-method-has-its-own-independently-initialized-copy-of-the-variable-ThreadLocal-instances-are-typically-private-static-fields-in-classes-that-wish-to-associate-state-with-a-thread-e-g-a-user-ID-or-Transaction-ID\"><a href=\"#This-class-provides-thread-local-variables-These-variables-differ-from-their-normal-counterparts-in-that-each-thread-that-accesses-one-via-its-get-or-set-method-has-its-own-independently-initialized-copy-of-the-variable-ThreadLocal-instances-are-typically-private-static-fields-in-classes-that-wish-to-associate-state-with-a-thread-e-g-a-user-ID-or-Transaction-ID\" class=\"headerlink\" title=\"This class provides thread-local variables.  These variables differ from their normal counterparts in that each thread that accesses one (via its get or set method) has its own, independently initialized copy of the variable.  ThreadLocal instances are typically private static fields in classes that wish to associate state with a thread (e.g., a user ID or Transaction ID).\"></a>This class provides thread-local variables.  These variables differ from their normal counterparts in that each thread that accesses one (via its <tt>get</tt> or <tt>set</tt> method) has its own, independently initialized copy of the variable.  <tt>ThreadLocal</tt> instances are typically private static fields in classes that wish to associate state with a thread (e.g., a user ID or Transaction ID).</h5><a id=\"more\"></a>\n<h3 id=\"这是ThreadLocal源码中一段介绍，翻译过来的大概意思是：\"><a href=\"#这是ThreadLocal源码中一段介绍，翻译过来的大概意思是：\" class=\"headerlink\" title=\"这是ThreadLocal源码中一段介绍，翻译过来的大概意思是：\"></a>这是ThreadLocal源码中一段介绍，翻译过来的大概意思是：</h3><h5 id=\"ThreadLocal类用来提供线程内部的局部变量。这种变量在多线程环境下访问-通过get或set方法访问-时能保证各个线程里的变量相对独立于其他线程内的变量。ThreadLocal实例通常来说都是private-static类型的，用于关联线程和线程的上下文。\"><a href=\"#ThreadLocal类用来提供线程内部的局部变量。这种变量在多线程环境下访问-通过get或set方法访问-时能保证各个线程里的变量相对独立于其他线程内的变量。ThreadLocal实例通常来说都是private-static类型的，用于关联线程和线程的上下文。\" class=\"headerlink\" title=\"ThreadLocal类用来提供线程内部的局部变量。这种变量在多线程环境下访问(通过get或set方法访问)时能保证各个线程里的变量相对独立于其他线程内的变量。ThreadLocal实例通常来说都是private static类型的，用于关联线程和线程的上下文。\"></a>ThreadLocal类用来提供线程内部的局部变量。这种变量在多线程环境下访问(通过get或set方法访问)时能保证各个线程里的变量相对独立于其他线程内的变量。ThreadLocal实例通常来说都是private static类型的，用于关联线程和线程的上下文。</h5><h5 id=\"这种解释和网络上所说的解决多线程的并发问题不太一样，当你把一个变量复制成了多份，我觉得这种方式并不叫解决多线程访问资源时的共享问题。本质上来说资源已经变成了多份，没有共享之说，当然这也是一种解决方式，但是如果资源不必线程共享，又何必要用ThreadLocal去实现呢。\"><a href=\"#这种解释和网络上所说的解决多线程的并发问题不太一样，当你把一个变量复制成了多份，我觉得这种方式并不叫解决多线程访问资源时的共享问题。本质上来说资源已经变成了多份，没有共享之说，当然这也是一种解决方式，但是如果资源不必线程共享，又何必要用ThreadLocal去实现呢。\" class=\"headerlink\" title=\"这种解释和网络上所说的解决多线程的并发问题不太一样，当你把一个变量复制成了多份，我觉得这种方式并不叫解决多线程访问资源时的共享问题。本质上来说资源已经变成了多份，没有共享之说，当然这也是一种解决方式，但是如果资源不必线程共享，又何必要用ThreadLocal去实现呢。\"></a>这种解释和网络上所说的解决多线程的并发问题不太一样，当你把一个变量复制成了多份，我觉得这种方式并不叫解决多线程访问资源时的共享问题。本质上来说资源已经变成了多份，没有共享之说，当然这也是一种解决方式，但是如果资源不必线程共享，又何必要用ThreadLocal去实现呢。</h5><h4 id=\"总结来说：ThreadLocal的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。\"><a href=\"#总结来说：ThreadLocal的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。\" class=\"headerlink\" title=\"总结来说：ThreadLocal的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。\"></a>总结来说：ThreadLocal的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。</h4><h5 id=\"举一个例子，一个请求需要按照1、2、3这个顺序执行3个函数。但是其中有一个参数是需要函数1提供给函数3使用的，但是这个参数对于函数2来说并没有作用（实际情况可能比这要复杂的多）。同时我们又不希望污染函数2，那么如何将该参数通过函数1传递到函数3呢？ThreadLocal是一个比较合理的解决方法。\"><a href=\"#举一个例子，一个请求需要按照1、2、3这个顺序执行3个函数。但是其中有一个参数是需要函数1提供给函数3使用的，但是这个参数对于函数2来说并没有作用（实际情况可能比这要复杂的多）。同时我们又不希望污染函数2，那么如何将该参数通过函数1传递到函数3呢？ThreadLocal是一个比较合理的解决方法。\" class=\"headerlink\" title=\"举一个例子，一个请求需要按照1、2、3这个顺序执行3个函数。但是其中有一个参数是需要函数1提供给函数3使用的，但是这个参数对于函数2来说并没有作用（实际情况可能比这要复杂的多）。同时我们又不希望污染函数2，那么如何将该参数通过函数1传递到函数3呢？ThreadLocal是一个比较合理的解决方法。\"></a>举一个例子，一个请求需要按照1、2、3这个顺序执行3个函数。但是其中有一个参数是需要函数1提供给函数3使用的，但是这个参数对于函数2来说并没有作用（实际情况可能比这要复杂的多）。同时我们又不希望污染函数2，那么如何将该参数通过函数1传递到函数3呢？ThreadLocal是一个比较合理的解决方法。</h5><h2 id=\"ThreadLocal代码演示\"><a href=\"#ThreadLocal代码演示\" class=\"headerlink\" title=\"ThreadLocal代码演示\"></a>ThreadLocal代码演示</h2><pre><code class=\"lang-JAVA\">/**\n * Created BY wangwenxiang on 2017/3/15.\n */\npublic class ThreadLocalTest {\n    private static ThreadLocal&lt;Integer&gt; integerThreadLocal = new ThreadLocal&lt;Integer&gt;();\n\n    /**\n     * 初始化并输出每个线程的ThreadLocal\n     * Runnable\n     * name\n     */\n    private static Thread[] initThread(){\n        Thread[] threads = new Thread[10];\n        for (int i=0;i&lt;10;i++){\n            final int finalI = i;\n            threads[i] = new Thread(new Runnable() {\n                public void run() {\n                    integerThreadLocal.set(finalI);\n                    System.out.println(Thread.currentThread().getName()+&quot;: &quot;+integerThreadLocal.get());\n                }\n            },&quot;thread-&quot; + i);\n        }\n        return threads;\n    }\n\n\n    public static void main(String[] args) {\n        Thread[] threads = initThread();\n        for (Thread thread : threads){\n            thread.start();\n        }\n    }\n}\n</code></pre>\n<h5 id=\"ThreadLocal的操作非常简单，基本上没有太多的过程。\"><a href=\"#ThreadLocal的操作非常简单，基本上没有太多的过程。\" class=\"headerlink\" title=\"ThreadLocal的操作非常简单，基本上没有太多的过程。\"></a>ThreadLocal的操作非常简单，基本上没有太多的过程。</h5><h5 id=\"执行结果：\"><a href=\"#执行结果：\" class=\"headerlink\" title=\"执行结果：\"></a>执行结果：</h5><pre><code>thread-0: 0\nthread-1: 1\nthread-2: 2\nthread-3: 3\nthread-4: 4\nthread-5: 5\nthread-6: 6\nthread-7: 7\nthread-8: 8\nthread-9: 9\n</code></pre><h5 id=\"可以看出虽然只创建了一个ThreadLocal对象，但是每个线程的初始化之后，得出来的结果并不一样。各个线程之间的值是相互独立的。\"><a href=\"#可以看出虽然只创建了一个ThreadLocal对象，但是每个线程的初始化之后，得出来的结果并不一样。各个线程之间的值是相互独立的。\" class=\"headerlink\" title=\"可以看出虽然只创建了一个ThreadLocal对象，但是每个线程的初始化之后，得出来的结果并不一样。各个线程之间的值是相互独立的。\"></a>可以看出虽然只创建了一个ThreadLocal对象，但是每个线程的初始化之后，得出来的结果并不一样。各个线程之间的值是相互独立的。</h5><h2 id=\"ThreadLocal源码\"><a href=\"#ThreadLocal源码\" class=\"headerlink\" title=\"ThreadLocal源码\"></a>ThreadLocal源码</h2><h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><pre><code class=\"lang-java\">/**\n * Creates a thread local variable.\n */\npublic ThreadLocal() {\n}\n</code></pre>\n<h5 id=\"这是ThreadLocal唯一的构造函数，什么也没做\"><a href=\"#这是ThreadLocal唯一的构造函数，什么也没做\" class=\"headerlink\" title=\"这是ThreadLocal唯一的构造函数，什么也没做\"></a>这是ThreadLocal唯一的构造函数，什么也没做</h5><h3 id=\"set方法\"><a href=\"#set方法\" class=\"headerlink\" title=\"set方法\"></a>set方法</h3><pre><code class=\"lang-JAVA\">/**\n * Sets the current thread&#39;s copy of this thread-local variable\n * to the specified value.  Most subclasses will have no need to\n * override this method, relying solely on the {@link #initialValue}\n * method to set the values of thread-locals.\n *\n * @param value the value to be stored in the current thread&#39;s copy of\n *        this thread-local.\n */\npublic void set(T value) {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null)\n            map.set(this, value);\n        else\n            createMap(t, value);\n    }\n</code></pre>\n<h5 id=\"代码比较简单\"><a href=\"#代码比较简单\" class=\"headerlink\" title=\"代码比较简单\"></a>代码比较简单</h5><ol>\n<li>获取当前线程 <code>Thread t = Thread.currentThread();</code></li>\n<li>获取当前线程的ThreadLocalMap，使得每个线程的本地数据相互隔离的原因也在于这里，因为每个线程都有自己的ThreadLocalMap；</li>\n<li>判断ThreadLocalMap是否为空，直接插入或者创建map并插入；</li>\n</ol>\n<h4 id=\"ThreadLocalMap的set方法\"><a href=\"#ThreadLocalMap的set方法\" class=\"headerlink\" title=\"ThreadLocalMap的set方法\"></a>ThreadLocalMap的set方法</h4><pre><code class=\"lang-JAVA\">/**\n * Set the value associated with key.\n * @param value the value to be set\n *\n * @param key the thread local object\n */\nprivate void set(ThreadLocal key, Object value) {\n\n    // We don&#39;t use a fast path as with get() because it is at\n    // least as common to use set() to create new entries as\n    // it is to replace existing ones, in which case, a fast\n    // path would fail more often than not.\n\n    Entry[] tab = table;\n    int len = tab.length;\n    int i = key.threadLocalHashCode &amp; (len-1);\n\n    for (Entry e = tab[i];\n         e != null;\n         e = tab[i = nextIndex(i, len)]) {\n        ThreadLocal k = e.get();\n\n        if (k == key) {\n            e.value = value;\n            return;\n        }\n\n        if (k == null) {\n            replaceStaleEntry(key, value, i);\n            return;\n        }\n    }\n\n    tab[i] = new Entry(key, value);\n    int sz = ++size;\n    if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)\n        rehash();\n}\n</code></pre>\n<h5 id=\"map的key和value分别对应的是ThreadLocal本身和往ThreadLocal中set的值。\"><a href=\"#map的key和value分别对应的是ThreadLocal本身和往ThreadLocal中set的值。\" class=\"headerlink\" title=\"map的key和value分别对应的是ThreadLocal本身和往ThreadLocal中set的值。\"></a>map的key和value分别对应的是ThreadLocal本身和往ThreadLocal中set的值。</h5><ol>\n<li>首先根据ThreadLocal元素的hashCode计算出其数组下标；由于数组的长度用于等于2<sup>n</sup>个，所以下表的取值范围在0到2<sup>n</sup>-1；</li>\n<li>for循环，从数组位置i开始以步长1向后循环遍历，直到找到一个空位，每次循环将该位置的值赋值给e；</li>\n<li>当数组位置不为空时执行方法体：<ol>\n<li>获得该数组位置的ThreadLocal，判断是否与当前ThreadLocal相等，如果相等，则将value更新，set方法结束；</li>\n<li>如果该ThreadLocal为空，则替换，然后结束方法。</li>\n</ol>\n</li>\n<li>在位置i插入新值，计数加1</li>\n</ol>\n<h3 id=\"get方法\"><a href=\"#get方法\" class=\"headerlink\" title=\"get方法\"></a>get方法</h3><pre><code class=\"lang-JAVA\">/**\n  * Returns the value in the current thread&#39;s copy of this\n  * thread-local variable.  If the variable has no value for the\n  * current thread, it is first initialized to the value returned\n  * by an invocation of the {@link #initialValue} method.\n  *\n  * @return the current thread&#39;s value of this thread-local\n  */\npublic T get() {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null) {\n            ThreadLocalMap.Entry e = map.getEntry(this);\n            if (e != null)\n                return (T)e.value;\n        }\n        return setInitialValue();\n    }\n</code></pre>\n<h5 id=\"get方法和set方法比较类似，首先获取当前线程，并获取线程的ThreadLocalMap，以当前的ThreadLocal作为key在map中获取value，判断value是否为null，如果为null，则将当前的ThreadLocal中设置初始值，并返回改值。\"><a href=\"#get方法和set方法比较类似，首先获取当前线程，并获取线程的ThreadLocalMap，以当前的ThreadLocal作为key在map中获取value，判断value是否为null，如果为null，则将当前的ThreadLocal中设置初始值，并返回改值。\" class=\"headerlink\" title=\"get方法和set方法比较类似，首先获取当前线程，并获取线程的ThreadLocalMap，以当前的ThreadLocal作为key在map中获取value，判断value是否为null，如果为null，则将当前的ThreadLocal中设置初始值，并返回改值。\"></a>get方法和set方法比较类似，首先获取当前线程，并获取线程的ThreadLocalMap，以当前的ThreadLocal作为key在map中获取value，判断value是否为null，如果为null，则将当前的ThreadLocal中设置初始值，并返回改值。</h5><h4 id=\"setInitialValue\"><a href=\"#setInitialValue\" class=\"headerlink\" title=\"setInitialValue()\"></a>setInitialValue()</h4><pre><code class=\"lang-JAVA\">/**\n * Variant of set() to establish initialValue. Used instead\n * of set() in case user has overridden the set() method.\n *\n * @return the initial value\n */\nprivate T setInitialValue() {\n    T value = initialValue();\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n    if (map != null)\n        map.set(this, value);\n    else\n        createMap(t, value);\n    return value;\n}\n</code></pre>\n<h5 id=\"该方法和set方法基本一样\"><a href=\"#该方法和set方法基本一样\" class=\"headerlink\" title=\"该方法和set方法基本一样\"></a>该方法和set方法基本一样</h5><h4 id=\"initialValue\"><a href=\"#initialValue\" class=\"headerlink\" title=\"initialValue()\"></a>initialValue()</h4><pre><code class=\"lang-JAVA\">/**\n * Returns the current thread&#39;s &quot;initial value&quot; for this\n * thread-local variable.  This method will be invoked the first\n * time a thread accesses the variable with the {@link #get}\n * method, unless the thread previously invoked the {@link #set}\n * method, in which case the &lt;tt&gt;initialValue&lt;/tt&gt; method will not\n * be invoked for the thread.  Normally, this method is invoked at\n * most once per thread, but it may be invoked again in case of\n * subsequent invocations of {@link #remove} followed by {@link #get}.\n *\n * &lt;p&gt;This implementation simply returns &lt;tt&gt;null&lt;/tt&gt;; if the\n * programmer desires thread-local variables to have an initial\n * value other than &lt;tt&gt;null&lt;/tt&gt;, &lt;tt&gt;ThreadLocal&lt;/tt&gt; must be\n * subclassed, and this method overridden.  Typically, an\n * anonymous inner class will be used.\n *\n * @return the initial value for this thread-local\n */\n protected T initialValue() {\n     return null;\n }\n</code></pre>\n<h5 id=\"该方法只在get方法中被调用，当ThreadLocal中没有设置value时。默认返回null，protected的访问权限表示该方法支持被覆盖。\"><a href=\"#该方法只在get方法中被调用，当ThreadLocal中没有设置value时。默认返回null，protected的访问权限表示该方法支持被覆盖。\" class=\"headerlink\" title=\"该方法只在get方法中被调用，当ThreadLocal中没有设置value时。默认返回null，protected的访问权限表示该方法支持被覆盖。\"></a>该方法只在get方法中被调用，当ThreadLocal中没有设置value时。默认返回null，protected的访问权限表示该方法支持被覆盖。</h5><h3 id=\"ThreadLocalMap\"><a href=\"#ThreadLocalMap\" class=\"headerlink\" title=\"ThreadLocalMap\"></a>ThreadLocalMap</h3><h5 id=\"ThreadLocalMap是使用ThreadLocal的弱引用作为Key的\"><a href=\"#ThreadLocalMap是使用ThreadLocal的弱引用作为Key的\" class=\"headerlink\" title=\"ThreadLocalMap是使用ThreadLocal的弱引用作为Key的\"></a>ThreadLocalMap是使用ThreadLocal的弱引用作为Key的</h5><pre><code class=\"lang-JAVA\">static class ThreadLocalMap {\n        /**\n         * The entries in this hash map extend WeakReference, using\n         * its main ref field as the key (which is always a\n         * ThreadLocal object).  Note that null keys (i.e. entry.get()\n         * == null) mean that the key is no longer referenced, so the\n         * entry can be expunged from table.  Such entries are referred to\n         * as &quot;stale entries&quot; in the code that follows.\n         */\n        static class Entry extends WeakReference&lt;ThreadLocal&gt; {\n            /** The value associated with this ThreadLocal. */\n            Object value;\n\n            Entry(ThreadLocal k, Object v) {\n                super(k);\n                value = v;\n            }\n        }\n        ...\n        ...\n}\n</code></pre>\n<h5 id=\"下图是本文介绍到的一些对象之间的引用关系图，实线表示强引用，虚线表示弱引用：\"><a href=\"#下图是本文介绍到的一些对象之间的引用关系图，实线表示强引用，虚线表示弱引用：\" class=\"headerlink\" title=\"下图是本文介绍到的一些对象之间的引用关系图，实线表示强引用，虚线表示弱引用：\"></a>下图是本文介绍到的一些对象之间的引用关系图，实线表示强引用，虚线表示弱引用：</h5><p><img src=\"../../img/note/ThreadLocal.png\" alt=\"ThreadLocal\"> <div class=\"img-note\">ThreadLocal对象引用</div></p>\n<h5 id=\"如上图，ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用引用他，那么系统gc的时候，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：\"><a href=\"#如上图，ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用引用他，那么系统gc的时候，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：\" class=\"headerlink\" title=\"如上图，ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用引用他，那么系统gc的时候，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：\"></a>如上图，ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用引用他，那么系统gc的时候，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：</h5><h4 id=\"Thread-Ref-gt-Thread-gt-ThreaLocalMap-gt-Entry-gt-value\"><a href=\"#Thread-Ref-gt-Thread-gt-ThreaLocalMap-gt-Entry-gt-value\" class=\"headerlink\" title=\"Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value\"></a>Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value</h4><h5 id=\"永远无法回收，造成内存泄露。\"><a href=\"#永远无法回收，造成内存泄露。\" class=\"headerlink\" title=\"永远无法回收，造成内存泄露。\"></a>永远无法回收，造成内存泄露。</h5><h5 id=\"其实，在JDK的ThreadLocalMap的设计中已经考虑到这种情况，也加上了一些防护措施，下面是ThreadLocalMap的getEntry方法的源码：\"><a href=\"#其实，在JDK的ThreadLocalMap的设计中已经考虑到这种情况，也加上了一些防护措施，下面是ThreadLocalMap的getEntry方法的源码：\" class=\"headerlink\" title=\"其实，在JDK的ThreadLocalMap的设计中已经考虑到这种情况，也加上了一些防护措施，下面是ThreadLocalMap的getEntry方法的源码：\"></a>其实，在JDK的ThreadLocalMap的设计中已经考虑到这种情况，也加上了一些防护措施，下面是ThreadLocalMap的<code>getEntry</code>方法的源码：</h5><pre><code class=\"lang-JAVA\">private Entry getEntry(ThreadLocal key) {\n    int i = key.threadLocalHashCode &amp; (table.length - 1);\n    Entry e = table[i];\n    if (e != null &amp;&amp; e.get() == key)\n        return e;\n    else\n        return getEntryAfterMiss(key, i, e);\n}\n</code></pre>\n<h4 id=\"当Entry为null时，getEntryAfterMiss方法\"><a href=\"#当Entry为null时，getEntryAfterMiss方法\" class=\"headerlink\" title=\"当Entry为null时，getEntryAfterMiss方法\"></a>当Entry为null时，getEntryAfterMiss方法</h4><pre><code class=\"lang-java\">private Entry getEntryAfterMiss(ThreadLocal key, int i, Entry e) {\n    Entry[] tab = table;\n    int len = tab.length;\n    while (e != null) {\n        ThreadLocal k = e.get();\n        if (k == key)\n            return e;\n        if (k == null)\n            expungeStaleEntry(i);\n        else\n            i = nextIndex(i, len);\n        e = tab[i];\n    }\n    return null;\n}\n</code></pre>\n<h4 id=\"expungeStaleEntry函数的源码：\"><a href=\"#expungeStaleEntry函数的源码：\" class=\"headerlink\" title=\"expungeStaleEntry函数的源码：\"></a><code>expungeStaleEntry</code>函数的源码：</h4><pre><code class=\"lang-java\">private int expungeStaleEntry(int staleSlot) {\n    Entry[] tab = table;\n    int len = tab.length;\n\n    // expunge entry at staleSlot\n    tab[staleSlot].value = null;\n    tab[staleSlot] = null;\n    size--;\n\n    // Rehash until we encounter null\n    Entry e;\n    int i;\n    for (i = nextIndex(staleSlot, len);\n         (e = tab[i]) != null;\n         i = nextIndex(i, len)) {\n        ThreadLocal k = e.get();\n        if (k == null) {\n            e.value = null;\n            tab[i] = null;\n            size--;\n        } else {\n            int h = k.threadLocalHashCode &amp; (len - 1);\n            if (h != i) {\n                tab[i] = null;\n\n                // Unlike Knuth 6.4 Algorithm R, we must scan until\n                // null because multiple entries could have been stale.\n                while (tab[h] != null)\n                    h = nextIndex(h, len);\n                tab[h] = e;\n            }\n        }\n    }\n    return i;\n}\n</code></pre>\n<h5 id=\"整理一下ThreadLocalMap的getEntry函数的流程：\"><a href=\"#整理一下ThreadLocalMap的getEntry函数的流程：\" class=\"headerlink\" title=\"整理一下ThreadLocalMap的getEntry函数的流程：\"></a>整理一下ThreadLocalMap的<code>getEntry</code>函数的流程：</h5><ol>\n<li>首先从ThreadLocal的直接索引位置(通过ThreadLocal.threadLocalHashCode &amp; (len-1)运算得到)获取Entry e，如果e不为null并且key相同则返回e；</li>\n<li>如果e为null或者key不一致则向下一个位置查询，如果下一个位置的key和当前需要查询的key相等，则返回对应的Entry，否则，如果key值为null，则擦除该位置的Entry，否则继续向下一个位置查询</li>\n</ol>\n<h5 id=\"在这个过程中遇到的key为null的Entry都会被擦除，那么Entry内的value也就没有强引用链，自然会被回收。仔细研究代码可以发现，set操作也有类似的思想，将key为null的这些Entry都删除，防止内存泄露。\"><a href=\"#在这个过程中遇到的key为null的Entry都会被擦除，那么Entry内的value也就没有强引用链，自然会被回收。仔细研究代码可以发现，set操作也有类似的思想，将key为null的这些Entry都删除，防止内存泄露。\" class=\"headerlink\" title=\"在这个过程中遇到的key为null的Entry都会被擦除，那么Entry内的value也就没有强引用链，自然会被回收。仔细研究代码可以发现，set操作也有类似的思想，将key为null的这些Entry都删除，防止内存泄露。\"></a>在这个过程中遇到的key为null的Entry都会被擦除，那么Entry内的value也就没有强引用链，自然会被回收。仔细研究代码可以发现，<code>set</code>操作也有类似的思想，将key为null的这些Entry都删除，防止内存泄露。</h5><h5 id=\"但是光这样还是不够的，上面的设计思路依赖一个前提条件：-要调用ThreadLocalMap的getEntry函数或者set函数。-这当然是不可能任何情况都成立的，所以很多情况下需要使用者手动调用ThreadLocal的remove函数，手动删除不再需要的ThreadLocal，防止内存泄露。所以JDK建议将ThreadLocal变量定义成private-static的，这样的话ThreadLocal的生命周期就更长，由于一直存在ThreadLocal的强引用，所以ThreadLocal也就不会被回收，也就能保证任何时候都能根据ThreadLocal的弱引用访问到Entry的value值，然后remove它，防止内存泄露。\"><a href=\"#但是光这样还是不够的，上面的设计思路依赖一个前提条件：-要调用ThreadLocalMap的getEntry函数或者set函数。-这当然是不可能任何情况都成立的，所以很多情况下需要使用者手动调用ThreadLocal的remove函数，手动删除不再需要的ThreadLocal，防止内存泄露。所以JDK建议将ThreadLocal变量定义成private-static的，这样的话ThreadLocal的生命周期就更长，由于一直存在ThreadLocal的强引用，所以ThreadLocal也就不会被回收，也就能保证任何时候都能根据ThreadLocal的弱引用访问到Entry的value值，然后remove它，防止内存泄露。\" class=\"headerlink\" title=\"但是光这样还是不够的，上面的设计思路依赖一个前提条件： 要调用ThreadLocalMap的getEntry函数或者set函数。 这当然是不可能任何情况都成立的，所以很多情况下需要使用者手动调用ThreadLocal的remove函数，手动删除不再需要的ThreadLocal，防止内存泄露。所以JDK建议将ThreadLocal变量定义成private static的，这样的话ThreadLocal的生命周期就更长，由于一直存在ThreadLocal的强引用，所以ThreadLocal也就不会被回收，也就能保证任何时候都能根据ThreadLocal的弱引用访问到Entry的value值，然后remove它，防止内存泄露。\"></a>但是光这样还是不够的，上面的设计思路依赖一个前提条件： 要调用ThreadLocalMap的<code>getEntry</code>函数或者<code>set</code>函数。 这当然是不可能任何情况都成立的，所以很多情况下需要使用者手动调用ThreadLocal的<code>remove</code>函数，手动删除不再需要的ThreadLocal，防止内存泄露。所以JDK建议将ThreadLocal变量定义成<code>private static</code>的，这样的话ThreadLocal的生命周期就更长，由于一直存在ThreadLocal的强引用，所以ThreadLocal也就不会被回收，也就能保证任何时候都能根据ThreadLocal的弱引用访问到Entry的value值，然后remove它，防止内存泄露。</h5>","site":{"data":{}},"excerpt":"<h2 id=\"ThreadLocal是什么\"><a href=\"#ThreadLocal是什么\" class=\"headerlink\" title=\"ThreadLocal是什么\"></a>ThreadLocal是什么</h2><h5 id=\"This-class-provides-thread-local-variables-These-variables-differ-from-their-normal-counterparts-in-that-each-thread-that-accesses-one-via-its-get-or-set-method-has-its-own-independently-initialized-copy-of-the-variable-ThreadLocal-instances-are-typically-private-static-fields-in-classes-that-wish-to-associate-state-with-a-thread-e-g-a-user-ID-or-Transaction-ID\"><a href=\"#This-class-provides-thread-local-variables-These-variables-differ-from-their-normal-counterparts-in-that-each-thread-that-accesses-one-via-its-get-or-set-method-has-its-own-independently-initialized-copy-of-the-variable-ThreadLocal-instances-are-typically-private-static-fields-in-classes-that-wish-to-associate-state-with-a-thread-e-g-a-user-ID-or-Transaction-ID\" class=\"headerlink\" title=\"This class provides thread-local variables.  These variables differ from their normal counterparts in that each thread that accesses one (via its get or set method) has its own, independently initialized copy of the variable.  ThreadLocal instances are typically private static fields in classes that wish to associate state with a thread (e.g., a user ID or Transaction ID).\"></a>This class provides thread-local variables.  These variables differ from their normal counterparts in that each thread that accesses one (via its <tt>get</tt> or <tt>set</tt> method) has its own, independently initialized copy of the variable.  <tt>ThreadLocal</tt> instances are typically private static fields in classes that wish to associate state with a thread (e.g., a user ID or Transaction ID).</h5>","more":"<h3 id=\"这是ThreadLocal源码中一段介绍，翻译过来的大概意思是：\"><a href=\"#这是ThreadLocal源码中一段介绍，翻译过来的大概意思是：\" class=\"headerlink\" title=\"这是ThreadLocal源码中一段介绍，翻译过来的大概意思是：\"></a>这是ThreadLocal源码中一段介绍，翻译过来的大概意思是：</h3><h5 id=\"ThreadLocal类用来提供线程内部的局部变量。这种变量在多线程环境下访问-通过get或set方法访问-时能保证各个线程里的变量相对独立于其他线程内的变量。ThreadLocal实例通常来说都是private-static类型的，用于关联线程和线程的上下文。\"><a href=\"#ThreadLocal类用来提供线程内部的局部变量。这种变量在多线程环境下访问-通过get或set方法访问-时能保证各个线程里的变量相对独立于其他线程内的变量。ThreadLocal实例通常来说都是private-static类型的，用于关联线程和线程的上下文。\" class=\"headerlink\" title=\"ThreadLocal类用来提供线程内部的局部变量。这种变量在多线程环境下访问(通过get或set方法访问)时能保证各个线程里的变量相对独立于其他线程内的变量。ThreadLocal实例通常来说都是private static类型的，用于关联线程和线程的上下文。\"></a>ThreadLocal类用来提供线程内部的局部变量。这种变量在多线程环境下访问(通过get或set方法访问)时能保证各个线程里的变量相对独立于其他线程内的变量。ThreadLocal实例通常来说都是private static类型的，用于关联线程和线程的上下文。</h5><h5 id=\"这种解释和网络上所说的解决多线程的并发问题不太一样，当你把一个变量复制成了多份，我觉得这种方式并不叫解决多线程访问资源时的共享问题。本质上来说资源已经变成了多份，没有共享之说，当然这也是一种解决方式，但是如果资源不必线程共享，又何必要用ThreadLocal去实现呢。\"><a href=\"#这种解释和网络上所说的解决多线程的并发问题不太一样，当你把一个变量复制成了多份，我觉得这种方式并不叫解决多线程访问资源时的共享问题。本质上来说资源已经变成了多份，没有共享之说，当然这也是一种解决方式，但是如果资源不必线程共享，又何必要用ThreadLocal去实现呢。\" class=\"headerlink\" title=\"这种解释和网络上所说的解决多线程的并发问题不太一样，当你把一个变量复制成了多份，我觉得这种方式并不叫解决多线程访问资源时的共享问题。本质上来说资源已经变成了多份，没有共享之说，当然这也是一种解决方式，但是如果资源不必线程共享，又何必要用ThreadLocal去实现呢。\"></a>这种解释和网络上所说的解决多线程的并发问题不太一样，当你把一个变量复制成了多份，我觉得这种方式并不叫解决多线程访问资源时的共享问题。本质上来说资源已经变成了多份，没有共享之说，当然这也是一种解决方式，但是如果资源不必线程共享，又何必要用ThreadLocal去实现呢。</h5><h4 id=\"总结来说：ThreadLocal的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。\"><a href=\"#总结来说：ThreadLocal的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。\" class=\"headerlink\" title=\"总结来说：ThreadLocal的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。\"></a>总结来说：ThreadLocal的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。</h4><h5 id=\"举一个例子，一个请求需要按照1、2、3这个顺序执行3个函数。但是其中有一个参数是需要函数1提供给函数3使用的，但是这个参数对于函数2来说并没有作用（实际情况可能比这要复杂的多）。同时我们又不希望污染函数2，那么如何将该参数通过函数1传递到函数3呢？ThreadLocal是一个比较合理的解决方法。\"><a href=\"#举一个例子，一个请求需要按照1、2、3这个顺序执行3个函数。但是其中有一个参数是需要函数1提供给函数3使用的，但是这个参数对于函数2来说并没有作用（实际情况可能比这要复杂的多）。同时我们又不希望污染函数2，那么如何将该参数通过函数1传递到函数3呢？ThreadLocal是一个比较合理的解决方法。\" class=\"headerlink\" title=\"举一个例子，一个请求需要按照1、2、3这个顺序执行3个函数。但是其中有一个参数是需要函数1提供给函数3使用的，但是这个参数对于函数2来说并没有作用（实际情况可能比这要复杂的多）。同时我们又不希望污染函数2，那么如何将该参数通过函数1传递到函数3呢？ThreadLocal是一个比较合理的解决方法。\"></a>举一个例子，一个请求需要按照1、2、3这个顺序执行3个函数。但是其中有一个参数是需要函数1提供给函数3使用的，但是这个参数对于函数2来说并没有作用（实际情况可能比这要复杂的多）。同时我们又不希望污染函数2，那么如何将该参数通过函数1传递到函数3呢？ThreadLocal是一个比较合理的解决方法。</h5><h2 id=\"ThreadLocal代码演示\"><a href=\"#ThreadLocal代码演示\" class=\"headerlink\" title=\"ThreadLocal代码演示\"></a>ThreadLocal代码演示</h2><pre><code class=\"lang-JAVA\">/**\n * Created BY wangwenxiang on 2017/3/15.\n */\npublic class ThreadLocalTest {\n    private static ThreadLocal&lt;Integer&gt; integerThreadLocal = new ThreadLocal&lt;Integer&gt;();\n\n    /**\n     * 初始化并输出每个线程的ThreadLocal\n     * Runnable\n     * name\n     */\n    private static Thread[] initThread(){\n        Thread[] threads = new Thread[10];\n        for (int i=0;i&lt;10;i++){\n            final int finalI = i;\n            threads[i] = new Thread(new Runnable() {\n                public void run() {\n                    integerThreadLocal.set(finalI);\n                    System.out.println(Thread.currentThread().getName()+&quot;: &quot;+integerThreadLocal.get());\n                }\n            },&quot;thread-&quot; + i);\n        }\n        return threads;\n    }\n\n\n    public static void main(String[] args) {\n        Thread[] threads = initThread();\n        for (Thread thread : threads){\n            thread.start();\n        }\n    }\n}\n</code></pre>\n<h5 id=\"ThreadLocal的操作非常简单，基本上没有太多的过程。\"><a href=\"#ThreadLocal的操作非常简单，基本上没有太多的过程。\" class=\"headerlink\" title=\"ThreadLocal的操作非常简单，基本上没有太多的过程。\"></a>ThreadLocal的操作非常简单，基本上没有太多的过程。</h5><h5 id=\"执行结果：\"><a href=\"#执行结果：\" class=\"headerlink\" title=\"执行结果：\"></a>执行结果：</h5><pre><code>thread-0: 0\nthread-1: 1\nthread-2: 2\nthread-3: 3\nthread-4: 4\nthread-5: 5\nthread-6: 6\nthread-7: 7\nthread-8: 8\nthread-9: 9\n</code></pre><h5 id=\"可以看出虽然只创建了一个ThreadLocal对象，但是每个线程的初始化之后，得出来的结果并不一样。各个线程之间的值是相互独立的。\"><a href=\"#可以看出虽然只创建了一个ThreadLocal对象，但是每个线程的初始化之后，得出来的结果并不一样。各个线程之间的值是相互独立的。\" class=\"headerlink\" title=\"可以看出虽然只创建了一个ThreadLocal对象，但是每个线程的初始化之后，得出来的结果并不一样。各个线程之间的值是相互独立的。\"></a>可以看出虽然只创建了一个ThreadLocal对象，但是每个线程的初始化之后，得出来的结果并不一样。各个线程之间的值是相互独立的。</h5><h2 id=\"ThreadLocal源码\"><a href=\"#ThreadLocal源码\" class=\"headerlink\" title=\"ThreadLocal源码\"></a>ThreadLocal源码</h2><h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><pre><code class=\"lang-java\">/**\n * Creates a thread local variable.\n */\npublic ThreadLocal() {\n}\n</code></pre>\n<h5 id=\"这是ThreadLocal唯一的构造函数，什么也没做\"><a href=\"#这是ThreadLocal唯一的构造函数，什么也没做\" class=\"headerlink\" title=\"这是ThreadLocal唯一的构造函数，什么也没做\"></a>这是ThreadLocal唯一的构造函数，什么也没做</h5><h3 id=\"set方法\"><a href=\"#set方法\" class=\"headerlink\" title=\"set方法\"></a>set方法</h3><pre><code class=\"lang-JAVA\">/**\n * Sets the current thread&#39;s copy of this thread-local variable\n * to the specified value.  Most subclasses will have no need to\n * override this method, relying solely on the {@link #initialValue}\n * method to set the values of thread-locals.\n *\n * @param value the value to be stored in the current thread&#39;s copy of\n *        this thread-local.\n */\npublic void set(T value) {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null)\n            map.set(this, value);\n        else\n            createMap(t, value);\n    }\n</code></pre>\n<h5 id=\"代码比较简单\"><a href=\"#代码比较简单\" class=\"headerlink\" title=\"代码比较简单\"></a>代码比较简单</h5><ol>\n<li>获取当前线程 <code>Thread t = Thread.currentThread();</code></li>\n<li>获取当前线程的ThreadLocalMap，使得每个线程的本地数据相互隔离的原因也在于这里，因为每个线程都有自己的ThreadLocalMap；</li>\n<li>判断ThreadLocalMap是否为空，直接插入或者创建map并插入；</li>\n</ol>\n<h4 id=\"ThreadLocalMap的set方法\"><a href=\"#ThreadLocalMap的set方法\" class=\"headerlink\" title=\"ThreadLocalMap的set方法\"></a>ThreadLocalMap的set方法</h4><pre><code class=\"lang-JAVA\">/**\n * Set the value associated with key.\n * @param value the value to be set\n *\n * @param key the thread local object\n */\nprivate void set(ThreadLocal key, Object value) {\n\n    // We don&#39;t use a fast path as with get() because it is at\n    // least as common to use set() to create new entries as\n    // it is to replace existing ones, in which case, a fast\n    // path would fail more often than not.\n\n    Entry[] tab = table;\n    int len = tab.length;\n    int i = key.threadLocalHashCode &amp; (len-1);\n\n    for (Entry e = tab[i];\n         e != null;\n         e = tab[i = nextIndex(i, len)]) {\n        ThreadLocal k = e.get();\n\n        if (k == key) {\n            e.value = value;\n            return;\n        }\n\n        if (k == null) {\n            replaceStaleEntry(key, value, i);\n            return;\n        }\n    }\n\n    tab[i] = new Entry(key, value);\n    int sz = ++size;\n    if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)\n        rehash();\n}\n</code></pre>\n<h5 id=\"map的key和value分别对应的是ThreadLocal本身和往ThreadLocal中set的值。\"><a href=\"#map的key和value分别对应的是ThreadLocal本身和往ThreadLocal中set的值。\" class=\"headerlink\" title=\"map的key和value分别对应的是ThreadLocal本身和往ThreadLocal中set的值。\"></a>map的key和value分别对应的是ThreadLocal本身和往ThreadLocal中set的值。</h5><ol>\n<li>首先根据ThreadLocal元素的hashCode计算出其数组下标；由于数组的长度用于等于2<sup>n</sup>个，所以下表的取值范围在0到2<sup>n</sup>-1；</li>\n<li>for循环，从数组位置i开始以步长1向后循环遍历，直到找到一个空位，每次循环将该位置的值赋值给e；</li>\n<li>当数组位置不为空时执行方法体：<ol>\n<li>获得该数组位置的ThreadLocal，判断是否与当前ThreadLocal相等，如果相等，则将value更新，set方法结束；</li>\n<li>如果该ThreadLocal为空，则替换，然后结束方法。</li>\n</ol>\n</li>\n<li>在位置i插入新值，计数加1</li>\n</ol>\n<h3 id=\"get方法\"><a href=\"#get方法\" class=\"headerlink\" title=\"get方法\"></a>get方法</h3><pre><code class=\"lang-JAVA\">/**\n  * Returns the value in the current thread&#39;s copy of this\n  * thread-local variable.  If the variable has no value for the\n  * current thread, it is first initialized to the value returned\n  * by an invocation of the {@link #initialValue} method.\n  *\n  * @return the current thread&#39;s value of this thread-local\n  */\npublic T get() {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null) {\n            ThreadLocalMap.Entry e = map.getEntry(this);\n            if (e != null)\n                return (T)e.value;\n        }\n        return setInitialValue();\n    }\n</code></pre>\n<h5 id=\"get方法和set方法比较类似，首先获取当前线程，并获取线程的ThreadLocalMap，以当前的ThreadLocal作为key在map中获取value，判断value是否为null，如果为null，则将当前的ThreadLocal中设置初始值，并返回改值。\"><a href=\"#get方法和set方法比较类似，首先获取当前线程，并获取线程的ThreadLocalMap，以当前的ThreadLocal作为key在map中获取value，判断value是否为null，如果为null，则将当前的ThreadLocal中设置初始值，并返回改值。\" class=\"headerlink\" title=\"get方法和set方法比较类似，首先获取当前线程，并获取线程的ThreadLocalMap，以当前的ThreadLocal作为key在map中获取value，判断value是否为null，如果为null，则将当前的ThreadLocal中设置初始值，并返回改值。\"></a>get方法和set方法比较类似，首先获取当前线程，并获取线程的ThreadLocalMap，以当前的ThreadLocal作为key在map中获取value，判断value是否为null，如果为null，则将当前的ThreadLocal中设置初始值，并返回改值。</h5><h4 id=\"setInitialValue\"><a href=\"#setInitialValue\" class=\"headerlink\" title=\"setInitialValue()\"></a>setInitialValue()</h4><pre><code class=\"lang-JAVA\">/**\n * Variant of set() to establish initialValue. Used instead\n * of set() in case user has overridden the set() method.\n *\n * @return the initial value\n */\nprivate T setInitialValue() {\n    T value = initialValue();\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n    if (map != null)\n        map.set(this, value);\n    else\n        createMap(t, value);\n    return value;\n}\n</code></pre>\n<h5 id=\"该方法和set方法基本一样\"><a href=\"#该方法和set方法基本一样\" class=\"headerlink\" title=\"该方法和set方法基本一样\"></a>该方法和set方法基本一样</h5><h4 id=\"initialValue\"><a href=\"#initialValue\" class=\"headerlink\" title=\"initialValue()\"></a>initialValue()</h4><pre><code class=\"lang-JAVA\">/**\n * Returns the current thread&#39;s &quot;initial value&quot; for this\n * thread-local variable.  This method will be invoked the first\n * time a thread accesses the variable with the {@link #get}\n * method, unless the thread previously invoked the {@link #set}\n * method, in which case the &lt;tt&gt;initialValue&lt;/tt&gt; method will not\n * be invoked for the thread.  Normally, this method is invoked at\n * most once per thread, but it may be invoked again in case of\n * subsequent invocations of {@link #remove} followed by {@link #get}.\n *\n * &lt;p&gt;This implementation simply returns &lt;tt&gt;null&lt;/tt&gt;; if the\n * programmer desires thread-local variables to have an initial\n * value other than &lt;tt&gt;null&lt;/tt&gt;, &lt;tt&gt;ThreadLocal&lt;/tt&gt; must be\n * subclassed, and this method overridden.  Typically, an\n * anonymous inner class will be used.\n *\n * @return the initial value for this thread-local\n */\n protected T initialValue() {\n     return null;\n }\n</code></pre>\n<h5 id=\"该方法只在get方法中被调用，当ThreadLocal中没有设置value时。默认返回null，protected的访问权限表示该方法支持被覆盖。\"><a href=\"#该方法只在get方法中被调用，当ThreadLocal中没有设置value时。默认返回null，protected的访问权限表示该方法支持被覆盖。\" class=\"headerlink\" title=\"该方法只在get方法中被调用，当ThreadLocal中没有设置value时。默认返回null，protected的访问权限表示该方法支持被覆盖。\"></a>该方法只在get方法中被调用，当ThreadLocal中没有设置value时。默认返回null，protected的访问权限表示该方法支持被覆盖。</h5><h3 id=\"ThreadLocalMap\"><a href=\"#ThreadLocalMap\" class=\"headerlink\" title=\"ThreadLocalMap\"></a>ThreadLocalMap</h3><h5 id=\"ThreadLocalMap是使用ThreadLocal的弱引用作为Key的\"><a href=\"#ThreadLocalMap是使用ThreadLocal的弱引用作为Key的\" class=\"headerlink\" title=\"ThreadLocalMap是使用ThreadLocal的弱引用作为Key的\"></a>ThreadLocalMap是使用ThreadLocal的弱引用作为Key的</h5><pre><code class=\"lang-JAVA\">static class ThreadLocalMap {\n        /**\n         * The entries in this hash map extend WeakReference, using\n         * its main ref field as the key (which is always a\n         * ThreadLocal object).  Note that null keys (i.e. entry.get()\n         * == null) mean that the key is no longer referenced, so the\n         * entry can be expunged from table.  Such entries are referred to\n         * as &quot;stale entries&quot; in the code that follows.\n         */\n        static class Entry extends WeakReference&lt;ThreadLocal&gt; {\n            /** The value associated with this ThreadLocal. */\n            Object value;\n\n            Entry(ThreadLocal k, Object v) {\n                super(k);\n                value = v;\n            }\n        }\n        ...\n        ...\n}\n</code></pre>\n<h5 id=\"下图是本文介绍到的一些对象之间的引用关系图，实线表示强引用，虚线表示弱引用：\"><a href=\"#下图是本文介绍到的一些对象之间的引用关系图，实线表示强引用，虚线表示弱引用：\" class=\"headerlink\" title=\"下图是本文介绍到的一些对象之间的引用关系图，实线表示强引用，虚线表示弱引用：\"></a>下图是本文介绍到的一些对象之间的引用关系图，实线表示强引用，虚线表示弱引用：</h5><p><img src=\"../../img/note/ThreadLocal.png\" alt=\"ThreadLocal\"> <div class=\"img-note\">ThreadLocal对象引用</div></p>\n<h5 id=\"如上图，ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用引用他，那么系统gc的时候，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：\"><a href=\"#如上图，ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用引用他，那么系统gc的时候，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：\" class=\"headerlink\" title=\"如上图，ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用引用他，那么系统gc的时候，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：\"></a>如上图，ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用引用他，那么系统gc的时候，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：</h5><h4 id=\"Thread-Ref-gt-Thread-gt-ThreaLocalMap-gt-Entry-gt-value\"><a href=\"#Thread-Ref-gt-Thread-gt-ThreaLocalMap-gt-Entry-gt-value\" class=\"headerlink\" title=\"Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value\"></a>Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value</h4><h5 id=\"永远无法回收，造成内存泄露。\"><a href=\"#永远无法回收，造成内存泄露。\" class=\"headerlink\" title=\"永远无法回收，造成内存泄露。\"></a>永远无法回收，造成内存泄露。</h5><h5 id=\"其实，在JDK的ThreadLocalMap的设计中已经考虑到这种情况，也加上了一些防护措施，下面是ThreadLocalMap的getEntry方法的源码：\"><a href=\"#其实，在JDK的ThreadLocalMap的设计中已经考虑到这种情况，也加上了一些防护措施，下面是ThreadLocalMap的getEntry方法的源码：\" class=\"headerlink\" title=\"其实，在JDK的ThreadLocalMap的设计中已经考虑到这种情况，也加上了一些防护措施，下面是ThreadLocalMap的getEntry方法的源码：\"></a>其实，在JDK的ThreadLocalMap的设计中已经考虑到这种情况，也加上了一些防护措施，下面是ThreadLocalMap的<code>getEntry</code>方法的源码：</h5><pre><code class=\"lang-JAVA\">private Entry getEntry(ThreadLocal key) {\n    int i = key.threadLocalHashCode &amp; (table.length - 1);\n    Entry e = table[i];\n    if (e != null &amp;&amp; e.get() == key)\n        return e;\n    else\n        return getEntryAfterMiss(key, i, e);\n}\n</code></pre>\n<h4 id=\"当Entry为null时，getEntryAfterMiss方法\"><a href=\"#当Entry为null时，getEntryAfterMiss方法\" class=\"headerlink\" title=\"当Entry为null时，getEntryAfterMiss方法\"></a>当Entry为null时，getEntryAfterMiss方法</h4><pre><code class=\"lang-java\">private Entry getEntryAfterMiss(ThreadLocal key, int i, Entry e) {\n    Entry[] tab = table;\n    int len = tab.length;\n    while (e != null) {\n        ThreadLocal k = e.get();\n        if (k == key)\n            return e;\n        if (k == null)\n            expungeStaleEntry(i);\n        else\n            i = nextIndex(i, len);\n        e = tab[i];\n    }\n    return null;\n}\n</code></pre>\n<h4 id=\"expungeStaleEntry函数的源码：\"><a href=\"#expungeStaleEntry函数的源码：\" class=\"headerlink\" title=\"expungeStaleEntry函数的源码：\"></a><code>expungeStaleEntry</code>函数的源码：</h4><pre><code class=\"lang-java\">private int expungeStaleEntry(int staleSlot) {\n    Entry[] tab = table;\n    int len = tab.length;\n\n    // expunge entry at staleSlot\n    tab[staleSlot].value = null;\n    tab[staleSlot] = null;\n    size--;\n\n    // Rehash until we encounter null\n    Entry e;\n    int i;\n    for (i = nextIndex(staleSlot, len);\n         (e = tab[i]) != null;\n         i = nextIndex(i, len)) {\n        ThreadLocal k = e.get();\n        if (k == null) {\n            e.value = null;\n            tab[i] = null;\n            size--;\n        } else {\n            int h = k.threadLocalHashCode &amp; (len - 1);\n            if (h != i) {\n                tab[i] = null;\n\n                // Unlike Knuth 6.4 Algorithm R, we must scan until\n                // null because multiple entries could have been stale.\n                while (tab[h] != null)\n                    h = nextIndex(h, len);\n                tab[h] = e;\n            }\n        }\n    }\n    return i;\n}\n</code></pre>\n<h5 id=\"整理一下ThreadLocalMap的getEntry函数的流程：\"><a href=\"#整理一下ThreadLocalMap的getEntry函数的流程：\" class=\"headerlink\" title=\"整理一下ThreadLocalMap的getEntry函数的流程：\"></a>整理一下ThreadLocalMap的<code>getEntry</code>函数的流程：</h5><ol>\n<li>首先从ThreadLocal的直接索引位置(通过ThreadLocal.threadLocalHashCode &amp; (len-1)运算得到)获取Entry e，如果e不为null并且key相同则返回e；</li>\n<li>如果e为null或者key不一致则向下一个位置查询，如果下一个位置的key和当前需要查询的key相等，则返回对应的Entry，否则，如果key值为null，则擦除该位置的Entry，否则继续向下一个位置查询</li>\n</ol>\n<h5 id=\"在这个过程中遇到的key为null的Entry都会被擦除，那么Entry内的value也就没有强引用链，自然会被回收。仔细研究代码可以发现，set操作也有类似的思想，将key为null的这些Entry都删除，防止内存泄露。\"><a href=\"#在这个过程中遇到的key为null的Entry都会被擦除，那么Entry内的value也就没有强引用链，自然会被回收。仔细研究代码可以发现，set操作也有类似的思想，将key为null的这些Entry都删除，防止内存泄露。\" class=\"headerlink\" title=\"在这个过程中遇到的key为null的Entry都会被擦除，那么Entry内的value也就没有强引用链，自然会被回收。仔细研究代码可以发现，set操作也有类似的思想，将key为null的这些Entry都删除，防止内存泄露。\"></a>在这个过程中遇到的key为null的Entry都会被擦除，那么Entry内的value也就没有强引用链，自然会被回收。仔细研究代码可以发现，<code>set</code>操作也有类似的思想，将key为null的这些Entry都删除，防止内存泄露。</h5><h5 id=\"但是光这样还是不够的，上面的设计思路依赖一个前提条件：-要调用ThreadLocalMap的getEntry函数或者set函数。-这当然是不可能任何情况都成立的，所以很多情况下需要使用者手动调用ThreadLocal的remove函数，手动删除不再需要的ThreadLocal，防止内存泄露。所以JDK建议将ThreadLocal变量定义成private-static的，这样的话ThreadLocal的生命周期就更长，由于一直存在ThreadLocal的强引用，所以ThreadLocal也就不会被回收，也就能保证任何时候都能根据ThreadLocal的弱引用访问到Entry的value值，然后remove它，防止内存泄露。\"><a href=\"#但是光这样还是不够的，上面的设计思路依赖一个前提条件：-要调用ThreadLocalMap的getEntry函数或者set函数。-这当然是不可能任何情况都成立的，所以很多情况下需要使用者手动调用ThreadLocal的remove函数，手动删除不再需要的ThreadLocal，防止内存泄露。所以JDK建议将ThreadLocal变量定义成private-static的，这样的话ThreadLocal的生命周期就更长，由于一直存在ThreadLocal的强引用，所以ThreadLocal也就不会被回收，也就能保证任何时候都能根据ThreadLocal的弱引用访问到Entry的value值，然后remove它，防止内存泄露。\" class=\"headerlink\" title=\"但是光这样还是不够的，上面的设计思路依赖一个前提条件： 要调用ThreadLocalMap的getEntry函数或者set函数。 这当然是不可能任何情况都成立的，所以很多情况下需要使用者手动调用ThreadLocal的remove函数，手动删除不再需要的ThreadLocal，防止内存泄露。所以JDK建议将ThreadLocal变量定义成private static的，这样的话ThreadLocal的生命周期就更长，由于一直存在ThreadLocal的强引用，所以ThreadLocal也就不会被回收，也就能保证任何时候都能根据ThreadLocal的弱引用访问到Entry的value值，然后remove它，防止内存泄露。\"></a>但是光这样还是不够的，上面的设计思路依赖一个前提条件： 要调用ThreadLocalMap的<code>getEntry</code>函数或者<code>set</code>函数。 这当然是不可能任何情况都成立的，所以很多情况下需要使用者手动调用ThreadLocal的<code>remove</code>函数，手动删除不再需要的ThreadLocal，防止内存泄露。所以JDK建议将ThreadLocal变量定义成<code>private static</code>的，这样的话ThreadLocal的生命周期就更长，由于一直存在ThreadLocal的强引用，所以ThreadLocal也就不会被回收，也就能保证任何时候都能根据ThreadLocal的弱引用访问到Entry的value值，然后remove它，防止内存泄露。</h5>"},{"layout":"book","title":"1984","author":"乔治·奥威尔[英]","date":"2017-05-31T16:00:00.000Z","cover":"1984.jpg","color":"#E30D23","_content":"\n## 内容简介\n##### 　　《1984》是一部杰出的政治寓言小说，也是一部幻想小说。作品刻画了人类在极权主义社会的生存状态，仿佛一个永不退色的警世标签，警醒世人提防这种预想中的黑暗成为现实。历经几十年，其生命力日益强大，被誉为20世纪影响最为深远的文学经典之一。\n\n## 笔记\n### 　　\"战争就是和平 自由就是奴役 无知就是力量\"\n### 　　\"那个黑发姑娘穿过田野向他走来。她好像一下子就脱光了衣服，不屑地扔到一边。她的身体白皙光滑，却没有引起他的任何欲望，事实上，他几乎没怎么看她。此刻，他满心只是赞叹着她扔衣服的动作。那种优雅随意的态度似乎能摧毁整个文化、整个思想体系，这绝妙的一挥手似乎能把老大哥、党和思想警察一扫而光。这也是一个属于古老的时代的动作。温斯顿醒来时嘴上还念着“莎士比亚”这个词。\"\n### 　　\"控制过去就能控制未来，控制现在就能控制过去\"\n### 　　\"眼前的真理就是永远的真理。很简单。所需的只是不断战胜自己的记忆而已。他们称它为“现实控制”，用新话说就是“双重思想”。\"\n### 　　\"用逻辑否定逻辑，既否认道德又维护道德，既相信民主的不可能又相信党是民主的卫士；\"\n### 　　\"“我讨厌纯洁，我讨厌善良！我讨厌任何美德的存在。我要让每个人都坏到骨子里去。”\"\n### 　　\"如果你遵守小的规定就可以违反大的规定。\"\n### 　　\"下等人的永久特征就是被劳役所压垮，以至于只能断断续续地认识到他们日常生活以外的东西——就是消除一切差别，建立一个人人平等的社会\"\n### 　　\"双重思想是英社的核心，因为党的主要行为就是故意欺骗，同时保持目标明确，毫不动摇，貌像完全诚实。故意撒谎又真诚地相信谎言；忘记不利的事实，必要的时候将它从遗忘中唤起，用完以后又立即忘记；否认客观现实的存在，同时又顾及被否认的事实——所有这些都必不可少。\"\n### 　　\"只是一个无望的幻想，像一个转瞬即逝的四月天，可一个眼神、一句话语却唤起了我的梦想，我的心便从此不见！\"\n","source":"_posts/read/1984.md","raw":"---\nlayout: book\ntitle: 1984\nauthor: 乔治·奥威尔[英]\ndate: 2017/06/01\ncover: 1984.jpg\ncategories: [read]\ncolor: '#E30D23'\n---\n\n## 内容简介\n##### 　　《1984》是一部杰出的政治寓言小说，也是一部幻想小说。作品刻画了人类在极权主义社会的生存状态，仿佛一个永不退色的警世标签，警醒世人提防这种预想中的黑暗成为现实。历经几十年，其生命力日益强大，被誉为20世纪影响最为深远的文学经典之一。\n\n## 笔记\n### 　　\"战争就是和平 自由就是奴役 无知就是力量\"\n### 　　\"那个黑发姑娘穿过田野向他走来。她好像一下子就脱光了衣服，不屑地扔到一边。她的身体白皙光滑，却没有引起他的任何欲望，事实上，他几乎没怎么看她。此刻，他满心只是赞叹着她扔衣服的动作。那种优雅随意的态度似乎能摧毁整个文化、整个思想体系，这绝妙的一挥手似乎能把老大哥、党和思想警察一扫而光。这也是一个属于古老的时代的动作。温斯顿醒来时嘴上还念着“莎士比亚”这个词。\"\n### 　　\"控制过去就能控制未来，控制现在就能控制过去\"\n### 　　\"眼前的真理就是永远的真理。很简单。所需的只是不断战胜自己的记忆而已。他们称它为“现实控制”，用新话说就是“双重思想”。\"\n### 　　\"用逻辑否定逻辑，既否认道德又维护道德，既相信民主的不可能又相信党是民主的卫士；\"\n### 　　\"“我讨厌纯洁，我讨厌善良！我讨厌任何美德的存在。我要让每个人都坏到骨子里去。”\"\n### 　　\"如果你遵守小的规定就可以违反大的规定。\"\n### 　　\"下等人的永久特征就是被劳役所压垮，以至于只能断断续续地认识到他们日常生活以外的东西——就是消除一切差别，建立一个人人平等的社会\"\n### 　　\"双重思想是英社的核心，因为党的主要行为就是故意欺骗，同时保持目标明确，毫不动摇，貌像完全诚实。故意撒谎又真诚地相信谎言；忘记不利的事实，必要的时候将它从遗忘中唤起，用完以后又立即忘记；否认客观现实的存在，同时又顾及被否认的事实——所有这些都必不可少。\"\n### 　　\"只是一个无望的幻想，像一个转瞬即逝的四月天，可一个眼神、一句话语却唤起了我的梦想，我的心便从此不见！\"\n","slug":"read/1984","published":1,"updated":"2017-08-15T11:31:46.000Z","comments":1,"photos":[],"link":"","_id":"cj8jros7d000n30s67xh97hsf","content":"<h2 id=\"内容简介\"><a href=\"#内容简介\" class=\"headerlink\" title=\"内容简介\"></a>内容简介</h2><h5 id=\"《1984》是一部杰出的政治寓言小说，也是一部幻想小说。作品刻画了人类在极权主义社会的生存状态，仿佛一个永不退色的警世标签，警醒世人提防这种预想中的黑暗成为现实。历经几十年，其生命力日益强大，被誉为20世纪影响最为深远的文学经典之一。\"><a href=\"#《1984》是一部杰出的政治寓言小说，也是一部幻想小说。作品刻画了人类在极权主义社会的生存状态，仿佛一个永不退色的警世标签，警醒世人提防这种预想中的黑暗成为现实。历经几十年，其生命力日益强大，被誉为20世纪影响最为深远的文学经典之一。\" class=\"headerlink\" title=\"　　《1984》是一部杰出的政治寓言小说，也是一部幻想小说。作品刻画了人类在极权主义社会的生存状态，仿佛一个永不退色的警世标签，警醒世人提防这种预想中的黑暗成为现实。历经几十年，其生命力日益强大，被誉为20世纪影响最为深远的文学经典之一。\"></a>　　《1984》是一部杰出的政治寓言小说，也是一部幻想小说。作品刻画了人类在极权主义社会的生存状态，仿佛一个永不退色的警世标签，警醒世人提防这种预想中的黑暗成为现实。历经几十年，其生命力日益强大，被誉为20世纪影响最为深远的文学经典之一。</h5><h2 id=\"笔记\"><a href=\"#笔记\" class=\"headerlink\" title=\"笔记\"></a>笔记</h2><h3 id=\"“战争就是和平-自由就是奴役-无知就是力量”\"><a href=\"#“战争就是和平-自由就是奴役-无知就是力量”\" class=\"headerlink\" title=\"　　“战争就是和平 自由就是奴役 无知就是力量”\"></a>　　“战争就是和平 自由就是奴役 无知就是力量”</h3><h3 id=\"“那个黑发姑娘穿过田野向他走来。她好像一下子就脱光了衣服，不屑地扔到一边。她的身体白皙光滑，却没有引起他的任何欲望，事实上，他几乎没怎么看她。此刻，他满心只是赞叹着她扔衣服的动作。那种优雅随意的态度似乎能摧毁整个文化、整个思想体系，这绝妙的一挥手似乎能把老大哥、党和思想警察一扫而光。这也是一个属于古老的时代的动作。温斯顿醒来时嘴上还念着“莎士比亚”这个词。”\"><a href=\"#“那个黑发姑娘穿过田野向他走来。她好像一下子就脱光了衣服，不屑地扔到一边。她的身体白皙光滑，却没有引起他的任何欲望，事实上，他几乎没怎么看她。此刻，他满心只是赞叹着她扔衣服的动作。那种优雅随意的态度似乎能摧毁整个文化、整个思想体系，这绝妙的一挥手似乎能把老大哥、党和思想警察一扫而光。这也是一个属于古老的时代的动作。温斯顿醒来时嘴上还念着“莎士比亚”这个词。”\" class=\"headerlink\" title=\"　　“那个黑发姑娘穿过田野向他走来。她好像一下子就脱光了衣服，不屑地扔到一边。她的身体白皙光滑，却没有引起他的任何欲望，事实上，他几乎没怎么看她。此刻，他满心只是赞叹着她扔衣服的动作。那种优雅随意的态度似乎能摧毁整个文化、整个思想体系，这绝妙的一挥手似乎能把老大哥、党和思想警察一扫而光。这也是一个属于古老的时代的动作。温斯顿醒来时嘴上还念着“莎士比亚”这个词。”\"></a>　　“那个黑发姑娘穿过田野向他走来。她好像一下子就脱光了衣服，不屑地扔到一边。她的身体白皙光滑，却没有引起他的任何欲望，事实上，他几乎没怎么看她。此刻，他满心只是赞叹着她扔衣服的动作。那种优雅随意的态度似乎能摧毁整个文化、整个思想体系，这绝妙的一挥手似乎能把老大哥、党和思想警察一扫而光。这也是一个属于古老的时代的动作。温斯顿醒来时嘴上还念着“莎士比亚”这个词。”</h3><h3 id=\"“控制过去就能控制未来，控制现在就能控制过去”\"><a href=\"#“控制过去就能控制未来，控制现在就能控制过去”\" class=\"headerlink\" title=\"　　“控制过去就能控制未来，控制现在就能控制过去”\"></a>　　“控制过去就能控制未来，控制现在就能控制过去”</h3><h3 id=\"“眼前的真理就是永远的真理。很简单。所需的只是不断战胜自己的记忆而已。他们称它为“现实控制”，用新话说就是“双重思想”。”\"><a href=\"#“眼前的真理就是永远的真理。很简单。所需的只是不断战胜自己的记忆而已。他们称它为“现实控制”，用新话说就是“双重思想”。”\" class=\"headerlink\" title=\"　　“眼前的真理就是永远的真理。很简单。所需的只是不断战胜自己的记忆而已。他们称它为“现实控制”，用新话说就是“双重思想”。”\"></a>　　“眼前的真理就是永远的真理。很简单。所需的只是不断战胜自己的记忆而已。他们称它为“现实控制”，用新话说就是“双重思想”。”</h3><h3 id=\"“用逻辑否定逻辑，既否认道德又维护道德，既相信民主的不可能又相信党是民主的卫士；”\"><a href=\"#“用逻辑否定逻辑，既否认道德又维护道德，既相信民主的不可能又相信党是民主的卫士；”\" class=\"headerlink\" title=\"　　“用逻辑否定逻辑，既否认道德又维护道德，既相信民主的不可能又相信党是民主的卫士；”\"></a>　　“用逻辑否定逻辑，既否认道德又维护道德，既相信民主的不可能又相信党是民主的卫士；”</h3><h3 id=\"““我讨厌纯洁，我讨厌善良！我讨厌任何美德的存在。我要让每个人都坏到骨子里去。””\"><a href=\"#““我讨厌纯洁，我讨厌善良！我讨厌任何美德的存在。我要让每个人都坏到骨子里去。””\" class=\"headerlink\" title=\"　　““我讨厌纯洁，我讨厌善良！我讨厌任何美德的存在。我要让每个人都坏到骨子里去。””\"></a>　　““我讨厌纯洁，我讨厌善良！我讨厌任何美德的存在。我要让每个人都坏到骨子里去。””</h3><h3 id=\"“如果你遵守小的规定就可以违反大的规定。”\"><a href=\"#“如果你遵守小的规定就可以违反大的规定。”\" class=\"headerlink\" title=\"　　“如果你遵守小的规定就可以违反大的规定。”\"></a>　　“如果你遵守小的规定就可以违反大的规定。”</h3><h3 id=\"“下等人的永久特征就是被劳役所压垮，以至于只能断断续续地认识到他们日常生活以外的东西——就是消除一切差别，建立一个人人平等的社会”\"><a href=\"#“下等人的永久特征就是被劳役所压垮，以至于只能断断续续地认识到他们日常生活以外的东西——就是消除一切差别，建立一个人人平等的社会”\" class=\"headerlink\" title=\"　　“下等人的永久特征就是被劳役所压垮，以至于只能断断续续地认识到他们日常生活以外的东西——就是消除一切差别，建立一个人人平等的社会”\"></a>　　“下等人的永久特征就是被劳役所压垮，以至于只能断断续续地认识到他们日常生活以外的东西——就是消除一切差别，建立一个人人平等的社会”</h3><h3 id=\"“双重思想是英社的核心，因为党的主要行为就是故意欺骗，同时保持目标明确，毫不动摇，貌像完全诚实。故意撒谎又真诚地相信谎言；忘记不利的事实，必要的时候将它从遗忘中唤起，用完以后又立即忘记；否认客观现实的存在，同时又顾及被否认的事实——所有这些都必不可少。”\"><a href=\"#“双重思想是英社的核心，因为党的主要行为就是故意欺骗，同时保持目标明确，毫不动摇，貌像完全诚实。故意撒谎又真诚地相信谎言；忘记不利的事实，必要的时候将它从遗忘中唤起，用完以后又立即忘记；否认客观现实的存在，同时又顾及被否认的事实——所有这些都必不可少。”\" class=\"headerlink\" title=\"　　“双重思想是英社的核心，因为党的主要行为就是故意欺骗，同时保持目标明确，毫不动摇，貌像完全诚实。故意撒谎又真诚地相信谎言；忘记不利的事实，必要的时候将它从遗忘中唤起，用完以后又立即忘记；否认客观现实的存在，同时又顾及被否认的事实——所有这些都必不可少。”\"></a>　　“双重思想是英社的核心，因为党的主要行为就是故意欺骗，同时保持目标明确，毫不动摇，貌像完全诚实。故意撒谎又真诚地相信谎言；忘记不利的事实，必要的时候将它从遗忘中唤起，用完以后又立即忘记；否认客观现实的存在，同时又顾及被否认的事实——所有这些都必不可少。”</h3><h3 id=\"“只是一个无望的幻想，像一个转瞬即逝的四月天，可一个眼神、一句话语却唤起了我的梦想，我的心便从此不见！”\"><a href=\"#“只是一个无望的幻想，像一个转瞬即逝的四月天，可一个眼神、一句话语却唤起了我的梦想，我的心便从此不见！”\" class=\"headerlink\" title=\"　　“只是一个无望的幻想，像一个转瞬即逝的四月天，可一个眼神、一句话语却唤起了我的梦想，我的心便从此不见！”\"></a>　　“只是一个无望的幻想，像一个转瞬即逝的四月天，可一个眼神、一句话语却唤起了我的梦想，我的心便从此不见！”</h3>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"内容简介\"><a href=\"#内容简介\" class=\"headerlink\" title=\"内容简介\"></a>内容简介</h2><h5 id=\"《1984》是一部杰出的政治寓言小说，也是一部幻想小说。作品刻画了人类在极权主义社会的生存状态，仿佛一个永不退色的警世标签，警醒世人提防这种预想中的黑暗成为现实。历经几十年，其生命力日益强大，被誉为20世纪影响最为深远的文学经典之一。\"><a href=\"#《1984》是一部杰出的政治寓言小说，也是一部幻想小说。作品刻画了人类在极权主义社会的生存状态，仿佛一个永不退色的警世标签，警醒世人提防这种预想中的黑暗成为现实。历经几十年，其生命力日益强大，被誉为20世纪影响最为深远的文学经典之一。\" class=\"headerlink\" title=\"　　《1984》是一部杰出的政治寓言小说，也是一部幻想小说。作品刻画了人类在极权主义社会的生存状态，仿佛一个永不退色的警世标签，警醒世人提防这种预想中的黑暗成为现实。历经几十年，其生命力日益强大，被誉为20世纪影响最为深远的文学经典之一。\"></a>　　《1984》是一部杰出的政治寓言小说，也是一部幻想小说。作品刻画了人类在极权主义社会的生存状态，仿佛一个永不退色的警世标签，警醒世人提防这种预想中的黑暗成为现实。历经几十年，其生命力日益强大，被誉为20世纪影响最为深远的文学经典之一。</h5><h2 id=\"笔记\"><a href=\"#笔记\" class=\"headerlink\" title=\"笔记\"></a>笔记</h2><h3 id=\"“战争就是和平-自由就是奴役-无知就是力量”\"><a href=\"#“战争就是和平-自由就是奴役-无知就是力量”\" class=\"headerlink\" title=\"　　“战争就是和平 自由就是奴役 无知就是力量”\"></a>　　“战争就是和平 自由就是奴役 无知就是力量”</h3><h3 id=\"“那个黑发姑娘穿过田野向他走来。她好像一下子就脱光了衣服，不屑地扔到一边。她的身体白皙光滑，却没有引起他的任何欲望，事实上，他几乎没怎么看她。此刻，他满心只是赞叹着她扔衣服的动作。那种优雅随意的态度似乎能摧毁整个文化、整个思想体系，这绝妙的一挥手似乎能把老大哥、党和思想警察一扫而光。这也是一个属于古老的时代的动作。温斯顿醒来时嘴上还念着“莎士比亚”这个词。”\"><a href=\"#“那个黑发姑娘穿过田野向他走来。她好像一下子就脱光了衣服，不屑地扔到一边。她的身体白皙光滑，却没有引起他的任何欲望，事实上，他几乎没怎么看她。此刻，他满心只是赞叹着她扔衣服的动作。那种优雅随意的态度似乎能摧毁整个文化、整个思想体系，这绝妙的一挥手似乎能把老大哥、党和思想警察一扫而光。这也是一个属于古老的时代的动作。温斯顿醒来时嘴上还念着“莎士比亚”这个词。”\" class=\"headerlink\" title=\"　　“那个黑发姑娘穿过田野向他走来。她好像一下子就脱光了衣服，不屑地扔到一边。她的身体白皙光滑，却没有引起他的任何欲望，事实上，他几乎没怎么看她。此刻，他满心只是赞叹着她扔衣服的动作。那种优雅随意的态度似乎能摧毁整个文化、整个思想体系，这绝妙的一挥手似乎能把老大哥、党和思想警察一扫而光。这也是一个属于古老的时代的动作。温斯顿醒来时嘴上还念着“莎士比亚”这个词。”\"></a>　　“那个黑发姑娘穿过田野向他走来。她好像一下子就脱光了衣服，不屑地扔到一边。她的身体白皙光滑，却没有引起他的任何欲望，事实上，他几乎没怎么看她。此刻，他满心只是赞叹着她扔衣服的动作。那种优雅随意的态度似乎能摧毁整个文化、整个思想体系，这绝妙的一挥手似乎能把老大哥、党和思想警察一扫而光。这也是一个属于古老的时代的动作。温斯顿醒来时嘴上还念着“莎士比亚”这个词。”</h3><h3 id=\"“控制过去就能控制未来，控制现在就能控制过去”\"><a href=\"#“控制过去就能控制未来，控制现在就能控制过去”\" class=\"headerlink\" title=\"　　“控制过去就能控制未来，控制现在就能控制过去”\"></a>　　“控制过去就能控制未来，控制现在就能控制过去”</h3><h3 id=\"“眼前的真理就是永远的真理。很简单。所需的只是不断战胜自己的记忆而已。他们称它为“现实控制”，用新话说就是“双重思想”。”\"><a href=\"#“眼前的真理就是永远的真理。很简单。所需的只是不断战胜自己的记忆而已。他们称它为“现实控制”，用新话说就是“双重思想”。”\" class=\"headerlink\" title=\"　　“眼前的真理就是永远的真理。很简单。所需的只是不断战胜自己的记忆而已。他们称它为“现实控制”，用新话说就是“双重思想”。”\"></a>　　“眼前的真理就是永远的真理。很简单。所需的只是不断战胜自己的记忆而已。他们称它为“现实控制”，用新话说就是“双重思想”。”</h3><h3 id=\"“用逻辑否定逻辑，既否认道德又维护道德，既相信民主的不可能又相信党是民主的卫士；”\"><a href=\"#“用逻辑否定逻辑，既否认道德又维护道德，既相信民主的不可能又相信党是民主的卫士；”\" class=\"headerlink\" title=\"　　“用逻辑否定逻辑，既否认道德又维护道德，既相信民主的不可能又相信党是民主的卫士；”\"></a>　　“用逻辑否定逻辑，既否认道德又维护道德，既相信民主的不可能又相信党是民主的卫士；”</h3><h3 id=\"““我讨厌纯洁，我讨厌善良！我讨厌任何美德的存在。我要让每个人都坏到骨子里去。””\"><a href=\"#““我讨厌纯洁，我讨厌善良！我讨厌任何美德的存在。我要让每个人都坏到骨子里去。””\" class=\"headerlink\" title=\"　　““我讨厌纯洁，我讨厌善良！我讨厌任何美德的存在。我要让每个人都坏到骨子里去。””\"></a>　　““我讨厌纯洁，我讨厌善良！我讨厌任何美德的存在。我要让每个人都坏到骨子里去。””</h3><h3 id=\"“如果你遵守小的规定就可以违反大的规定。”\"><a href=\"#“如果你遵守小的规定就可以违反大的规定。”\" class=\"headerlink\" title=\"　　“如果你遵守小的规定就可以违反大的规定。”\"></a>　　“如果你遵守小的规定就可以违反大的规定。”</h3><h3 id=\"“下等人的永久特征就是被劳役所压垮，以至于只能断断续续地认识到他们日常生活以外的东西——就是消除一切差别，建立一个人人平等的社会”\"><a href=\"#“下等人的永久特征就是被劳役所压垮，以至于只能断断续续地认识到他们日常生活以外的东西——就是消除一切差别，建立一个人人平等的社会”\" class=\"headerlink\" title=\"　　“下等人的永久特征就是被劳役所压垮，以至于只能断断续续地认识到他们日常生活以外的东西——就是消除一切差别，建立一个人人平等的社会”\"></a>　　“下等人的永久特征就是被劳役所压垮，以至于只能断断续续地认识到他们日常生活以外的东西——就是消除一切差别，建立一个人人平等的社会”</h3><h3 id=\"“双重思想是英社的核心，因为党的主要行为就是故意欺骗，同时保持目标明确，毫不动摇，貌像完全诚实。故意撒谎又真诚地相信谎言；忘记不利的事实，必要的时候将它从遗忘中唤起，用完以后又立即忘记；否认客观现实的存在，同时又顾及被否认的事实——所有这些都必不可少。”\"><a href=\"#“双重思想是英社的核心，因为党的主要行为就是故意欺骗，同时保持目标明确，毫不动摇，貌像完全诚实。故意撒谎又真诚地相信谎言；忘记不利的事实，必要的时候将它从遗忘中唤起，用完以后又立即忘记；否认客观现实的存在，同时又顾及被否认的事实——所有这些都必不可少。”\" class=\"headerlink\" title=\"　　“双重思想是英社的核心，因为党的主要行为就是故意欺骗，同时保持目标明确，毫不动摇，貌像完全诚实。故意撒谎又真诚地相信谎言；忘记不利的事实，必要的时候将它从遗忘中唤起，用完以后又立即忘记；否认客观现实的存在，同时又顾及被否认的事实——所有这些都必不可少。”\"></a>　　“双重思想是英社的核心，因为党的主要行为就是故意欺骗，同时保持目标明确，毫不动摇，貌像完全诚实。故意撒谎又真诚地相信谎言；忘记不利的事实，必要的时候将它从遗忘中唤起，用完以后又立即忘记；否认客观现实的存在，同时又顾及被否认的事实——所有这些都必不可少。”</h3><h3 id=\"“只是一个无望的幻想，像一个转瞬即逝的四月天，可一个眼神、一句话语却唤起了我的梦想，我的心便从此不见！”\"><a href=\"#“只是一个无望的幻想，像一个转瞬即逝的四月天，可一个眼神、一句话语却唤起了我的梦想，我的心便从此不见！”\" class=\"headerlink\" title=\"　　“只是一个无望的幻想，像一个转瞬即逝的四月天，可一个眼神、一句话语却唤起了我的梦想，我的心便从此不见！”\"></a>　　“只是一个无望的幻想，像一个转瞬即逝的四月天，可一个眼神、一句话语却唤起了我的梦想，我的心便从此不见！”</h3>"},{"layout":"book","title":"解忧杂货铺","date":"2016-12-14T16:00:00.000Z","cover":"varietyShop.jpeg","_content":"","source":"_posts/read/GriefGroceryStore.md","raw":"---\nlayout: book\ntitle: 解忧杂货铺\ndate: 2016/12/15\ncover: varietyShop.jpeg\ncategories: [read]\n---\n","slug":"read/GriefGroceryStore","published":1,"updated":"2017-08-15T11:31:46.000Z","comments":1,"photos":[],"link":"","_id":"cj8jros7e000p30s6bpxnq8ce","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"post","title":"zookeeper原理","date":"2016-11-30T16:00:00.000Z","_content":"\n##### ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，它包含一个简单的原语集，分布式应用程序可以基于它实现同步服务，配置维护和命名服务等。Zookeeper是hadoop的一个子项目，其发展历程无需赘述。在分布式应用中，由于工程师不能很好地使用锁机制，以及基于消息的协调机制不适合在某些应用中使用，因此需要有一种可靠的、可扩展的、分布式的、可配置的协调机制来统一系统的状态。Zookeeper的目的就在于此。本文简单分析zookeeper的工作原理，对于如何使用zookeeper不是本文讨论的重点。\n<!--more-->\n## 1 Zookeeper的基本概念\n### 1.1 角色\n\n##### Zookeeper中的角色主要有以下三类，如下表所示：\n![zookeeper角色](../../img/zookeeper/role.jpg)\n\n##### 系统模型如图所示：\n![zookeeper系统模型](../../img/zookeeper/zookeeperModel.jpg)\n\n\n### 1.2 设计目的\n\n1. 最终一致性：client不论连接到哪个Server，展示给它都是同一个视图，这是zookeeper最重要的性能。\n2. 可靠性：具有简单、健壮、良好的性能，如果消息m被到一台服务器接受，那么它将被所有的服务器接受。\n3. 实时性：Zookeeper保证客户端将在一个时间间隔范围内获得服务器的更新信息，或者服务器失效的信息。但由于网络延时等原因，Zookeeper不能保证两个客户端能同时得到刚更新的数据，如果需要最新数据，应该在读数据之前调用sync()接口。\n4. 等待无关（wait-free）：慢的或者失效的client不得干预快速的client的请求，使得每个client都能有效的等待。\n5. 原子性：更新只能成功或者失败，没有中间状态。\n6. 顺序性：包括全局有序和偏序两种：全局有序是指如果在一台服务器上消息a在消息b前发布，则在所有Server上消息a都将在消息b前被发布；偏序是指如果一个消息b在消息a后被同一个发送者发布，a必将排在b前面。\n\n## 2 ZooKeeper的工作原理\n##### Zookeeper的核心是原子广播，这个机制保证了各个Server之间的同步。实现这个机制的协议叫做Zab协议。Zab协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数Server完成了和leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和Server具有相同的系统状态。\n##### 为了保证事务的顺序一致性，zookeeper采用了递增的事务id号（zxid）来标识事务。所有的提议（proposal）都在被提出的时候加上了zxid。实现中zxid是一个64位的数字，它高32位是epoch用来标识leader关系是否改变，每次一个leader被选出来，它都会有一个新的epoch，标识当前属于那个leader的统治时期。低32位用于递增计数。\n##### 每个Server在工作过程中有三种状态：\n* LOOKING：当前Server不知道leader是谁，正在搜寻\n* LEADING：当前Server即为选举出来的leader\n* FOLLOWING：leader已经选举出来，当前Server与之同步\n\n### 2.1 选主流程\n\n##### 当leader崩溃或者leader失去大多数的follower，这时候zk进入恢复模式，恢复模式需要重新选举出一个新的leader，让所有的Server都恢复到一个正确的状态。Zk的选举算法有两种：一种是基于basic paxos实现的，另外一种是基于fast paxos算法实现的。系统默认的选举算法为fast paxos。先介绍basic paxos流程：\n1. 选举线程由当前Server发起选举的线程担任，其主要功能是对投票结果进行统计，并选出推荐的Server；\n2. 选举线程首先向所有Server发起一次询问(包括自己)；\n3. 选举线程收到回复后，验证是否是自己发起的询问(验证zxid是否一致)，然后获取对方的id(myid)，并存储到当前询问对象列表中，最后获取对方提议的leader相关信息(id,zxid)，并将这些信息存储到当次选举的投票记录表中；\n4. 收到所有Server回复以后，就计算出zxid最大的那个Server，并将这个Server相关信息设置成下一次要投票的Server；\n5. 线程将当前zxid最大的Server设置为当前Server要推荐的Leader，如果此时获胜的Server获得n/2 + 1的Server票数， 设置当前推荐的leader为获胜的Server，将根据获胜的Server相关信息设置自己的状态，否则，继续这个过程，直到leader被选举出来。\n\n##### 通过流程分析我们可以得出：要使Leader获得多数Server的支持，则Server总数必须是奇数2n+1，且存活的Server的数目不得少于n+1.\n##### 每个Server启动后都会重复以上流程。在恢复模式下，如果是刚从崩溃状态恢复的或者刚启动的server还会从磁盘快照中恢复数据和会话信息，zk会记录事务日志并定期进行快照，方便在恢复时进行状态恢复。选主的具体流程图如下所示：\n![zookeeper流程图](../../img/zookeeper/zookeeperLc.jpg)\n\n##### fast paxos流程是在选举过程中，某Server首先向所有Server提议自己要成为leader，当其它Server收到提议以后，解决epoch和zxid的冲突，并接受对方的提议，然后向对方发送接受提议完成的消息，重复这个流程，最后一定能选举出Leader。其流程图如下所示：\n![zookeeper流程图](../../img/zookeeper/zookeeperLc2.jpg)\n\n### 2.2 同步流程\n##### 选完leader以后，zk就进入状态同步过程。\n1. leader等待server连接；\n2. Follower连接leader，将最大的zxid发送给leader；\n3. Leader根据follower的zxid确定同步点；\n4. 完成同步后通知follower 已经成为uptodate状态；\n5. Follower收到uptodate消息后，又可以重新接受client的请求进行服务了。\n\n##### 流程图如下所示：\n![zookeeper流程图](../../img/zookeeper/zookeeperLc3.jpg)\n\n### 2.3 工作流程\n#### 2.3.1 Leader工作流程\n##### Leader主要有三个功能：\n1. 恢复数据；\n2. 维持与Learner的心跳，接收Learner请求并判断Learner的请求消息类型；\n3. Learner的消息类型主要有PING消息、REQUEST消息、ACK消息、REVALIDATE消息，根据不同的消息类型，进行不同的处理。\n\n##### PING消息是指Learner的心跳信息；REQUEST消息是Follower发送的提议信息，包括写请求及同步请求；ACK消息是Follower的对提议的回复，超过半数的Follower通过，则commit该提议；REVALIDATE消息是用来延长SESSION有效时间。\n##### Leader的工作流程简图如下所示，在实际实现中，流程要比下图复杂得多，启动了三个线程来实现功能。\n![zookeeper流程图](../../img/zookeeper/zookeeperLc4.jpg)\n\n#### 2.3.2 Follower工作流程\n##### Follower主要有四个功能：\n1. 向Leader发送请求（PING消息、REQUEST消息、ACK消息、REVALIDATE消息）；\n2. 接收Leader消息并进行处理；\n3. 接收Client的请求，如果为写请求，发送给Leader进行投票；\n4. 返回Client结果。\n\n##### Follower的消息循环处理如下几种来自Leader的消息：\n1. PING消息： 心跳消息；\n2. PROPOSAL消息：Leader发起的提案，要求Follower投票；\n3. COMMIT消息：服务器端最新一次提案的信息；\n4. UPTODATE消息：表明同步完成；\n5. REVALIDATE消息：根据Leader的REVALIDATE结果，关闭待revalidate的session还是允许其接受消息；\n6. SYNC消息：返回SYNC结果到客户端，这个消息最初由客户端发起，用来强制得到最新的更新。\n\n##### Follower的工作流程简图如下所示，在实际实现中，Follower是通过5个线程来实现功能的。\n![zookeeper流程图](../../img/zookeeper/zookeeperLc5.jpg)\n\n##### 对于observer的流程不再叙述，observer流程和Follower的唯一不同的地方就是observer不会参加leader发起的投票。\n##### 主流应用场景：\n##### __Zookeeper的主流应用场景实现思路（除去官方示例）__ \n\n#### (1)配置管理\n##### 集中式的配置管理在应用集群中是非常常见的，一般商业公司内部都会实现一套集中的配置管理中心，应对不同的应用集群对于共享各自配置的需求，并且在配置变更时能够通知到集群中的每一个机器。\n##### Zookeeper很容易实现这种集中式的配置管理，比如将APP1的所有配置配置到/APP1 znode下，APP1所有机器一启动就对/APP1这个节点进行监控(zk.exist(\"/APP1\",true)),并且实现回调方法Watcher，那么在zookeeper上/APP1 znode节点下数据发生变化的时候，每个机器都会收到通知，Watcher方法将会被执行，那么应用再取下数据即可(zk.getData(\"/APP1\",false,null));\n##### 以上这个例子只是简单的粗颗粒度配置监控，细颗粒度的数据可以进行分层级监控，这一切都是可以设计和控制的。     \n![zookeeper流程图](../../img/zookeeper/zookeeper1.jpg)\n\n#### (2)集群管理 \n##### 应用集群中，我们常常需要让每一个机器知道集群中（或依赖的其他某一个集群）哪些机器是活着的，并且在集群机器因为宕机，网络断链等原因能够不在人工介入的情况下迅速通知到每一个机器。\n##### Zookeeper同样很容易实现这个功能，比如我在zookeeper服务器端有一个znode叫/APP1SERVERS,那么集群中每一个机器启动的时候都去这个节点下创建一个EPHEMERAL类型的节点，比如server1创建/APP1SERVERS/SERVER1(可以使用ip,保证不重复)，server2创建/APP1SERVERS/SERVER2，然后SERVER1和SERVER2都watch /APP1SERVERS这个父节点，那么也就是这个父节点下数据或者子节点变化都会通知对该节点进行watch的客户端。因为EPHEMERAL类型节点有一个很重要的特性，就是客户端和服务器端连接断掉或者session过期就会使节点消失，那么在某一个机器挂掉或者断链的时候，其对应的节点就会消失，然后集群中所有对/APP1SERVERS进行watch的客户端都会收到通知，然后取得最新列表即可。\n##### 另外有一个应用场景就是集群选master,一旦master挂掉能够马上能从slave中选出一个master,实现步骤和前者一样，只是机器在启动的时候在APP1SERVERS创建的节点类型变为EPHEMERAL_SEQUENTIAL类型，这样每个节点会自动被编号\n##### 我们默认规定编号最小的为master,所以当我们对/APP1SERVERS节点做监控的时候，得到服务器列表，只要所有集群机器逻辑认为最小编号节点为master，那么master就被选出，而这个master宕机的时候，相应的znode会消失，然后新的服务器列表就被推送到客户端，然后每个节点逻辑认为最小编号节点为master，这样就做到动态master选举。\n![zookeeper流程图](../../img/zookeeper/zookeeper2.jpg)\n\n#### Zookeeper 监视（Watches） 简介\n##### Zookeeper C API 的声明和描述在 include/zookeeper.h 中可以找到，另外大部分的 Zookeeper C API 常量、结构体声明也在 zookeeper.h 中，如果如果你在使用 C API 是遇到不明白的地方，最好看看 zookeeper.h，或者自己使用 doxygen 生成 Zookeeper C API 的帮助文档。\n##### Zookeeper 中最有特色且最不容易理解的是监视(Watches)。Zookeeper 所有的读操作——getData(), getChildren(), 和 exists() 都 可以设置监视(watch)，监视事件可以理解为一次性的触发器， 官方定义如下： a watch event is one-time trigger, sent to the client that set the watch, which occurs when the data for which the watch was set changes。对此需要作出如下理解：\n* （一次性触发）One-time trigger\n\n##### 当设置监视的数据发生改变时，该监视事件会被发送到客户端，例如，如果客户端调用了 getData(\"/znode1\", true) 并且稍后 /znode1 节点上的数据发生了改变或者被删除了，客户端将会获取到 /znode1 发生变化的监视事件，而如果 /znode1 再一次发生了变化，除非客户端再次对 /znode1 设置监视，否则客户端不会收到事件通知。\n* （发送至客户端）Sent to the client\n\n##### Zookeeper 客户端和服务端是通过 socket 进行通信的，由于网络存在故障，所以监视事件很有可能不会成功地到达客户端，监视事件是异步发送至监视者的，Zookeeper 本身提供了保序性(ordering guarantee)：即客户端只有首先看到了监视事件后，才会感知到它所设置监视的 znode 发生了变化(a client will never see a change for which it has set a watch until it first sees the watch event). 网络延迟或者其他因素可能导致不同的客户端在不同的时刻感知某一监视事件，但是不同的客户端所看到的一切具有一致的顺序。\n* （被设置 watch 的数据）The data for which the watch was set\n\n##### 这意味着 znode 节点本身具有不同的改变方式。你也可以想象 Zookeeper 维护了两条监视链表：数据监视和子节点监视(data watches and child watches) getData() and exists() 设置数据监视，getChildren() 设置子节点监视。 或者，你也可以想象 Zookeeper 设置的不同监视返回不同的数据，getData() 和 exists() 返回 znode 节点的相关信息，而 getChildren() 返回子节点列表。因此， setData() 会触发设置在某一节点上所设置的数据监视(假定数据设置成功)，而一次成功的 create() 操作则会出发当前节点上所设置的数据监视以及父节点的子节点监视。一次成功的 delete() 操作将会触发当前节点的数据监视和子节点监视事件，同时也会触发该节点父节点的child watch。\n##### Zookeeper 中的监视是轻量级的，因此容易设置、维护和分发。当客户端与 Zookeeper 服务器端失去联系时，客户端并不会收到监视事件的通知，只有当客户端重新连接后，若在必要的情况下，以前注册的监视会重新被注册并触发，对于开发人员来说 这通常是透明的。只有一种情况会导致监视事件的丢失，即：通过 exists() 设置了某个 znode 节点的监视，但是如果某个客户端在此 znode 节点被创建和删除的时间间隔内与 zookeeper 服务器失去了联系，该客户端即使稍后重新连接 zookeeper服务器后也得不到事件通知。\n\n### Zookeeper C API 常量与部分结构(struct)介绍\n\n#### 与 ACL 相关的结构与常量：\n##### struct Id 结构为：\n```\nstruct Id {     char * scheme;     char * id; };\n```\n##### struct ACL 结构为：\n```\nstruct ACL {     int32_t perms;     struct Id id; };\n```\n##### struct ACL_vector 结构为：\n```\nstruct ACL_vector {     int32_t count;     struct ACL *data; };\n```\n##### 与 znode 访问权限有关的常量\n* const int ZOO_PERM_READ; //允许客户端读取 znode 节点的值以及子节点列表。\n* const int ZOO_PERM_WRITE;// 允许客户端设置 znode 节点的值。\n* const int ZOO_PERM_CREATE; //允许客户端在该 znode 节点下创建子节点。\n* const int ZOO_PERM_DELETE;//允许客户端删除子节点。\n* const int ZOO_PERM_ADMIN; //允许客户端执行 set_acl()。\n* const int ZOO_PERM_ALL;//允许客户端执行所有操作，等价与上述所有标志的或(OR) 。\n\n##### 与 ACL IDs 相关的常量\n* struct Id ZOO_ANYONE_ID_UNSAFE; //(‘world’,’anyone’)\n* struct Id ZOO_AUTH_IDS;// (‘auth’,’’)\n\n##### 三种标准的 ACL\n* struct ACL_vector ZOO_OPEN_ACL_UNSAFE; //(ZOO_PERM_ALL,ZOO_ANYONE_ID_UNSAFE)\n* struct ACL_vector ZOO_READ_ACL_UNSAFE;// (ZOO_PERM_READ, ZOO_ANYONE_ID_UNSAFE)\n* struct ACL_vector ZOO_CREATOR_ALL_ACL; //(ZOO_PERM_ALL,ZOO_AUTH_IDS)\n\n#### 与 Interest 相关的常量：ZOOKEEPER_WRITE, ZOOKEEPER_READ\n##### 这两个常量用于标识感兴趣的事件并通知zookeeper发生了哪些事件。Interest 常量可以进行组合或（OR）来标识多种兴趣(multiple interests: write, read)，这两个常量一般用于 zookeeper_interest() 和 zookeeper_process()两个函数中。\n\n#### 与节点创建相关的常量：ZOO_EPHEMERAL, ZOO_SEQUENCE\n##### zoo_create 函数标志，ZOO_EPHEMERAL 用来标识创建临时节点，ZOO_SEQUENCE 用来标识节点命名具有递增的后缀序号(一般是节点名称后填充 10 位字符的序号，如 /xyz0000000000, /xyz0000000001, /xyz0000000002, ...)，同样地，ZOO_EPHEMERAL, ZOO_SEQUENCE 可以组合。\n\n#### 与连接状态 Stat 相关的常量\n\n##### 以下常量均与 Zookeeper 连接状态有关，他们通常用作监视器回调函数的参数。\n\n| ZOOAPI const int | ZOO_EXPIRED_SESSION_STATE |\n|:-----------------|:--------------------------|\n| ZOOAPI const int |     ZOO_AUTH_FAILED_STATE |\n| ZOOAPI const int |      ZOO_CONNECTING_STATE |\n| ZOOAPI const int |     ZOO_ASSOCIATING_STATE |\n| ZOOAPI const int |       ZOO_CONNECTED_STATE |\n\n#### 与监视类型(Watch Types)相关的常量\n\n##### 以下常量标识监视事件的类型，他们通常用作监视器回调函数的第一个参数。\n* ZOO_CREATED_EVENT; // 节点被创建(此前该节点不存在)，通过 zoo_exists() 设置监视。\n* ZOO_DELETED_EVENT; // 节点被删除，通过 zoo_exists() 和 zoo_get() 设置监视。\n* ZOO_CHANGED_EVENT; // 节点发生变化，通过 zoo_exists() 和 zoo_get() 设置监视。\n* ZOO_CHILD_EVENT; // 子节点事件，通过zoo_get_children() 和 zoo_get_children2()设置监视。\n* ZOO_SESSION_EVENT; // 会话丢失\n* ZOO_NOTWATCHING_EVENT; // 监视被移除。\n\n#### Zookeeper C API 错误码介绍 ZOO_ERRORS\n\nZOK | 正常返回\n----|--------\nZSYSTEMERROR | 系统或服务器端错误(System and server-side errors)，服务器不会抛出该错误，该错误也只是用来标识错误范围的，即大于该错误值，且小于 ZAPIERROR 都是系统错误。\nZRUNTIMEINCONSISTENCY | 运行时非一致性错误。\nZDATAINCONSISTENCY | 数据非一致性错误。\nZCONNECTIONLOSS | Zookeeper 客户端与服务器端失去连接\nZMARSHALLINGERROR | 在 marshalling 和 unmarshalling 数据时出现错误(Error while marshalling or unmarshalling data)\nZUNIMPLEMENTED | 该操作未实现(Operation is unimplemented)\nZOPERATIONTIMEOUT | 该操作超时(Operation timeout)\nZBADARGUMENTS | 非法参数错误(Invalid arguments)\nZINVALIDSTATE | 非法句柄状态(Invliad zhandle state)\nZAPIERROR | API 错误(API errors)，服务器不会抛出该错误，该错误也只是用来标识错误范围的，错误值大于该值的标识 API 错误，而小于该值的标识 ZSYSTEMERROR。\nZNONODE | 节点不存在(Node does not exist)\nZNOAUTH | 没有经过授权(Not authenticated)\nZBADVERSION | 版本冲突(Version conflict)\nZNOCHILDRENFOREPHEMERALS | 临时节点不能拥有子节点(Ephemeral nodes may not have children)\nZNODEEXISTS | 节点已经存在(The node already exists)\nZNOTEMPTY | 该节点具有自身的子节点(The node has children)\nZSESSIONEXPIRED | 会话过期(The session has been expired by the server)\nZINVALIDCALLBACK | 非法的回调函数(Invalid callback specified)\nZINVALIDACL | 非法的ACL(Invalid ACL specified)\nZAUTHFAILED | 客户端授权失败(Client authentication failed)\nZCLOSING | Zookeeper 连接关闭(ZooKeeper is closing)\nZNOTHING | 并非错误，客户端不需要处理服务器的响应(not error, no server responses to process)\nZSESSIONMOVED | 会话转移至其他服务器，所以操作被忽略(session moved to another server, so operation is ignored) \n\n##### Watch事件类型：\n* ZOO_CREATED_EVENT：节点创建事件，需要watch一个不存在的节点，当节点被创建时触发，此watch通过zoo_exists()设置\n* ZOO_DELETED_EVENT：节点删除事件，此watch通过zoo_exists()或zoo_get()设置\n* ZOO_CHANGED_EVENT：节点数据改变事件，此watch通过zoo_exists()或zoo_get()设置\n* ZOO_CHILD_EVENT：子节点列表改变事件，此watch通过zoo_get_children()或zoo_get_children2()设置\n* ZOO_SESSION_EVENT：会话失效事件，客户端与服务端断开或重连时触发\n* ZOO_NOTWATCHING_EVENT：watch移除事件，服务端出于某些原因不再为客户端watch节点时触发","source":"_posts/note/zookeeper.md","raw":"---\nlayout: post\ntitle: zookeeper原理\ndate: 2016/12/01\ntags: [tech, note, index]\n---\n\n##### ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，它包含一个简单的原语集，分布式应用程序可以基于它实现同步服务，配置维护和命名服务等。Zookeeper是hadoop的一个子项目，其发展历程无需赘述。在分布式应用中，由于工程师不能很好地使用锁机制，以及基于消息的协调机制不适合在某些应用中使用，因此需要有一种可靠的、可扩展的、分布式的、可配置的协调机制来统一系统的状态。Zookeeper的目的就在于此。本文简单分析zookeeper的工作原理，对于如何使用zookeeper不是本文讨论的重点。\n<!--more-->\n## 1 Zookeeper的基本概念\n### 1.1 角色\n\n##### Zookeeper中的角色主要有以下三类，如下表所示：\n![zookeeper角色](../../img/zookeeper/role.jpg)\n\n##### 系统模型如图所示：\n![zookeeper系统模型](../../img/zookeeper/zookeeperModel.jpg)\n\n\n### 1.2 设计目的\n\n1. 最终一致性：client不论连接到哪个Server，展示给它都是同一个视图，这是zookeeper最重要的性能。\n2. 可靠性：具有简单、健壮、良好的性能，如果消息m被到一台服务器接受，那么它将被所有的服务器接受。\n3. 实时性：Zookeeper保证客户端将在一个时间间隔范围内获得服务器的更新信息，或者服务器失效的信息。但由于网络延时等原因，Zookeeper不能保证两个客户端能同时得到刚更新的数据，如果需要最新数据，应该在读数据之前调用sync()接口。\n4. 等待无关（wait-free）：慢的或者失效的client不得干预快速的client的请求，使得每个client都能有效的等待。\n5. 原子性：更新只能成功或者失败，没有中间状态。\n6. 顺序性：包括全局有序和偏序两种：全局有序是指如果在一台服务器上消息a在消息b前发布，则在所有Server上消息a都将在消息b前被发布；偏序是指如果一个消息b在消息a后被同一个发送者发布，a必将排在b前面。\n\n## 2 ZooKeeper的工作原理\n##### Zookeeper的核心是原子广播，这个机制保证了各个Server之间的同步。实现这个机制的协议叫做Zab协议。Zab协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数Server完成了和leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和Server具有相同的系统状态。\n##### 为了保证事务的顺序一致性，zookeeper采用了递增的事务id号（zxid）来标识事务。所有的提议（proposal）都在被提出的时候加上了zxid。实现中zxid是一个64位的数字，它高32位是epoch用来标识leader关系是否改变，每次一个leader被选出来，它都会有一个新的epoch，标识当前属于那个leader的统治时期。低32位用于递增计数。\n##### 每个Server在工作过程中有三种状态：\n* LOOKING：当前Server不知道leader是谁，正在搜寻\n* LEADING：当前Server即为选举出来的leader\n* FOLLOWING：leader已经选举出来，当前Server与之同步\n\n### 2.1 选主流程\n\n##### 当leader崩溃或者leader失去大多数的follower，这时候zk进入恢复模式，恢复模式需要重新选举出一个新的leader，让所有的Server都恢复到一个正确的状态。Zk的选举算法有两种：一种是基于basic paxos实现的，另外一种是基于fast paxos算法实现的。系统默认的选举算法为fast paxos。先介绍basic paxos流程：\n1. 选举线程由当前Server发起选举的线程担任，其主要功能是对投票结果进行统计，并选出推荐的Server；\n2. 选举线程首先向所有Server发起一次询问(包括自己)；\n3. 选举线程收到回复后，验证是否是自己发起的询问(验证zxid是否一致)，然后获取对方的id(myid)，并存储到当前询问对象列表中，最后获取对方提议的leader相关信息(id,zxid)，并将这些信息存储到当次选举的投票记录表中；\n4. 收到所有Server回复以后，就计算出zxid最大的那个Server，并将这个Server相关信息设置成下一次要投票的Server；\n5. 线程将当前zxid最大的Server设置为当前Server要推荐的Leader，如果此时获胜的Server获得n/2 + 1的Server票数， 设置当前推荐的leader为获胜的Server，将根据获胜的Server相关信息设置自己的状态，否则，继续这个过程，直到leader被选举出来。\n\n##### 通过流程分析我们可以得出：要使Leader获得多数Server的支持，则Server总数必须是奇数2n+1，且存活的Server的数目不得少于n+1.\n##### 每个Server启动后都会重复以上流程。在恢复模式下，如果是刚从崩溃状态恢复的或者刚启动的server还会从磁盘快照中恢复数据和会话信息，zk会记录事务日志并定期进行快照，方便在恢复时进行状态恢复。选主的具体流程图如下所示：\n![zookeeper流程图](../../img/zookeeper/zookeeperLc.jpg)\n\n##### fast paxos流程是在选举过程中，某Server首先向所有Server提议自己要成为leader，当其它Server收到提议以后，解决epoch和zxid的冲突，并接受对方的提议，然后向对方发送接受提议完成的消息，重复这个流程，最后一定能选举出Leader。其流程图如下所示：\n![zookeeper流程图](../../img/zookeeper/zookeeperLc2.jpg)\n\n### 2.2 同步流程\n##### 选完leader以后，zk就进入状态同步过程。\n1. leader等待server连接；\n2. Follower连接leader，将最大的zxid发送给leader；\n3. Leader根据follower的zxid确定同步点；\n4. 完成同步后通知follower 已经成为uptodate状态；\n5. Follower收到uptodate消息后，又可以重新接受client的请求进行服务了。\n\n##### 流程图如下所示：\n![zookeeper流程图](../../img/zookeeper/zookeeperLc3.jpg)\n\n### 2.3 工作流程\n#### 2.3.1 Leader工作流程\n##### Leader主要有三个功能：\n1. 恢复数据；\n2. 维持与Learner的心跳，接收Learner请求并判断Learner的请求消息类型；\n3. Learner的消息类型主要有PING消息、REQUEST消息、ACK消息、REVALIDATE消息，根据不同的消息类型，进行不同的处理。\n\n##### PING消息是指Learner的心跳信息；REQUEST消息是Follower发送的提议信息，包括写请求及同步请求；ACK消息是Follower的对提议的回复，超过半数的Follower通过，则commit该提议；REVALIDATE消息是用来延长SESSION有效时间。\n##### Leader的工作流程简图如下所示，在实际实现中，流程要比下图复杂得多，启动了三个线程来实现功能。\n![zookeeper流程图](../../img/zookeeper/zookeeperLc4.jpg)\n\n#### 2.3.2 Follower工作流程\n##### Follower主要有四个功能：\n1. 向Leader发送请求（PING消息、REQUEST消息、ACK消息、REVALIDATE消息）；\n2. 接收Leader消息并进行处理；\n3. 接收Client的请求，如果为写请求，发送给Leader进行投票；\n4. 返回Client结果。\n\n##### Follower的消息循环处理如下几种来自Leader的消息：\n1. PING消息： 心跳消息；\n2. PROPOSAL消息：Leader发起的提案，要求Follower投票；\n3. COMMIT消息：服务器端最新一次提案的信息；\n4. UPTODATE消息：表明同步完成；\n5. REVALIDATE消息：根据Leader的REVALIDATE结果，关闭待revalidate的session还是允许其接受消息；\n6. SYNC消息：返回SYNC结果到客户端，这个消息最初由客户端发起，用来强制得到最新的更新。\n\n##### Follower的工作流程简图如下所示，在实际实现中，Follower是通过5个线程来实现功能的。\n![zookeeper流程图](../../img/zookeeper/zookeeperLc5.jpg)\n\n##### 对于observer的流程不再叙述，observer流程和Follower的唯一不同的地方就是observer不会参加leader发起的投票。\n##### 主流应用场景：\n##### __Zookeeper的主流应用场景实现思路（除去官方示例）__ \n\n#### (1)配置管理\n##### 集中式的配置管理在应用集群中是非常常见的，一般商业公司内部都会实现一套集中的配置管理中心，应对不同的应用集群对于共享各自配置的需求，并且在配置变更时能够通知到集群中的每一个机器。\n##### Zookeeper很容易实现这种集中式的配置管理，比如将APP1的所有配置配置到/APP1 znode下，APP1所有机器一启动就对/APP1这个节点进行监控(zk.exist(\"/APP1\",true)),并且实现回调方法Watcher，那么在zookeeper上/APP1 znode节点下数据发生变化的时候，每个机器都会收到通知，Watcher方法将会被执行，那么应用再取下数据即可(zk.getData(\"/APP1\",false,null));\n##### 以上这个例子只是简单的粗颗粒度配置监控，细颗粒度的数据可以进行分层级监控，这一切都是可以设计和控制的。     \n![zookeeper流程图](../../img/zookeeper/zookeeper1.jpg)\n\n#### (2)集群管理 \n##### 应用集群中，我们常常需要让每一个机器知道集群中（或依赖的其他某一个集群）哪些机器是活着的，并且在集群机器因为宕机，网络断链等原因能够不在人工介入的情况下迅速通知到每一个机器。\n##### Zookeeper同样很容易实现这个功能，比如我在zookeeper服务器端有一个znode叫/APP1SERVERS,那么集群中每一个机器启动的时候都去这个节点下创建一个EPHEMERAL类型的节点，比如server1创建/APP1SERVERS/SERVER1(可以使用ip,保证不重复)，server2创建/APP1SERVERS/SERVER2，然后SERVER1和SERVER2都watch /APP1SERVERS这个父节点，那么也就是这个父节点下数据或者子节点变化都会通知对该节点进行watch的客户端。因为EPHEMERAL类型节点有一个很重要的特性，就是客户端和服务器端连接断掉或者session过期就会使节点消失，那么在某一个机器挂掉或者断链的时候，其对应的节点就会消失，然后集群中所有对/APP1SERVERS进行watch的客户端都会收到通知，然后取得最新列表即可。\n##### 另外有一个应用场景就是集群选master,一旦master挂掉能够马上能从slave中选出一个master,实现步骤和前者一样，只是机器在启动的时候在APP1SERVERS创建的节点类型变为EPHEMERAL_SEQUENTIAL类型，这样每个节点会自动被编号\n##### 我们默认规定编号最小的为master,所以当我们对/APP1SERVERS节点做监控的时候，得到服务器列表，只要所有集群机器逻辑认为最小编号节点为master，那么master就被选出，而这个master宕机的时候，相应的znode会消失，然后新的服务器列表就被推送到客户端，然后每个节点逻辑认为最小编号节点为master，这样就做到动态master选举。\n![zookeeper流程图](../../img/zookeeper/zookeeper2.jpg)\n\n#### Zookeeper 监视（Watches） 简介\n##### Zookeeper C API 的声明和描述在 include/zookeeper.h 中可以找到，另外大部分的 Zookeeper C API 常量、结构体声明也在 zookeeper.h 中，如果如果你在使用 C API 是遇到不明白的地方，最好看看 zookeeper.h，或者自己使用 doxygen 生成 Zookeeper C API 的帮助文档。\n##### Zookeeper 中最有特色且最不容易理解的是监视(Watches)。Zookeeper 所有的读操作——getData(), getChildren(), 和 exists() 都 可以设置监视(watch)，监视事件可以理解为一次性的触发器， 官方定义如下： a watch event is one-time trigger, sent to the client that set the watch, which occurs when the data for which the watch was set changes。对此需要作出如下理解：\n* （一次性触发）One-time trigger\n\n##### 当设置监视的数据发生改变时，该监视事件会被发送到客户端，例如，如果客户端调用了 getData(\"/znode1\", true) 并且稍后 /znode1 节点上的数据发生了改变或者被删除了，客户端将会获取到 /znode1 发生变化的监视事件，而如果 /znode1 再一次发生了变化，除非客户端再次对 /znode1 设置监视，否则客户端不会收到事件通知。\n* （发送至客户端）Sent to the client\n\n##### Zookeeper 客户端和服务端是通过 socket 进行通信的，由于网络存在故障，所以监视事件很有可能不会成功地到达客户端，监视事件是异步发送至监视者的，Zookeeper 本身提供了保序性(ordering guarantee)：即客户端只有首先看到了监视事件后，才会感知到它所设置监视的 znode 发生了变化(a client will never see a change for which it has set a watch until it first sees the watch event). 网络延迟或者其他因素可能导致不同的客户端在不同的时刻感知某一监视事件，但是不同的客户端所看到的一切具有一致的顺序。\n* （被设置 watch 的数据）The data for which the watch was set\n\n##### 这意味着 znode 节点本身具有不同的改变方式。你也可以想象 Zookeeper 维护了两条监视链表：数据监视和子节点监视(data watches and child watches) getData() and exists() 设置数据监视，getChildren() 设置子节点监视。 或者，你也可以想象 Zookeeper 设置的不同监视返回不同的数据，getData() 和 exists() 返回 znode 节点的相关信息，而 getChildren() 返回子节点列表。因此， setData() 会触发设置在某一节点上所设置的数据监视(假定数据设置成功)，而一次成功的 create() 操作则会出发当前节点上所设置的数据监视以及父节点的子节点监视。一次成功的 delete() 操作将会触发当前节点的数据监视和子节点监视事件，同时也会触发该节点父节点的child watch。\n##### Zookeeper 中的监视是轻量级的，因此容易设置、维护和分发。当客户端与 Zookeeper 服务器端失去联系时，客户端并不会收到监视事件的通知，只有当客户端重新连接后，若在必要的情况下，以前注册的监视会重新被注册并触发，对于开发人员来说 这通常是透明的。只有一种情况会导致监视事件的丢失，即：通过 exists() 设置了某个 znode 节点的监视，但是如果某个客户端在此 znode 节点被创建和删除的时间间隔内与 zookeeper 服务器失去了联系，该客户端即使稍后重新连接 zookeeper服务器后也得不到事件通知。\n\n### Zookeeper C API 常量与部分结构(struct)介绍\n\n#### 与 ACL 相关的结构与常量：\n##### struct Id 结构为：\n```\nstruct Id {     char * scheme;     char * id; };\n```\n##### struct ACL 结构为：\n```\nstruct ACL {     int32_t perms;     struct Id id; };\n```\n##### struct ACL_vector 结构为：\n```\nstruct ACL_vector {     int32_t count;     struct ACL *data; };\n```\n##### 与 znode 访问权限有关的常量\n* const int ZOO_PERM_READ; //允许客户端读取 znode 节点的值以及子节点列表。\n* const int ZOO_PERM_WRITE;// 允许客户端设置 znode 节点的值。\n* const int ZOO_PERM_CREATE; //允许客户端在该 znode 节点下创建子节点。\n* const int ZOO_PERM_DELETE;//允许客户端删除子节点。\n* const int ZOO_PERM_ADMIN; //允许客户端执行 set_acl()。\n* const int ZOO_PERM_ALL;//允许客户端执行所有操作，等价与上述所有标志的或(OR) 。\n\n##### 与 ACL IDs 相关的常量\n* struct Id ZOO_ANYONE_ID_UNSAFE; //(‘world’,’anyone’)\n* struct Id ZOO_AUTH_IDS;// (‘auth’,’’)\n\n##### 三种标准的 ACL\n* struct ACL_vector ZOO_OPEN_ACL_UNSAFE; //(ZOO_PERM_ALL,ZOO_ANYONE_ID_UNSAFE)\n* struct ACL_vector ZOO_READ_ACL_UNSAFE;// (ZOO_PERM_READ, ZOO_ANYONE_ID_UNSAFE)\n* struct ACL_vector ZOO_CREATOR_ALL_ACL; //(ZOO_PERM_ALL,ZOO_AUTH_IDS)\n\n#### 与 Interest 相关的常量：ZOOKEEPER_WRITE, ZOOKEEPER_READ\n##### 这两个常量用于标识感兴趣的事件并通知zookeeper发生了哪些事件。Interest 常量可以进行组合或（OR）来标识多种兴趣(multiple interests: write, read)，这两个常量一般用于 zookeeper_interest() 和 zookeeper_process()两个函数中。\n\n#### 与节点创建相关的常量：ZOO_EPHEMERAL, ZOO_SEQUENCE\n##### zoo_create 函数标志，ZOO_EPHEMERAL 用来标识创建临时节点，ZOO_SEQUENCE 用来标识节点命名具有递增的后缀序号(一般是节点名称后填充 10 位字符的序号，如 /xyz0000000000, /xyz0000000001, /xyz0000000002, ...)，同样地，ZOO_EPHEMERAL, ZOO_SEQUENCE 可以组合。\n\n#### 与连接状态 Stat 相关的常量\n\n##### 以下常量均与 Zookeeper 连接状态有关，他们通常用作监视器回调函数的参数。\n\n| ZOOAPI const int | ZOO_EXPIRED_SESSION_STATE |\n|:-----------------|:--------------------------|\n| ZOOAPI const int |     ZOO_AUTH_FAILED_STATE |\n| ZOOAPI const int |      ZOO_CONNECTING_STATE |\n| ZOOAPI const int |     ZOO_ASSOCIATING_STATE |\n| ZOOAPI const int |       ZOO_CONNECTED_STATE |\n\n#### 与监视类型(Watch Types)相关的常量\n\n##### 以下常量标识监视事件的类型，他们通常用作监视器回调函数的第一个参数。\n* ZOO_CREATED_EVENT; // 节点被创建(此前该节点不存在)，通过 zoo_exists() 设置监视。\n* ZOO_DELETED_EVENT; // 节点被删除，通过 zoo_exists() 和 zoo_get() 设置监视。\n* ZOO_CHANGED_EVENT; // 节点发生变化，通过 zoo_exists() 和 zoo_get() 设置监视。\n* ZOO_CHILD_EVENT; // 子节点事件，通过zoo_get_children() 和 zoo_get_children2()设置监视。\n* ZOO_SESSION_EVENT; // 会话丢失\n* ZOO_NOTWATCHING_EVENT; // 监视被移除。\n\n#### Zookeeper C API 错误码介绍 ZOO_ERRORS\n\nZOK | 正常返回\n----|--------\nZSYSTEMERROR | 系统或服务器端错误(System and server-side errors)，服务器不会抛出该错误，该错误也只是用来标识错误范围的，即大于该错误值，且小于 ZAPIERROR 都是系统错误。\nZRUNTIMEINCONSISTENCY | 运行时非一致性错误。\nZDATAINCONSISTENCY | 数据非一致性错误。\nZCONNECTIONLOSS | Zookeeper 客户端与服务器端失去连接\nZMARSHALLINGERROR | 在 marshalling 和 unmarshalling 数据时出现错误(Error while marshalling or unmarshalling data)\nZUNIMPLEMENTED | 该操作未实现(Operation is unimplemented)\nZOPERATIONTIMEOUT | 该操作超时(Operation timeout)\nZBADARGUMENTS | 非法参数错误(Invalid arguments)\nZINVALIDSTATE | 非法句柄状态(Invliad zhandle state)\nZAPIERROR | API 错误(API errors)，服务器不会抛出该错误，该错误也只是用来标识错误范围的，错误值大于该值的标识 API 错误，而小于该值的标识 ZSYSTEMERROR。\nZNONODE | 节点不存在(Node does not exist)\nZNOAUTH | 没有经过授权(Not authenticated)\nZBADVERSION | 版本冲突(Version conflict)\nZNOCHILDRENFOREPHEMERALS | 临时节点不能拥有子节点(Ephemeral nodes may not have children)\nZNODEEXISTS | 节点已经存在(The node already exists)\nZNOTEMPTY | 该节点具有自身的子节点(The node has children)\nZSESSIONEXPIRED | 会话过期(The session has been expired by the server)\nZINVALIDCALLBACK | 非法的回调函数(Invalid callback specified)\nZINVALIDACL | 非法的ACL(Invalid ACL specified)\nZAUTHFAILED | 客户端授权失败(Client authentication failed)\nZCLOSING | Zookeeper 连接关闭(ZooKeeper is closing)\nZNOTHING | 并非错误，客户端不需要处理服务器的响应(not error, no server responses to process)\nZSESSIONMOVED | 会话转移至其他服务器，所以操作被忽略(session moved to another server, so operation is ignored) \n\n##### Watch事件类型：\n* ZOO_CREATED_EVENT：节点创建事件，需要watch一个不存在的节点，当节点被创建时触发，此watch通过zoo_exists()设置\n* ZOO_DELETED_EVENT：节点删除事件，此watch通过zoo_exists()或zoo_get()设置\n* ZOO_CHANGED_EVENT：节点数据改变事件，此watch通过zoo_exists()或zoo_get()设置\n* ZOO_CHILD_EVENT：子节点列表改变事件，此watch通过zoo_get_children()或zoo_get_children2()设置\n* ZOO_SESSION_EVENT：会话失效事件，客户端与服务端断开或重连时触发\n* ZOO_NOTWATCHING_EVENT：watch移除事件，服务端出于某些原因不再为客户端watch节点时触发","slug":"note/zookeeper","published":1,"updated":"2017-08-15T11:31:46.000Z","comments":1,"photos":[],"link":"","_id":"cj8jros7j000w30s69pdn7dkh","content":"<h5 id=\"ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，它包含一个简单的原语集，分布式应用程序可以基于它实现同步服务，配置维护和命名服务等。Zookeeper是hadoop的一个子项目，其发展历程无需赘述。在分布式应用中，由于工程师不能很好地使用锁机制，以及基于消息的协调机制不适合在某些应用中使用，因此需要有一种可靠的、可扩展的、分布式的、可配置的协调机制来统一系统的状态。Zookeeper的目的就在于此。本文简单分析zookeeper的工作原理，对于如何使用zookeeper不是本文讨论的重点。\"><a href=\"#ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，它包含一个简单的原语集，分布式应用程序可以基于它实现同步服务，配置维护和命名服务等。Zookeeper是hadoop的一个子项目，其发展历程无需赘述。在分布式应用中，由于工程师不能很好地使用锁机制，以及基于消息的协调机制不适合在某些应用中使用，因此需要有一种可靠的、可扩展的、分布式的、可配置的协调机制来统一系统的状态。Zookeeper的目的就在于此。本文简单分析zookeeper的工作原理，对于如何使用zookeeper不是本文讨论的重点。\" class=\"headerlink\" title=\"ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，它包含一个简单的原语集，分布式应用程序可以基于它实现同步服务，配置维护和命名服务等。Zookeeper是hadoop的一个子项目，其发展历程无需赘述。在分布式应用中，由于工程师不能很好地使用锁机制，以及基于消息的协调机制不适合在某些应用中使用，因此需要有一种可靠的、可扩展的、分布式的、可配置的协调机制来统一系统的状态。Zookeeper的目的就在于此。本文简单分析zookeeper的工作原理，对于如何使用zookeeper不是本文讨论的重点。\"></a>ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，它包含一个简单的原语集，分布式应用程序可以基于它实现同步服务，配置维护和命名服务等。Zookeeper是hadoop的一个子项目，其发展历程无需赘述。在分布式应用中，由于工程师不能很好地使用锁机制，以及基于消息的协调机制不适合在某些应用中使用，因此需要有一种可靠的、可扩展的、分布式的、可配置的协调机制来统一系统的状态。Zookeeper的目的就在于此。本文简单分析zookeeper的工作原理，对于如何使用zookeeper不是本文讨论的重点。</h5><a id=\"more\"></a>\n<h2 id=\"1-Zookeeper的基本概念\"><a href=\"#1-Zookeeper的基本概念\" class=\"headerlink\" title=\"1 Zookeeper的基本概念\"></a>1 Zookeeper的基本概念</h2><h3 id=\"1-1-角色\"><a href=\"#1-1-角色\" class=\"headerlink\" title=\"1.1 角色\"></a>1.1 角色</h3><h5 id=\"Zookeeper中的角色主要有以下三类，如下表所示：\"><a href=\"#Zookeeper中的角色主要有以下三类，如下表所示：\" class=\"headerlink\" title=\"Zookeeper中的角色主要有以下三类，如下表所示：\"></a>Zookeeper中的角色主要有以下三类，如下表所示：</h5><p><img src=\"../../img/zookeeper/role.jpg\" alt=\"zookeeper角色\"></p>\n<h5 id=\"系统模型如图所示：\"><a href=\"#系统模型如图所示：\" class=\"headerlink\" title=\"系统模型如图所示：\"></a>系统模型如图所示：</h5><p><img src=\"../../img/zookeeper/zookeeperModel.jpg\" alt=\"zookeeper系统模型\"></p>\n<h3 id=\"1-2-设计目的\"><a href=\"#1-2-设计目的\" class=\"headerlink\" title=\"1.2 设计目的\"></a>1.2 设计目的</h3><ol>\n<li>最终一致性：client不论连接到哪个Server，展示给它都是同一个视图，这是zookeeper最重要的性能。</li>\n<li>可靠性：具有简单、健壮、良好的性能，如果消息m被到一台服务器接受，那么它将被所有的服务器接受。</li>\n<li>实时性：Zookeeper保证客户端将在一个时间间隔范围内获得服务器的更新信息，或者服务器失效的信息。但由于网络延时等原因，Zookeeper不能保证两个客户端能同时得到刚更新的数据，如果需要最新数据，应该在读数据之前调用sync()接口。</li>\n<li>等待无关（wait-free）：慢的或者失效的client不得干预快速的client的请求，使得每个client都能有效的等待。</li>\n<li>原子性：更新只能成功或者失败，没有中间状态。</li>\n<li>顺序性：包括全局有序和偏序两种：全局有序是指如果在一台服务器上消息a在消息b前发布，则在所有Server上消息a都将在消息b前被发布；偏序是指如果一个消息b在消息a后被同一个发送者发布，a必将排在b前面。</li>\n</ol>\n<h2 id=\"2-ZooKeeper的工作原理\"><a href=\"#2-ZooKeeper的工作原理\" class=\"headerlink\" title=\"2 ZooKeeper的工作原理\"></a>2 ZooKeeper的工作原理</h2><h5 id=\"Zookeeper的核心是原子广播，这个机制保证了各个Server之间的同步。实现这个机制的协议叫做Zab协议。Zab协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数Server完成了和leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和Server具有相同的系统状态。\"><a href=\"#Zookeeper的核心是原子广播，这个机制保证了各个Server之间的同步。实现这个机制的协议叫做Zab协议。Zab协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数Server完成了和leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和Server具有相同的系统状态。\" class=\"headerlink\" title=\"Zookeeper的核心是原子广播，这个机制保证了各个Server之间的同步。实现这个机制的协议叫做Zab协议。Zab协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数Server完成了和leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和Server具有相同的系统状态。\"></a>Zookeeper的核心是原子广播，这个机制保证了各个Server之间的同步。实现这个机制的协议叫做Zab协议。Zab协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数Server完成了和leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和Server具有相同的系统状态。</h5><h5 id=\"为了保证事务的顺序一致性，zookeeper采用了递增的事务id号（zxid）来标识事务。所有的提议（proposal）都在被提出的时候加上了zxid。实现中zxid是一个64位的数字，它高32位是epoch用来标识leader关系是否改变，每次一个leader被选出来，它都会有一个新的epoch，标识当前属于那个leader的统治时期。低32位用于递增计数。\"><a href=\"#为了保证事务的顺序一致性，zookeeper采用了递增的事务id号（zxid）来标识事务。所有的提议（proposal）都在被提出的时候加上了zxid。实现中zxid是一个64位的数字，它高32位是epoch用来标识leader关系是否改变，每次一个leader被选出来，它都会有一个新的epoch，标识当前属于那个leader的统治时期。低32位用于递增计数。\" class=\"headerlink\" title=\"为了保证事务的顺序一致性，zookeeper采用了递增的事务id号（zxid）来标识事务。所有的提议（proposal）都在被提出的时候加上了zxid。实现中zxid是一个64位的数字，它高32位是epoch用来标识leader关系是否改变，每次一个leader被选出来，它都会有一个新的epoch，标识当前属于那个leader的统治时期。低32位用于递增计数。\"></a>为了保证事务的顺序一致性，zookeeper采用了递增的事务id号（zxid）来标识事务。所有的提议（proposal）都在被提出的时候加上了zxid。实现中zxid是一个64位的数字，它高32位是epoch用来标识leader关系是否改变，每次一个leader被选出来，它都会有一个新的epoch，标识当前属于那个leader的统治时期。低32位用于递增计数。</h5><h5 id=\"每个Server在工作过程中有三种状态：\"><a href=\"#每个Server在工作过程中有三种状态：\" class=\"headerlink\" title=\"每个Server在工作过程中有三种状态：\"></a>每个Server在工作过程中有三种状态：</h5><ul>\n<li>LOOKING：当前Server不知道leader是谁，正在搜寻</li>\n<li>LEADING：当前Server即为选举出来的leader</li>\n<li>FOLLOWING：leader已经选举出来，当前Server与之同步</li>\n</ul>\n<h3 id=\"2-1-选主流程\"><a href=\"#2-1-选主流程\" class=\"headerlink\" title=\"2.1 选主流程\"></a>2.1 选主流程</h3><h5 id=\"当leader崩溃或者leader失去大多数的follower，这时候zk进入恢复模式，恢复模式需要重新选举出一个新的leader，让所有的Server都恢复到一个正确的状态。Zk的选举算法有两种：一种是基于basic-paxos实现的，另外一种是基于fast-paxos算法实现的。系统默认的选举算法为fast-paxos。先介绍basic-paxos流程：\"><a href=\"#当leader崩溃或者leader失去大多数的follower，这时候zk进入恢复模式，恢复模式需要重新选举出一个新的leader，让所有的Server都恢复到一个正确的状态。Zk的选举算法有两种：一种是基于basic-paxos实现的，另外一种是基于fast-paxos算法实现的。系统默认的选举算法为fast-paxos。先介绍basic-paxos流程：\" class=\"headerlink\" title=\"当leader崩溃或者leader失去大多数的follower，这时候zk进入恢复模式，恢复模式需要重新选举出一个新的leader，让所有的Server都恢复到一个正确的状态。Zk的选举算法有两种：一种是基于basic paxos实现的，另外一种是基于fast paxos算法实现的。系统默认的选举算法为fast paxos。先介绍basic paxos流程：\"></a>当leader崩溃或者leader失去大多数的follower，这时候zk进入恢复模式，恢复模式需要重新选举出一个新的leader，让所有的Server都恢复到一个正确的状态。Zk的选举算法有两种：一种是基于basic paxos实现的，另外一种是基于fast paxos算法实现的。系统默认的选举算法为fast paxos。先介绍basic paxos流程：</h5><ol>\n<li>选举线程由当前Server发起选举的线程担任，其主要功能是对投票结果进行统计，并选出推荐的Server；</li>\n<li>选举线程首先向所有Server发起一次询问(包括自己)；</li>\n<li>选举线程收到回复后，验证是否是自己发起的询问(验证zxid是否一致)，然后获取对方的id(myid)，并存储到当前询问对象列表中，最后获取对方提议的leader相关信息(id,zxid)，并将这些信息存储到当次选举的投票记录表中；</li>\n<li>收到所有Server回复以后，就计算出zxid最大的那个Server，并将这个Server相关信息设置成下一次要投票的Server；</li>\n<li>线程将当前zxid最大的Server设置为当前Server要推荐的Leader，如果此时获胜的Server获得n/2 + 1的Server票数， 设置当前推荐的leader为获胜的Server，将根据获胜的Server相关信息设置自己的状态，否则，继续这个过程，直到leader被选举出来。</li>\n</ol>\n<h5 id=\"通过流程分析我们可以得出：要使Leader获得多数Server的支持，则Server总数必须是奇数2n-1，且存活的Server的数目不得少于n-1\"><a href=\"#通过流程分析我们可以得出：要使Leader获得多数Server的支持，则Server总数必须是奇数2n-1，且存活的Server的数目不得少于n-1\" class=\"headerlink\" title=\"通过流程分析我们可以得出：要使Leader获得多数Server的支持，则Server总数必须是奇数2n+1，且存活的Server的数目不得少于n+1.\"></a>通过流程分析我们可以得出：要使Leader获得多数Server的支持，则Server总数必须是奇数2n+1，且存活的Server的数目不得少于n+1.</h5><h5 id=\"每个Server启动后都会重复以上流程。在恢复模式下，如果是刚从崩溃状态恢复的或者刚启动的server还会从磁盘快照中恢复数据和会话信息，zk会记录事务日志并定期进行快照，方便在恢复时进行状态恢复。选主的具体流程图如下所示：\"><a href=\"#每个Server启动后都会重复以上流程。在恢复模式下，如果是刚从崩溃状态恢复的或者刚启动的server还会从磁盘快照中恢复数据和会话信息，zk会记录事务日志并定期进行快照，方便在恢复时进行状态恢复。选主的具体流程图如下所示：\" class=\"headerlink\" title=\"每个Server启动后都会重复以上流程。在恢复模式下，如果是刚从崩溃状态恢复的或者刚启动的server还会从磁盘快照中恢复数据和会话信息，zk会记录事务日志并定期进行快照，方便在恢复时进行状态恢复。选主的具体流程图如下所示：\"></a>每个Server启动后都会重复以上流程。在恢复模式下，如果是刚从崩溃状态恢复的或者刚启动的server还会从磁盘快照中恢复数据和会话信息，zk会记录事务日志并定期进行快照，方便在恢复时进行状态恢复。选主的具体流程图如下所示：</h5><p><img src=\"../../img/zookeeper/zookeeperLc.jpg\" alt=\"zookeeper流程图\"></p>\n<h5 id=\"fast-paxos流程是在选举过程中，某Server首先向所有Server提议自己要成为leader，当其它Server收到提议以后，解决epoch和zxid的冲突，并接受对方的提议，然后向对方发送接受提议完成的消息，重复这个流程，最后一定能选举出Leader。其流程图如下所示：\"><a href=\"#fast-paxos流程是在选举过程中，某Server首先向所有Server提议自己要成为leader，当其它Server收到提议以后，解决epoch和zxid的冲突，并接受对方的提议，然后向对方发送接受提议完成的消息，重复这个流程，最后一定能选举出Leader。其流程图如下所示：\" class=\"headerlink\" title=\"fast paxos流程是在选举过程中，某Server首先向所有Server提议自己要成为leader，当其它Server收到提议以后，解决epoch和zxid的冲突，并接受对方的提议，然后向对方发送接受提议完成的消息，重复这个流程，最后一定能选举出Leader。其流程图如下所示：\"></a>fast paxos流程是在选举过程中，某Server首先向所有Server提议自己要成为leader，当其它Server收到提议以后，解决epoch和zxid的冲突，并接受对方的提议，然后向对方发送接受提议完成的消息，重复这个流程，最后一定能选举出Leader。其流程图如下所示：</h5><p><img src=\"../../img/zookeeper/zookeeperLc2.jpg\" alt=\"zookeeper流程图\"></p>\n<h3 id=\"2-2-同步流程\"><a href=\"#2-2-同步流程\" class=\"headerlink\" title=\"2.2 同步流程\"></a>2.2 同步流程</h3><h5 id=\"选完leader以后，zk就进入状态同步过程。\"><a href=\"#选完leader以后，zk就进入状态同步过程。\" class=\"headerlink\" title=\"选完leader以后，zk就进入状态同步过程。\"></a>选完leader以后，zk就进入状态同步过程。</h5><ol>\n<li>leader等待server连接；</li>\n<li>Follower连接leader，将最大的zxid发送给leader；</li>\n<li>Leader根据follower的zxid确定同步点；</li>\n<li>完成同步后通知follower 已经成为uptodate状态；</li>\n<li>Follower收到uptodate消息后，又可以重新接受client的请求进行服务了。</li>\n</ol>\n<h5 id=\"流程图如下所示：\"><a href=\"#流程图如下所示：\" class=\"headerlink\" title=\"流程图如下所示：\"></a>流程图如下所示：</h5><p><img src=\"../../img/zookeeper/zookeeperLc3.jpg\" alt=\"zookeeper流程图\"></p>\n<h3 id=\"2-3-工作流程\"><a href=\"#2-3-工作流程\" class=\"headerlink\" title=\"2.3 工作流程\"></a>2.3 工作流程</h3><h4 id=\"2-3-1-Leader工作流程\"><a href=\"#2-3-1-Leader工作流程\" class=\"headerlink\" title=\"2.3.1 Leader工作流程\"></a>2.3.1 Leader工作流程</h4><h5 id=\"Leader主要有三个功能：\"><a href=\"#Leader主要有三个功能：\" class=\"headerlink\" title=\"Leader主要有三个功能：\"></a>Leader主要有三个功能：</h5><ol>\n<li>恢复数据；</li>\n<li>维持与Learner的心跳，接收Learner请求并判断Learner的请求消息类型；</li>\n<li>Learner的消息类型主要有PING消息、REQUEST消息、ACK消息、REVALIDATE消息，根据不同的消息类型，进行不同的处理。</li>\n</ol>\n<h5 id=\"PING消息是指Learner的心跳信息；REQUEST消息是Follower发送的提议信息，包括写请求及同步请求；ACK消息是Follower的对提议的回复，超过半数的Follower通过，则commit该提议；REVALIDATE消息是用来延长SESSION有效时间。\"><a href=\"#PING消息是指Learner的心跳信息；REQUEST消息是Follower发送的提议信息，包括写请求及同步请求；ACK消息是Follower的对提议的回复，超过半数的Follower通过，则commit该提议；REVALIDATE消息是用来延长SESSION有效时间。\" class=\"headerlink\" title=\"PING消息是指Learner的心跳信息；REQUEST消息是Follower发送的提议信息，包括写请求及同步请求；ACK消息是Follower的对提议的回复，超过半数的Follower通过，则commit该提议；REVALIDATE消息是用来延长SESSION有效时间。\"></a>PING消息是指Learner的心跳信息；REQUEST消息是Follower发送的提议信息，包括写请求及同步请求；ACK消息是Follower的对提议的回复，超过半数的Follower通过，则commit该提议；REVALIDATE消息是用来延长SESSION有效时间。</h5><h5 id=\"Leader的工作流程简图如下所示，在实际实现中，流程要比下图复杂得多，启动了三个线程来实现功能。\"><a href=\"#Leader的工作流程简图如下所示，在实际实现中，流程要比下图复杂得多，启动了三个线程来实现功能。\" class=\"headerlink\" title=\"Leader的工作流程简图如下所示，在实际实现中，流程要比下图复杂得多，启动了三个线程来实现功能。\"></a>Leader的工作流程简图如下所示，在实际实现中，流程要比下图复杂得多，启动了三个线程来实现功能。</h5><p><img src=\"../../img/zookeeper/zookeeperLc4.jpg\" alt=\"zookeeper流程图\"></p>\n<h4 id=\"2-3-2-Follower工作流程\"><a href=\"#2-3-2-Follower工作流程\" class=\"headerlink\" title=\"2.3.2 Follower工作流程\"></a>2.3.2 Follower工作流程</h4><h5 id=\"Follower主要有四个功能：\"><a href=\"#Follower主要有四个功能：\" class=\"headerlink\" title=\"Follower主要有四个功能：\"></a>Follower主要有四个功能：</h5><ol>\n<li>向Leader发送请求（PING消息、REQUEST消息、ACK消息、REVALIDATE消息）；</li>\n<li>接收Leader消息并进行处理；</li>\n<li>接收Client的请求，如果为写请求，发送给Leader进行投票；</li>\n<li>返回Client结果。</li>\n</ol>\n<h5 id=\"Follower的消息循环处理如下几种来自Leader的消息：\"><a href=\"#Follower的消息循环处理如下几种来自Leader的消息：\" class=\"headerlink\" title=\"Follower的消息循环处理如下几种来自Leader的消息：\"></a>Follower的消息循环处理如下几种来自Leader的消息：</h5><ol>\n<li>PING消息： 心跳消息；</li>\n<li>PROPOSAL消息：Leader发起的提案，要求Follower投票；</li>\n<li>COMMIT消息：服务器端最新一次提案的信息；</li>\n<li>UPTODATE消息：表明同步完成；</li>\n<li>REVALIDATE消息：根据Leader的REVALIDATE结果，关闭待revalidate的session还是允许其接受消息；</li>\n<li>SYNC消息：返回SYNC结果到客户端，这个消息最初由客户端发起，用来强制得到最新的更新。</li>\n</ol>\n<h5 id=\"Follower的工作流程简图如下所示，在实际实现中，Follower是通过5个线程来实现功能的。\"><a href=\"#Follower的工作流程简图如下所示，在实际实现中，Follower是通过5个线程来实现功能的。\" class=\"headerlink\" title=\"Follower的工作流程简图如下所示，在实际实现中，Follower是通过5个线程来实现功能的。\"></a>Follower的工作流程简图如下所示，在实际实现中，Follower是通过5个线程来实现功能的。</h5><p><img src=\"../../img/zookeeper/zookeeperLc5.jpg\" alt=\"zookeeper流程图\"></p>\n<h5 id=\"对于observer的流程不再叙述，observer流程和Follower的唯一不同的地方就是observer不会参加leader发起的投票。\"><a href=\"#对于observer的流程不再叙述，observer流程和Follower的唯一不同的地方就是observer不会参加leader发起的投票。\" class=\"headerlink\" title=\"对于observer的流程不再叙述，observer流程和Follower的唯一不同的地方就是observer不会参加leader发起的投票。\"></a>对于observer的流程不再叙述，observer流程和Follower的唯一不同的地方就是observer不会参加leader发起的投票。</h5><h5 id=\"主流应用场景：\"><a href=\"#主流应用场景：\" class=\"headerlink\" title=\"主流应用场景：\"></a>主流应用场景：</h5><h5 id=\"Zookeeper的主流应用场景实现思路（除去官方示例）\"><a href=\"#Zookeeper的主流应用场景实现思路（除去官方示例）\" class=\"headerlink\" title=\"Zookeeper的主流应用场景实现思路（除去官方示例）\"></a><strong>Zookeeper的主流应用场景实现思路（除去官方示例）</strong></h5><h4 id=\"1-配置管理\"><a href=\"#1-配置管理\" class=\"headerlink\" title=\"(1)配置管理\"></a>(1)配置管理</h4><h5 id=\"集中式的配置管理在应用集群中是非常常见的，一般商业公司内部都会实现一套集中的配置管理中心，应对不同的应用集群对于共享各自配置的需求，并且在配置变更时能够通知到集群中的每一个机器。\"><a href=\"#集中式的配置管理在应用集群中是非常常见的，一般商业公司内部都会实现一套集中的配置管理中心，应对不同的应用集群对于共享各自配置的需求，并且在配置变更时能够通知到集群中的每一个机器。\" class=\"headerlink\" title=\"集中式的配置管理在应用集群中是非常常见的，一般商业公司内部都会实现一套集中的配置管理中心，应对不同的应用集群对于共享各自配置的需求，并且在配置变更时能够通知到集群中的每一个机器。\"></a>集中式的配置管理在应用集群中是非常常见的，一般商业公司内部都会实现一套集中的配置管理中心，应对不同的应用集群对于共享各自配置的需求，并且在配置变更时能够通知到集群中的每一个机器。</h5><h5 id=\"Zookeeper很容易实现这种集中式的配置管理，比如将APP1的所有配置配置到-APP1-znode下，APP1所有机器一启动就对-APP1这个节点进行监控-zk-exist-“-APP1”-true-并且实现回调方法Watcher，那么在zookeeper上-APP1-znode节点下数据发生变化的时候，每个机器都会收到通知，Watcher方法将会被执行，那么应用再取下数据即可-zk-getData-“-APP1”-false-null\"><a href=\"#Zookeeper很容易实现这种集中式的配置管理，比如将APP1的所有配置配置到-APP1-znode下，APP1所有机器一启动就对-APP1这个节点进行监控-zk-exist-“-APP1”-true-并且实现回调方法Watcher，那么在zookeeper上-APP1-znode节点下数据发生变化的时候，每个机器都会收到通知，Watcher方法将会被执行，那么应用再取下数据即可-zk-getData-“-APP1”-false-null\" class=\"headerlink\" title=\"Zookeeper很容易实现这种集中式的配置管理，比如将APP1的所有配置配置到/APP1 znode下，APP1所有机器一启动就对/APP1这个节点进行监控(zk.exist(“/APP1”,true)),并且实现回调方法Watcher，那么在zookeeper上/APP1 znode节点下数据发生变化的时候，每个机器都会收到通知，Watcher方法将会被执行，那么应用再取下数据即可(zk.getData(“/APP1”,false,null));\"></a>Zookeeper很容易实现这种集中式的配置管理，比如将APP1的所有配置配置到/APP1 znode下，APP1所有机器一启动就对/APP1这个节点进行监控(zk.exist(“/APP1”,true)),并且实现回调方法Watcher，那么在zookeeper上/APP1 znode节点下数据发生变化的时候，每个机器都会收到通知，Watcher方法将会被执行，那么应用再取下数据即可(zk.getData(“/APP1”,false,null));</h5><h5 id=\"以上这个例子只是简单的粗颗粒度配置监控，细颗粒度的数据可以进行分层级监控，这一切都是可以设计和控制的。\"><a href=\"#以上这个例子只是简单的粗颗粒度配置监控，细颗粒度的数据可以进行分层级监控，这一切都是可以设计和控制的。\" class=\"headerlink\" title=\"以上这个例子只是简单的粗颗粒度配置监控，细颗粒度的数据可以进行分层级监控，这一切都是可以设计和控制的。\"></a>以上这个例子只是简单的粗颗粒度配置监控，细颗粒度的数据可以进行分层级监控，这一切都是可以设计和控制的。</h5><p><img src=\"../../img/zookeeper/zookeeper1.jpg\" alt=\"zookeeper流程图\"></p>\n<h4 id=\"2-集群管理\"><a href=\"#2-集群管理\" class=\"headerlink\" title=\"(2)集群管理\"></a>(2)集群管理</h4><h5 id=\"应用集群中，我们常常需要让每一个机器知道集群中（或依赖的其他某一个集群）哪些机器是活着的，并且在集群机器因为宕机，网络断链等原因能够不在人工介入的情况下迅速通知到每一个机器。\"><a href=\"#应用集群中，我们常常需要让每一个机器知道集群中（或依赖的其他某一个集群）哪些机器是活着的，并且在集群机器因为宕机，网络断链等原因能够不在人工介入的情况下迅速通知到每一个机器。\" class=\"headerlink\" title=\"应用集群中，我们常常需要让每一个机器知道集群中（或依赖的其他某一个集群）哪些机器是活着的，并且在集群机器因为宕机，网络断链等原因能够不在人工介入的情况下迅速通知到每一个机器。\"></a>应用集群中，我们常常需要让每一个机器知道集群中（或依赖的其他某一个集群）哪些机器是活着的，并且在集群机器因为宕机，网络断链等原因能够不在人工介入的情况下迅速通知到每一个机器。</h5><h5 id=\"Zookeeper同样很容易实现这个功能，比如我在zookeeper服务器端有一个znode叫-APP1SERVERS-那么集群中每一个机器启动的时候都去这个节点下创建一个EPHEMERAL类型的节点，比如server1创建-APP1SERVERS-SERVER1-可以使用ip-保证不重复-，server2创建-APP1SERVERS-SERVER2，然后SERVER1和SERVER2都watch-APP1SERVERS这个父节点，那么也就是这个父节点下数据或者子节点变化都会通知对该节点进行watch的客户端。因为EPHEMERAL类型节点有一个很重要的特性，就是客户端和服务器端连接断掉或者session过期就会使节点消失，那么在某一个机器挂掉或者断链的时候，其对应的节点就会消失，然后集群中所有对-APP1SERVERS进行watch的客户端都会收到通知，然后取得最新列表即可。\"><a href=\"#Zookeeper同样很容易实现这个功能，比如我在zookeeper服务器端有一个znode叫-APP1SERVERS-那么集群中每一个机器启动的时候都去这个节点下创建一个EPHEMERAL类型的节点，比如server1创建-APP1SERVERS-SERVER1-可以使用ip-保证不重复-，server2创建-APP1SERVERS-SERVER2，然后SERVER1和SERVER2都watch-APP1SERVERS这个父节点，那么也就是这个父节点下数据或者子节点变化都会通知对该节点进行watch的客户端。因为EPHEMERAL类型节点有一个很重要的特性，就是客户端和服务器端连接断掉或者session过期就会使节点消失，那么在某一个机器挂掉或者断链的时候，其对应的节点就会消失，然后集群中所有对-APP1SERVERS进行watch的客户端都会收到通知，然后取得最新列表即可。\" class=\"headerlink\" title=\"Zookeeper同样很容易实现这个功能，比如我在zookeeper服务器端有一个znode叫/APP1SERVERS,那么集群中每一个机器启动的时候都去这个节点下创建一个EPHEMERAL类型的节点，比如server1创建/APP1SERVERS/SERVER1(可以使用ip,保证不重复)，server2创建/APP1SERVERS/SERVER2，然后SERVER1和SERVER2都watch /APP1SERVERS这个父节点，那么也就是这个父节点下数据或者子节点变化都会通知对该节点进行watch的客户端。因为EPHEMERAL类型节点有一个很重要的特性，就是客户端和服务器端连接断掉或者session过期就会使节点消失，那么在某一个机器挂掉或者断链的时候，其对应的节点就会消失，然后集群中所有对/APP1SERVERS进行watch的客户端都会收到通知，然后取得最新列表即可。\"></a>Zookeeper同样很容易实现这个功能，比如我在zookeeper服务器端有一个znode叫/APP1SERVERS,那么集群中每一个机器启动的时候都去这个节点下创建一个EPHEMERAL类型的节点，比如server1创建/APP1SERVERS/SERVER1(可以使用ip,保证不重复)，server2创建/APP1SERVERS/SERVER2，然后SERVER1和SERVER2都watch /APP1SERVERS这个父节点，那么也就是这个父节点下数据或者子节点变化都会通知对该节点进行watch的客户端。因为EPHEMERAL类型节点有一个很重要的特性，就是客户端和服务器端连接断掉或者session过期就会使节点消失，那么在某一个机器挂掉或者断链的时候，其对应的节点就会消失，然后集群中所有对/APP1SERVERS进行watch的客户端都会收到通知，然后取得最新列表即可。</h5><h5 id=\"另外有一个应用场景就是集群选master-一旦master挂掉能够马上能从slave中选出一个master-实现步骤和前者一样，只是机器在启动的时候在APP1SERVERS创建的节点类型变为EPHEMERAL-SEQUENTIAL类型，这样每个节点会自动被编号\"><a href=\"#另外有一个应用场景就是集群选master-一旦master挂掉能够马上能从slave中选出一个master-实现步骤和前者一样，只是机器在启动的时候在APP1SERVERS创建的节点类型变为EPHEMERAL-SEQUENTIAL类型，这样每个节点会自动被编号\" class=\"headerlink\" title=\"另外有一个应用场景就是集群选master,一旦master挂掉能够马上能从slave中选出一个master,实现步骤和前者一样，只是机器在启动的时候在APP1SERVERS创建的节点类型变为EPHEMERAL_SEQUENTIAL类型，这样每个节点会自动被编号\"></a>另外有一个应用场景就是集群选master,一旦master挂掉能够马上能从slave中选出一个master,实现步骤和前者一样，只是机器在启动的时候在APP1SERVERS创建的节点类型变为EPHEMERAL_SEQUENTIAL类型，这样每个节点会自动被编号</h5><h5 id=\"我们默认规定编号最小的为master-所以当我们对-APP1SERVERS节点做监控的时候，得到服务器列表，只要所有集群机器逻辑认为最小编号节点为master，那么master就被选出，而这个master宕机的时候，相应的znode会消失，然后新的服务器列表就被推送到客户端，然后每个节点逻辑认为最小编号节点为master，这样就做到动态master选举。\"><a href=\"#我们默认规定编号最小的为master-所以当我们对-APP1SERVERS节点做监控的时候，得到服务器列表，只要所有集群机器逻辑认为最小编号节点为master，那么master就被选出，而这个master宕机的时候，相应的znode会消失，然后新的服务器列表就被推送到客户端，然后每个节点逻辑认为最小编号节点为master，这样就做到动态master选举。\" class=\"headerlink\" title=\"我们默认规定编号最小的为master,所以当我们对/APP1SERVERS节点做监控的时候，得到服务器列表，只要所有集群机器逻辑认为最小编号节点为master，那么master就被选出，而这个master宕机的时候，相应的znode会消失，然后新的服务器列表就被推送到客户端，然后每个节点逻辑认为最小编号节点为master，这样就做到动态master选举。\"></a>我们默认规定编号最小的为master,所以当我们对/APP1SERVERS节点做监控的时候，得到服务器列表，只要所有集群机器逻辑认为最小编号节点为master，那么master就被选出，而这个master宕机的时候，相应的znode会消失，然后新的服务器列表就被推送到客户端，然后每个节点逻辑认为最小编号节点为master，这样就做到动态master选举。</h5><p><img src=\"../../img/zookeeper/zookeeper2.jpg\" alt=\"zookeeper流程图\"></p>\n<h4 id=\"Zookeeper-监视（Watches）-简介\"><a href=\"#Zookeeper-监视（Watches）-简介\" class=\"headerlink\" title=\"Zookeeper 监视（Watches） 简介\"></a>Zookeeper 监视（Watches） 简介</h4><h5 id=\"Zookeeper-C-API-的声明和描述在-include-zookeeper-h-中可以找到，另外大部分的-Zookeeper-C-API-常量、结构体声明也在-zookeeper-h-中，如果如果你在使用-C-API-是遇到不明白的地方，最好看看-zookeeper-h，或者自己使用-doxygen-生成-Zookeeper-C-API-的帮助文档。\"><a href=\"#Zookeeper-C-API-的声明和描述在-include-zookeeper-h-中可以找到，另外大部分的-Zookeeper-C-API-常量、结构体声明也在-zookeeper-h-中，如果如果你在使用-C-API-是遇到不明白的地方，最好看看-zookeeper-h，或者自己使用-doxygen-生成-Zookeeper-C-API-的帮助文档。\" class=\"headerlink\" title=\"Zookeeper C API 的声明和描述在 include/zookeeper.h 中可以找到，另外大部分的 Zookeeper C API 常量、结构体声明也在 zookeeper.h 中，如果如果你在使用 C API 是遇到不明白的地方，最好看看 zookeeper.h，或者自己使用 doxygen 生成 Zookeeper C API 的帮助文档。\"></a>Zookeeper C API 的声明和描述在 include/zookeeper.h 中可以找到，另外大部分的 Zookeeper C API 常量、结构体声明也在 zookeeper.h 中，如果如果你在使用 C API 是遇到不明白的地方，最好看看 zookeeper.h，或者自己使用 doxygen 生成 Zookeeper C API 的帮助文档。</h5><h5 id=\"Zookeeper-中最有特色且最不容易理解的是监视-Watches-。Zookeeper-所有的读操作——getData-getChildren-和-exists-都-可以设置监视-watch-，监视事件可以理解为一次性的触发器，-官方定义如下：-a-watch-event-is-one-time-trigger-sent-to-the-client-that-set-the-watch-which-occurs-when-the-data-for-which-the-watch-was-set-changes。对此需要作出如下理解：\"><a href=\"#Zookeeper-中最有特色且最不容易理解的是监视-Watches-。Zookeeper-所有的读操作——getData-getChildren-和-exists-都-可以设置监视-watch-，监视事件可以理解为一次性的触发器，-官方定义如下：-a-watch-event-is-one-time-trigger-sent-to-the-client-that-set-the-watch-which-occurs-when-the-data-for-which-the-watch-was-set-changes。对此需要作出如下理解：\" class=\"headerlink\" title=\"Zookeeper 中最有特色且最不容易理解的是监视(Watches)。Zookeeper 所有的读操作——getData(), getChildren(), 和 exists() 都 可以设置监视(watch)，监视事件可以理解为一次性的触发器， 官方定义如下： a watch event is one-time trigger, sent to the client that set the watch, which occurs when the data for which the watch was set changes。对此需要作出如下理解：\"></a>Zookeeper 中最有特色且最不容易理解的是监视(Watches)。Zookeeper 所有的读操作——getData(), getChildren(), 和 exists() 都 可以设置监视(watch)，监视事件可以理解为一次性的触发器， 官方定义如下： a watch event is one-time trigger, sent to the client that set the watch, which occurs when the data for which the watch was set changes。对此需要作出如下理解：</h5><ul>\n<li>（一次性触发）One-time trigger</li>\n</ul>\n<h5 id=\"当设置监视的数据发生改变时，该监视事件会被发送到客户端，例如，如果客户端调用了-getData-“-znode1”-true-并且稍后-znode1-节点上的数据发生了改变或者被删除了，客户端将会获取到-znode1-发生变化的监视事件，而如果-znode1-再一次发生了变化，除非客户端再次对-znode1-设置监视，否则客户端不会收到事件通知。\"><a href=\"#当设置监视的数据发生改变时，该监视事件会被发送到客户端，例如，如果客户端调用了-getData-“-znode1”-true-并且稍后-znode1-节点上的数据发生了改变或者被删除了，客户端将会获取到-znode1-发生变化的监视事件，而如果-znode1-再一次发生了变化，除非客户端再次对-znode1-设置监视，否则客户端不会收到事件通知。\" class=\"headerlink\" title=\"当设置监视的数据发生改变时，该监视事件会被发送到客户端，例如，如果客户端调用了 getData(“/znode1”, true) 并且稍后 /znode1 节点上的数据发生了改变或者被删除了，客户端将会获取到 /znode1 发生变化的监视事件，而如果 /znode1 再一次发生了变化，除非客户端再次对 /znode1 设置监视，否则客户端不会收到事件通知。\"></a>当设置监视的数据发生改变时，该监视事件会被发送到客户端，例如，如果客户端调用了 getData(“/znode1”, true) 并且稍后 /znode1 节点上的数据发生了改变或者被删除了，客户端将会获取到 /znode1 发生变化的监视事件，而如果 /znode1 再一次发生了变化，除非客户端再次对 /znode1 设置监视，否则客户端不会收到事件通知。</h5><ul>\n<li>（发送至客户端）Sent to the client</li>\n</ul>\n<h5 id=\"Zookeeper-客户端和服务端是通过-socket-进行通信的，由于网络存在故障，所以监视事件很有可能不会成功地到达客户端，监视事件是异步发送至监视者的，Zookeeper-本身提供了保序性-ordering-guarantee-：即客户端只有首先看到了监视事件后，才会感知到它所设置监视的-znode-发生了变化-a-client-will-never-see-a-change-for-which-it-has-set-a-watch-until-it-first-sees-the-watch-event-网络延迟或者其他因素可能导致不同的客户端在不同的时刻感知某一监视事件，但是不同的客户端所看到的一切具有一致的顺序。\"><a href=\"#Zookeeper-客户端和服务端是通过-socket-进行通信的，由于网络存在故障，所以监视事件很有可能不会成功地到达客户端，监视事件是异步发送至监视者的，Zookeeper-本身提供了保序性-ordering-guarantee-：即客户端只有首先看到了监视事件后，才会感知到它所设置监视的-znode-发生了变化-a-client-will-never-see-a-change-for-which-it-has-set-a-watch-until-it-first-sees-the-watch-event-网络延迟或者其他因素可能导致不同的客户端在不同的时刻感知某一监视事件，但是不同的客户端所看到的一切具有一致的顺序。\" class=\"headerlink\" title=\"Zookeeper 客户端和服务端是通过 socket 进行通信的，由于网络存在故障，所以监视事件很有可能不会成功地到达客户端，监视事件是异步发送至监视者的，Zookeeper 本身提供了保序性(ordering guarantee)：即客户端只有首先看到了监视事件后，才会感知到它所设置监视的 znode 发生了变化(a client will never see a change for which it has set a watch until it first sees the watch event). 网络延迟或者其他因素可能导致不同的客户端在不同的时刻感知某一监视事件，但是不同的客户端所看到的一切具有一致的顺序。\"></a>Zookeeper 客户端和服务端是通过 socket 进行通信的，由于网络存在故障，所以监视事件很有可能不会成功地到达客户端，监视事件是异步发送至监视者的，Zookeeper 本身提供了保序性(ordering guarantee)：即客户端只有首先看到了监视事件后，才会感知到它所设置监视的 znode 发生了变化(a client will never see a change for which it has set a watch until it first sees the watch event). 网络延迟或者其他因素可能导致不同的客户端在不同的时刻感知某一监视事件，但是不同的客户端所看到的一切具有一致的顺序。</h5><ul>\n<li>（被设置 watch 的数据）The data for which the watch was set</li>\n</ul>\n<h5 id=\"这意味着-znode-节点本身具有不同的改变方式。你也可以想象-Zookeeper-维护了两条监视链表：数据监视和子节点监视-data-watches-and-child-watches-getData-and-exists-设置数据监视，getChildren-设置子节点监视。-或者，你也可以想象-Zookeeper-设置的不同监视返回不同的数据，getData-和-exists-返回-znode-节点的相关信息，而-getChildren-返回子节点列表。因此，-setData-会触发设置在某一节点上所设置的数据监视-假定数据设置成功-，而一次成功的-create-操作则会出发当前节点上所设置的数据监视以及父节点的子节点监视。一次成功的-delete-操作将会触发当前节点的数据监视和子节点监视事件，同时也会触发该节点父节点的child-watch。\"><a href=\"#这意味着-znode-节点本身具有不同的改变方式。你也可以想象-Zookeeper-维护了两条监视链表：数据监视和子节点监视-data-watches-and-child-watches-getData-and-exists-设置数据监视，getChildren-设置子节点监视。-或者，你也可以想象-Zookeeper-设置的不同监视返回不同的数据，getData-和-exists-返回-znode-节点的相关信息，而-getChildren-返回子节点列表。因此，-setData-会触发设置在某一节点上所设置的数据监视-假定数据设置成功-，而一次成功的-create-操作则会出发当前节点上所设置的数据监视以及父节点的子节点监视。一次成功的-delete-操作将会触发当前节点的数据监视和子节点监视事件，同时也会触发该节点父节点的child-watch。\" class=\"headerlink\" title=\"这意味着 znode 节点本身具有不同的改变方式。你也可以想象 Zookeeper 维护了两条监视链表：数据监视和子节点监视(data watches and child watches) getData() and exists() 设置数据监视，getChildren() 设置子节点监视。 或者，你也可以想象 Zookeeper 设置的不同监视返回不同的数据，getData() 和 exists() 返回 znode 节点的相关信息，而 getChildren() 返回子节点列表。因此， setData() 会触发设置在某一节点上所设置的数据监视(假定数据设置成功)，而一次成功的 create() 操作则会出发当前节点上所设置的数据监视以及父节点的子节点监视。一次成功的 delete() 操作将会触发当前节点的数据监视和子节点监视事件，同时也会触发该节点父节点的child watch。\"></a>这意味着 znode 节点本身具有不同的改变方式。你也可以想象 Zookeeper 维护了两条监视链表：数据监视和子节点监视(data watches and child watches) getData() and exists() 设置数据监视，getChildren() 设置子节点监视。 或者，你也可以想象 Zookeeper 设置的不同监视返回不同的数据，getData() 和 exists() 返回 znode 节点的相关信息，而 getChildren() 返回子节点列表。因此， setData() 会触发设置在某一节点上所设置的数据监视(假定数据设置成功)，而一次成功的 create() 操作则会出发当前节点上所设置的数据监视以及父节点的子节点监视。一次成功的 delete() 操作将会触发当前节点的数据监视和子节点监视事件，同时也会触发该节点父节点的child watch。</h5><h5 id=\"Zookeeper-中的监视是轻量级的，因此容易设置、维护和分发。当客户端与-Zookeeper-服务器端失去联系时，客户端并不会收到监视事件的通知，只有当客户端重新连接后，若在必要的情况下，以前注册的监视会重新被注册并触发，对于开发人员来说-这通常是透明的。只有一种情况会导致监视事件的丢失，即：通过-exists-设置了某个-znode-节点的监视，但是如果某个客户端在此-znode-节点被创建和删除的时间间隔内与-zookeeper-服务器失去了联系，该客户端即使稍后重新连接-zookeeper服务器后也得不到事件通知。\"><a href=\"#Zookeeper-中的监视是轻量级的，因此容易设置、维护和分发。当客户端与-Zookeeper-服务器端失去联系时，客户端并不会收到监视事件的通知，只有当客户端重新连接后，若在必要的情况下，以前注册的监视会重新被注册并触发，对于开发人员来说-这通常是透明的。只有一种情况会导致监视事件的丢失，即：通过-exists-设置了某个-znode-节点的监视，但是如果某个客户端在此-znode-节点被创建和删除的时间间隔内与-zookeeper-服务器失去了联系，该客户端即使稍后重新连接-zookeeper服务器后也得不到事件通知。\" class=\"headerlink\" title=\"Zookeeper 中的监视是轻量级的，因此容易设置、维护和分发。当客户端与 Zookeeper 服务器端失去联系时，客户端并不会收到监视事件的通知，只有当客户端重新连接后，若在必要的情况下，以前注册的监视会重新被注册并触发，对于开发人员来说 这通常是透明的。只有一种情况会导致监视事件的丢失，即：通过 exists() 设置了某个 znode 节点的监视，但是如果某个客户端在此 znode 节点被创建和删除的时间间隔内与 zookeeper 服务器失去了联系，该客户端即使稍后重新连接 zookeeper服务器后也得不到事件通知。\"></a>Zookeeper 中的监视是轻量级的，因此容易设置、维护和分发。当客户端与 Zookeeper 服务器端失去联系时，客户端并不会收到监视事件的通知，只有当客户端重新连接后，若在必要的情况下，以前注册的监视会重新被注册并触发，对于开发人员来说 这通常是透明的。只有一种情况会导致监视事件的丢失，即：通过 exists() 设置了某个 znode 节点的监视，但是如果某个客户端在此 znode 节点被创建和删除的时间间隔内与 zookeeper 服务器失去了联系，该客户端即使稍后重新连接 zookeeper服务器后也得不到事件通知。</h5><h3 id=\"Zookeeper-C-API-常量与部分结构-struct-介绍\"><a href=\"#Zookeeper-C-API-常量与部分结构-struct-介绍\" class=\"headerlink\" title=\"Zookeeper C API 常量与部分结构(struct)介绍\"></a>Zookeeper C API 常量与部分结构(struct)介绍</h3><h4 id=\"与-ACL-相关的结构与常量：\"><a href=\"#与-ACL-相关的结构与常量：\" class=\"headerlink\" title=\"与 ACL 相关的结构与常量：\"></a>与 ACL 相关的结构与常量：</h4><h5 id=\"struct-Id-结构为：\"><a href=\"#struct-Id-结构为：\" class=\"headerlink\" title=\"struct Id 结构为：\"></a>struct Id 结构为：</h5><pre><code>struct Id {     char * scheme;     char * id; };\n</code></pre><h5 id=\"struct-ACL-结构为：\"><a href=\"#struct-ACL-结构为：\" class=\"headerlink\" title=\"struct ACL 结构为：\"></a>struct ACL 结构为：</h5><pre><code>struct ACL {     int32_t perms;     struct Id id; };\n</code></pre><h5 id=\"struct-ACL-vector-结构为：\"><a href=\"#struct-ACL-vector-结构为：\" class=\"headerlink\" title=\"struct ACL_vector 结构为：\"></a>struct ACL_vector 结构为：</h5><pre><code>struct ACL_vector {     int32_t count;     struct ACL *data; };\n</code></pre><h5 id=\"与-znode-访问权限有关的常量\"><a href=\"#与-znode-访问权限有关的常量\" class=\"headerlink\" title=\"与 znode 访问权限有关的常量\"></a>与 znode 访问权限有关的常量</h5><ul>\n<li>const int ZOO_PERM_READ; //允许客户端读取 znode 节点的值以及子节点列表。</li>\n<li>const int ZOO_PERM_WRITE;// 允许客户端设置 znode 节点的值。</li>\n<li>const int ZOO_PERM_CREATE; //允许客户端在该 znode 节点下创建子节点。</li>\n<li>const int ZOO_PERM_DELETE;//允许客户端删除子节点。</li>\n<li>const int ZOO_PERM_ADMIN; //允许客户端执行 set_acl()。</li>\n<li>const int ZOO_PERM_ALL;//允许客户端执行所有操作，等价与上述所有标志的或(OR) 。</li>\n</ul>\n<h5 id=\"与-ACL-IDs-相关的常量\"><a href=\"#与-ACL-IDs-相关的常量\" class=\"headerlink\" title=\"与 ACL IDs 相关的常量\"></a>与 ACL IDs 相关的常量</h5><ul>\n<li>struct Id ZOO_ANYONE_ID_UNSAFE; //(‘world’,’anyone’)</li>\n<li>struct Id ZOO_AUTH_IDS;// (‘auth’,’’)</li>\n</ul>\n<h5 id=\"三种标准的-ACL\"><a href=\"#三种标准的-ACL\" class=\"headerlink\" title=\"三种标准的 ACL\"></a>三种标准的 ACL</h5><ul>\n<li>struct ACL_vector ZOO_OPEN_ACL_UNSAFE; //(ZOO_PERM_ALL,ZOO_ANYONE_ID_UNSAFE)</li>\n<li>struct ACL_vector ZOO_READ_ACL_UNSAFE;// (ZOO_PERM_READ, ZOO_ANYONE_ID_UNSAFE)</li>\n<li>struct ACL_vector ZOO_CREATOR_ALL_ACL; //(ZOO_PERM_ALL,ZOO_AUTH_IDS)</li>\n</ul>\n<h4 id=\"与-Interest-相关的常量：ZOOKEEPER-WRITE-ZOOKEEPER-READ\"><a href=\"#与-Interest-相关的常量：ZOOKEEPER-WRITE-ZOOKEEPER-READ\" class=\"headerlink\" title=\"与 Interest 相关的常量：ZOOKEEPER_WRITE, ZOOKEEPER_READ\"></a>与 Interest 相关的常量：ZOOKEEPER_WRITE, ZOOKEEPER_READ</h4><h5 id=\"这两个常量用于标识感兴趣的事件并通知zookeeper发生了哪些事件。Interest-常量可以进行组合或（OR）来标识多种兴趣-multiple-interests-write-read-，这两个常量一般用于-zookeeper-interest-和-zookeeper-process-两个函数中。\"><a href=\"#这两个常量用于标识感兴趣的事件并通知zookeeper发生了哪些事件。Interest-常量可以进行组合或（OR）来标识多种兴趣-multiple-interests-write-read-，这两个常量一般用于-zookeeper-interest-和-zookeeper-process-两个函数中。\" class=\"headerlink\" title=\"这两个常量用于标识感兴趣的事件并通知zookeeper发生了哪些事件。Interest 常量可以进行组合或（OR）来标识多种兴趣(multiple interests: write, read)，这两个常量一般用于 zookeeper_interest() 和 zookeeper_process()两个函数中。\"></a>这两个常量用于标识感兴趣的事件并通知zookeeper发生了哪些事件。Interest 常量可以进行组合或（OR）来标识多种兴趣(multiple interests: write, read)，这两个常量一般用于 zookeeper_interest() 和 zookeeper_process()两个函数中。</h5><h4 id=\"与节点创建相关的常量：ZOO-EPHEMERAL-ZOO-SEQUENCE\"><a href=\"#与节点创建相关的常量：ZOO-EPHEMERAL-ZOO-SEQUENCE\" class=\"headerlink\" title=\"与节点创建相关的常量：ZOO_EPHEMERAL, ZOO_SEQUENCE\"></a>与节点创建相关的常量：ZOO_EPHEMERAL, ZOO_SEQUENCE</h4><h5 id=\"zoo-create-函数标志，ZOO-EPHEMERAL-用来标识创建临时节点，ZOO-SEQUENCE-用来标识节点命名具有递增的后缀序号-一般是节点名称后填充-10-位字符的序号，如-xyz0000000000-xyz0000000001-xyz0000000002-…-，同样地，ZOO-EPHEMERAL-ZOO-SEQUENCE-可以组合。\"><a href=\"#zoo-create-函数标志，ZOO-EPHEMERAL-用来标识创建临时节点，ZOO-SEQUENCE-用来标识节点命名具有递增的后缀序号-一般是节点名称后填充-10-位字符的序号，如-xyz0000000000-xyz0000000001-xyz0000000002-…-，同样地，ZOO-EPHEMERAL-ZOO-SEQUENCE-可以组合。\" class=\"headerlink\" title=\"zoo_create 函数标志，ZOO_EPHEMERAL 用来标识创建临时节点，ZOO_SEQUENCE 用来标识节点命名具有递增的后缀序号(一般是节点名称后填充 10 位字符的序号，如 /xyz0000000000, /xyz0000000001, /xyz0000000002, …)，同样地，ZOO_EPHEMERAL, ZOO_SEQUENCE 可以组合。\"></a>zoo_create 函数标志，ZOO_EPHEMERAL 用来标识创建临时节点，ZOO_SEQUENCE 用来标识节点命名具有递增的后缀序号(一般是节点名称后填充 10 位字符的序号，如 /xyz0000000000, /xyz0000000001, /xyz0000000002, …)，同样地，ZOO_EPHEMERAL, ZOO_SEQUENCE 可以组合。</h5><h4 id=\"与连接状态-Stat-相关的常量\"><a href=\"#与连接状态-Stat-相关的常量\" class=\"headerlink\" title=\"与连接状态 Stat 相关的常量\"></a>与连接状态 Stat 相关的常量</h4><h5 id=\"以下常量均与-Zookeeper-连接状态有关，他们通常用作监视器回调函数的参数。\"><a href=\"#以下常量均与-Zookeeper-连接状态有关，他们通常用作监视器回调函数的参数。\" class=\"headerlink\" title=\"以下常量均与 Zookeeper 连接状态有关，他们通常用作监视器回调函数的参数。\"></a>以下常量均与 Zookeeper 连接状态有关，他们通常用作监视器回调函数的参数。</h5><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">ZOOAPI const int</th>\n<th style=\"text-align:left\">ZOO_EXPIRED_SESSION_STATE</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ZOOAPI const int</td>\n<td style=\"text-align:left\">ZOO_AUTH_FAILED_STATE</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ZOOAPI const int</td>\n<td style=\"text-align:left\">ZOO_CONNECTING_STATE</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ZOOAPI const int</td>\n<td style=\"text-align:left\">ZOO_ASSOCIATING_STATE</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ZOOAPI const int</td>\n<td style=\"text-align:left\">ZOO_CONNECTED_STATE</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h4 id=\"与监视类型-Watch-Types-相关的常量\"><a href=\"#与监视类型-Watch-Types-相关的常量\" class=\"headerlink\" title=\"与监视类型(Watch Types)相关的常量\"></a>与监视类型(Watch Types)相关的常量</h4><h5 id=\"以下常量标识监视事件的类型，他们通常用作监视器回调函数的第一个参数。\"><a href=\"#以下常量标识监视事件的类型，他们通常用作监视器回调函数的第一个参数。\" class=\"headerlink\" title=\"以下常量标识监视事件的类型，他们通常用作监视器回调函数的第一个参数。\"></a>以下常量标识监视事件的类型，他们通常用作监视器回调函数的第一个参数。</h5><ul>\n<li>ZOO_CREATED_EVENT; // 节点被创建(此前该节点不存在)，通过 zoo_exists() 设置监视。</li>\n<li>ZOO_DELETED_EVENT; // 节点被删除，通过 zoo_exists() 和 zoo_get() 设置监视。</li>\n<li>ZOO_CHANGED_EVENT; // 节点发生变化，通过 zoo_exists() 和 zoo_get() 设置监视。</li>\n<li>ZOO_CHILD_EVENT; // 子节点事件，通过zoo_get_children() 和 zoo_get_children2()设置监视。</li>\n<li>ZOO_SESSION_EVENT; // 会话丢失</li>\n<li>ZOO_NOTWATCHING_EVENT; // 监视被移除。</li>\n</ul>\n<h4 id=\"Zookeeper-C-API-错误码介绍-ZOO-ERRORS\"><a href=\"#Zookeeper-C-API-错误码介绍-ZOO-ERRORS\" class=\"headerlink\" title=\"Zookeeper C API 错误码介绍 ZOO_ERRORS\"></a>Zookeeper C API 错误码介绍 ZOO_ERRORS</h4><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>ZOK</th>\n<th>正常返回</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ZSYSTEMERROR</td>\n<td>系统或服务器端错误(System and server-side errors)，服务器不会抛出该错误，该错误也只是用来标识错误范围的，即大于该错误值，且小于 ZAPIERROR 都是系统错误。</td>\n</tr>\n<tr>\n<td>ZRUNTIMEINCONSISTENCY</td>\n<td>运行时非一致性错误。</td>\n</tr>\n<tr>\n<td>ZDATAINCONSISTENCY</td>\n<td>数据非一致性错误。</td>\n</tr>\n<tr>\n<td>ZCONNECTIONLOSS</td>\n<td>Zookeeper 客户端与服务器端失去连接</td>\n</tr>\n<tr>\n<td>ZMARSHALLINGERROR</td>\n<td>在 marshalling 和 unmarshalling 数据时出现错误(Error while marshalling or unmarshalling data)</td>\n</tr>\n<tr>\n<td>ZUNIMPLEMENTED</td>\n<td>该操作未实现(Operation is unimplemented)</td>\n</tr>\n<tr>\n<td>ZOPERATIONTIMEOUT</td>\n<td>该操作超时(Operation timeout)</td>\n</tr>\n<tr>\n<td>ZBADARGUMENTS</td>\n<td>非法参数错误(Invalid arguments)</td>\n</tr>\n<tr>\n<td>ZINVALIDSTATE</td>\n<td>非法句柄状态(Invliad zhandle state)</td>\n</tr>\n<tr>\n<td>ZAPIERROR</td>\n<td>API 错误(API errors)，服务器不会抛出该错误，该错误也只是用来标识错误范围的，错误值大于该值的标识 API 错误，而小于该值的标识 ZSYSTEMERROR。</td>\n</tr>\n<tr>\n<td>ZNONODE</td>\n<td>节点不存在(Node does not exist)</td>\n</tr>\n<tr>\n<td>ZNOAUTH</td>\n<td>没有经过授权(Not authenticated)</td>\n</tr>\n<tr>\n<td>ZBADVERSION</td>\n<td>版本冲突(Version conflict)</td>\n</tr>\n<tr>\n<td>ZNOCHILDRENFOREPHEMERALS</td>\n<td>临时节点不能拥有子节点(Ephemeral nodes may not have children)</td>\n</tr>\n<tr>\n<td>ZNODEEXISTS</td>\n<td>节点已经存在(The node already exists)</td>\n</tr>\n<tr>\n<td>ZNOTEMPTY</td>\n<td>该节点具有自身的子节点(The node has children)</td>\n</tr>\n<tr>\n<td>ZSESSIONEXPIRED</td>\n<td>会话过期(The session has been expired by the server)</td>\n</tr>\n<tr>\n<td>ZINVALIDCALLBACK</td>\n<td>非法的回调函数(Invalid callback specified)</td>\n</tr>\n<tr>\n<td>ZINVALIDACL</td>\n<td>非法的ACL(Invalid ACL specified)</td>\n</tr>\n<tr>\n<td>ZAUTHFAILED</td>\n<td>客户端授权失败(Client authentication failed)</td>\n</tr>\n<tr>\n<td>ZCLOSING</td>\n<td>Zookeeper 连接关闭(ZooKeeper is closing)</td>\n</tr>\n<tr>\n<td>ZNOTHING</td>\n<td>并非错误，客户端不需要处理服务器的响应(not error, no server responses to process)</td>\n</tr>\n<tr>\n<td>ZSESSIONMOVED</td>\n<td>会话转移至其他服务器，所以操作被忽略(session moved to another server, so operation is ignored) </td>\n</tr>\n</tbody>\n</table>\n</div>\n<h5 id=\"Watch事件类型：\"><a href=\"#Watch事件类型：\" class=\"headerlink\" title=\"Watch事件类型：\"></a>Watch事件类型：</h5><ul>\n<li>ZOO_CREATED_EVENT：节点创建事件，需要watch一个不存在的节点，当节点被创建时触发，此watch通过zoo_exists()设置</li>\n<li>ZOO_DELETED_EVENT：节点删除事件，此watch通过zoo_exists()或zoo_get()设置</li>\n<li>ZOO_CHANGED_EVENT：节点数据改变事件，此watch通过zoo_exists()或zoo_get()设置</li>\n<li>ZOO_CHILD_EVENT：子节点列表改变事件，此watch通过zoo_get_children()或zoo_get_children2()设置</li>\n<li>ZOO_SESSION_EVENT：会话失效事件，客户端与服务端断开或重连时触发</li>\n<li>ZOO_NOTWATCHING_EVENT：watch移除事件，服务端出于某些原因不再为客户端watch节点时触发</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h5 id=\"ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，它包含一个简单的原语集，分布式应用程序可以基于它实现同步服务，配置维护和命名服务等。Zookeeper是hadoop的一个子项目，其发展历程无需赘述。在分布式应用中，由于工程师不能很好地使用锁机制，以及基于消息的协调机制不适合在某些应用中使用，因此需要有一种可靠的、可扩展的、分布式的、可配置的协调机制来统一系统的状态。Zookeeper的目的就在于此。本文简单分析zookeeper的工作原理，对于如何使用zookeeper不是本文讨论的重点。\"><a href=\"#ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，它包含一个简单的原语集，分布式应用程序可以基于它实现同步服务，配置维护和命名服务等。Zookeeper是hadoop的一个子项目，其发展历程无需赘述。在分布式应用中，由于工程师不能很好地使用锁机制，以及基于消息的协调机制不适合在某些应用中使用，因此需要有一种可靠的、可扩展的、分布式的、可配置的协调机制来统一系统的状态。Zookeeper的目的就在于此。本文简单分析zookeeper的工作原理，对于如何使用zookeeper不是本文讨论的重点。\" class=\"headerlink\" title=\"ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，它包含一个简单的原语集，分布式应用程序可以基于它实现同步服务，配置维护和命名服务等。Zookeeper是hadoop的一个子项目，其发展历程无需赘述。在分布式应用中，由于工程师不能很好地使用锁机制，以及基于消息的协调机制不适合在某些应用中使用，因此需要有一种可靠的、可扩展的、分布式的、可配置的协调机制来统一系统的状态。Zookeeper的目的就在于此。本文简单分析zookeeper的工作原理，对于如何使用zookeeper不是本文讨论的重点。\"></a>ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，它包含一个简单的原语集，分布式应用程序可以基于它实现同步服务，配置维护和命名服务等。Zookeeper是hadoop的一个子项目，其发展历程无需赘述。在分布式应用中，由于工程师不能很好地使用锁机制，以及基于消息的协调机制不适合在某些应用中使用，因此需要有一种可靠的、可扩展的、分布式的、可配置的协调机制来统一系统的状态。Zookeeper的目的就在于此。本文简单分析zookeeper的工作原理，对于如何使用zookeeper不是本文讨论的重点。</h5>","more":"<h2 id=\"1-Zookeeper的基本概念\"><a href=\"#1-Zookeeper的基本概念\" class=\"headerlink\" title=\"1 Zookeeper的基本概念\"></a>1 Zookeeper的基本概念</h2><h3 id=\"1-1-角色\"><a href=\"#1-1-角色\" class=\"headerlink\" title=\"1.1 角色\"></a>1.1 角色</h3><h5 id=\"Zookeeper中的角色主要有以下三类，如下表所示：\"><a href=\"#Zookeeper中的角色主要有以下三类，如下表所示：\" class=\"headerlink\" title=\"Zookeeper中的角色主要有以下三类，如下表所示：\"></a>Zookeeper中的角色主要有以下三类，如下表所示：</h5><p><img src=\"../../img/zookeeper/role.jpg\" alt=\"zookeeper角色\"></p>\n<h5 id=\"系统模型如图所示：\"><a href=\"#系统模型如图所示：\" class=\"headerlink\" title=\"系统模型如图所示：\"></a>系统模型如图所示：</h5><p><img src=\"../../img/zookeeper/zookeeperModel.jpg\" alt=\"zookeeper系统模型\"></p>\n<h3 id=\"1-2-设计目的\"><a href=\"#1-2-设计目的\" class=\"headerlink\" title=\"1.2 设计目的\"></a>1.2 设计目的</h3><ol>\n<li>最终一致性：client不论连接到哪个Server，展示给它都是同一个视图，这是zookeeper最重要的性能。</li>\n<li>可靠性：具有简单、健壮、良好的性能，如果消息m被到一台服务器接受，那么它将被所有的服务器接受。</li>\n<li>实时性：Zookeeper保证客户端将在一个时间间隔范围内获得服务器的更新信息，或者服务器失效的信息。但由于网络延时等原因，Zookeeper不能保证两个客户端能同时得到刚更新的数据，如果需要最新数据，应该在读数据之前调用sync()接口。</li>\n<li>等待无关（wait-free）：慢的或者失效的client不得干预快速的client的请求，使得每个client都能有效的等待。</li>\n<li>原子性：更新只能成功或者失败，没有中间状态。</li>\n<li>顺序性：包括全局有序和偏序两种：全局有序是指如果在一台服务器上消息a在消息b前发布，则在所有Server上消息a都将在消息b前被发布；偏序是指如果一个消息b在消息a后被同一个发送者发布，a必将排在b前面。</li>\n</ol>\n<h2 id=\"2-ZooKeeper的工作原理\"><a href=\"#2-ZooKeeper的工作原理\" class=\"headerlink\" title=\"2 ZooKeeper的工作原理\"></a>2 ZooKeeper的工作原理</h2><h5 id=\"Zookeeper的核心是原子广播，这个机制保证了各个Server之间的同步。实现这个机制的协议叫做Zab协议。Zab协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数Server完成了和leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和Server具有相同的系统状态。\"><a href=\"#Zookeeper的核心是原子广播，这个机制保证了各个Server之间的同步。实现这个机制的协议叫做Zab协议。Zab协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数Server完成了和leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和Server具有相同的系统状态。\" class=\"headerlink\" title=\"Zookeeper的核心是原子广播，这个机制保证了各个Server之间的同步。实现这个机制的协议叫做Zab协议。Zab协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数Server完成了和leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和Server具有相同的系统状态。\"></a>Zookeeper的核心是原子广播，这个机制保证了各个Server之间的同步。实现这个机制的协议叫做Zab协议。Zab协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数Server完成了和leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和Server具有相同的系统状态。</h5><h5 id=\"为了保证事务的顺序一致性，zookeeper采用了递增的事务id号（zxid）来标识事务。所有的提议（proposal）都在被提出的时候加上了zxid。实现中zxid是一个64位的数字，它高32位是epoch用来标识leader关系是否改变，每次一个leader被选出来，它都会有一个新的epoch，标识当前属于那个leader的统治时期。低32位用于递增计数。\"><a href=\"#为了保证事务的顺序一致性，zookeeper采用了递增的事务id号（zxid）来标识事务。所有的提议（proposal）都在被提出的时候加上了zxid。实现中zxid是一个64位的数字，它高32位是epoch用来标识leader关系是否改变，每次一个leader被选出来，它都会有一个新的epoch，标识当前属于那个leader的统治时期。低32位用于递增计数。\" class=\"headerlink\" title=\"为了保证事务的顺序一致性，zookeeper采用了递增的事务id号（zxid）来标识事务。所有的提议（proposal）都在被提出的时候加上了zxid。实现中zxid是一个64位的数字，它高32位是epoch用来标识leader关系是否改变，每次一个leader被选出来，它都会有一个新的epoch，标识当前属于那个leader的统治时期。低32位用于递增计数。\"></a>为了保证事务的顺序一致性，zookeeper采用了递增的事务id号（zxid）来标识事务。所有的提议（proposal）都在被提出的时候加上了zxid。实现中zxid是一个64位的数字，它高32位是epoch用来标识leader关系是否改变，每次一个leader被选出来，它都会有一个新的epoch，标识当前属于那个leader的统治时期。低32位用于递增计数。</h5><h5 id=\"每个Server在工作过程中有三种状态：\"><a href=\"#每个Server在工作过程中有三种状态：\" class=\"headerlink\" title=\"每个Server在工作过程中有三种状态：\"></a>每个Server在工作过程中有三种状态：</h5><ul>\n<li>LOOKING：当前Server不知道leader是谁，正在搜寻</li>\n<li>LEADING：当前Server即为选举出来的leader</li>\n<li>FOLLOWING：leader已经选举出来，当前Server与之同步</li>\n</ul>\n<h3 id=\"2-1-选主流程\"><a href=\"#2-1-选主流程\" class=\"headerlink\" title=\"2.1 选主流程\"></a>2.1 选主流程</h3><h5 id=\"当leader崩溃或者leader失去大多数的follower，这时候zk进入恢复模式，恢复模式需要重新选举出一个新的leader，让所有的Server都恢复到一个正确的状态。Zk的选举算法有两种：一种是基于basic-paxos实现的，另外一种是基于fast-paxos算法实现的。系统默认的选举算法为fast-paxos。先介绍basic-paxos流程：\"><a href=\"#当leader崩溃或者leader失去大多数的follower，这时候zk进入恢复模式，恢复模式需要重新选举出一个新的leader，让所有的Server都恢复到一个正确的状态。Zk的选举算法有两种：一种是基于basic-paxos实现的，另外一种是基于fast-paxos算法实现的。系统默认的选举算法为fast-paxos。先介绍basic-paxos流程：\" class=\"headerlink\" title=\"当leader崩溃或者leader失去大多数的follower，这时候zk进入恢复模式，恢复模式需要重新选举出一个新的leader，让所有的Server都恢复到一个正确的状态。Zk的选举算法有两种：一种是基于basic paxos实现的，另外一种是基于fast paxos算法实现的。系统默认的选举算法为fast paxos。先介绍basic paxos流程：\"></a>当leader崩溃或者leader失去大多数的follower，这时候zk进入恢复模式，恢复模式需要重新选举出一个新的leader，让所有的Server都恢复到一个正确的状态。Zk的选举算法有两种：一种是基于basic paxos实现的，另外一种是基于fast paxos算法实现的。系统默认的选举算法为fast paxos。先介绍basic paxos流程：</h5><ol>\n<li>选举线程由当前Server发起选举的线程担任，其主要功能是对投票结果进行统计，并选出推荐的Server；</li>\n<li>选举线程首先向所有Server发起一次询问(包括自己)；</li>\n<li>选举线程收到回复后，验证是否是自己发起的询问(验证zxid是否一致)，然后获取对方的id(myid)，并存储到当前询问对象列表中，最后获取对方提议的leader相关信息(id,zxid)，并将这些信息存储到当次选举的投票记录表中；</li>\n<li>收到所有Server回复以后，就计算出zxid最大的那个Server，并将这个Server相关信息设置成下一次要投票的Server；</li>\n<li>线程将当前zxid最大的Server设置为当前Server要推荐的Leader，如果此时获胜的Server获得n/2 + 1的Server票数， 设置当前推荐的leader为获胜的Server，将根据获胜的Server相关信息设置自己的状态，否则，继续这个过程，直到leader被选举出来。</li>\n</ol>\n<h5 id=\"通过流程分析我们可以得出：要使Leader获得多数Server的支持，则Server总数必须是奇数2n-1，且存活的Server的数目不得少于n-1\"><a href=\"#通过流程分析我们可以得出：要使Leader获得多数Server的支持，则Server总数必须是奇数2n-1，且存活的Server的数目不得少于n-1\" class=\"headerlink\" title=\"通过流程分析我们可以得出：要使Leader获得多数Server的支持，则Server总数必须是奇数2n+1，且存活的Server的数目不得少于n+1.\"></a>通过流程分析我们可以得出：要使Leader获得多数Server的支持，则Server总数必须是奇数2n+1，且存活的Server的数目不得少于n+1.</h5><h5 id=\"每个Server启动后都会重复以上流程。在恢复模式下，如果是刚从崩溃状态恢复的或者刚启动的server还会从磁盘快照中恢复数据和会话信息，zk会记录事务日志并定期进行快照，方便在恢复时进行状态恢复。选主的具体流程图如下所示：\"><a href=\"#每个Server启动后都会重复以上流程。在恢复模式下，如果是刚从崩溃状态恢复的或者刚启动的server还会从磁盘快照中恢复数据和会话信息，zk会记录事务日志并定期进行快照，方便在恢复时进行状态恢复。选主的具体流程图如下所示：\" class=\"headerlink\" title=\"每个Server启动后都会重复以上流程。在恢复模式下，如果是刚从崩溃状态恢复的或者刚启动的server还会从磁盘快照中恢复数据和会话信息，zk会记录事务日志并定期进行快照，方便在恢复时进行状态恢复。选主的具体流程图如下所示：\"></a>每个Server启动后都会重复以上流程。在恢复模式下，如果是刚从崩溃状态恢复的或者刚启动的server还会从磁盘快照中恢复数据和会话信息，zk会记录事务日志并定期进行快照，方便在恢复时进行状态恢复。选主的具体流程图如下所示：</h5><p><img src=\"../../img/zookeeper/zookeeperLc.jpg\" alt=\"zookeeper流程图\"></p>\n<h5 id=\"fast-paxos流程是在选举过程中，某Server首先向所有Server提议自己要成为leader，当其它Server收到提议以后，解决epoch和zxid的冲突，并接受对方的提议，然后向对方发送接受提议完成的消息，重复这个流程，最后一定能选举出Leader。其流程图如下所示：\"><a href=\"#fast-paxos流程是在选举过程中，某Server首先向所有Server提议自己要成为leader，当其它Server收到提议以后，解决epoch和zxid的冲突，并接受对方的提议，然后向对方发送接受提议完成的消息，重复这个流程，最后一定能选举出Leader。其流程图如下所示：\" class=\"headerlink\" title=\"fast paxos流程是在选举过程中，某Server首先向所有Server提议自己要成为leader，当其它Server收到提议以后，解决epoch和zxid的冲突，并接受对方的提议，然后向对方发送接受提议完成的消息，重复这个流程，最后一定能选举出Leader。其流程图如下所示：\"></a>fast paxos流程是在选举过程中，某Server首先向所有Server提议自己要成为leader，当其它Server收到提议以后，解决epoch和zxid的冲突，并接受对方的提议，然后向对方发送接受提议完成的消息，重复这个流程，最后一定能选举出Leader。其流程图如下所示：</h5><p><img src=\"../../img/zookeeper/zookeeperLc2.jpg\" alt=\"zookeeper流程图\"></p>\n<h3 id=\"2-2-同步流程\"><a href=\"#2-2-同步流程\" class=\"headerlink\" title=\"2.2 同步流程\"></a>2.2 同步流程</h3><h5 id=\"选完leader以后，zk就进入状态同步过程。\"><a href=\"#选完leader以后，zk就进入状态同步过程。\" class=\"headerlink\" title=\"选完leader以后，zk就进入状态同步过程。\"></a>选完leader以后，zk就进入状态同步过程。</h5><ol>\n<li>leader等待server连接；</li>\n<li>Follower连接leader，将最大的zxid发送给leader；</li>\n<li>Leader根据follower的zxid确定同步点；</li>\n<li>完成同步后通知follower 已经成为uptodate状态；</li>\n<li>Follower收到uptodate消息后，又可以重新接受client的请求进行服务了。</li>\n</ol>\n<h5 id=\"流程图如下所示：\"><a href=\"#流程图如下所示：\" class=\"headerlink\" title=\"流程图如下所示：\"></a>流程图如下所示：</h5><p><img src=\"../../img/zookeeper/zookeeperLc3.jpg\" alt=\"zookeeper流程图\"></p>\n<h3 id=\"2-3-工作流程\"><a href=\"#2-3-工作流程\" class=\"headerlink\" title=\"2.3 工作流程\"></a>2.3 工作流程</h3><h4 id=\"2-3-1-Leader工作流程\"><a href=\"#2-3-1-Leader工作流程\" class=\"headerlink\" title=\"2.3.1 Leader工作流程\"></a>2.3.1 Leader工作流程</h4><h5 id=\"Leader主要有三个功能：\"><a href=\"#Leader主要有三个功能：\" class=\"headerlink\" title=\"Leader主要有三个功能：\"></a>Leader主要有三个功能：</h5><ol>\n<li>恢复数据；</li>\n<li>维持与Learner的心跳，接收Learner请求并判断Learner的请求消息类型；</li>\n<li>Learner的消息类型主要有PING消息、REQUEST消息、ACK消息、REVALIDATE消息，根据不同的消息类型，进行不同的处理。</li>\n</ol>\n<h5 id=\"PING消息是指Learner的心跳信息；REQUEST消息是Follower发送的提议信息，包括写请求及同步请求；ACK消息是Follower的对提议的回复，超过半数的Follower通过，则commit该提议；REVALIDATE消息是用来延长SESSION有效时间。\"><a href=\"#PING消息是指Learner的心跳信息；REQUEST消息是Follower发送的提议信息，包括写请求及同步请求；ACK消息是Follower的对提议的回复，超过半数的Follower通过，则commit该提议；REVALIDATE消息是用来延长SESSION有效时间。\" class=\"headerlink\" title=\"PING消息是指Learner的心跳信息；REQUEST消息是Follower发送的提议信息，包括写请求及同步请求；ACK消息是Follower的对提议的回复，超过半数的Follower通过，则commit该提议；REVALIDATE消息是用来延长SESSION有效时间。\"></a>PING消息是指Learner的心跳信息；REQUEST消息是Follower发送的提议信息，包括写请求及同步请求；ACK消息是Follower的对提议的回复，超过半数的Follower通过，则commit该提议；REVALIDATE消息是用来延长SESSION有效时间。</h5><h5 id=\"Leader的工作流程简图如下所示，在实际实现中，流程要比下图复杂得多，启动了三个线程来实现功能。\"><a href=\"#Leader的工作流程简图如下所示，在实际实现中，流程要比下图复杂得多，启动了三个线程来实现功能。\" class=\"headerlink\" title=\"Leader的工作流程简图如下所示，在实际实现中，流程要比下图复杂得多，启动了三个线程来实现功能。\"></a>Leader的工作流程简图如下所示，在实际实现中，流程要比下图复杂得多，启动了三个线程来实现功能。</h5><p><img src=\"../../img/zookeeper/zookeeperLc4.jpg\" alt=\"zookeeper流程图\"></p>\n<h4 id=\"2-3-2-Follower工作流程\"><a href=\"#2-3-2-Follower工作流程\" class=\"headerlink\" title=\"2.3.2 Follower工作流程\"></a>2.3.2 Follower工作流程</h4><h5 id=\"Follower主要有四个功能：\"><a href=\"#Follower主要有四个功能：\" class=\"headerlink\" title=\"Follower主要有四个功能：\"></a>Follower主要有四个功能：</h5><ol>\n<li>向Leader发送请求（PING消息、REQUEST消息、ACK消息、REVALIDATE消息）；</li>\n<li>接收Leader消息并进行处理；</li>\n<li>接收Client的请求，如果为写请求，发送给Leader进行投票；</li>\n<li>返回Client结果。</li>\n</ol>\n<h5 id=\"Follower的消息循环处理如下几种来自Leader的消息：\"><a href=\"#Follower的消息循环处理如下几种来自Leader的消息：\" class=\"headerlink\" title=\"Follower的消息循环处理如下几种来自Leader的消息：\"></a>Follower的消息循环处理如下几种来自Leader的消息：</h5><ol>\n<li>PING消息： 心跳消息；</li>\n<li>PROPOSAL消息：Leader发起的提案，要求Follower投票；</li>\n<li>COMMIT消息：服务器端最新一次提案的信息；</li>\n<li>UPTODATE消息：表明同步完成；</li>\n<li>REVALIDATE消息：根据Leader的REVALIDATE结果，关闭待revalidate的session还是允许其接受消息；</li>\n<li>SYNC消息：返回SYNC结果到客户端，这个消息最初由客户端发起，用来强制得到最新的更新。</li>\n</ol>\n<h5 id=\"Follower的工作流程简图如下所示，在实际实现中，Follower是通过5个线程来实现功能的。\"><a href=\"#Follower的工作流程简图如下所示，在实际实现中，Follower是通过5个线程来实现功能的。\" class=\"headerlink\" title=\"Follower的工作流程简图如下所示，在实际实现中，Follower是通过5个线程来实现功能的。\"></a>Follower的工作流程简图如下所示，在实际实现中，Follower是通过5个线程来实现功能的。</h5><p><img src=\"../../img/zookeeper/zookeeperLc5.jpg\" alt=\"zookeeper流程图\"></p>\n<h5 id=\"对于observer的流程不再叙述，observer流程和Follower的唯一不同的地方就是observer不会参加leader发起的投票。\"><a href=\"#对于observer的流程不再叙述，observer流程和Follower的唯一不同的地方就是observer不会参加leader发起的投票。\" class=\"headerlink\" title=\"对于observer的流程不再叙述，observer流程和Follower的唯一不同的地方就是observer不会参加leader发起的投票。\"></a>对于observer的流程不再叙述，observer流程和Follower的唯一不同的地方就是observer不会参加leader发起的投票。</h5><h5 id=\"主流应用场景：\"><a href=\"#主流应用场景：\" class=\"headerlink\" title=\"主流应用场景：\"></a>主流应用场景：</h5><h5 id=\"Zookeeper的主流应用场景实现思路（除去官方示例）\"><a href=\"#Zookeeper的主流应用场景实现思路（除去官方示例）\" class=\"headerlink\" title=\"Zookeeper的主流应用场景实现思路（除去官方示例）\"></a><strong>Zookeeper的主流应用场景实现思路（除去官方示例）</strong></h5><h4 id=\"1-配置管理\"><a href=\"#1-配置管理\" class=\"headerlink\" title=\"(1)配置管理\"></a>(1)配置管理</h4><h5 id=\"集中式的配置管理在应用集群中是非常常见的，一般商业公司内部都会实现一套集中的配置管理中心，应对不同的应用集群对于共享各自配置的需求，并且在配置变更时能够通知到集群中的每一个机器。\"><a href=\"#集中式的配置管理在应用集群中是非常常见的，一般商业公司内部都会实现一套集中的配置管理中心，应对不同的应用集群对于共享各自配置的需求，并且在配置变更时能够通知到集群中的每一个机器。\" class=\"headerlink\" title=\"集中式的配置管理在应用集群中是非常常见的，一般商业公司内部都会实现一套集中的配置管理中心，应对不同的应用集群对于共享各自配置的需求，并且在配置变更时能够通知到集群中的每一个机器。\"></a>集中式的配置管理在应用集群中是非常常见的，一般商业公司内部都会实现一套集中的配置管理中心，应对不同的应用集群对于共享各自配置的需求，并且在配置变更时能够通知到集群中的每一个机器。</h5><h5 id=\"Zookeeper很容易实现这种集中式的配置管理，比如将APP1的所有配置配置到-APP1-znode下，APP1所有机器一启动就对-APP1这个节点进行监控-zk-exist-“-APP1”-true-并且实现回调方法Watcher，那么在zookeeper上-APP1-znode节点下数据发生变化的时候，每个机器都会收到通知，Watcher方法将会被执行，那么应用再取下数据即可-zk-getData-“-APP1”-false-null\"><a href=\"#Zookeeper很容易实现这种集中式的配置管理，比如将APP1的所有配置配置到-APP1-znode下，APP1所有机器一启动就对-APP1这个节点进行监控-zk-exist-“-APP1”-true-并且实现回调方法Watcher，那么在zookeeper上-APP1-znode节点下数据发生变化的时候，每个机器都会收到通知，Watcher方法将会被执行，那么应用再取下数据即可-zk-getData-“-APP1”-false-null\" class=\"headerlink\" title=\"Zookeeper很容易实现这种集中式的配置管理，比如将APP1的所有配置配置到/APP1 znode下，APP1所有机器一启动就对/APP1这个节点进行监控(zk.exist(“/APP1”,true)),并且实现回调方法Watcher，那么在zookeeper上/APP1 znode节点下数据发生变化的时候，每个机器都会收到通知，Watcher方法将会被执行，那么应用再取下数据即可(zk.getData(“/APP1”,false,null));\"></a>Zookeeper很容易实现这种集中式的配置管理，比如将APP1的所有配置配置到/APP1 znode下，APP1所有机器一启动就对/APP1这个节点进行监控(zk.exist(“/APP1”,true)),并且实现回调方法Watcher，那么在zookeeper上/APP1 znode节点下数据发生变化的时候，每个机器都会收到通知，Watcher方法将会被执行，那么应用再取下数据即可(zk.getData(“/APP1”,false,null));</h5><h5 id=\"以上这个例子只是简单的粗颗粒度配置监控，细颗粒度的数据可以进行分层级监控，这一切都是可以设计和控制的。\"><a href=\"#以上这个例子只是简单的粗颗粒度配置监控，细颗粒度的数据可以进行分层级监控，这一切都是可以设计和控制的。\" class=\"headerlink\" title=\"以上这个例子只是简单的粗颗粒度配置监控，细颗粒度的数据可以进行分层级监控，这一切都是可以设计和控制的。\"></a>以上这个例子只是简单的粗颗粒度配置监控，细颗粒度的数据可以进行分层级监控，这一切都是可以设计和控制的。</h5><p><img src=\"../../img/zookeeper/zookeeper1.jpg\" alt=\"zookeeper流程图\"></p>\n<h4 id=\"2-集群管理\"><a href=\"#2-集群管理\" class=\"headerlink\" title=\"(2)集群管理\"></a>(2)集群管理</h4><h5 id=\"应用集群中，我们常常需要让每一个机器知道集群中（或依赖的其他某一个集群）哪些机器是活着的，并且在集群机器因为宕机，网络断链等原因能够不在人工介入的情况下迅速通知到每一个机器。\"><a href=\"#应用集群中，我们常常需要让每一个机器知道集群中（或依赖的其他某一个集群）哪些机器是活着的，并且在集群机器因为宕机，网络断链等原因能够不在人工介入的情况下迅速通知到每一个机器。\" class=\"headerlink\" title=\"应用集群中，我们常常需要让每一个机器知道集群中（或依赖的其他某一个集群）哪些机器是活着的，并且在集群机器因为宕机，网络断链等原因能够不在人工介入的情况下迅速通知到每一个机器。\"></a>应用集群中，我们常常需要让每一个机器知道集群中（或依赖的其他某一个集群）哪些机器是活着的，并且在集群机器因为宕机，网络断链等原因能够不在人工介入的情况下迅速通知到每一个机器。</h5><h5 id=\"Zookeeper同样很容易实现这个功能，比如我在zookeeper服务器端有一个znode叫-APP1SERVERS-那么集群中每一个机器启动的时候都去这个节点下创建一个EPHEMERAL类型的节点，比如server1创建-APP1SERVERS-SERVER1-可以使用ip-保证不重复-，server2创建-APP1SERVERS-SERVER2，然后SERVER1和SERVER2都watch-APP1SERVERS这个父节点，那么也就是这个父节点下数据或者子节点变化都会通知对该节点进行watch的客户端。因为EPHEMERAL类型节点有一个很重要的特性，就是客户端和服务器端连接断掉或者session过期就会使节点消失，那么在某一个机器挂掉或者断链的时候，其对应的节点就会消失，然后集群中所有对-APP1SERVERS进行watch的客户端都会收到通知，然后取得最新列表即可。\"><a href=\"#Zookeeper同样很容易实现这个功能，比如我在zookeeper服务器端有一个znode叫-APP1SERVERS-那么集群中每一个机器启动的时候都去这个节点下创建一个EPHEMERAL类型的节点，比如server1创建-APP1SERVERS-SERVER1-可以使用ip-保证不重复-，server2创建-APP1SERVERS-SERVER2，然后SERVER1和SERVER2都watch-APP1SERVERS这个父节点，那么也就是这个父节点下数据或者子节点变化都会通知对该节点进行watch的客户端。因为EPHEMERAL类型节点有一个很重要的特性，就是客户端和服务器端连接断掉或者session过期就会使节点消失，那么在某一个机器挂掉或者断链的时候，其对应的节点就会消失，然后集群中所有对-APP1SERVERS进行watch的客户端都会收到通知，然后取得最新列表即可。\" class=\"headerlink\" title=\"Zookeeper同样很容易实现这个功能，比如我在zookeeper服务器端有一个znode叫/APP1SERVERS,那么集群中每一个机器启动的时候都去这个节点下创建一个EPHEMERAL类型的节点，比如server1创建/APP1SERVERS/SERVER1(可以使用ip,保证不重复)，server2创建/APP1SERVERS/SERVER2，然后SERVER1和SERVER2都watch /APP1SERVERS这个父节点，那么也就是这个父节点下数据或者子节点变化都会通知对该节点进行watch的客户端。因为EPHEMERAL类型节点有一个很重要的特性，就是客户端和服务器端连接断掉或者session过期就会使节点消失，那么在某一个机器挂掉或者断链的时候，其对应的节点就会消失，然后集群中所有对/APP1SERVERS进行watch的客户端都会收到通知，然后取得最新列表即可。\"></a>Zookeeper同样很容易实现这个功能，比如我在zookeeper服务器端有一个znode叫/APP1SERVERS,那么集群中每一个机器启动的时候都去这个节点下创建一个EPHEMERAL类型的节点，比如server1创建/APP1SERVERS/SERVER1(可以使用ip,保证不重复)，server2创建/APP1SERVERS/SERVER2，然后SERVER1和SERVER2都watch /APP1SERVERS这个父节点，那么也就是这个父节点下数据或者子节点变化都会通知对该节点进行watch的客户端。因为EPHEMERAL类型节点有一个很重要的特性，就是客户端和服务器端连接断掉或者session过期就会使节点消失，那么在某一个机器挂掉或者断链的时候，其对应的节点就会消失，然后集群中所有对/APP1SERVERS进行watch的客户端都会收到通知，然后取得最新列表即可。</h5><h5 id=\"另外有一个应用场景就是集群选master-一旦master挂掉能够马上能从slave中选出一个master-实现步骤和前者一样，只是机器在启动的时候在APP1SERVERS创建的节点类型变为EPHEMERAL-SEQUENTIAL类型，这样每个节点会自动被编号\"><a href=\"#另外有一个应用场景就是集群选master-一旦master挂掉能够马上能从slave中选出一个master-实现步骤和前者一样，只是机器在启动的时候在APP1SERVERS创建的节点类型变为EPHEMERAL-SEQUENTIAL类型，这样每个节点会自动被编号\" class=\"headerlink\" title=\"另外有一个应用场景就是集群选master,一旦master挂掉能够马上能从slave中选出一个master,实现步骤和前者一样，只是机器在启动的时候在APP1SERVERS创建的节点类型变为EPHEMERAL_SEQUENTIAL类型，这样每个节点会自动被编号\"></a>另外有一个应用场景就是集群选master,一旦master挂掉能够马上能从slave中选出一个master,实现步骤和前者一样，只是机器在启动的时候在APP1SERVERS创建的节点类型变为EPHEMERAL_SEQUENTIAL类型，这样每个节点会自动被编号</h5><h5 id=\"我们默认规定编号最小的为master-所以当我们对-APP1SERVERS节点做监控的时候，得到服务器列表，只要所有集群机器逻辑认为最小编号节点为master，那么master就被选出，而这个master宕机的时候，相应的znode会消失，然后新的服务器列表就被推送到客户端，然后每个节点逻辑认为最小编号节点为master，这样就做到动态master选举。\"><a href=\"#我们默认规定编号最小的为master-所以当我们对-APP1SERVERS节点做监控的时候，得到服务器列表，只要所有集群机器逻辑认为最小编号节点为master，那么master就被选出，而这个master宕机的时候，相应的znode会消失，然后新的服务器列表就被推送到客户端，然后每个节点逻辑认为最小编号节点为master，这样就做到动态master选举。\" class=\"headerlink\" title=\"我们默认规定编号最小的为master,所以当我们对/APP1SERVERS节点做监控的时候，得到服务器列表，只要所有集群机器逻辑认为最小编号节点为master，那么master就被选出，而这个master宕机的时候，相应的znode会消失，然后新的服务器列表就被推送到客户端，然后每个节点逻辑认为最小编号节点为master，这样就做到动态master选举。\"></a>我们默认规定编号最小的为master,所以当我们对/APP1SERVERS节点做监控的时候，得到服务器列表，只要所有集群机器逻辑认为最小编号节点为master，那么master就被选出，而这个master宕机的时候，相应的znode会消失，然后新的服务器列表就被推送到客户端，然后每个节点逻辑认为最小编号节点为master，这样就做到动态master选举。</h5><p><img src=\"../../img/zookeeper/zookeeper2.jpg\" alt=\"zookeeper流程图\"></p>\n<h4 id=\"Zookeeper-监视（Watches）-简介\"><a href=\"#Zookeeper-监视（Watches）-简介\" class=\"headerlink\" title=\"Zookeeper 监视（Watches） 简介\"></a>Zookeeper 监视（Watches） 简介</h4><h5 id=\"Zookeeper-C-API-的声明和描述在-include-zookeeper-h-中可以找到，另外大部分的-Zookeeper-C-API-常量、结构体声明也在-zookeeper-h-中，如果如果你在使用-C-API-是遇到不明白的地方，最好看看-zookeeper-h，或者自己使用-doxygen-生成-Zookeeper-C-API-的帮助文档。\"><a href=\"#Zookeeper-C-API-的声明和描述在-include-zookeeper-h-中可以找到，另外大部分的-Zookeeper-C-API-常量、结构体声明也在-zookeeper-h-中，如果如果你在使用-C-API-是遇到不明白的地方，最好看看-zookeeper-h，或者自己使用-doxygen-生成-Zookeeper-C-API-的帮助文档。\" class=\"headerlink\" title=\"Zookeeper C API 的声明和描述在 include/zookeeper.h 中可以找到，另外大部分的 Zookeeper C API 常量、结构体声明也在 zookeeper.h 中，如果如果你在使用 C API 是遇到不明白的地方，最好看看 zookeeper.h，或者自己使用 doxygen 生成 Zookeeper C API 的帮助文档。\"></a>Zookeeper C API 的声明和描述在 include/zookeeper.h 中可以找到，另外大部分的 Zookeeper C API 常量、结构体声明也在 zookeeper.h 中，如果如果你在使用 C API 是遇到不明白的地方，最好看看 zookeeper.h，或者自己使用 doxygen 生成 Zookeeper C API 的帮助文档。</h5><h5 id=\"Zookeeper-中最有特色且最不容易理解的是监视-Watches-。Zookeeper-所有的读操作——getData-getChildren-和-exists-都-可以设置监视-watch-，监视事件可以理解为一次性的触发器，-官方定义如下：-a-watch-event-is-one-time-trigger-sent-to-the-client-that-set-the-watch-which-occurs-when-the-data-for-which-the-watch-was-set-changes。对此需要作出如下理解：\"><a href=\"#Zookeeper-中最有特色且最不容易理解的是监视-Watches-。Zookeeper-所有的读操作——getData-getChildren-和-exists-都-可以设置监视-watch-，监视事件可以理解为一次性的触发器，-官方定义如下：-a-watch-event-is-one-time-trigger-sent-to-the-client-that-set-the-watch-which-occurs-when-the-data-for-which-the-watch-was-set-changes。对此需要作出如下理解：\" class=\"headerlink\" title=\"Zookeeper 中最有特色且最不容易理解的是监视(Watches)。Zookeeper 所有的读操作——getData(), getChildren(), 和 exists() 都 可以设置监视(watch)，监视事件可以理解为一次性的触发器， 官方定义如下： a watch event is one-time trigger, sent to the client that set the watch, which occurs when the data for which the watch was set changes。对此需要作出如下理解：\"></a>Zookeeper 中最有特色且最不容易理解的是监视(Watches)。Zookeeper 所有的读操作——getData(), getChildren(), 和 exists() 都 可以设置监视(watch)，监视事件可以理解为一次性的触发器， 官方定义如下： a watch event is one-time trigger, sent to the client that set the watch, which occurs when the data for which the watch was set changes。对此需要作出如下理解：</h5><ul>\n<li>（一次性触发）One-time trigger</li>\n</ul>\n<h5 id=\"当设置监视的数据发生改变时，该监视事件会被发送到客户端，例如，如果客户端调用了-getData-“-znode1”-true-并且稍后-znode1-节点上的数据发生了改变或者被删除了，客户端将会获取到-znode1-发生变化的监视事件，而如果-znode1-再一次发生了变化，除非客户端再次对-znode1-设置监视，否则客户端不会收到事件通知。\"><a href=\"#当设置监视的数据发生改变时，该监视事件会被发送到客户端，例如，如果客户端调用了-getData-“-znode1”-true-并且稍后-znode1-节点上的数据发生了改变或者被删除了，客户端将会获取到-znode1-发生变化的监视事件，而如果-znode1-再一次发生了变化，除非客户端再次对-znode1-设置监视，否则客户端不会收到事件通知。\" class=\"headerlink\" title=\"当设置监视的数据发生改变时，该监视事件会被发送到客户端，例如，如果客户端调用了 getData(“/znode1”, true) 并且稍后 /znode1 节点上的数据发生了改变或者被删除了，客户端将会获取到 /znode1 发生变化的监视事件，而如果 /znode1 再一次发生了变化，除非客户端再次对 /znode1 设置监视，否则客户端不会收到事件通知。\"></a>当设置监视的数据发生改变时，该监视事件会被发送到客户端，例如，如果客户端调用了 getData(“/znode1”, true) 并且稍后 /znode1 节点上的数据发生了改变或者被删除了，客户端将会获取到 /znode1 发生变化的监视事件，而如果 /znode1 再一次发生了变化，除非客户端再次对 /znode1 设置监视，否则客户端不会收到事件通知。</h5><ul>\n<li>（发送至客户端）Sent to the client</li>\n</ul>\n<h5 id=\"Zookeeper-客户端和服务端是通过-socket-进行通信的，由于网络存在故障，所以监视事件很有可能不会成功地到达客户端，监视事件是异步发送至监视者的，Zookeeper-本身提供了保序性-ordering-guarantee-：即客户端只有首先看到了监视事件后，才会感知到它所设置监视的-znode-发生了变化-a-client-will-never-see-a-change-for-which-it-has-set-a-watch-until-it-first-sees-the-watch-event-网络延迟或者其他因素可能导致不同的客户端在不同的时刻感知某一监视事件，但是不同的客户端所看到的一切具有一致的顺序。\"><a href=\"#Zookeeper-客户端和服务端是通过-socket-进行通信的，由于网络存在故障，所以监视事件很有可能不会成功地到达客户端，监视事件是异步发送至监视者的，Zookeeper-本身提供了保序性-ordering-guarantee-：即客户端只有首先看到了监视事件后，才会感知到它所设置监视的-znode-发生了变化-a-client-will-never-see-a-change-for-which-it-has-set-a-watch-until-it-first-sees-the-watch-event-网络延迟或者其他因素可能导致不同的客户端在不同的时刻感知某一监视事件，但是不同的客户端所看到的一切具有一致的顺序。\" class=\"headerlink\" title=\"Zookeeper 客户端和服务端是通过 socket 进行通信的，由于网络存在故障，所以监视事件很有可能不会成功地到达客户端，监视事件是异步发送至监视者的，Zookeeper 本身提供了保序性(ordering guarantee)：即客户端只有首先看到了监视事件后，才会感知到它所设置监视的 znode 发生了变化(a client will never see a change for which it has set a watch until it first sees the watch event). 网络延迟或者其他因素可能导致不同的客户端在不同的时刻感知某一监视事件，但是不同的客户端所看到的一切具有一致的顺序。\"></a>Zookeeper 客户端和服务端是通过 socket 进行通信的，由于网络存在故障，所以监视事件很有可能不会成功地到达客户端，监视事件是异步发送至监视者的，Zookeeper 本身提供了保序性(ordering guarantee)：即客户端只有首先看到了监视事件后，才会感知到它所设置监视的 znode 发生了变化(a client will never see a change for which it has set a watch until it first sees the watch event). 网络延迟或者其他因素可能导致不同的客户端在不同的时刻感知某一监视事件，但是不同的客户端所看到的一切具有一致的顺序。</h5><ul>\n<li>（被设置 watch 的数据）The data for which the watch was set</li>\n</ul>\n<h5 id=\"这意味着-znode-节点本身具有不同的改变方式。你也可以想象-Zookeeper-维护了两条监视链表：数据监视和子节点监视-data-watches-and-child-watches-getData-and-exists-设置数据监视，getChildren-设置子节点监视。-或者，你也可以想象-Zookeeper-设置的不同监视返回不同的数据，getData-和-exists-返回-znode-节点的相关信息，而-getChildren-返回子节点列表。因此，-setData-会触发设置在某一节点上所设置的数据监视-假定数据设置成功-，而一次成功的-create-操作则会出发当前节点上所设置的数据监视以及父节点的子节点监视。一次成功的-delete-操作将会触发当前节点的数据监视和子节点监视事件，同时也会触发该节点父节点的child-watch。\"><a href=\"#这意味着-znode-节点本身具有不同的改变方式。你也可以想象-Zookeeper-维护了两条监视链表：数据监视和子节点监视-data-watches-and-child-watches-getData-and-exists-设置数据监视，getChildren-设置子节点监视。-或者，你也可以想象-Zookeeper-设置的不同监视返回不同的数据，getData-和-exists-返回-znode-节点的相关信息，而-getChildren-返回子节点列表。因此，-setData-会触发设置在某一节点上所设置的数据监视-假定数据设置成功-，而一次成功的-create-操作则会出发当前节点上所设置的数据监视以及父节点的子节点监视。一次成功的-delete-操作将会触发当前节点的数据监视和子节点监视事件，同时也会触发该节点父节点的child-watch。\" class=\"headerlink\" title=\"这意味着 znode 节点本身具有不同的改变方式。你也可以想象 Zookeeper 维护了两条监视链表：数据监视和子节点监视(data watches and child watches) getData() and exists() 设置数据监视，getChildren() 设置子节点监视。 或者，你也可以想象 Zookeeper 设置的不同监视返回不同的数据，getData() 和 exists() 返回 znode 节点的相关信息，而 getChildren() 返回子节点列表。因此， setData() 会触发设置在某一节点上所设置的数据监视(假定数据设置成功)，而一次成功的 create() 操作则会出发当前节点上所设置的数据监视以及父节点的子节点监视。一次成功的 delete() 操作将会触发当前节点的数据监视和子节点监视事件，同时也会触发该节点父节点的child watch。\"></a>这意味着 znode 节点本身具有不同的改变方式。你也可以想象 Zookeeper 维护了两条监视链表：数据监视和子节点监视(data watches and child watches) getData() and exists() 设置数据监视，getChildren() 设置子节点监视。 或者，你也可以想象 Zookeeper 设置的不同监视返回不同的数据，getData() 和 exists() 返回 znode 节点的相关信息，而 getChildren() 返回子节点列表。因此， setData() 会触发设置在某一节点上所设置的数据监视(假定数据设置成功)，而一次成功的 create() 操作则会出发当前节点上所设置的数据监视以及父节点的子节点监视。一次成功的 delete() 操作将会触发当前节点的数据监视和子节点监视事件，同时也会触发该节点父节点的child watch。</h5><h5 id=\"Zookeeper-中的监视是轻量级的，因此容易设置、维护和分发。当客户端与-Zookeeper-服务器端失去联系时，客户端并不会收到监视事件的通知，只有当客户端重新连接后，若在必要的情况下，以前注册的监视会重新被注册并触发，对于开发人员来说-这通常是透明的。只有一种情况会导致监视事件的丢失，即：通过-exists-设置了某个-znode-节点的监视，但是如果某个客户端在此-znode-节点被创建和删除的时间间隔内与-zookeeper-服务器失去了联系，该客户端即使稍后重新连接-zookeeper服务器后也得不到事件通知。\"><a href=\"#Zookeeper-中的监视是轻量级的，因此容易设置、维护和分发。当客户端与-Zookeeper-服务器端失去联系时，客户端并不会收到监视事件的通知，只有当客户端重新连接后，若在必要的情况下，以前注册的监视会重新被注册并触发，对于开发人员来说-这通常是透明的。只有一种情况会导致监视事件的丢失，即：通过-exists-设置了某个-znode-节点的监视，但是如果某个客户端在此-znode-节点被创建和删除的时间间隔内与-zookeeper-服务器失去了联系，该客户端即使稍后重新连接-zookeeper服务器后也得不到事件通知。\" class=\"headerlink\" title=\"Zookeeper 中的监视是轻量级的，因此容易设置、维护和分发。当客户端与 Zookeeper 服务器端失去联系时，客户端并不会收到监视事件的通知，只有当客户端重新连接后，若在必要的情况下，以前注册的监视会重新被注册并触发，对于开发人员来说 这通常是透明的。只有一种情况会导致监视事件的丢失，即：通过 exists() 设置了某个 znode 节点的监视，但是如果某个客户端在此 znode 节点被创建和删除的时间间隔内与 zookeeper 服务器失去了联系，该客户端即使稍后重新连接 zookeeper服务器后也得不到事件通知。\"></a>Zookeeper 中的监视是轻量级的，因此容易设置、维护和分发。当客户端与 Zookeeper 服务器端失去联系时，客户端并不会收到监视事件的通知，只有当客户端重新连接后，若在必要的情况下，以前注册的监视会重新被注册并触发，对于开发人员来说 这通常是透明的。只有一种情况会导致监视事件的丢失，即：通过 exists() 设置了某个 znode 节点的监视，但是如果某个客户端在此 znode 节点被创建和删除的时间间隔内与 zookeeper 服务器失去了联系，该客户端即使稍后重新连接 zookeeper服务器后也得不到事件通知。</h5><h3 id=\"Zookeeper-C-API-常量与部分结构-struct-介绍\"><a href=\"#Zookeeper-C-API-常量与部分结构-struct-介绍\" class=\"headerlink\" title=\"Zookeeper C API 常量与部分结构(struct)介绍\"></a>Zookeeper C API 常量与部分结构(struct)介绍</h3><h4 id=\"与-ACL-相关的结构与常量：\"><a href=\"#与-ACL-相关的结构与常量：\" class=\"headerlink\" title=\"与 ACL 相关的结构与常量：\"></a>与 ACL 相关的结构与常量：</h4><h5 id=\"struct-Id-结构为：\"><a href=\"#struct-Id-结构为：\" class=\"headerlink\" title=\"struct Id 结构为：\"></a>struct Id 结构为：</h5><pre><code>struct Id {     char * scheme;     char * id; };\n</code></pre><h5 id=\"struct-ACL-结构为：\"><a href=\"#struct-ACL-结构为：\" class=\"headerlink\" title=\"struct ACL 结构为：\"></a>struct ACL 结构为：</h5><pre><code>struct ACL {     int32_t perms;     struct Id id; };\n</code></pre><h5 id=\"struct-ACL-vector-结构为：\"><a href=\"#struct-ACL-vector-结构为：\" class=\"headerlink\" title=\"struct ACL_vector 结构为：\"></a>struct ACL_vector 结构为：</h5><pre><code>struct ACL_vector {     int32_t count;     struct ACL *data; };\n</code></pre><h5 id=\"与-znode-访问权限有关的常量\"><a href=\"#与-znode-访问权限有关的常量\" class=\"headerlink\" title=\"与 znode 访问权限有关的常量\"></a>与 znode 访问权限有关的常量</h5><ul>\n<li>const int ZOO_PERM_READ; //允许客户端读取 znode 节点的值以及子节点列表。</li>\n<li>const int ZOO_PERM_WRITE;// 允许客户端设置 znode 节点的值。</li>\n<li>const int ZOO_PERM_CREATE; //允许客户端在该 znode 节点下创建子节点。</li>\n<li>const int ZOO_PERM_DELETE;//允许客户端删除子节点。</li>\n<li>const int ZOO_PERM_ADMIN; //允许客户端执行 set_acl()。</li>\n<li>const int ZOO_PERM_ALL;//允许客户端执行所有操作，等价与上述所有标志的或(OR) 。</li>\n</ul>\n<h5 id=\"与-ACL-IDs-相关的常量\"><a href=\"#与-ACL-IDs-相关的常量\" class=\"headerlink\" title=\"与 ACL IDs 相关的常量\"></a>与 ACL IDs 相关的常量</h5><ul>\n<li>struct Id ZOO_ANYONE_ID_UNSAFE; //(‘world’,’anyone’)</li>\n<li>struct Id ZOO_AUTH_IDS;// (‘auth’,’’)</li>\n</ul>\n<h5 id=\"三种标准的-ACL\"><a href=\"#三种标准的-ACL\" class=\"headerlink\" title=\"三种标准的 ACL\"></a>三种标准的 ACL</h5><ul>\n<li>struct ACL_vector ZOO_OPEN_ACL_UNSAFE; //(ZOO_PERM_ALL,ZOO_ANYONE_ID_UNSAFE)</li>\n<li>struct ACL_vector ZOO_READ_ACL_UNSAFE;// (ZOO_PERM_READ, ZOO_ANYONE_ID_UNSAFE)</li>\n<li>struct ACL_vector ZOO_CREATOR_ALL_ACL; //(ZOO_PERM_ALL,ZOO_AUTH_IDS)</li>\n</ul>\n<h4 id=\"与-Interest-相关的常量：ZOOKEEPER-WRITE-ZOOKEEPER-READ\"><a href=\"#与-Interest-相关的常量：ZOOKEEPER-WRITE-ZOOKEEPER-READ\" class=\"headerlink\" title=\"与 Interest 相关的常量：ZOOKEEPER_WRITE, ZOOKEEPER_READ\"></a>与 Interest 相关的常量：ZOOKEEPER_WRITE, ZOOKEEPER_READ</h4><h5 id=\"这两个常量用于标识感兴趣的事件并通知zookeeper发生了哪些事件。Interest-常量可以进行组合或（OR）来标识多种兴趣-multiple-interests-write-read-，这两个常量一般用于-zookeeper-interest-和-zookeeper-process-两个函数中。\"><a href=\"#这两个常量用于标识感兴趣的事件并通知zookeeper发生了哪些事件。Interest-常量可以进行组合或（OR）来标识多种兴趣-multiple-interests-write-read-，这两个常量一般用于-zookeeper-interest-和-zookeeper-process-两个函数中。\" class=\"headerlink\" title=\"这两个常量用于标识感兴趣的事件并通知zookeeper发生了哪些事件。Interest 常量可以进行组合或（OR）来标识多种兴趣(multiple interests: write, read)，这两个常量一般用于 zookeeper_interest() 和 zookeeper_process()两个函数中。\"></a>这两个常量用于标识感兴趣的事件并通知zookeeper发生了哪些事件。Interest 常量可以进行组合或（OR）来标识多种兴趣(multiple interests: write, read)，这两个常量一般用于 zookeeper_interest() 和 zookeeper_process()两个函数中。</h5><h4 id=\"与节点创建相关的常量：ZOO-EPHEMERAL-ZOO-SEQUENCE\"><a href=\"#与节点创建相关的常量：ZOO-EPHEMERAL-ZOO-SEQUENCE\" class=\"headerlink\" title=\"与节点创建相关的常量：ZOO_EPHEMERAL, ZOO_SEQUENCE\"></a>与节点创建相关的常量：ZOO_EPHEMERAL, ZOO_SEQUENCE</h4><h5 id=\"zoo-create-函数标志，ZOO-EPHEMERAL-用来标识创建临时节点，ZOO-SEQUENCE-用来标识节点命名具有递增的后缀序号-一般是节点名称后填充-10-位字符的序号，如-xyz0000000000-xyz0000000001-xyz0000000002-…-，同样地，ZOO-EPHEMERAL-ZOO-SEQUENCE-可以组合。\"><a href=\"#zoo-create-函数标志，ZOO-EPHEMERAL-用来标识创建临时节点，ZOO-SEQUENCE-用来标识节点命名具有递增的后缀序号-一般是节点名称后填充-10-位字符的序号，如-xyz0000000000-xyz0000000001-xyz0000000002-…-，同样地，ZOO-EPHEMERAL-ZOO-SEQUENCE-可以组合。\" class=\"headerlink\" title=\"zoo_create 函数标志，ZOO_EPHEMERAL 用来标识创建临时节点，ZOO_SEQUENCE 用来标识节点命名具有递增的后缀序号(一般是节点名称后填充 10 位字符的序号，如 /xyz0000000000, /xyz0000000001, /xyz0000000002, …)，同样地，ZOO_EPHEMERAL, ZOO_SEQUENCE 可以组合。\"></a>zoo_create 函数标志，ZOO_EPHEMERAL 用来标识创建临时节点，ZOO_SEQUENCE 用来标识节点命名具有递增的后缀序号(一般是节点名称后填充 10 位字符的序号，如 /xyz0000000000, /xyz0000000001, /xyz0000000002, …)，同样地，ZOO_EPHEMERAL, ZOO_SEQUENCE 可以组合。</h5><h4 id=\"与连接状态-Stat-相关的常量\"><a href=\"#与连接状态-Stat-相关的常量\" class=\"headerlink\" title=\"与连接状态 Stat 相关的常量\"></a>与连接状态 Stat 相关的常量</h4><h5 id=\"以下常量均与-Zookeeper-连接状态有关，他们通常用作监视器回调函数的参数。\"><a href=\"#以下常量均与-Zookeeper-连接状态有关，他们通常用作监视器回调函数的参数。\" class=\"headerlink\" title=\"以下常量均与 Zookeeper 连接状态有关，他们通常用作监视器回调函数的参数。\"></a>以下常量均与 Zookeeper 连接状态有关，他们通常用作监视器回调函数的参数。</h5><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">ZOOAPI const int</th>\n<th style=\"text-align:left\">ZOO_EXPIRED_SESSION_STATE</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ZOOAPI const int</td>\n<td style=\"text-align:left\">ZOO_AUTH_FAILED_STATE</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ZOOAPI const int</td>\n<td style=\"text-align:left\">ZOO_CONNECTING_STATE</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ZOOAPI const int</td>\n<td style=\"text-align:left\">ZOO_ASSOCIATING_STATE</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ZOOAPI const int</td>\n<td style=\"text-align:left\">ZOO_CONNECTED_STATE</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h4 id=\"与监视类型-Watch-Types-相关的常量\"><a href=\"#与监视类型-Watch-Types-相关的常量\" class=\"headerlink\" title=\"与监视类型(Watch Types)相关的常量\"></a>与监视类型(Watch Types)相关的常量</h4><h5 id=\"以下常量标识监视事件的类型，他们通常用作监视器回调函数的第一个参数。\"><a href=\"#以下常量标识监视事件的类型，他们通常用作监视器回调函数的第一个参数。\" class=\"headerlink\" title=\"以下常量标识监视事件的类型，他们通常用作监视器回调函数的第一个参数。\"></a>以下常量标识监视事件的类型，他们通常用作监视器回调函数的第一个参数。</h5><ul>\n<li>ZOO_CREATED_EVENT; // 节点被创建(此前该节点不存在)，通过 zoo_exists() 设置监视。</li>\n<li>ZOO_DELETED_EVENT; // 节点被删除，通过 zoo_exists() 和 zoo_get() 设置监视。</li>\n<li>ZOO_CHANGED_EVENT; // 节点发生变化，通过 zoo_exists() 和 zoo_get() 设置监视。</li>\n<li>ZOO_CHILD_EVENT; // 子节点事件，通过zoo_get_children() 和 zoo_get_children2()设置监视。</li>\n<li>ZOO_SESSION_EVENT; // 会话丢失</li>\n<li>ZOO_NOTWATCHING_EVENT; // 监视被移除。</li>\n</ul>\n<h4 id=\"Zookeeper-C-API-错误码介绍-ZOO-ERRORS\"><a href=\"#Zookeeper-C-API-错误码介绍-ZOO-ERRORS\" class=\"headerlink\" title=\"Zookeeper C API 错误码介绍 ZOO_ERRORS\"></a>Zookeeper C API 错误码介绍 ZOO_ERRORS</h4><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>ZOK</th>\n<th>正常返回</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ZSYSTEMERROR</td>\n<td>系统或服务器端错误(System and server-side errors)，服务器不会抛出该错误，该错误也只是用来标识错误范围的，即大于该错误值，且小于 ZAPIERROR 都是系统错误。</td>\n</tr>\n<tr>\n<td>ZRUNTIMEINCONSISTENCY</td>\n<td>运行时非一致性错误。</td>\n</tr>\n<tr>\n<td>ZDATAINCONSISTENCY</td>\n<td>数据非一致性错误。</td>\n</tr>\n<tr>\n<td>ZCONNECTIONLOSS</td>\n<td>Zookeeper 客户端与服务器端失去连接</td>\n</tr>\n<tr>\n<td>ZMARSHALLINGERROR</td>\n<td>在 marshalling 和 unmarshalling 数据时出现错误(Error while marshalling or unmarshalling data)</td>\n</tr>\n<tr>\n<td>ZUNIMPLEMENTED</td>\n<td>该操作未实现(Operation is unimplemented)</td>\n</tr>\n<tr>\n<td>ZOPERATIONTIMEOUT</td>\n<td>该操作超时(Operation timeout)</td>\n</tr>\n<tr>\n<td>ZBADARGUMENTS</td>\n<td>非法参数错误(Invalid arguments)</td>\n</tr>\n<tr>\n<td>ZINVALIDSTATE</td>\n<td>非法句柄状态(Invliad zhandle state)</td>\n</tr>\n<tr>\n<td>ZAPIERROR</td>\n<td>API 错误(API errors)，服务器不会抛出该错误，该错误也只是用来标识错误范围的，错误值大于该值的标识 API 错误，而小于该值的标识 ZSYSTEMERROR。</td>\n</tr>\n<tr>\n<td>ZNONODE</td>\n<td>节点不存在(Node does not exist)</td>\n</tr>\n<tr>\n<td>ZNOAUTH</td>\n<td>没有经过授权(Not authenticated)</td>\n</tr>\n<tr>\n<td>ZBADVERSION</td>\n<td>版本冲突(Version conflict)</td>\n</tr>\n<tr>\n<td>ZNOCHILDRENFOREPHEMERALS</td>\n<td>临时节点不能拥有子节点(Ephemeral nodes may not have children)</td>\n</tr>\n<tr>\n<td>ZNODEEXISTS</td>\n<td>节点已经存在(The node already exists)</td>\n</tr>\n<tr>\n<td>ZNOTEMPTY</td>\n<td>该节点具有自身的子节点(The node has children)</td>\n</tr>\n<tr>\n<td>ZSESSIONEXPIRED</td>\n<td>会话过期(The session has been expired by the server)</td>\n</tr>\n<tr>\n<td>ZINVALIDCALLBACK</td>\n<td>非法的回调函数(Invalid callback specified)</td>\n</tr>\n<tr>\n<td>ZINVALIDACL</td>\n<td>非法的ACL(Invalid ACL specified)</td>\n</tr>\n<tr>\n<td>ZAUTHFAILED</td>\n<td>客户端授权失败(Client authentication failed)</td>\n</tr>\n<tr>\n<td>ZCLOSING</td>\n<td>Zookeeper 连接关闭(ZooKeeper is closing)</td>\n</tr>\n<tr>\n<td>ZNOTHING</td>\n<td>并非错误，客户端不需要处理服务器的响应(not error, no server responses to process)</td>\n</tr>\n<tr>\n<td>ZSESSIONMOVED</td>\n<td>会话转移至其他服务器，所以操作被忽略(session moved to another server, so operation is ignored) </td>\n</tr>\n</tbody>\n</table>\n</div>\n<h5 id=\"Watch事件类型：\"><a href=\"#Watch事件类型：\" class=\"headerlink\" title=\"Watch事件类型：\"></a>Watch事件类型：</h5><ul>\n<li>ZOO_CREATED_EVENT：节点创建事件，需要watch一个不存在的节点，当节点被创建时触发，此watch通过zoo_exists()设置</li>\n<li>ZOO_DELETED_EVENT：节点删除事件，此watch通过zoo_exists()或zoo_get()设置</li>\n<li>ZOO_CHANGED_EVENT：节点数据改变事件，此watch通过zoo_exists()或zoo_get()设置</li>\n<li>ZOO_CHILD_EVENT：子节点列表改变事件，此watch通过zoo_get_children()或zoo_get_children2()设置</li>\n<li>ZOO_SESSION_EVENT：会话失效事件，客户端与服务端断开或重连时触发</li>\n<li>ZOO_NOTWATCHING_EVENT：watch移除事件，服务端出于某些原因不再为客户端watch节点时触发</li>\n</ul>"},{"layout":"post","title":"spring boot 动态启动与加载","date":"2017-08-30T16:00:00.000Z","original":true,"tag":[["spring","spring"],["java","java"]],"top":1,"topTag":["index"],"_content":"\n##### 　　通常情况下，我们通过XML或者Annotation两种方式配置Bean Definition。从Spring 3.0开始，增加了一种新的途径来配置Bean Definition，这就是通过Java Code配置Bean Definition。\n<!--more-->\n\n#### Java Code配置与XML和Annotation两种配置方式不同点在于：\n##### 　　前两种方式XML和Annotation的配置方式为预定义方式，即开发人员通过XML文件或者Annotation预定义配置Bean的各种属性后，启动Spring容器，Spring容器会首先解析这些配置属性，生成对应的Bean Definition,装入到`DefaultListtableBeanFactory`对象的属性容器中，以此同时，Spring框架也会定义内部使用的Bean定义，如Bean名为：`org.springframework.context.annotation.internalConfigurationAnnotationProcessor`的 `ConfigurationClassPostProcessor` 定义。而后此刻不会做任何Bean Definition的解析动作，Spring框架会根据前两种配置，过滤出`BeanDefinitionRegistryPostProcessor` 类型的Bean定义，并通过Spring框架生成对应的Bean对象（如 `ConfigurationClassPostProcessor` 实例）。结合 Spring 上下文源码可知这个对象是一个 processor 类型工具类，<u>Spring容器会在实例化开发人员所定义的 Bean 前先调用该 processor 的 postProcessBeanDefinitionRegistry(…) 方法。此处实现基于 Java Code 配置Bean Definition的处理</u>。\n\n##### 　　基于 Java Code 的配置方式，其执行原理不同于前两种。它是在 Spring 框架已经解析了基于 XML 和 Annotation 配置后，通过加入 BeanDefinitionRegistryPostProcessor 类型的 processor 来处理配置信息，让开发人员通过 Java 编程方式定义一个 Java 对象。其优点在于可以将配置信息集中在一定数量的 Java 对象中，同时通过 Java 编程方式，比基于 Annotation 方式具有更高的灵活性。并且该配置方式给开发人员提供了一种非常好的范例来增加用户自定义的解析工具类。其主要缺点在于与 Java 代码结合紧密，配置信息的改变需要重新编译 Java 代码，另外这是一种新引入的解析方式，需要一定的学习成本。\n\n<br/>\n\n#### 提及一点的就是，Spring框架有3个主要的Hook类，分别是：\n`org.springframework.context.ApplicationContextAware`\n##### 它的setApplicationContext 方法将在Spring启动之前第一个被调用。\n`org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor`\n##### 它的postProcessBeanDefinitionRegistry 和 postProcessBeanFactory 方法是第二和第三被调用，它们在Bean初始化创建之前启动，如果Spring的bean需要的其他第三方中的组件，我们在这里将其注入给Spring。\n`org.springframework.context.ApplicationListener`\n用于在初始化完成后做一些事情，当Spring所有XML或元注解的Bean都启动被创建成功了，这时会调用它的唯一方法onApplicationEvent。\n<br/>\n#### 通过 BeanDefinitionRegistryPostProcessor 加载自己的bean的demo：\n```java\nimport org.springframework.beans.BeansException;\nimport org.springframework.beans.MutablePropertyValues;\nimport org.springframework.beans.factory.annotation.AnnotatedBeanDefinition;\nimport org.springframework.beans.factory.annotation.AnnotatedGenericBeanDefinition;\nimport org.springframework.beans.factory.config.BeanDefinition;\nimport org.springframework.beans.factory.config.BeanDefinitionHolder;\nimport org.springframework.beans.factory.config.ConfigurableListableBeanFactory;\nimport org.springframework.beans.factory.support.BeanDefinitionReaderUtils;\nimport org.springframework.beans.factory.support.BeanDefinitionRegistry;\nimport org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor;\n\n/**\n * @author winx\n * @create 2017-09-01.\n */\n@Configuration\npublic class MyBeanDefinitionRegistryPostProcessor implements BeanDefinitionRegistryPostProcessor {\n\n    /**\n     * 先执行：postProcessBeanDefinitionRegistry()方法\n     * 通过Class对象，注册自己的 BeanDefinition\n     */\n    @Override\n    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException {\n        try {\n            AnnotatedBeanDefinition annotatedBeanDefinition = new AnnotatedGenericBeanDefinition(Class.forName(\"\"));\n            BeanDefinitionHolder beanDefinitionHolder = new BeanDefinitionHolder(annotatedBeanDefinition, \"beanName\");\n            BeanDefinitionReaderUtils.registerBeanDefinition(beanDefinitionHolder, registry);\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * 再执行：postProcessBeanFactory()方法。\n     * 通过 beanName 拿到注册后的 BeanDefinition\n     * 然后加入自定义属性，BeanDefinition 会在初始化bean时，将 Property 键值对插入到之前的Class对象属性中。\n     */\n    @Override\n    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {\n        BeanDefinition beanDefinition = beanFactory.getBeanDefinition(\"beanName\");\n        MutablePropertyValues mutablePropertyValues = beanDefinition.getPropertyValues();\n        //加入属性.\n        mutablePropertyValues.addPropertyValue(\"username\", \"root\");\n    }\n}\n```\n\n##### `@Configuration`注解提示spring boot通过该类加载bean\n##### `postProcessBeanDefinitionRegistry()` 通过Class对象，注册自己的 BeanDefinition\n##### `postProcessBeanFactory()`方法会在`postProcessBeanDefinitionRegistry()`之后执行， 通过beanFactory拿到 BeanDefinition 后加入属性，这一步可以跳过。\n\n### 实际项目需求\n##### 　　目前项目分为线上环境和dev环境，项目本身只支持http服务，因为线上环境有nginx做反向代理，所以用http和https均能正常访问线上服务。但是本地环境相对简单，不能支持https服务。先在需要根据环境的不同。动态的扩张spring boot的多连接器设置。当环境为dev时，即加载多连接器，分别用两个端口提供http和https服务。当环境不为dev时，只加载默认http即可。\n##### 　　根据这些需求，通过xml或者annotation去定义bean都不太合适。只能是通过java code去判断环境并动态加载。\n\n##### 　　省去spring boot支持https以及多连接器的配置，相关的代码网络上很多。直接说遇到的主要问题吧。上面的demo通过`mutablePropertyValues.addPropertyValue(\"key\", \"root\");`的方式为目标class定义属性，但是要求属性key必须有相应的set方法。\n\n```java\n@Configuration\npublic class HttpsBeanDefinitionRegistryPostProcessor implements BeanDefinitionRegistryPostProcessor, EnvironmentAware {\n\n    private String profile;\n\n    @Override\n    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry beanDefinitionRegistry) throws BeansException {\n        if (\"dev\".equals(profile)){\n            AnnotatedBeanDefinition annotatedBeanDefinition = new AnnotatedGenericBeanDefinition(TomcatEmbeddedServletContainerFactory.class);\n            BeanDefinitionHolder beanDefinitionHolder = new BeanDefinitionHolder(annotatedBeanDefinition, \"tomcatEmbeddedServletContainerFactory\");\n            BeanDefinitionReaderUtils.registerBeanDefinition(beanDefinitionHolder, beanDefinitionRegistry);\n        }\n    }\n\n    @Override\n    public void postProcessBeanFactory(ConfigurableListableBeanFactory configurableListableBeanFactory) throws BeansException {\n        MutablePropertyValues tomcatEmbeddedServletContainerFactory = configurableListableBeanFactory.getBeanDefinition(\"tomcatEmbeddedServletContainerFactory\").getPropertyValues();\n        tomcatEmbeddedServletContainerFactory.addPropertyValue(\"additionalTomcatConnectors\", getConnector());\n    }\n\n    public Connector getConnector(){\n        Connector connector = new Connector(\"org.apache.coyote.http11.Http11NioProtocol\");\n        Http11NioProtocol protocol = (Http11NioProtocol) connector.getProtocolHandler();\n        connector.setScheme(\"https\");\n        connector.setSecure(true);\n        connector.setPort(8443);\n        protocol.setSSLEnabled(true);\n        protocol.setKeystoreFile(\"/Users/winx/.keystore\");\n        protocol.setKeystorePass(\"123456\");\n        protocol.setTruststoreFile(\"/Users/winx/.keystore\");\n        protocol.setTruststorePass(\"123456\");\n        protocol.setKeyAlias(\"tomcat\");\n        return connector;\n    }\n\n    @Override\n    public void setEnvironment(Environment environment) {\n        profile = environment.getProperty(\"profile\");\n    }\n}\n```\n\n##### 　　在拿到`MutablePropertyValues`之后，想要给`TomcatEmbeddedServletContainerFactory`对象设置`additionalTomcatConnectors`属性，Connector中包含了https关键信息的设置。之后报错如下：\n```\norg.springframework.context.ApplicationContextException: Unable to start embedded container; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'tomcatEmbeddedServletContainerFactory': Error setting property values; nested exception is org.springframework.beans.NotWritablePropertyException: Invalid property 'additionalTomcatConnectors' of bean class [org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedServletContainerFactory]: Bean property 'additionalTomcatConnectors' is not writable or has an invalid setter method. Does the parameter type of the setter match the return type of the getter?\n\tat org.springframework.boot.context.embedded.EmbeddedWebApplicationContext.onRefresh(EmbeddedWebApplicationContext.java:133) ~[spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n\tat org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:532) ~[spring-context-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n\tat org.springframework.boot.context.embedded.EmbeddedWebApplicationContext.refresh(EmbeddedWebApplicationContext.java:118) ~[spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n\tat org.springframework.boot.SpringApplication.refresh(SpringApplication.java:760) [spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n\tat org.springframework.boot.SpringApplication.createAndRefreshContext(SpringApplication.java:360) [spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n\tat org.springframework.boot.SpringApplication.run(SpringApplication.java:306) [spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n\tat org.springframework.boot.SpringApplication.run(SpringApplication.java:1185) [spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n\tat org.springframework.boot.SpringApplication.run(SpringApplication.java:1174) [spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n\tat com.winx.es.metis.RunMetis.main(RunMetis.java:47) [classes/:na]\nCaused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'tomcatEmbeddedServletContainerFactory': Error setting property values; nested exception is org.springframework.beans.NotWritablePropertyException: Invalid property 'additionalTomcatConnectors' of bean class [org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedServletContainerFactory]: Bean property 'additionalTomcatConnectors' is not writable or has an invalid setter method. Does the parameter type of the setter match the return type of the getter?\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyPropertyValues(AbstractAutowireCapableBeanFactory.java:1518) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1226) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:543) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:482) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n\tat org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:306) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n\tat org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:302) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n\tat org.springframework.boot.context.embedded.EmbeddedWebApplicationContext.getEmbeddedServletContainerFactory(EmbeddedWebApplicationContext.java:195) ~[spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n\tat org.springframework.boot.context.embedded.EmbeddedWebApplicationContext.createEmbeddedServletContainer(EmbeddedWebApplicationContext.java:158) ~[spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n\tat org.springframework.boot.context.embedded.EmbeddedWebApplicationContext.onRefresh(EmbeddedWebApplicationContext.java:130) ~[spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n\t... 8 common frames omitted\nCaused by: org.springframework.beans.NotWritablePropertyException: Invalid property 'additionalTomcatConnectors' of bean class [org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedServletContainerFactory]: Bean property 'additionalTomcatConnectors' is not writable or has an invalid setter method. Does the parameter type of the setter match the return type of the getter?\n\tat org.springframework.beans.BeanWrapperImpl.createNotWritablePropertyException(BeanWrapperImpl.java:230) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n\tat org.springframework.beans.AbstractNestablePropertyAccessor.setPropertyValue(AbstractNestablePropertyAccessor.java:423) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n\tat org.springframework.beans.AbstractNestablePropertyAccessor.setPropertyValue(AbstractNestablePropertyAccessor.java:280) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n\tat org.springframework.beans.AbstractPropertyAccessor.setPropertyValues(AbstractPropertyAccessor.java:95) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n\tat org.springframework.beans.AbstractPropertyAccessor.setPropertyValues(AbstractPropertyAccessor.java:75) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyPropertyValues(AbstractAutowireCapableBeanFactory.java:1514) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n\t... 18 common frames omitted\n```\n\n##### 　　**关键错误信息**：`Bean property 'additionalTomcatConnectors' is not writable or has an invalid setter method. Does the parameter type of the setter match the return type of the getter?`，没有权限写入以及没有找到相应的个体方法。\n\n##### 查看`TomcatEmbeddedServletContainerFactory`源码后发现其相应的设置方法如下：\n```java\npublic void addAdditionalTomcatConnectors(Connector... connectors) {\n    Assert.notNull(connectors, \"Connectors must not be null\");\n    this.additionalTomcatConnectors.addAll(Arrays.asList(connectors));\n}\n```\n\n##### 　　顿时觉得坑爹的add啊，之后在Bean Definition的私有属性设置，以及通过方法设置属性值得方向去尝试解决问题，没有任何效果。几乎快要绝望的时候，突然灵机一动，为什么我不能自己定义一个不需要后置设置属性的`TomcatEmbeddedServletContainerFactory`呢，于是有了下面的代码：\n\n```java\n@Configuration\npublic class HttpsBeanDefinitionRegistryPostProcessor implements BeanDefinitionRegistryPostProcessor, EnvironmentAware {\n\n    private String profile;\n\n    @Override\n    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry beanDefinitionRegistry) throws BeansException {\n        if (\"dev\".equals(profile)){\n            AnnotatedBeanDefinition annotatedBeanDefinition = new AnnotatedGenericBeanDefinition(HttpsTomcatEmbeddedServletContainerFactory.class);\n            BeanDefinitionHolder beanDefinitionHolder = new BeanDefinitionHolder(annotatedBeanDefinition, \"tomcatEmbeddedServletContainerFactory\");\n            BeanDefinitionReaderUtils.registerBeanDefinition(beanDefinitionHolder, beanDefinitionRegistry);\n        }\n    }\n\n    @Override\n    public void postProcessBeanFactory(ConfigurableListableBeanFactory configurableListableBeanFactory) throws BeansException {}\n\n\n    @Override\n    public void setEnvironment(Environment environment) {\n        profile = environment.getProperty(\"profile\");\n    }\n}\n```\n\n##### 　　注意上面的注入对象是`HttpsTomcatEmbeddedServletContainerFactory`，不是之前的`TomcatEmbeddedServletContainerFactory`，贴上`HttpsTomcatEmbeddedServletContainerFactory`代码：\n\n```java\nimport org.apache.catalina.connector.Connector;\nimport org.apache.coyote.http11.Http11NioProtocol;\nimport org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedServletContainerFactory;\n\n/**\n * @author winx\n * @create 2017-09-01.\n */\npublic class HttpsTomcatEmbeddedServletContainerFactory extends TomcatEmbeddedServletContainerFactory {\n\n    public HttpsTomcatEmbeddedServletContainerFactory() {\n        super();\n        Connector connector = new Connector(\"org.apache.coyote.http11.Http11NioProtocol\");\n        Http11NioProtocol protocol = (Http11NioProtocol) connector.getProtocolHandler();\n        connector.setScheme(\"https\");\n        connector.setSecure(true);\n        connector.setPort(8443);\n        protocol.setSSLEnabled(true);\n        protocol.setKeystoreFile(\"/Users/winx/.keystore\");\n        protocol.setKeystorePass(\"123456\");\n        protocol.setTruststoreFile(\"/Users/winx/.keystore\");\n        protocol.setTruststorePass(\"123456\");\n        protocol.setKeyAlias(\"tomcat\");\n        addAdditionalTomcatConnectors(connector);\n    }\n}\n```\n\n##### 成功的解决了之前属性设置问题。","source":"_posts/note/springbootDynamic.md","raw":"---\nlayout: post\ntitle: spring boot 动态启动与加载\ndate: 2017/08/31\ntags: [tech, note, index, spring, java]\noriginal: true\ntag: [[spring, spring],[java, java]]\ntop: 1\ntopTag: [index]\n---\n\n##### 　　通常情况下，我们通过XML或者Annotation两种方式配置Bean Definition。从Spring 3.0开始，增加了一种新的途径来配置Bean Definition，这就是通过Java Code配置Bean Definition。\n<!--more-->\n\n#### Java Code配置与XML和Annotation两种配置方式不同点在于：\n##### 　　前两种方式XML和Annotation的配置方式为预定义方式，即开发人员通过XML文件或者Annotation预定义配置Bean的各种属性后，启动Spring容器，Spring容器会首先解析这些配置属性，生成对应的Bean Definition,装入到`DefaultListtableBeanFactory`对象的属性容器中，以此同时，Spring框架也会定义内部使用的Bean定义，如Bean名为：`org.springframework.context.annotation.internalConfigurationAnnotationProcessor`的 `ConfigurationClassPostProcessor` 定义。而后此刻不会做任何Bean Definition的解析动作，Spring框架会根据前两种配置，过滤出`BeanDefinitionRegistryPostProcessor` 类型的Bean定义，并通过Spring框架生成对应的Bean对象（如 `ConfigurationClassPostProcessor` 实例）。结合 Spring 上下文源码可知这个对象是一个 processor 类型工具类，<u>Spring容器会在实例化开发人员所定义的 Bean 前先调用该 processor 的 postProcessBeanDefinitionRegistry(…) 方法。此处实现基于 Java Code 配置Bean Definition的处理</u>。\n\n##### 　　基于 Java Code 的配置方式，其执行原理不同于前两种。它是在 Spring 框架已经解析了基于 XML 和 Annotation 配置后，通过加入 BeanDefinitionRegistryPostProcessor 类型的 processor 来处理配置信息，让开发人员通过 Java 编程方式定义一个 Java 对象。其优点在于可以将配置信息集中在一定数量的 Java 对象中，同时通过 Java 编程方式，比基于 Annotation 方式具有更高的灵活性。并且该配置方式给开发人员提供了一种非常好的范例来增加用户自定义的解析工具类。其主要缺点在于与 Java 代码结合紧密，配置信息的改变需要重新编译 Java 代码，另外这是一种新引入的解析方式，需要一定的学习成本。\n\n<br/>\n\n#### 提及一点的就是，Spring框架有3个主要的Hook类，分别是：\n`org.springframework.context.ApplicationContextAware`\n##### 它的setApplicationContext 方法将在Spring启动之前第一个被调用。\n`org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor`\n##### 它的postProcessBeanDefinitionRegistry 和 postProcessBeanFactory 方法是第二和第三被调用，它们在Bean初始化创建之前启动，如果Spring的bean需要的其他第三方中的组件，我们在这里将其注入给Spring。\n`org.springframework.context.ApplicationListener`\n用于在初始化完成后做一些事情，当Spring所有XML或元注解的Bean都启动被创建成功了，这时会调用它的唯一方法onApplicationEvent。\n<br/>\n#### 通过 BeanDefinitionRegistryPostProcessor 加载自己的bean的demo：\n```java\nimport org.springframework.beans.BeansException;\nimport org.springframework.beans.MutablePropertyValues;\nimport org.springframework.beans.factory.annotation.AnnotatedBeanDefinition;\nimport org.springframework.beans.factory.annotation.AnnotatedGenericBeanDefinition;\nimport org.springframework.beans.factory.config.BeanDefinition;\nimport org.springframework.beans.factory.config.BeanDefinitionHolder;\nimport org.springframework.beans.factory.config.ConfigurableListableBeanFactory;\nimport org.springframework.beans.factory.support.BeanDefinitionReaderUtils;\nimport org.springframework.beans.factory.support.BeanDefinitionRegistry;\nimport org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor;\n\n/**\n * @author winx\n * @create 2017-09-01.\n */\n@Configuration\npublic class MyBeanDefinitionRegistryPostProcessor implements BeanDefinitionRegistryPostProcessor {\n\n    /**\n     * 先执行：postProcessBeanDefinitionRegistry()方法\n     * 通过Class对象，注册自己的 BeanDefinition\n     */\n    @Override\n    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException {\n        try {\n            AnnotatedBeanDefinition annotatedBeanDefinition = new AnnotatedGenericBeanDefinition(Class.forName(\"\"));\n            BeanDefinitionHolder beanDefinitionHolder = new BeanDefinitionHolder(annotatedBeanDefinition, \"beanName\");\n            BeanDefinitionReaderUtils.registerBeanDefinition(beanDefinitionHolder, registry);\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * 再执行：postProcessBeanFactory()方法。\n     * 通过 beanName 拿到注册后的 BeanDefinition\n     * 然后加入自定义属性，BeanDefinition 会在初始化bean时，将 Property 键值对插入到之前的Class对象属性中。\n     */\n    @Override\n    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {\n        BeanDefinition beanDefinition = beanFactory.getBeanDefinition(\"beanName\");\n        MutablePropertyValues mutablePropertyValues = beanDefinition.getPropertyValues();\n        //加入属性.\n        mutablePropertyValues.addPropertyValue(\"username\", \"root\");\n    }\n}\n```\n\n##### `@Configuration`注解提示spring boot通过该类加载bean\n##### `postProcessBeanDefinitionRegistry()` 通过Class对象，注册自己的 BeanDefinition\n##### `postProcessBeanFactory()`方法会在`postProcessBeanDefinitionRegistry()`之后执行， 通过beanFactory拿到 BeanDefinition 后加入属性，这一步可以跳过。\n\n### 实际项目需求\n##### 　　目前项目分为线上环境和dev环境，项目本身只支持http服务，因为线上环境有nginx做反向代理，所以用http和https均能正常访问线上服务。但是本地环境相对简单，不能支持https服务。先在需要根据环境的不同。动态的扩张spring boot的多连接器设置。当环境为dev时，即加载多连接器，分别用两个端口提供http和https服务。当环境不为dev时，只加载默认http即可。\n##### 　　根据这些需求，通过xml或者annotation去定义bean都不太合适。只能是通过java code去判断环境并动态加载。\n\n##### 　　省去spring boot支持https以及多连接器的配置，相关的代码网络上很多。直接说遇到的主要问题吧。上面的demo通过`mutablePropertyValues.addPropertyValue(\"key\", \"root\");`的方式为目标class定义属性，但是要求属性key必须有相应的set方法。\n\n```java\n@Configuration\npublic class HttpsBeanDefinitionRegistryPostProcessor implements BeanDefinitionRegistryPostProcessor, EnvironmentAware {\n\n    private String profile;\n\n    @Override\n    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry beanDefinitionRegistry) throws BeansException {\n        if (\"dev\".equals(profile)){\n            AnnotatedBeanDefinition annotatedBeanDefinition = new AnnotatedGenericBeanDefinition(TomcatEmbeddedServletContainerFactory.class);\n            BeanDefinitionHolder beanDefinitionHolder = new BeanDefinitionHolder(annotatedBeanDefinition, \"tomcatEmbeddedServletContainerFactory\");\n            BeanDefinitionReaderUtils.registerBeanDefinition(beanDefinitionHolder, beanDefinitionRegistry);\n        }\n    }\n\n    @Override\n    public void postProcessBeanFactory(ConfigurableListableBeanFactory configurableListableBeanFactory) throws BeansException {\n        MutablePropertyValues tomcatEmbeddedServletContainerFactory = configurableListableBeanFactory.getBeanDefinition(\"tomcatEmbeddedServletContainerFactory\").getPropertyValues();\n        tomcatEmbeddedServletContainerFactory.addPropertyValue(\"additionalTomcatConnectors\", getConnector());\n    }\n\n    public Connector getConnector(){\n        Connector connector = new Connector(\"org.apache.coyote.http11.Http11NioProtocol\");\n        Http11NioProtocol protocol = (Http11NioProtocol) connector.getProtocolHandler();\n        connector.setScheme(\"https\");\n        connector.setSecure(true);\n        connector.setPort(8443);\n        protocol.setSSLEnabled(true);\n        protocol.setKeystoreFile(\"/Users/winx/.keystore\");\n        protocol.setKeystorePass(\"123456\");\n        protocol.setTruststoreFile(\"/Users/winx/.keystore\");\n        protocol.setTruststorePass(\"123456\");\n        protocol.setKeyAlias(\"tomcat\");\n        return connector;\n    }\n\n    @Override\n    public void setEnvironment(Environment environment) {\n        profile = environment.getProperty(\"profile\");\n    }\n}\n```\n\n##### 　　在拿到`MutablePropertyValues`之后，想要给`TomcatEmbeddedServletContainerFactory`对象设置`additionalTomcatConnectors`属性，Connector中包含了https关键信息的设置。之后报错如下：\n```\norg.springframework.context.ApplicationContextException: Unable to start embedded container; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'tomcatEmbeddedServletContainerFactory': Error setting property values; nested exception is org.springframework.beans.NotWritablePropertyException: Invalid property 'additionalTomcatConnectors' of bean class [org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedServletContainerFactory]: Bean property 'additionalTomcatConnectors' is not writable or has an invalid setter method. Does the parameter type of the setter match the return type of the getter?\n\tat org.springframework.boot.context.embedded.EmbeddedWebApplicationContext.onRefresh(EmbeddedWebApplicationContext.java:133) ~[spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n\tat org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:532) ~[spring-context-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n\tat org.springframework.boot.context.embedded.EmbeddedWebApplicationContext.refresh(EmbeddedWebApplicationContext.java:118) ~[spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n\tat org.springframework.boot.SpringApplication.refresh(SpringApplication.java:760) [spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n\tat org.springframework.boot.SpringApplication.createAndRefreshContext(SpringApplication.java:360) [spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n\tat org.springframework.boot.SpringApplication.run(SpringApplication.java:306) [spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n\tat org.springframework.boot.SpringApplication.run(SpringApplication.java:1185) [spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n\tat org.springframework.boot.SpringApplication.run(SpringApplication.java:1174) [spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n\tat com.winx.es.metis.RunMetis.main(RunMetis.java:47) [classes/:na]\nCaused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'tomcatEmbeddedServletContainerFactory': Error setting property values; nested exception is org.springframework.beans.NotWritablePropertyException: Invalid property 'additionalTomcatConnectors' of bean class [org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedServletContainerFactory]: Bean property 'additionalTomcatConnectors' is not writable or has an invalid setter method. Does the parameter type of the setter match the return type of the getter?\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyPropertyValues(AbstractAutowireCapableBeanFactory.java:1518) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1226) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:543) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:482) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n\tat org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:306) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n\tat org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:302) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n\tat org.springframework.boot.context.embedded.EmbeddedWebApplicationContext.getEmbeddedServletContainerFactory(EmbeddedWebApplicationContext.java:195) ~[spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n\tat org.springframework.boot.context.embedded.EmbeddedWebApplicationContext.createEmbeddedServletContainer(EmbeddedWebApplicationContext.java:158) ~[spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n\tat org.springframework.boot.context.embedded.EmbeddedWebApplicationContext.onRefresh(EmbeddedWebApplicationContext.java:130) ~[spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n\t... 8 common frames omitted\nCaused by: org.springframework.beans.NotWritablePropertyException: Invalid property 'additionalTomcatConnectors' of bean class [org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedServletContainerFactory]: Bean property 'additionalTomcatConnectors' is not writable or has an invalid setter method. Does the parameter type of the setter match the return type of the getter?\n\tat org.springframework.beans.BeanWrapperImpl.createNotWritablePropertyException(BeanWrapperImpl.java:230) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n\tat org.springframework.beans.AbstractNestablePropertyAccessor.setPropertyValue(AbstractNestablePropertyAccessor.java:423) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n\tat org.springframework.beans.AbstractNestablePropertyAccessor.setPropertyValue(AbstractNestablePropertyAccessor.java:280) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n\tat org.springframework.beans.AbstractPropertyAccessor.setPropertyValues(AbstractPropertyAccessor.java:95) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n\tat org.springframework.beans.AbstractPropertyAccessor.setPropertyValues(AbstractPropertyAccessor.java:75) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyPropertyValues(AbstractAutowireCapableBeanFactory.java:1514) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n\t... 18 common frames omitted\n```\n\n##### 　　**关键错误信息**：`Bean property 'additionalTomcatConnectors' is not writable or has an invalid setter method. Does the parameter type of the setter match the return type of the getter?`，没有权限写入以及没有找到相应的个体方法。\n\n##### 查看`TomcatEmbeddedServletContainerFactory`源码后发现其相应的设置方法如下：\n```java\npublic void addAdditionalTomcatConnectors(Connector... connectors) {\n    Assert.notNull(connectors, \"Connectors must not be null\");\n    this.additionalTomcatConnectors.addAll(Arrays.asList(connectors));\n}\n```\n\n##### 　　顿时觉得坑爹的add啊，之后在Bean Definition的私有属性设置，以及通过方法设置属性值得方向去尝试解决问题，没有任何效果。几乎快要绝望的时候，突然灵机一动，为什么我不能自己定义一个不需要后置设置属性的`TomcatEmbeddedServletContainerFactory`呢，于是有了下面的代码：\n\n```java\n@Configuration\npublic class HttpsBeanDefinitionRegistryPostProcessor implements BeanDefinitionRegistryPostProcessor, EnvironmentAware {\n\n    private String profile;\n\n    @Override\n    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry beanDefinitionRegistry) throws BeansException {\n        if (\"dev\".equals(profile)){\n            AnnotatedBeanDefinition annotatedBeanDefinition = new AnnotatedGenericBeanDefinition(HttpsTomcatEmbeddedServletContainerFactory.class);\n            BeanDefinitionHolder beanDefinitionHolder = new BeanDefinitionHolder(annotatedBeanDefinition, \"tomcatEmbeddedServletContainerFactory\");\n            BeanDefinitionReaderUtils.registerBeanDefinition(beanDefinitionHolder, beanDefinitionRegistry);\n        }\n    }\n\n    @Override\n    public void postProcessBeanFactory(ConfigurableListableBeanFactory configurableListableBeanFactory) throws BeansException {}\n\n\n    @Override\n    public void setEnvironment(Environment environment) {\n        profile = environment.getProperty(\"profile\");\n    }\n}\n```\n\n##### 　　注意上面的注入对象是`HttpsTomcatEmbeddedServletContainerFactory`，不是之前的`TomcatEmbeddedServletContainerFactory`，贴上`HttpsTomcatEmbeddedServletContainerFactory`代码：\n\n```java\nimport org.apache.catalina.connector.Connector;\nimport org.apache.coyote.http11.Http11NioProtocol;\nimport org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedServletContainerFactory;\n\n/**\n * @author winx\n * @create 2017-09-01.\n */\npublic class HttpsTomcatEmbeddedServletContainerFactory extends TomcatEmbeddedServletContainerFactory {\n\n    public HttpsTomcatEmbeddedServletContainerFactory() {\n        super();\n        Connector connector = new Connector(\"org.apache.coyote.http11.Http11NioProtocol\");\n        Http11NioProtocol protocol = (Http11NioProtocol) connector.getProtocolHandler();\n        connector.setScheme(\"https\");\n        connector.setSecure(true);\n        connector.setPort(8443);\n        protocol.setSSLEnabled(true);\n        protocol.setKeystoreFile(\"/Users/winx/.keystore\");\n        protocol.setKeystorePass(\"123456\");\n        protocol.setTruststoreFile(\"/Users/winx/.keystore\");\n        protocol.setTruststorePass(\"123456\");\n        protocol.setKeyAlias(\"tomcat\");\n        addAdditionalTomcatConnectors(connector);\n    }\n}\n```\n\n##### 成功的解决了之前属性设置问题。","slug":"note/springbootDynamic","published":1,"updated":"2017-10-09T06:06:06.795Z","_id":"cj8jros7z001n30s6nvwh0rem","comments":1,"photos":[],"link":"","content":"<h5 id=\"通常情况下，我们通过XML或者Annotation两种方式配置Bean-Definition。从Spring-3-0开始，增加了一种新的途径来配置Bean-Definition，这就是通过Java-Code配置Bean-Definition。\"><a href=\"#通常情况下，我们通过XML或者Annotation两种方式配置Bean-Definition。从Spring-3-0开始，增加了一种新的途径来配置Bean-Definition，这就是通过Java-Code配置Bean-Definition。\" class=\"headerlink\" title=\"　　通常情况下，我们通过XML或者Annotation两种方式配置Bean Definition。从Spring 3.0开始，增加了一种新的途径来配置Bean Definition，这就是通过Java Code配置Bean Definition。\"></a>　　通常情况下，我们通过XML或者Annotation两种方式配置Bean Definition。从Spring 3.0开始，增加了一种新的途径来配置Bean Definition，这就是通过Java Code配置Bean Definition。</h5><a id=\"more\"></a>\n<h4 id=\"Java-Code配置与XML和Annotation两种配置方式不同点在于：\"><a href=\"#Java-Code配置与XML和Annotation两种配置方式不同点在于：\" class=\"headerlink\" title=\"Java Code配置与XML和Annotation两种配置方式不同点在于：\"></a>Java Code配置与XML和Annotation两种配置方式不同点在于：</h4><h5 id=\"前两种方式XML和Annotation的配置方式为预定义方式，即开发人员通过XML文件或者Annotation预定义配置Bean的各种属性后，启动Spring容器，Spring容器会首先解析这些配置属性，生成对应的Bean-Definition-装入到DefaultListtableBeanFactory对象的属性容器中，以此同时，Spring框架也会定义内部使用的Bean定义，如Bean名为：org-springframework-context-annotation-internalConfigurationAnnotationProcessor的-ConfigurationClassPostProcessor-定义。而后此刻不会做任何Bean-Definition的解析动作，Spring框架会根据前两种配置，过滤出BeanDefinitionRegistryPostProcessor-类型的Bean定义，并通过Spring框架生成对应的Bean对象（如-ConfigurationClassPostProcessor-实例）。结合-Spring-上下文源码可知这个对象是一个-processor-类型工具类，Spring容器会在实例化开发人员所定义的-Bean-前先调用该-processor-的-postProcessBeanDefinitionRegistry-…-方法。此处实现基于-Java-Code-配置Bean-Definition的处理。\"><a href=\"#前两种方式XML和Annotation的配置方式为预定义方式，即开发人员通过XML文件或者Annotation预定义配置Bean的各种属性后，启动Spring容器，Spring容器会首先解析这些配置属性，生成对应的Bean-Definition-装入到DefaultListtableBeanFactory对象的属性容器中，以此同时，Spring框架也会定义内部使用的Bean定义，如Bean名为：org-springframework-context-annotation-internalConfigurationAnnotationProcessor的-ConfigurationClassPostProcessor-定义。而后此刻不会做任何Bean-Definition的解析动作，Spring框架会根据前两种配置，过滤出BeanDefinitionRegistryPostProcessor-类型的Bean定义，并通过Spring框架生成对应的Bean对象（如-ConfigurationClassPostProcessor-实例）。结合-Spring-上下文源码可知这个对象是一个-processor-类型工具类，Spring容器会在实例化开发人员所定义的-Bean-前先调用该-processor-的-postProcessBeanDefinitionRegistry-…-方法。此处实现基于-Java-Code-配置Bean-Definition的处理。\" class=\"headerlink\" title=\"　　前两种方式XML和Annotation的配置方式为预定义方式，即开发人员通过XML文件或者Annotation预定义配置Bean的各种属性后，启动Spring容器，Spring容器会首先解析这些配置属性，生成对应的Bean Definition,装入到DefaultListtableBeanFactory对象的属性容器中，以此同时，Spring框架也会定义内部使用的Bean定义，如Bean名为：org.springframework.context.annotation.internalConfigurationAnnotationProcessor的 ConfigurationClassPostProcessor 定义。而后此刻不会做任何Bean Definition的解析动作，Spring框架会根据前两种配置，过滤出BeanDefinitionRegistryPostProcessor 类型的Bean定义，并通过Spring框架生成对应的Bean对象（如 ConfigurationClassPostProcessor 实例）。结合 Spring 上下文源码可知这个对象是一个 processor 类型工具类，Spring容器会在实例化开发人员所定义的 Bean 前先调用该 processor 的 postProcessBeanDefinitionRegistry(…) 方法。此处实现基于 Java Code 配置Bean Definition的处理。\"></a>　　前两种方式XML和Annotation的配置方式为预定义方式，即开发人员通过XML文件或者Annotation预定义配置Bean的各种属性后，启动Spring容器，Spring容器会首先解析这些配置属性，生成对应的Bean Definition,装入到<code>DefaultListtableBeanFactory</code>对象的属性容器中，以此同时，Spring框架也会定义内部使用的Bean定义，如Bean名为：<code>org.springframework.context.annotation.internalConfigurationAnnotationProcessor</code>的 <code>ConfigurationClassPostProcessor</code> 定义。而后此刻不会做任何Bean Definition的解析动作，Spring框架会根据前两种配置，过滤出<code>BeanDefinitionRegistryPostProcessor</code> 类型的Bean定义，并通过Spring框架生成对应的Bean对象（如 <code>ConfigurationClassPostProcessor</code> 实例）。结合 Spring 上下文源码可知这个对象是一个 processor 类型工具类，<u>Spring容器会在实例化开发人员所定义的 Bean 前先调用该 processor 的 postProcessBeanDefinitionRegistry(…) 方法。此处实现基于 Java Code 配置Bean Definition的处理</u>。</h5><h5 id=\"基于-Java-Code-的配置方式，其执行原理不同于前两种。它是在-Spring-框架已经解析了基于-XML-和-Annotation-配置后，通过加入-BeanDefinitionRegistryPostProcessor-类型的-processor-来处理配置信息，让开发人员通过-Java-编程方式定义一个-Java-对象。其优点在于可以将配置信息集中在一定数量的-Java-对象中，同时通过-Java-编程方式，比基于-Annotation-方式具有更高的灵活性。并且该配置方式给开发人员提供了一种非常好的范例来增加用户自定义的解析工具类。其主要缺点在于与-Java-代码结合紧密，配置信息的改变需要重新编译-Java-代码，另外这是一种新引入的解析方式，需要一定的学习成本。\"><a href=\"#基于-Java-Code-的配置方式，其执行原理不同于前两种。它是在-Spring-框架已经解析了基于-XML-和-Annotation-配置后，通过加入-BeanDefinitionRegistryPostProcessor-类型的-processor-来处理配置信息，让开发人员通过-Java-编程方式定义一个-Java-对象。其优点在于可以将配置信息集中在一定数量的-Java-对象中，同时通过-Java-编程方式，比基于-Annotation-方式具有更高的灵活性。并且该配置方式给开发人员提供了一种非常好的范例来增加用户自定义的解析工具类。其主要缺点在于与-Java-代码结合紧密，配置信息的改变需要重新编译-Java-代码，另外这是一种新引入的解析方式，需要一定的学习成本。\" class=\"headerlink\" title=\"　　基于 Java Code 的配置方式，其执行原理不同于前两种。它是在 Spring 框架已经解析了基于 XML 和 Annotation 配置后，通过加入 BeanDefinitionRegistryPostProcessor 类型的 processor 来处理配置信息，让开发人员通过 Java 编程方式定义一个 Java 对象。其优点在于可以将配置信息集中在一定数量的 Java 对象中，同时通过 Java 编程方式，比基于 Annotation 方式具有更高的灵活性。并且该配置方式给开发人员提供了一种非常好的范例来增加用户自定义的解析工具类。其主要缺点在于与 Java 代码结合紧密，配置信息的改变需要重新编译 Java 代码，另外这是一种新引入的解析方式，需要一定的学习成本。\"></a>　　基于 Java Code 的配置方式，其执行原理不同于前两种。它是在 Spring 框架已经解析了基于 XML 和 Annotation 配置后，通过加入 BeanDefinitionRegistryPostProcessor 类型的 processor 来处理配置信息，让开发人员通过 Java 编程方式定义一个 Java 对象。其优点在于可以将配置信息集中在一定数量的 Java 对象中，同时通过 Java 编程方式，比基于 Annotation 方式具有更高的灵活性。并且该配置方式给开发人员提供了一种非常好的范例来增加用户自定义的解析工具类。其主要缺点在于与 Java 代码结合紧密，配置信息的改变需要重新编译 Java 代码，另外这是一种新引入的解析方式，需要一定的学习成本。</h5><p><br></p>\n<h4 id=\"提及一点的就是，Spring框架有3个主要的Hook类，分别是：\"><a href=\"#提及一点的就是，Spring框架有3个主要的Hook类，分别是：\" class=\"headerlink\" title=\"提及一点的就是，Spring框架有3个主要的Hook类，分别是：\"></a>提及一点的就是，Spring框架有3个主要的Hook类，分别是：</h4><p><code>org.springframework.context.ApplicationContextAware</code></p>\n<h5 id=\"它的setApplicationContext-方法将在Spring启动之前第一个被调用。\"><a href=\"#它的setApplicationContext-方法将在Spring启动之前第一个被调用。\" class=\"headerlink\" title=\"它的setApplicationContext 方法将在Spring启动之前第一个被调用。\"></a>它的setApplicationContext 方法将在Spring启动之前第一个被调用。</h5><p><code>org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor</code></p>\n<h5 id=\"它的postProcessBeanDefinitionRegistry-和-postProcessBeanFactory-方法是第二和第三被调用，它们在Bean初始化创建之前启动，如果Spring的bean需要的其他第三方中的组件，我们在这里将其注入给Spring。\"><a href=\"#它的postProcessBeanDefinitionRegistry-和-postProcessBeanFactory-方法是第二和第三被调用，它们在Bean初始化创建之前启动，如果Spring的bean需要的其他第三方中的组件，我们在这里将其注入给Spring。\" class=\"headerlink\" title=\"它的postProcessBeanDefinitionRegistry 和 postProcessBeanFactory 方法是第二和第三被调用，它们在Bean初始化创建之前启动，如果Spring的bean需要的其他第三方中的组件，我们在这里将其注入给Spring。\"></a>它的postProcessBeanDefinitionRegistry 和 postProcessBeanFactory 方法是第二和第三被调用，它们在Bean初始化创建之前启动，如果Spring的bean需要的其他第三方中的组件，我们在这里将其注入给Spring。</h5><p><code>org.springframework.context.ApplicationListener</code><br>用于在初始化完成后做一些事情，当Spring所有XML或元注解的Bean都启动被创建成功了，这时会调用它的唯一方法onApplicationEvent。<br><br></p>\n<h4 id=\"通过-BeanDefinitionRegistryPostProcessor-加载自己的bean的demo：\"><a href=\"#通过-BeanDefinitionRegistryPostProcessor-加载自己的bean的demo：\" class=\"headerlink\" title=\"通过 BeanDefinitionRegistryPostProcessor 加载自己的bean的demo：\"></a>通过 BeanDefinitionRegistryPostProcessor 加载自己的bean的demo：</h4><pre><code class=\"lang-java\">import org.springframework.beans.BeansException;\nimport org.springframework.beans.MutablePropertyValues;\nimport org.springframework.beans.factory.annotation.AnnotatedBeanDefinition;\nimport org.springframework.beans.factory.annotation.AnnotatedGenericBeanDefinition;\nimport org.springframework.beans.factory.config.BeanDefinition;\nimport org.springframework.beans.factory.config.BeanDefinitionHolder;\nimport org.springframework.beans.factory.config.ConfigurableListableBeanFactory;\nimport org.springframework.beans.factory.support.BeanDefinitionReaderUtils;\nimport org.springframework.beans.factory.support.BeanDefinitionRegistry;\nimport org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor;\n\n/**\n * @author winx\n * @create 2017-09-01.\n */\n@Configuration\npublic class MyBeanDefinitionRegistryPostProcessor implements BeanDefinitionRegistryPostProcessor {\n\n    /**\n     * 先执行：postProcessBeanDefinitionRegistry()方法\n     * 通过Class对象，注册自己的 BeanDefinition\n     */\n    @Override\n    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException {\n        try {\n            AnnotatedBeanDefinition annotatedBeanDefinition = new AnnotatedGenericBeanDefinition(Class.forName(&quot;&quot;));\n            BeanDefinitionHolder beanDefinitionHolder = new BeanDefinitionHolder(annotatedBeanDefinition, &quot;beanName&quot;);\n            BeanDefinitionReaderUtils.registerBeanDefinition(beanDefinitionHolder, registry);\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * 再执行：postProcessBeanFactory()方法。\n     * 通过 beanName 拿到注册后的 BeanDefinition\n     * 然后加入自定义属性，BeanDefinition 会在初始化bean时，将 Property 键值对插入到之前的Class对象属性中。\n     */\n    @Override\n    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {\n        BeanDefinition beanDefinition = beanFactory.getBeanDefinition(&quot;beanName&quot;);\n        MutablePropertyValues mutablePropertyValues = beanDefinition.getPropertyValues();\n        //加入属性.\n        mutablePropertyValues.addPropertyValue(&quot;username&quot;, &quot;root&quot;);\n    }\n}\n</code></pre>\n<h5 id=\"Configuration注解提示spring-boot通过该类加载bean\"><a href=\"#Configuration注解提示spring-boot通过该类加载bean\" class=\"headerlink\" title=\"@Configuration注解提示spring boot通过该类加载bean\"></a><code>@Configuration</code>注解提示spring boot通过该类加载bean</h5><h5 id=\"postProcessBeanDefinitionRegistry-通过Class对象，注册自己的-BeanDefinition\"><a href=\"#postProcessBeanDefinitionRegistry-通过Class对象，注册自己的-BeanDefinition\" class=\"headerlink\" title=\"postProcessBeanDefinitionRegistry() 通过Class对象，注册自己的 BeanDefinition\"></a><code>postProcessBeanDefinitionRegistry()</code> 通过Class对象，注册自己的 BeanDefinition</h5><h5 id=\"postProcessBeanFactory-方法会在postProcessBeanDefinitionRegistry-之后执行，-通过beanFactory拿到-BeanDefinition-后加入属性，这一步可以跳过。\"><a href=\"#postProcessBeanFactory-方法会在postProcessBeanDefinitionRegistry-之后执行，-通过beanFactory拿到-BeanDefinition-后加入属性，这一步可以跳过。\" class=\"headerlink\" title=\"postProcessBeanFactory()方法会在postProcessBeanDefinitionRegistry()之后执行， 通过beanFactory拿到 BeanDefinition 后加入属性，这一步可以跳过。\"></a><code>postProcessBeanFactory()</code>方法会在<code>postProcessBeanDefinitionRegistry()</code>之后执行， 通过beanFactory拿到 BeanDefinition 后加入属性，这一步可以跳过。</h5><h3 id=\"实际项目需求\"><a href=\"#实际项目需求\" class=\"headerlink\" title=\"实际项目需求\"></a>实际项目需求</h3><h5 id=\"目前项目分为线上环境和dev环境，项目本身只支持http服务，因为线上环境有nginx做反向代理，所以用http和https均能正常访问线上服务。但是本地环境相对简单，不能支持https服务。先在需要根据环境的不同。动态的扩张spring-boot的多连接器设置。当环境为dev时，即加载多连接器，分别用两个端口提供http和https服务。当环境不为dev时，只加载默认http即可。\"><a href=\"#目前项目分为线上环境和dev环境，项目本身只支持http服务，因为线上环境有nginx做反向代理，所以用http和https均能正常访问线上服务。但是本地环境相对简单，不能支持https服务。先在需要根据环境的不同。动态的扩张spring-boot的多连接器设置。当环境为dev时，即加载多连接器，分别用两个端口提供http和https服务。当环境不为dev时，只加载默认http即可。\" class=\"headerlink\" title=\"　　目前项目分为线上环境和dev环境，项目本身只支持http服务，因为线上环境有nginx做反向代理，所以用http和https均能正常访问线上服务。但是本地环境相对简单，不能支持https服务。先在需要根据环境的不同。动态的扩张spring boot的多连接器设置。当环境为dev时，即加载多连接器，分别用两个端口提供http和https服务。当环境不为dev时，只加载默认http即可。\"></a>　　目前项目分为线上环境和dev环境，项目本身只支持http服务，因为线上环境有nginx做反向代理，所以用http和https均能正常访问线上服务。但是本地环境相对简单，不能支持https服务。先在需要根据环境的不同。动态的扩张spring boot的多连接器设置。当环境为dev时，即加载多连接器，分别用两个端口提供http和https服务。当环境不为dev时，只加载默认http即可。</h5><h5 id=\"根据这些需求，通过xml或者annotation去定义bean都不太合适。只能是通过java-code去判断环境并动态加载。\"><a href=\"#根据这些需求，通过xml或者annotation去定义bean都不太合适。只能是通过java-code去判断环境并动态加载。\" class=\"headerlink\" title=\"　　根据这些需求，通过xml或者annotation去定义bean都不太合适。只能是通过java code去判断环境并动态加载。\"></a>　　根据这些需求，通过xml或者annotation去定义bean都不太合适。只能是通过java code去判断环境并动态加载。</h5><h5 id=\"省去spring-boot支持https以及多连接器的配置，相关的代码网络上很多。直接说遇到的主要问题吧。上面的demo通过mutablePropertyValues-addPropertyValue-quot-key-quot-quot-root-quot-的方式为目标class定义属性，但是要求属性key必须有相应的set方法。\"><a href=\"#省去spring-boot支持https以及多连接器的配置，相关的代码网络上很多。直接说遇到的主要问题吧。上面的demo通过mutablePropertyValues-addPropertyValue-quot-key-quot-quot-root-quot-的方式为目标class定义属性，但是要求属性key必须有相应的set方法。\" class=\"headerlink\" title=\"　　省去spring boot支持https以及多连接器的配置，相关的代码网络上很多。直接说遇到的主要问题吧。上面的demo通过mutablePropertyValues.addPropertyValue(&quot;key&quot;, &quot;root&quot;);的方式为目标class定义属性，但是要求属性key必须有相应的set方法。\"></a>　　省去spring boot支持https以及多连接器的配置，相关的代码网络上很多。直接说遇到的主要问题吧。上面的demo通过<code>mutablePropertyValues.addPropertyValue(&quot;key&quot;, &quot;root&quot;);</code>的方式为目标class定义属性，但是要求属性key必须有相应的set方法。</h5><pre><code class=\"lang-java\">@Configuration\npublic class HttpsBeanDefinitionRegistryPostProcessor implements BeanDefinitionRegistryPostProcessor, EnvironmentAware {\n\n    private String profile;\n\n    @Override\n    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry beanDefinitionRegistry) throws BeansException {\n        if (&quot;dev&quot;.equals(profile)){\n            AnnotatedBeanDefinition annotatedBeanDefinition = new AnnotatedGenericBeanDefinition(TomcatEmbeddedServletContainerFactory.class);\n            BeanDefinitionHolder beanDefinitionHolder = new BeanDefinitionHolder(annotatedBeanDefinition, &quot;tomcatEmbeddedServletContainerFactory&quot;);\n            BeanDefinitionReaderUtils.registerBeanDefinition(beanDefinitionHolder, beanDefinitionRegistry);\n        }\n    }\n\n    @Override\n    public void postProcessBeanFactory(ConfigurableListableBeanFactory configurableListableBeanFactory) throws BeansException {\n        MutablePropertyValues tomcatEmbeddedServletContainerFactory = configurableListableBeanFactory.getBeanDefinition(&quot;tomcatEmbeddedServletContainerFactory&quot;).getPropertyValues();\n        tomcatEmbeddedServletContainerFactory.addPropertyValue(&quot;additionalTomcatConnectors&quot;, getConnector());\n    }\n\n    public Connector getConnector(){\n        Connector connector = new Connector(&quot;org.apache.coyote.http11.Http11NioProtocol&quot;);\n        Http11NioProtocol protocol = (Http11NioProtocol) connector.getProtocolHandler();\n        connector.setScheme(&quot;https&quot;);\n        connector.setSecure(true);\n        connector.setPort(8443);\n        protocol.setSSLEnabled(true);\n        protocol.setKeystoreFile(&quot;/Users/winx/.keystore&quot;);\n        protocol.setKeystorePass(&quot;123456&quot;);\n        protocol.setTruststoreFile(&quot;/Users/winx/.keystore&quot;);\n        protocol.setTruststorePass(&quot;123456&quot;);\n        protocol.setKeyAlias(&quot;tomcat&quot;);\n        return connector;\n    }\n\n    @Override\n    public void setEnvironment(Environment environment) {\n        profile = environment.getProperty(&quot;profile&quot;);\n    }\n}\n</code></pre>\n<h5 id=\"在拿到MutablePropertyValues之后，想要给TomcatEmbeddedServletContainerFactory对象设置additionalTomcatConnectors属性，Connector中包含了https关键信息的设置。之后报错如下：\"><a href=\"#在拿到MutablePropertyValues之后，想要给TomcatEmbeddedServletContainerFactory对象设置additionalTomcatConnectors属性，Connector中包含了https关键信息的设置。之后报错如下：\" class=\"headerlink\" title=\"　　在拿到MutablePropertyValues之后，想要给TomcatEmbeddedServletContainerFactory对象设置additionalTomcatConnectors属性，Connector中包含了https关键信息的设置。之后报错如下：\"></a>　　在拿到<code>MutablePropertyValues</code>之后，想要给<code>TomcatEmbeddedServletContainerFactory</code>对象设置<code>additionalTomcatConnectors</code>属性，Connector中包含了https关键信息的设置。之后报错如下：</h5><pre><code>org.springframework.context.ApplicationContextException: Unable to start embedded container; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#39;tomcatEmbeddedServletContainerFactory&#39;: Error setting property values; nested exception is org.springframework.beans.NotWritablePropertyException: Invalid property &#39;additionalTomcatConnectors&#39; of bean class [org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedServletContainerFactory]: Bean property &#39;additionalTomcatConnectors&#39; is not writable or has an invalid setter method. Does the parameter type of the setter match the return type of the getter?\n    at org.springframework.boot.context.embedded.EmbeddedWebApplicationContext.onRefresh(EmbeddedWebApplicationContext.java:133) ~[spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n    at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:532) ~[spring-context-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n    at org.springframework.boot.context.embedded.EmbeddedWebApplicationContext.refresh(EmbeddedWebApplicationContext.java:118) ~[spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n    at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:760) [spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n    at org.springframework.boot.SpringApplication.createAndRefreshContext(SpringApplication.java:360) [spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n    at org.springframework.boot.SpringApplication.run(SpringApplication.java:306) [spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n    at org.springframework.boot.SpringApplication.run(SpringApplication.java:1185) [spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n    at org.springframework.boot.SpringApplication.run(SpringApplication.java:1174) [spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n    at com.winx.es.metis.RunMetis.main(RunMetis.java:47) [classes/:na]\nCaused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#39;tomcatEmbeddedServletContainerFactory&#39;: Error setting property values; nested exception is org.springframework.beans.NotWritablePropertyException: Invalid property &#39;additionalTomcatConnectors&#39; of bean class [org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedServletContainerFactory]: Bean property &#39;additionalTomcatConnectors&#39; is not writable or has an invalid setter method. Does the parameter type of the setter match the return type of the getter?\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyPropertyValues(AbstractAutowireCapableBeanFactory.java:1518) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1226) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:543) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:482) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n    at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:306) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n    at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n    at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:302) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n    at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n    at org.springframework.boot.context.embedded.EmbeddedWebApplicationContext.getEmbeddedServletContainerFactory(EmbeddedWebApplicationContext.java:195) ~[spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n    at org.springframework.boot.context.embedded.EmbeddedWebApplicationContext.createEmbeddedServletContainer(EmbeddedWebApplicationContext.java:158) ~[spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n    at org.springframework.boot.context.embedded.EmbeddedWebApplicationContext.onRefresh(EmbeddedWebApplicationContext.java:130) ~[spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n    ... 8 common frames omitted\nCaused by: org.springframework.beans.NotWritablePropertyException: Invalid property &#39;additionalTomcatConnectors&#39; of bean class [org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedServletContainerFactory]: Bean property &#39;additionalTomcatConnectors&#39; is not writable or has an invalid setter method. Does the parameter type of the setter match the return type of the getter?\n    at org.springframework.beans.BeanWrapperImpl.createNotWritablePropertyException(BeanWrapperImpl.java:230) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n    at org.springframework.beans.AbstractNestablePropertyAccessor.setPropertyValue(AbstractNestablePropertyAccessor.java:423) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n    at org.springframework.beans.AbstractNestablePropertyAccessor.setPropertyValue(AbstractNestablePropertyAccessor.java:280) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n    at org.springframework.beans.AbstractPropertyAccessor.setPropertyValues(AbstractPropertyAccessor.java:95) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n    at org.springframework.beans.AbstractPropertyAccessor.setPropertyValues(AbstractPropertyAccessor.java:75) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyPropertyValues(AbstractAutowireCapableBeanFactory.java:1514) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n    ... 18 common frames omitted\n</code></pre><h5 id=\"关键错误信息：Bean-property-39-additionalTomcatConnectors-39-is-not-writable-or-has-an-invalid-setter-method-Does-the-parameter-type-of-the-setter-match-the-return-type-of-the-getter-，没有权限写入以及没有找到相应的个体方法。\"><a href=\"#关键错误信息：Bean-property-39-additionalTomcatConnectors-39-is-not-writable-or-has-an-invalid-setter-method-Does-the-parameter-type-of-the-setter-match-the-return-type-of-the-getter-，没有权限写入以及没有找到相应的个体方法。\" class=\"headerlink\" title=\"　　关键错误信息：Bean property &#39;additionalTomcatConnectors&#39; is not writable or has an invalid setter method. Does the parameter type of the setter match the return type of the getter?，没有权限写入以及没有找到相应的个体方法。\"></a>　　<strong>关键错误信息</strong>：<code>Bean property &#39;additionalTomcatConnectors&#39; is not writable or has an invalid setter method. Does the parameter type of the setter match the return type of the getter?</code>，没有权限写入以及没有找到相应的个体方法。</h5><h5 id=\"查看TomcatEmbeddedServletContainerFactory源码后发现其相应的设置方法如下：\"><a href=\"#查看TomcatEmbeddedServletContainerFactory源码后发现其相应的设置方法如下：\" class=\"headerlink\" title=\"查看TomcatEmbeddedServletContainerFactory源码后发现其相应的设置方法如下：\"></a>查看<code>TomcatEmbeddedServletContainerFactory</code>源码后发现其相应的设置方法如下：</h5><pre><code class=\"lang-java\">public void addAdditionalTomcatConnectors(Connector... connectors) {\n    Assert.notNull(connectors, &quot;Connectors must not be null&quot;);\n    this.additionalTomcatConnectors.addAll(Arrays.asList(connectors));\n}\n</code></pre>\n<h5 id=\"顿时觉得坑爹的add啊，之后在Bean-Definition的私有属性设置，以及通过方法设置属性值得方向去尝试解决问题，没有任何效果。几乎快要绝望的时候，突然灵机一动，为什么我不能自己定义一个不需要后置设置属性的TomcatEmbeddedServletContainerFactory呢，于是有了下面的代码：\"><a href=\"#顿时觉得坑爹的add啊，之后在Bean-Definition的私有属性设置，以及通过方法设置属性值得方向去尝试解决问题，没有任何效果。几乎快要绝望的时候，突然灵机一动，为什么我不能自己定义一个不需要后置设置属性的TomcatEmbeddedServletContainerFactory呢，于是有了下面的代码：\" class=\"headerlink\" title=\"　　顿时觉得坑爹的add啊，之后在Bean Definition的私有属性设置，以及通过方法设置属性值得方向去尝试解决问题，没有任何效果。几乎快要绝望的时候，突然灵机一动，为什么我不能自己定义一个不需要后置设置属性的TomcatEmbeddedServletContainerFactory呢，于是有了下面的代码：\"></a>　　顿时觉得坑爹的add啊，之后在Bean Definition的私有属性设置，以及通过方法设置属性值得方向去尝试解决问题，没有任何效果。几乎快要绝望的时候，突然灵机一动，为什么我不能自己定义一个不需要后置设置属性的<code>TomcatEmbeddedServletContainerFactory</code>呢，于是有了下面的代码：</h5><pre><code class=\"lang-java\">@Configuration\npublic class HttpsBeanDefinitionRegistryPostProcessor implements BeanDefinitionRegistryPostProcessor, EnvironmentAware {\n\n    private String profile;\n\n    @Override\n    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry beanDefinitionRegistry) throws BeansException {\n        if (&quot;dev&quot;.equals(profile)){\n            AnnotatedBeanDefinition annotatedBeanDefinition = new AnnotatedGenericBeanDefinition(HttpsTomcatEmbeddedServletContainerFactory.class);\n            BeanDefinitionHolder beanDefinitionHolder = new BeanDefinitionHolder(annotatedBeanDefinition, &quot;tomcatEmbeddedServletContainerFactory&quot;);\n            BeanDefinitionReaderUtils.registerBeanDefinition(beanDefinitionHolder, beanDefinitionRegistry);\n        }\n    }\n\n    @Override\n    public void postProcessBeanFactory(ConfigurableListableBeanFactory configurableListableBeanFactory) throws BeansException {}\n\n\n    @Override\n    public void setEnvironment(Environment environment) {\n        profile = environment.getProperty(&quot;profile&quot;);\n    }\n}\n</code></pre>\n<h5 id=\"注意上面的注入对象是HttpsTomcatEmbeddedServletContainerFactory，不是之前的TomcatEmbeddedServletContainerFactory，贴上HttpsTomcatEmbeddedServletContainerFactory代码：\"><a href=\"#注意上面的注入对象是HttpsTomcatEmbeddedServletContainerFactory，不是之前的TomcatEmbeddedServletContainerFactory，贴上HttpsTomcatEmbeddedServletContainerFactory代码：\" class=\"headerlink\" title=\"　　注意上面的注入对象是HttpsTomcatEmbeddedServletContainerFactory，不是之前的TomcatEmbeddedServletContainerFactory，贴上HttpsTomcatEmbeddedServletContainerFactory代码：\"></a>　　注意上面的注入对象是<code>HttpsTomcatEmbeddedServletContainerFactory</code>，不是之前的<code>TomcatEmbeddedServletContainerFactory</code>，贴上<code>HttpsTomcatEmbeddedServletContainerFactory</code>代码：</h5><pre><code class=\"lang-java\">import org.apache.catalina.connector.Connector;\nimport org.apache.coyote.http11.Http11NioProtocol;\nimport org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedServletContainerFactory;\n\n/**\n * @author winx\n * @create 2017-09-01.\n */\npublic class HttpsTomcatEmbeddedServletContainerFactory extends TomcatEmbeddedServletContainerFactory {\n\n    public HttpsTomcatEmbeddedServletContainerFactory() {\n        super();\n        Connector connector = new Connector(&quot;org.apache.coyote.http11.Http11NioProtocol&quot;);\n        Http11NioProtocol protocol = (Http11NioProtocol) connector.getProtocolHandler();\n        connector.setScheme(&quot;https&quot;);\n        connector.setSecure(true);\n        connector.setPort(8443);\n        protocol.setSSLEnabled(true);\n        protocol.setKeystoreFile(&quot;/Users/winx/.keystore&quot;);\n        protocol.setKeystorePass(&quot;123456&quot;);\n        protocol.setTruststoreFile(&quot;/Users/winx/.keystore&quot;);\n        protocol.setTruststorePass(&quot;123456&quot;);\n        protocol.setKeyAlias(&quot;tomcat&quot;);\n        addAdditionalTomcatConnectors(connector);\n    }\n}\n</code></pre>\n<h5 id=\"成功的解决了之前属性设置问题。\"><a href=\"#成功的解决了之前属性设置问题。\" class=\"headerlink\" title=\"成功的解决了之前属性设置问题。\"></a>成功的解决了之前属性设置问题。</h5>","site":{"data":{}},"excerpt":"<h5 id=\"通常情况下，我们通过XML或者Annotation两种方式配置Bean-Definition。从Spring-3-0开始，增加了一种新的途径来配置Bean-Definition，这就是通过Java-Code配置Bean-Definition。\"><a href=\"#通常情况下，我们通过XML或者Annotation两种方式配置Bean-Definition。从Spring-3-0开始，增加了一种新的途径来配置Bean-Definition，这就是通过Java-Code配置Bean-Definition。\" class=\"headerlink\" title=\"　　通常情况下，我们通过XML或者Annotation两种方式配置Bean Definition。从Spring 3.0开始，增加了一种新的途径来配置Bean Definition，这就是通过Java Code配置Bean Definition。\"></a>　　通常情况下，我们通过XML或者Annotation两种方式配置Bean Definition。从Spring 3.0开始，增加了一种新的途径来配置Bean Definition，这就是通过Java Code配置Bean Definition。</h5>","more":"<h4 id=\"Java-Code配置与XML和Annotation两种配置方式不同点在于：\"><a href=\"#Java-Code配置与XML和Annotation两种配置方式不同点在于：\" class=\"headerlink\" title=\"Java Code配置与XML和Annotation两种配置方式不同点在于：\"></a>Java Code配置与XML和Annotation两种配置方式不同点在于：</h4><h5 id=\"前两种方式XML和Annotation的配置方式为预定义方式，即开发人员通过XML文件或者Annotation预定义配置Bean的各种属性后，启动Spring容器，Spring容器会首先解析这些配置属性，生成对应的Bean-Definition-装入到DefaultListtableBeanFactory对象的属性容器中，以此同时，Spring框架也会定义内部使用的Bean定义，如Bean名为：org-springframework-context-annotation-internalConfigurationAnnotationProcessor的-ConfigurationClassPostProcessor-定义。而后此刻不会做任何Bean-Definition的解析动作，Spring框架会根据前两种配置，过滤出BeanDefinitionRegistryPostProcessor-类型的Bean定义，并通过Spring框架生成对应的Bean对象（如-ConfigurationClassPostProcessor-实例）。结合-Spring-上下文源码可知这个对象是一个-processor-类型工具类，Spring容器会在实例化开发人员所定义的-Bean-前先调用该-processor-的-postProcessBeanDefinitionRegistry-…-方法。此处实现基于-Java-Code-配置Bean-Definition的处理。\"><a href=\"#前两种方式XML和Annotation的配置方式为预定义方式，即开发人员通过XML文件或者Annotation预定义配置Bean的各种属性后，启动Spring容器，Spring容器会首先解析这些配置属性，生成对应的Bean-Definition-装入到DefaultListtableBeanFactory对象的属性容器中，以此同时，Spring框架也会定义内部使用的Bean定义，如Bean名为：org-springframework-context-annotation-internalConfigurationAnnotationProcessor的-ConfigurationClassPostProcessor-定义。而后此刻不会做任何Bean-Definition的解析动作，Spring框架会根据前两种配置，过滤出BeanDefinitionRegistryPostProcessor-类型的Bean定义，并通过Spring框架生成对应的Bean对象（如-ConfigurationClassPostProcessor-实例）。结合-Spring-上下文源码可知这个对象是一个-processor-类型工具类，Spring容器会在实例化开发人员所定义的-Bean-前先调用该-processor-的-postProcessBeanDefinitionRegistry-…-方法。此处实现基于-Java-Code-配置Bean-Definition的处理。\" class=\"headerlink\" title=\"　　前两种方式XML和Annotation的配置方式为预定义方式，即开发人员通过XML文件或者Annotation预定义配置Bean的各种属性后，启动Spring容器，Spring容器会首先解析这些配置属性，生成对应的Bean Definition,装入到DefaultListtableBeanFactory对象的属性容器中，以此同时，Spring框架也会定义内部使用的Bean定义，如Bean名为：org.springframework.context.annotation.internalConfigurationAnnotationProcessor的 ConfigurationClassPostProcessor 定义。而后此刻不会做任何Bean Definition的解析动作，Spring框架会根据前两种配置，过滤出BeanDefinitionRegistryPostProcessor 类型的Bean定义，并通过Spring框架生成对应的Bean对象（如 ConfigurationClassPostProcessor 实例）。结合 Spring 上下文源码可知这个对象是一个 processor 类型工具类，Spring容器会在实例化开发人员所定义的 Bean 前先调用该 processor 的 postProcessBeanDefinitionRegistry(…) 方法。此处实现基于 Java Code 配置Bean Definition的处理。\"></a>　　前两种方式XML和Annotation的配置方式为预定义方式，即开发人员通过XML文件或者Annotation预定义配置Bean的各种属性后，启动Spring容器，Spring容器会首先解析这些配置属性，生成对应的Bean Definition,装入到<code>DefaultListtableBeanFactory</code>对象的属性容器中，以此同时，Spring框架也会定义内部使用的Bean定义，如Bean名为：<code>org.springframework.context.annotation.internalConfigurationAnnotationProcessor</code>的 <code>ConfigurationClassPostProcessor</code> 定义。而后此刻不会做任何Bean Definition的解析动作，Spring框架会根据前两种配置，过滤出<code>BeanDefinitionRegistryPostProcessor</code> 类型的Bean定义，并通过Spring框架生成对应的Bean对象（如 <code>ConfigurationClassPostProcessor</code> 实例）。结合 Spring 上下文源码可知这个对象是一个 processor 类型工具类，<u>Spring容器会在实例化开发人员所定义的 Bean 前先调用该 processor 的 postProcessBeanDefinitionRegistry(…) 方法。此处实现基于 Java Code 配置Bean Definition的处理</u>。</h5><h5 id=\"基于-Java-Code-的配置方式，其执行原理不同于前两种。它是在-Spring-框架已经解析了基于-XML-和-Annotation-配置后，通过加入-BeanDefinitionRegistryPostProcessor-类型的-processor-来处理配置信息，让开发人员通过-Java-编程方式定义一个-Java-对象。其优点在于可以将配置信息集中在一定数量的-Java-对象中，同时通过-Java-编程方式，比基于-Annotation-方式具有更高的灵活性。并且该配置方式给开发人员提供了一种非常好的范例来增加用户自定义的解析工具类。其主要缺点在于与-Java-代码结合紧密，配置信息的改变需要重新编译-Java-代码，另外这是一种新引入的解析方式，需要一定的学习成本。\"><a href=\"#基于-Java-Code-的配置方式，其执行原理不同于前两种。它是在-Spring-框架已经解析了基于-XML-和-Annotation-配置后，通过加入-BeanDefinitionRegistryPostProcessor-类型的-processor-来处理配置信息，让开发人员通过-Java-编程方式定义一个-Java-对象。其优点在于可以将配置信息集中在一定数量的-Java-对象中，同时通过-Java-编程方式，比基于-Annotation-方式具有更高的灵活性。并且该配置方式给开发人员提供了一种非常好的范例来增加用户自定义的解析工具类。其主要缺点在于与-Java-代码结合紧密，配置信息的改变需要重新编译-Java-代码，另外这是一种新引入的解析方式，需要一定的学习成本。\" class=\"headerlink\" title=\"　　基于 Java Code 的配置方式，其执行原理不同于前两种。它是在 Spring 框架已经解析了基于 XML 和 Annotation 配置后，通过加入 BeanDefinitionRegistryPostProcessor 类型的 processor 来处理配置信息，让开发人员通过 Java 编程方式定义一个 Java 对象。其优点在于可以将配置信息集中在一定数量的 Java 对象中，同时通过 Java 编程方式，比基于 Annotation 方式具有更高的灵活性。并且该配置方式给开发人员提供了一种非常好的范例来增加用户自定义的解析工具类。其主要缺点在于与 Java 代码结合紧密，配置信息的改变需要重新编译 Java 代码，另外这是一种新引入的解析方式，需要一定的学习成本。\"></a>　　基于 Java Code 的配置方式，其执行原理不同于前两种。它是在 Spring 框架已经解析了基于 XML 和 Annotation 配置后，通过加入 BeanDefinitionRegistryPostProcessor 类型的 processor 来处理配置信息，让开发人员通过 Java 编程方式定义一个 Java 对象。其优点在于可以将配置信息集中在一定数量的 Java 对象中，同时通过 Java 编程方式，比基于 Annotation 方式具有更高的灵活性。并且该配置方式给开发人员提供了一种非常好的范例来增加用户自定义的解析工具类。其主要缺点在于与 Java 代码结合紧密，配置信息的改变需要重新编译 Java 代码，另外这是一种新引入的解析方式，需要一定的学习成本。</h5><p><br></p>\n<h4 id=\"提及一点的就是，Spring框架有3个主要的Hook类，分别是：\"><a href=\"#提及一点的就是，Spring框架有3个主要的Hook类，分别是：\" class=\"headerlink\" title=\"提及一点的就是，Spring框架有3个主要的Hook类，分别是：\"></a>提及一点的就是，Spring框架有3个主要的Hook类，分别是：</h4><p><code>org.springframework.context.ApplicationContextAware</code></p>\n<h5 id=\"它的setApplicationContext-方法将在Spring启动之前第一个被调用。\"><a href=\"#它的setApplicationContext-方法将在Spring启动之前第一个被调用。\" class=\"headerlink\" title=\"它的setApplicationContext 方法将在Spring启动之前第一个被调用。\"></a>它的setApplicationContext 方法将在Spring启动之前第一个被调用。</h5><p><code>org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor</code></p>\n<h5 id=\"它的postProcessBeanDefinitionRegistry-和-postProcessBeanFactory-方法是第二和第三被调用，它们在Bean初始化创建之前启动，如果Spring的bean需要的其他第三方中的组件，我们在这里将其注入给Spring。\"><a href=\"#它的postProcessBeanDefinitionRegistry-和-postProcessBeanFactory-方法是第二和第三被调用，它们在Bean初始化创建之前启动，如果Spring的bean需要的其他第三方中的组件，我们在这里将其注入给Spring。\" class=\"headerlink\" title=\"它的postProcessBeanDefinitionRegistry 和 postProcessBeanFactory 方法是第二和第三被调用，它们在Bean初始化创建之前启动，如果Spring的bean需要的其他第三方中的组件，我们在这里将其注入给Spring。\"></a>它的postProcessBeanDefinitionRegistry 和 postProcessBeanFactory 方法是第二和第三被调用，它们在Bean初始化创建之前启动，如果Spring的bean需要的其他第三方中的组件，我们在这里将其注入给Spring。</h5><p><code>org.springframework.context.ApplicationListener</code><br>用于在初始化完成后做一些事情，当Spring所有XML或元注解的Bean都启动被创建成功了，这时会调用它的唯一方法onApplicationEvent。<br><br></p>\n<h4 id=\"通过-BeanDefinitionRegistryPostProcessor-加载自己的bean的demo：\"><a href=\"#通过-BeanDefinitionRegistryPostProcessor-加载自己的bean的demo：\" class=\"headerlink\" title=\"通过 BeanDefinitionRegistryPostProcessor 加载自己的bean的demo：\"></a>通过 BeanDefinitionRegistryPostProcessor 加载自己的bean的demo：</h4><pre><code class=\"lang-java\">import org.springframework.beans.BeansException;\nimport org.springframework.beans.MutablePropertyValues;\nimport org.springframework.beans.factory.annotation.AnnotatedBeanDefinition;\nimport org.springframework.beans.factory.annotation.AnnotatedGenericBeanDefinition;\nimport org.springframework.beans.factory.config.BeanDefinition;\nimport org.springframework.beans.factory.config.BeanDefinitionHolder;\nimport org.springframework.beans.factory.config.ConfigurableListableBeanFactory;\nimport org.springframework.beans.factory.support.BeanDefinitionReaderUtils;\nimport org.springframework.beans.factory.support.BeanDefinitionRegistry;\nimport org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor;\n\n/**\n * @author winx\n * @create 2017-09-01.\n */\n@Configuration\npublic class MyBeanDefinitionRegistryPostProcessor implements BeanDefinitionRegistryPostProcessor {\n\n    /**\n     * 先执行：postProcessBeanDefinitionRegistry()方法\n     * 通过Class对象，注册自己的 BeanDefinition\n     */\n    @Override\n    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException {\n        try {\n            AnnotatedBeanDefinition annotatedBeanDefinition = new AnnotatedGenericBeanDefinition(Class.forName(&quot;&quot;));\n            BeanDefinitionHolder beanDefinitionHolder = new BeanDefinitionHolder(annotatedBeanDefinition, &quot;beanName&quot;);\n            BeanDefinitionReaderUtils.registerBeanDefinition(beanDefinitionHolder, registry);\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * 再执行：postProcessBeanFactory()方法。\n     * 通过 beanName 拿到注册后的 BeanDefinition\n     * 然后加入自定义属性，BeanDefinition 会在初始化bean时，将 Property 键值对插入到之前的Class对象属性中。\n     */\n    @Override\n    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {\n        BeanDefinition beanDefinition = beanFactory.getBeanDefinition(&quot;beanName&quot;);\n        MutablePropertyValues mutablePropertyValues = beanDefinition.getPropertyValues();\n        //加入属性.\n        mutablePropertyValues.addPropertyValue(&quot;username&quot;, &quot;root&quot;);\n    }\n}\n</code></pre>\n<h5 id=\"Configuration注解提示spring-boot通过该类加载bean\"><a href=\"#Configuration注解提示spring-boot通过该类加载bean\" class=\"headerlink\" title=\"@Configuration注解提示spring boot通过该类加载bean\"></a><code>@Configuration</code>注解提示spring boot通过该类加载bean</h5><h5 id=\"postProcessBeanDefinitionRegistry-通过Class对象，注册自己的-BeanDefinition\"><a href=\"#postProcessBeanDefinitionRegistry-通过Class对象，注册自己的-BeanDefinition\" class=\"headerlink\" title=\"postProcessBeanDefinitionRegistry() 通过Class对象，注册自己的 BeanDefinition\"></a><code>postProcessBeanDefinitionRegistry()</code> 通过Class对象，注册自己的 BeanDefinition</h5><h5 id=\"postProcessBeanFactory-方法会在postProcessBeanDefinitionRegistry-之后执行，-通过beanFactory拿到-BeanDefinition-后加入属性，这一步可以跳过。\"><a href=\"#postProcessBeanFactory-方法会在postProcessBeanDefinitionRegistry-之后执行，-通过beanFactory拿到-BeanDefinition-后加入属性，这一步可以跳过。\" class=\"headerlink\" title=\"postProcessBeanFactory()方法会在postProcessBeanDefinitionRegistry()之后执行， 通过beanFactory拿到 BeanDefinition 后加入属性，这一步可以跳过。\"></a><code>postProcessBeanFactory()</code>方法会在<code>postProcessBeanDefinitionRegistry()</code>之后执行， 通过beanFactory拿到 BeanDefinition 后加入属性，这一步可以跳过。</h5><h3 id=\"实际项目需求\"><a href=\"#实际项目需求\" class=\"headerlink\" title=\"实际项目需求\"></a>实际项目需求</h3><h5 id=\"目前项目分为线上环境和dev环境，项目本身只支持http服务，因为线上环境有nginx做反向代理，所以用http和https均能正常访问线上服务。但是本地环境相对简单，不能支持https服务。先在需要根据环境的不同。动态的扩张spring-boot的多连接器设置。当环境为dev时，即加载多连接器，分别用两个端口提供http和https服务。当环境不为dev时，只加载默认http即可。\"><a href=\"#目前项目分为线上环境和dev环境，项目本身只支持http服务，因为线上环境有nginx做反向代理，所以用http和https均能正常访问线上服务。但是本地环境相对简单，不能支持https服务。先在需要根据环境的不同。动态的扩张spring-boot的多连接器设置。当环境为dev时，即加载多连接器，分别用两个端口提供http和https服务。当环境不为dev时，只加载默认http即可。\" class=\"headerlink\" title=\"　　目前项目分为线上环境和dev环境，项目本身只支持http服务，因为线上环境有nginx做反向代理，所以用http和https均能正常访问线上服务。但是本地环境相对简单，不能支持https服务。先在需要根据环境的不同。动态的扩张spring boot的多连接器设置。当环境为dev时，即加载多连接器，分别用两个端口提供http和https服务。当环境不为dev时，只加载默认http即可。\"></a>　　目前项目分为线上环境和dev环境，项目本身只支持http服务，因为线上环境有nginx做反向代理，所以用http和https均能正常访问线上服务。但是本地环境相对简单，不能支持https服务。先在需要根据环境的不同。动态的扩张spring boot的多连接器设置。当环境为dev时，即加载多连接器，分别用两个端口提供http和https服务。当环境不为dev时，只加载默认http即可。</h5><h5 id=\"根据这些需求，通过xml或者annotation去定义bean都不太合适。只能是通过java-code去判断环境并动态加载。\"><a href=\"#根据这些需求，通过xml或者annotation去定义bean都不太合适。只能是通过java-code去判断环境并动态加载。\" class=\"headerlink\" title=\"　　根据这些需求，通过xml或者annotation去定义bean都不太合适。只能是通过java code去判断环境并动态加载。\"></a>　　根据这些需求，通过xml或者annotation去定义bean都不太合适。只能是通过java code去判断环境并动态加载。</h5><h5 id=\"省去spring-boot支持https以及多连接器的配置，相关的代码网络上很多。直接说遇到的主要问题吧。上面的demo通过mutablePropertyValues-addPropertyValue-quot-key-quot-quot-root-quot-的方式为目标class定义属性，但是要求属性key必须有相应的set方法。\"><a href=\"#省去spring-boot支持https以及多连接器的配置，相关的代码网络上很多。直接说遇到的主要问题吧。上面的demo通过mutablePropertyValues-addPropertyValue-quot-key-quot-quot-root-quot-的方式为目标class定义属性，但是要求属性key必须有相应的set方法。\" class=\"headerlink\" title=\"　　省去spring boot支持https以及多连接器的配置，相关的代码网络上很多。直接说遇到的主要问题吧。上面的demo通过mutablePropertyValues.addPropertyValue(&quot;key&quot;, &quot;root&quot;);的方式为目标class定义属性，但是要求属性key必须有相应的set方法。\"></a>　　省去spring boot支持https以及多连接器的配置，相关的代码网络上很多。直接说遇到的主要问题吧。上面的demo通过<code>mutablePropertyValues.addPropertyValue(&quot;key&quot;, &quot;root&quot;);</code>的方式为目标class定义属性，但是要求属性key必须有相应的set方法。</h5><pre><code class=\"lang-java\">@Configuration\npublic class HttpsBeanDefinitionRegistryPostProcessor implements BeanDefinitionRegistryPostProcessor, EnvironmentAware {\n\n    private String profile;\n\n    @Override\n    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry beanDefinitionRegistry) throws BeansException {\n        if (&quot;dev&quot;.equals(profile)){\n            AnnotatedBeanDefinition annotatedBeanDefinition = new AnnotatedGenericBeanDefinition(TomcatEmbeddedServletContainerFactory.class);\n            BeanDefinitionHolder beanDefinitionHolder = new BeanDefinitionHolder(annotatedBeanDefinition, &quot;tomcatEmbeddedServletContainerFactory&quot;);\n            BeanDefinitionReaderUtils.registerBeanDefinition(beanDefinitionHolder, beanDefinitionRegistry);\n        }\n    }\n\n    @Override\n    public void postProcessBeanFactory(ConfigurableListableBeanFactory configurableListableBeanFactory) throws BeansException {\n        MutablePropertyValues tomcatEmbeddedServletContainerFactory = configurableListableBeanFactory.getBeanDefinition(&quot;tomcatEmbeddedServletContainerFactory&quot;).getPropertyValues();\n        tomcatEmbeddedServletContainerFactory.addPropertyValue(&quot;additionalTomcatConnectors&quot;, getConnector());\n    }\n\n    public Connector getConnector(){\n        Connector connector = new Connector(&quot;org.apache.coyote.http11.Http11NioProtocol&quot;);\n        Http11NioProtocol protocol = (Http11NioProtocol) connector.getProtocolHandler();\n        connector.setScheme(&quot;https&quot;);\n        connector.setSecure(true);\n        connector.setPort(8443);\n        protocol.setSSLEnabled(true);\n        protocol.setKeystoreFile(&quot;/Users/winx/.keystore&quot;);\n        protocol.setKeystorePass(&quot;123456&quot;);\n        protocol.setTruststoreFile(&quot;/Users/winx/.keystore&quot;);\n        protocol.setTruststorePass(&quot;123456&quot;);\n        protocol.setKeyAlias(&quot;tomcat&quot;);\n        return connector;\n    }\n\n    @Override\n    public void setEnvironment(Environment environment) {\n        profile = environment.getProperty(&quot;profile&quot;);\n    }\n}\n</code></pre>\n<h5 id=\"在拿到MutablePropertyValues之后，想要给TomcatEmbeddedServletContainerFactory对象设置additionalTomcatConnectors属性，Connector中包含了https关键信息的设置。之后报错如下：\"><a href=\"#在拿到MutablePropertyValues之后，想要给TomcatEmbeddedServletContainerFactory对象设置additionalTomcatConnectors属性，Connector中包含了https关键信息的设置。之后报错如下：\" class=\"headerlink\" title=\"　　在拿到MutablePropertyValues之后，想要给TomcatEmbeddedServletContainerFactory对象设置additionalTomcatConnectors属性，Connector中包含了https关键信息的设置。之后报错如下：\"></a>　　在拿到<code>MutablePropertyValues</code>之后，想要给<code>TomcatEmbeddedServletContainerFactory</code>对象设置<code>additionalTomcatConnectors</code>属性，Connector中包含了https关键信息的设置。之后报错如下：</h5><pre><code>org.springframework.context.ApplicationContextException: Unable to start embedded container; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#39;tomcatEmbeddedServletContainerFactory&#39;: Error setting property values; nested exception is org.springframework.beans.NotWritablePropertyException: Invalid property &#39;additionalTomcatConnectors&#39; of bean class [org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedServletContainerFactory]: Bean property &#39;additionalTomcatConnectors&#39; is not writable or has an invalid setter method. Does the parameter type of the setter match the return type of the getter?\n    at org.springframework.boot.context.embedded.EmbeddedWebApplicationContext.onRefresh(EmbeddedWebApplicationContext.java:133) ~[spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n    at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:532) ~[spring-context-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n    at org.springframework.boot.context.embedded.EmbeddedWebApplicationContext.refresh(EmbeddedWebApplicationContext.java:118) ~[spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n    at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:760) [spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n    at org.springframework.boot.SpringApplication.createAndRefreshContext(SpringApplication.java:360) [spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n    at org.springframework.boot.SpringApplication.run(SpringApplication.java:306) [spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n    at org.springframework.boot.SpringApplication.run(SpringApplication.java:1185) [spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n    at org.springframework.boot.SpringApplication.run(SpringApplication.java:1174) [spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n    at com.winx.es.metis.RunMetis.main(RunMetis.java:47) [classes/:na]\nCaused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#39;tomcatEmbeddedServletContainerFactory&#39;: Error setting property values; nested exception is org.springframework.beans.NotWritablePropertyException: Invalid property &#39;additionalTomcatConnectors&#39; of bean class [org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedServletContainerFactory]: Bean property &#39;additionalTomcatConnectors&#39; is not writable or has an invalid setter method. Does the parameter type of the setter match the return type of the getter?\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyPropertyValues(AbstractAutowireCapableBeanFactory.java:1518) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1226) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:543) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:482) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n    at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:306) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n    at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n    at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:302) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n    at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n    at org.springframework.boot.context.embedded.EmbeddedWebApplicationContext.getEmbeddedServletContainerFactory(EmbeddedWebApplicationContext.java:195) ~[spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n    at org.springframework.boot.context.embedded.EmbeddedWebApplicationContext.createEmbeddedServletContainer(EmbeddedWebApplicationContext.java:158) ~[spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n    at org.springframework.boot.context.embedded.EmbeddedWebApplicationContext.onRefresh(EmbeddedWebApplicationContext.java:130) ~[spring-boot-1.3.6.RELEASE.jar:1.3.6.RELEASE]\n    ... 8 common frames omitted\nCaused by: org.springframework.beans.NotWritablePropertyException: Invalid property &#39;additionalTomcatConnectors&#39; of bean class [org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedServletContainerFactory]: Bean property &#39;additionalTomcatConnectors&#39; is not writable or has an invalid setter method. Does the parameter type of the setter match the return type of the getter?\n    at org.springframework.beans.BeanWrapperImpl.createNotWritablePropertyException(BeanWrapperImpl.java:230) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n    at org.springframework.beans.AbstractNestablePropertyAccessor.setPropertyValue(AbstractNestablePropertyAccessor.java:423) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n    at org.springframework.beans.AbstractNestablePropertyAccessor.setPropertyValue(AbstractNestablePropertyAccessor.java:280) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n    at org.springframework.beans.AbstractPropertyAccessor.setPropertyValues(AbstractPropertyAccessor.java:95) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n    at org.springframework.beans.AbstractPropertyAccessor.setPropertyValues(AbstractPropertyAccessor.java:75) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyPropertyValues(AbstractAutowireCapableBeanFactory.java:1514) ~[spring-beans-4.2.7.RELEASE.jar:4.2.7.RELEASE]\n    ... 18 common frames omitted\n</code></pre><h5 id=\"关键错误信息：Bean-property-39-additionalTomcatConnectors-39-is-not-writable-or-has-an-invalid-setter-method-Does-the-parameter-type-of-the-setter-match-the-return-type-of-the-getter-，没有权限写入以及没有找到相应的个体方法。\"><a href=\"#关键错误信息：Bean-property-39-additionalTomcatConnectors-39-is-not-writable-or-has-an-invalid-setter-method-Does-the-parameter-type-of-the-setter-match-the-return-type-of-the-getter-，没有权限写入以及没有找到相应的个体方法。\" class=\"headerlink\" title=\"　　关键错误信息：Bean property &#39;additionalTomcatConnectors&#39; is not writable or has an invalid setter method. Does the parameter type of the setter match the return type of the getter?，没有权限写入以及没有找到相应的个体方法。\"></a>　　<strong>关键错误信息</strong>：<code>Bean property &#39;additionalTomcatConnectors&#39; is not writable or has an invalid setter method. Does the parameter type of the setter match the return type of the getter?</code>，没有权限写入以及没有找到相应的个体方法。</h5><h5 id=\"查看TomcatEmbeddedServletContainerFactory源码后发现其相应的设置方法如下：\"><a href=\"#查看TomcatEmbeddedServletContainerFactory源码后发现其相应的设置方法如下：\" class=\"headerlink\" title=\"查看TomcatEmbeddedServletContainerFactory源码后发现其相应的设置方法如下：\"></a>查看<code>TomcatEmbeddedServletContainerFactory</code>源码后发现其相应的设置方法如下：</h5><pre><code class=\"lang-java\">public void addAdditionalTomcatConnectors(Connector... connectors) {\n    Assert.notNull(connectors, &quot;Connectors must not be null&quot;);\n    this.additionalTomcatConnectors.addAll(Arrays.asList(connectors));\n}\n</code></pre>\n<h5 id=\"顿时觉得坑爹的add啊，之后在Bean-Definition的私有属性设置，以及通过方法设置属性值得方向去尝试解决问题，没有任何效果。几乎快要绝望的时候，突然灵机一动，为什么我不能自己定义一个不需要后置设置属性的TomcatEmbeddedServletContainerFactory呢，于是有了下面的代码：\"><a href=\"#顿时觉得坑爹的add啊，之后在Bean-Definition的私有属性设置，以及通过方法设置属性值得方向去尝试解决问题，没有任何效果。几乎快要绝望的时候，突然灵机一动，为什么我不能自己定义一个不需要后置设置属性的TomcatEmbeddedServletContainerFactory呢，于是有了下面的代码：\" class=\"headerlink\" title=\"　　顿时觉得坑爹的add啊，之后在Bean Definition的私有属性设置，以及通过方法设置属性值得方向去尝试解决问题，没有任何效果。几乎快要绝望的时候，突然灵机一动，为什么我不能自己定义一个不需要后置设置属性的TomcatEmbeddedServletContainerFactory呢，于是有了下面的代码：\"></a>　　顿时觉得坑爹的add啊，之后在Bean Definition的私有属性设置，以及通过方法设置属性值得方向去尝试解决问题，没有任何效果。几乎快要绝望的时候，突然灵机一动，为什么我不能自己定义一个不需要后置设置属性的<code>TomcatEmbeddedServletContainerFactory</code>呢，于是有了下面的代码：</h5><pre><code class=\"lang-java\">@Configuration\npublic class HttpsBeanDefinitionRegistryPostProcessor implements BeanDefinitionRegistryPostProcessor, EnvironmentAware {\n\n    private String profile;\n\n    @Override\n    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry beanDefinitionRegistry) throws BeansException {\n        if (&quot;dev&quot;.equals(profile)){\n            AnnotatedBeanDefinition annotatedBeanDefinition = new AnnotatedGenericBeanDefinition(HttpsTomcatEmbeddedServletContainerFactory.class);\n            BeanDefinitionHolder beanDefinitionHolder = new BeanDefinitionHolder(annotatedBeanDefinition, &quot;tomcatEmbeddedServletContainerFactory&quot;);\n            BeanDefinitionReaderUtils.registerBeanDefinition(beanDefinitionHolder, beanDefinitionRegistry);\n        }\n    }\n\n    @Override\n    public void postProcessBeanFactory(ConfigurableListableBeanFactory configurableListableBeanFactory) throws BeansException {}\n\n\n    @Override\n    public void setEnvironment(Environment environment) {\n        profile = environment.getProperty(&quot;profile&quot;);\n    }\n}\n</code></pre>\n<h5 id=\"注意上面的注入对象是HttpsTomcatEmbeddedServletContainerFactory，不是之前的TomcatEmbeddedServletContainerFactory，贴上HttpsTomcatEmbeddedServletContainerFactory代码：\"><a href=\"#注意上面的注入对象是HttpsTomcatEmbeddedServletContainerFactory，不是之前的TomcatEmbeddedServletContainerFactory，贴上HttpsTomcatEmbeddedServletContainerFactory代码：\" class=\"headerlink\" title=\"　　注意上面的注入对象是HttpsTomcatEmbeddedServletContainerFactory，不是之前的TomcatEmbeddedServletContainerFactory，贴上HttpsTomcatEmbeddedServletContainerFactory代码：\"></a>　　注意上面的注入对象是<code>HttpsTomcatEmbeddedServletContainerFactory</code>，不是之前的<code>TomcatEmbeddedServletContainerFactory</code>，贴上<code>HttpsTomcatEmbeddedServletContainerFactory</code>代码：</h5><pre><code class=\"lang-java\">import org.apache.catalina.connector.Connector;\nimport org.apache.coyote.http11.Http11NioProtocol;\nimport org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedServletContainerFactory;\n\n/**\n * @author winx\n * @create 2017-09-01.\n */\npublic class HttpsTomcatEmbeddedServletContainerFactory extends TomcatEmbeddedServletContainerFactory {\n\n    public HttpsTomcatEmbeddedServletContainerFactory() {\n        super();\n        Connector connector = new Connector(&quot;org.apache.coyote.http11.Http11NioProtocol&quot;);\n        Http11NioProtocol protocol = (Http11NioProtocol) connector.getProtocolHandler();\n        connector.setScheme(&quot;https&quot;);\n        connector.setSecure(true);\n        connector.setPort(8443);\n        protocol.setSSLEnabled(true);\n        protocol.setKeystoreFile(&quot;/Users/winx/.keystore&quot;);\n        protocol.setKeystorePass(&quot;123456&quot;);\n        protocol.setTruststoreFile(&quot;/Users/winx/.keystore&quot;);\n        protocol.setTruststorePass(&quot;123456&quot;);\n        protocol.setKeyAlias(&quot;tomcat&quot;);\n        addAdditionalTomcatConnectors(connector);\n    }\n}\n</code></pre>\n<h5 id=\"成功的解决了之前属性设置问题。\"><a href=\"#成功的解决了之前属性设置问题。\" class=\"headerlink\" title=\"成功的解决了之前属性设置问题。\"></a>成功的解决了之前属性设置问题。</h5>"},{"layout":"book","title":"java核心技术 卷I","date":"2016-12-31T16:00:00.000Z","cover":"coreJavaVolume1.jpeg","_content":"","source":"_posts/read/coreJava.md","raw":"---\nlayout: book\ntitle: java核心技术 卷I\ndate: 2017/01/01\ncover: coreJavaVolume1.jpeg\ncategories: [read]\n---\n","slug":"read/coreJava","published":1,"updated":"2017-08-15T11:31:46.000Z","comments":1,"photos":[],"link":"","_id":"cj8jros80001o30s6il8t8b0t","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"book","title":"乌合之众","author":"古斯塔夫・勒庞","date":"2016-12-31T16:00:00.000Z","cover":"crowd.png","_content":"","source":"_posts/read/crowd.md","raw":"---\nlayout: book\ntitle: 乌合之众\nauthor: 古斯塔夫・勒庞\ndate: 2017/01/01\ncover: crowd.png\ncategories: [read]\n---\n","slug":"read/crowd","published":1,"updated":"2017-08-15T11:31:46.000Z","comments":1,"photos":[],"link":"","_id":"cj8jros82001q30s6gg0pxq2t","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"book","title":"牛奶可乐经济学","date":"2016-12-14T16:00:00.000Z","cover":"milk.jpeg","_content":"","source":"_posts/read/economics.md","raw":"---\nlayout: book\ntitle: 牛奶可乐经济学\ndate: 2016/12/15\ncover: milk.jpeg\ncategories: [read]\n---\n","slug":"read/economics","published":1,"updated":"2017-08-15T11:31:46.000Z","comments":1,"photos":[],"link":"","_id":"cj8jros82001s30s6h8udouda","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"book","title":"父与子","date":"2016-12-31T16:00:00.000Z","cover":"fatherAndSon.jpeg","_content":"","source":"_posts/read/fatherAndSon.md","raw":"---\nlayout: book\ntitle: 父与子\ndate: 2017/01/01\ncover: fatherAndSon.jpeg\ncategories: [read]\n---\n","slug":"read/fatherAndSon","published":1,"updated":"2017-08-15T11:31:46.000Z","comments":1,"photos":[],"link":"","_id":"cj8jros83001u30s6so5uqla3","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"book","title":"当我们谈论爱情时，我们在谈论什么","date":"2016-12-14T16:00:00.000Z","cover":"love.jpeg","_content":"","source":"_posts/read/love.md","raw":"---\nlayout: book\ntitle: 当我们谈论爱情时，我们在谈论什么\ndate: 2016/12/15\ncover: love.jpeg\ncategories: [read]\n---\n","slug":"read/love","published":1,"updated":"2017-08-15T11:31:46.000Z","comments":1,"photos":[],"link":"","_id":"cj8jros84001x30s6lyk2vqe1","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"book","title":"黄金时代","author":"王小波","date":"2017-04-23T16:00:00.000Z","cover":"goldenAge.jpg","color":"#F8CA6B","_content":"\n##### 《黄金时代》包括中篇小说《黄金时代》、《三十而立》、《似水流年》、《革命时期的爱情》和《我的阴阳两界》等。\n\n## 笔记\n\n### 　　\"我是这么想的：假如我想证明她不是破鞋，就能证明她不是破鞋，那事情未免太容易了。实际上我什么都不能证明，除了那些不需要证明的东西。\"\n##### 　　在某些程度上，我们什么都证明不了。姓名、年龄、经历。因为这些都是建立在一定的某些基础之上，当世界上的人说你不是你自己时，你就不是你自己。你没法证明。\n\n### 　　\"我想到，用不着写诗给别人看，如果一个人来享受静夜，我的诗对他毫无用处。别人念了它，只会妨碍他享受自己的静夜诗。如果一个人不会唱，那么全世界的歌对他毫无用处；如果他会唱，那他一定要唱自己的歌。这就是说，诗人这个行当应该取消，每个人都要做自己的诗人。\"\n##### 　　从古至今留存下来的诗集，从来都是作者对自己内心的一种情感抒发。每个人都要做自己的诗人\n\n### 　　\"照批者认为，这李先生是无聊之辈，你何必理他？既然理他，你也是无聊之辈。但是李先生对着大字报倒是认真答辩了。他认为大道理管小道理，其实是不讲理。大问题管小问题，实则混淆命题。就算揭批查重要，也不能叫人龟头血肿呀？只论大小重要不重要，不论是非真伪，是混蛋逻辑。\"\n\n### 　　\"文化革命\"到来之时，有些人高兴，有些人不高兴。刘老先生对我说过，一开头他就想自杀。因为他见那势头，总觉得躲不过去。但是他想到再峨嵋酒家还能吃到东坡肘子，又觉得死了太亏。\"\n##### 　　有时候让你坚持下去往往是一些很不起眼的东西。\n\n### 　　\"我活得很没劲，好像一个没用的人。人到了这步田地，反而会脑子伟大的想法。那时我想：要是发生了战争就好了。\"\n\n### 　　\"人在四十岁之前，过得很慢，过了四十岁，过得就快了。\"\n\n### 　　\"爬铜炉子没有一点好处，只能带来刻骨铭心的痛苦，但我还是要爬。这大概是说明你干的事情越傻，决心就会越大吧。这也说明我喜欢自己愚弄自己，却不喜欢被别人愚弄。\"\n\n### 　　\"在革命时期里，我随时准备承认自己是一只猪，来换取安宁。\"\n\n### 　　\"既然人饿了就要吃饭，渴了就要喝水，到了一定岁数就想性交，上了会场就要发呆，同属万般无奈；所以吃饭喝水性交和发呆，都属天赋人权的范畴。假如人犯了错误，可以用别的方法来惩办，却不能令他不发呆。如不其然，就会引起火灾。\"\n\n### 　　\"对于不能恨的人，我只能用爱来化解仇恨。我爱上她了。\"\n\n### 　　\"人活在世界上，快乐和痛苦本就分不清。所以我只求它货真价实。\"\n\n### 　　\"有关我爸爸打我的事，还有一些要补充的地方。他戴着高帽子游街，我看到他时笑了一笑，于是我就挨了一顿打。由此容易得出一个结论：在那种场合应该苦着脸。但是这个结论是错的，因为哭丧着脸也要挨打。正确的结论是到了我该挨打的时候就会挨打，不管我是哭还是笑。既然活在世界上，不管怎样都要挨打，所以做什么都没有了意义。唯一有意义的事就是寻找神奇。\"\n\n### 　　\"弗洛伊德说，受虐狂是这样形成的：假如人处于一种不能克服的痛苦之中，就会爱上这种痛苦，把它看成幸福。\"\n\n### 　　\"在革命时期自己失掉了一个人，就如损失了十几块钱，有点伤心。这时候我们背上一段毛主席语录：“这种方法也要介绍到老百姓那里去，村上的人死了，开个追悼会，用这种方法寄托我们的哀思……”，然后就一点也不伤心，因为伤心被这种程式消化了。这种种程式就是高级智能。因为有了这种种程式，好多东西失去了它本来的意义——连死都不真了。\"\n\n### 　　\"小孙和我谈恋爱，结果是我们俩都变成了一种气体，叫做什么一氧化二氮，或者说，叫做笑气，人家一见到我们在一起就要笑。\"\n\n### 　　\"李先生见了我就说这件事，同时愁眉苦脸。我就安慰他说：这也好，省得再找我修。我这样安慰过以后，他好像更伤心了。这件事证明了一个道理：萨特先生说得很对，他人是你的地狱。\"\n\n### 　　\"李先生干出了一件大家都干不出的事，这一点没有问题。这证明了他和大家不一样，这一点也没有问题。但是这种不一样是聪明还是有毛病，还没有定论。既然如此，就应该少数服从多数。大家说你聪明，你就是聪明，大家觉得你有毛病，你就是有毛病。\"","source":"_posts/read/goldenAge.md","raw":"---\nlayout: book\ntitle: 黄金时代\nauthor: 王小波\ndate: 2017/04/24\ncover: goldenAge.jpg\ncategories: [read]\ncolor: '#F8CA6B'\n---\n\n##### 《黄金时代》包括中篇小说《黄金时代》、《三十而立》、《似水流年》、《革命时期的爱情》和《我的阴阳两界》等。\n\n## 笔记\n\n### 　　\"我是这么想的：假如我想证明她不是破鞋，就能证明她不是破鞋，那事情未免太容易了。实际上我什么都不能证明，除了那些不需要证明的东西。\"\n##### 　　在某些程度上，我们什么都证明不了。姓名、年龄、经历。因为这些都是建立在一定的某些基础之上，当世界上的人说你不是你自己时，你就不是你自己。你没法证明。\n\n### 　　\"我想到，用不着写诗给别人看，如果一个人来享受静夜，我的诗对他毫无用处。别人念了它，只会妨碍他享受自己的静夜诗。如果一个人不会唱，那么全世界的歌对他毫无用处；如果他会唱，那他一定要唱自己的歌。这就是说，诗人这个行当应该取消，每个人都要做自己的诗人。\"\n##### 　　从古至今留存下来的诗集，从来都是作者对自己内心的一种情感抒发。每个人都要做自己的诗人\n\n### 　　\"照批者认为，这李先生是无聊之辈，你何必理他？既然理他，你也是无聊之辈。但是李先生对着大字报倒是认真答辩了。他认为大道理管小道理，其实是不讲理。大问题管小问题，实则混淆命题。就算揭批查重要，也不能叫人龟头血肿呀？只论大小重要不重要，不论是非真伪，是混蛋逻辑。\"\n\n### 　　\"文化革命\"到来之时，有些人高兴，有些人不高兴。刘老先生对我说过，一开头他就想自杀。因为他见那势头，总觉得躲不过去。但是他想到再峨嵋酒家还能吃到东坡肘子，又觉得死了太亏。\"\n##### 　　有时候让你坚持下去往往是一些很不起眼的东西。\n\n### 　　\"我活得很没劲，好像一个没用的人。人到了这步田地，反而会脑子伟大的想法。那时我想：要是发生了战争就好了。\"\n\n### 　　\"人在四十岁之前，过得很慢，过了四十岁，过得就快了。\"\n\n### 　　\"爬铜炉子没有一点好处，只能带来刻骨铭心的痛苦，但我还是要爬。这大概是说明你干的事情越傻，决心就会越大吧。这也说明我喜欢自己愚弄自己，却不喜欢被别人愚弄。\"\n\n### 　　\"在革命时期里，我随时准备承认自己是一只猪，来换取安宁。\"\n\n### 　　\"既然人饿了就要吃饭，渴了就要喝水，到了一定岁数就想性交，上了会场就要发呆，同属万般无奈；所以吃饭喝水性交和发呆，都属天赋人权的范畴。假如人犯了错误，可以用别的方法来惩办，却不能令他不发呆。如不其然，就会引起火灾。\"\n\n### 　　\"对于不能恨的人，我只能用爱来化解仇恨。我爱上她了。\"\n\n### 　　\"人活在世界上，快乐和痛苦本就分不清。所以我只求它货真价实。\"\n\n### 　　\"有关我爸爸打我的事，还有一些要补充的地方。他戴着高帽子游街，我看到他时笑了一笑，于是我就挨了一顿打。由此容易得出一个结论：在那种场合应该苦着脸。但是这个结论是错的，因为哭丧着脸也要挨打。正确的结论是到了我该挨打的时候就会挨打，不管我是哭还是笑。既然活在世界上，不管怎样都要挨打，所以做什么都没有了意义。唯一有意义的事就是寻找神奇。\"\n\n### 　　\"弗洛伊德说，受虐狂是这样形成的：假如人处于一种不能克服的痛苦之中，就会爱上这种痛苦，把它看成幸福。\"\n\n### 　　\"在革命时期自己失掉了一个人，就如损失了十几块钱，有点伤心。这时候我们背上一段毛主席语录：“这种方法也要介绍到老百姓那里去，村上的人死了，开个追悼会，用这种方法寄托我们的哀思……”，然后就一点也不伤心，因为伤心被这种程式消化了。这种种程式就是高级智能。因为有了这种种程式，好多东西失去了它本来的意义——连死都不真了。\"\n\n### 　　\"小孙和我谈恋爱，结果是我们俩都变成了一种气体，叫做什么一氧化二氮，或者说，叫做笑气，人家一见到我们在一起就要笑。\"\n\n### 　　\"李先生见了我就说这件事，同时愁眉苦脸。我就安慰他说：这也好，省得再找我修。我这样安慰过以后，他好像更伤心了。这件事证明了一个道理：萨特先生说得很对，他人是你的地狱。\"\n\n### 　　\"李先生干出了一件大家都干不出的事，这一点没有问题。这证明了他和大家不一样，这一点也没有问题。但是这种不一样是聪明还是有毛病，还没有定论。既然如此，就应该少数服从多数。大家说你聪明，你就是聪明，大家觉得你有毛病，你就是有毛病。\"","slug":"read/goldenAge","published":1,"updated":"2017-08-15T11:31:46.000Z","comments":1,"photos":[],"link":"","_id":"cj8jros85002030s60nv3i1du","content":"<h5 id=\"《黄金时代》包括中篇小说《黄金时代》、《三十而立》、《似水流年》、《革命时期的爱情》和《我的阴阳两界》等。\"><a href=\"#《黄金时代》包括中篇小说《黄金时代》、《三十而立》、《似水流年》、《革命时期的爱情》和《我的阴阳两界》等。\" class=\"headerlink\" title=\"《黄金时代》包括中篇小说《黄金时代》、《三十而立》、《似水流年》、《革命时期的爱情》和《我的阴阳两界》等。\"></a>《黄金时代》包括中篇小说《黄金时代》、《三十而立》、《似水流年》、《革命时期的爱情》和《我的阴阳两界》等。</h5><h2 id=\"笔记\"><a href=\"#笔记\" class=\"headerlink\" title=\"笔记\"></a>笔记</h2><h3 id=\"“我是这么想的：假如我想证明她不是破鞋，就能证明她不是破鞋，那事情未免太容易了。实际上我什么都不能证明，除了那些不需要证明的东西。”\"><a href=\"#“我是这么想的：假如我想证明她不是破鞋，就能证明她不是破鞋，那事情未免太容易了。实际上我什么都不能证明，除了那些不需要证明的东西。”\" class=\"headerlink\" title=\"　　“我是这么想的：假如我想证明她不是破鞋，就能证明她不是破鞋，那事情未免太容易了。实际上我什么都不能证明，除了那些不需要证明的东西。”\"></a>　　“我是这么想的：假如我想证明她不是破鞋，就能证明她不是破鞋，那事情未免太容易了。实际上我什么都不能证明，除了那些不需要证明的东西。”</h3><h5 id=\"在某些程度上，我们什么都证明不了。姓名、年龄、经历。因为这些都是建立在一定的某些基础之上，当世界上的人说你不是你自己时，你就不是你自己。你没法证明。\"><a href=\"#在某些程度上，我们什么都证明不了。姓名、年龄、经历。因为这些都是建立在一定的某些基础之上，当世界上的人说你不是你自己时，你就不是你自己。你没法证明。\" class=\"headerlink\" title=\"　　在某些程度上，我们什么都证明不了。姓名、年龄、经历。因为这些都是建立在一定的某些基础之上，当世界上的人说你不是你自己时，你就不是你自己。你没法证明。\"></a>　　在某些程度上，我们什么都证明不了。姓名、年龄、经历。因为这些都是建立在一定的某些基础之上，当世界上的人说你不是你自己时，你就不是你自己。你没法证明。</h5><h3 id=\"“我想到，用不着写诗给别人看，如果一个人来享受静夜，我的诗对他毫无用处。别人念了它，只会妨碍他享受自己的静夜诗。如果一个人不会唱，那么全世界的歌对他毫无用处；如果他会唱，那他一定要唱自己的歌。这就是说，诗人这个行当应该取消，每个人都要做自己的诗人。”\"><a href=\"#“我想到，用不着写诗给别人看，如果一个人来享受静夜，我的诗对他毫无用处。别人念了它，只会妨碍他享受自己的静夜诗。如果一个人不会唱，那么全世界的歌对他毫无用处；如果他会唱，那他一定要唱自己的歌。这就是说，诗人这个行当应该取消，每个人都要做自己的诗人。”\" class=\"headerlink\" title=\"　　“我想到，用不着写诗给别人看，如果一个人来享受静夜，我的诗对他毫无用处。别人念了它，只会妨碍他享受自己的静夜诗。如果一个人不会唱，那么全世界的歌对他毫无用处；如果他会唱，那他一定要唱自己的歌。这就是说，诗人这个行当应该取消，每个人都要做自己的诗人。”\"></a>　　“我想到，用不着写诗给别人看，如果一个人来享受静夜，我的诗对他毫无用处。别人念了它，只会妨碍他享受自己的静夜诗。如果一个人不会唱，那么全世界的歌对他毫无用处；如果他会唱，那他一定要唱自己的歌。这就是说，诗人这个行当应该取消，每个人都要做自己的诗人。”</h3><h5 id=\"从古至今留存下来的诗集，从来都是作者对自己内心的一种情感抒发。每个人都要做自己的诗人\"><a href=\"#从古至今留存下来的诗集，从来都是作者对自己内心的一种情感抒发。每个人都要做自己的诗人\" class=\"headerlink\" title=\"　　从古至今留存下来的诗集，从来都是作者对自己内心的一种情感抒发。每个人都要做自己的诗人\"></a>　　从古至今留存下来的诗集，从来都是作者对自己内心的一种情感抒发。每个人都要做自己的诗人</h5><h3 id=\"“照批者认为，这李先生是无聊之辈，你何必理他？既然理他，你也是无聊之辈。但是李先生对着大字报倒是认真答辩了。他认为大道理管小道理，其实是不讲理。大问题管小问题，实则混淆命题。就算揭批查重要，也不能叫人龟头血肿呀？只论大小重要不重要，不论是非真伪，是混蛋逻辑。”\"><a href=\"#“照批者认为，这李先生是无聊之辈，你何必理他？既然理他，你也是无聊之辈。但是李先生对着大字报倒是认真答辩了。他认为大道理管小道理，其实是不讲理。大问题管小问题，实则混淆命题。就算揭批查重要，也不能叫人龟头血肿呀？只论大小重要不重要，不论是非真伪，是混蛋逻辑。”\" class=\"headerlink\" title=\"　　“照批者认为，这李先生是无聊之辈，你何必理他？既然理他，你也是无聊之辈。但是李先生对着大字报倒是认真答辩了。他认为大道理管小道理，其实是不讲理。大问题管小问题，实则混淆命题。就算揭批查重要，也不能叫人龟头血肿呀？只论大小重要不重要，不论是非真伪，是混蛋逻辑。”\"></a>　　“照批者认为，这李先生是无聊之辈，你何必理他？既然理他，你也是无聊之辈。但是李先生对着大字报倒是认真答辩了。他认为大道理管小道理，其实是不讲理。大问题管小问题，实则混淆命题。就算揭批查重要，也不能叫人龟头血肿呀？只论大小重要不重要，不论是非真伪，是混蛋逻辑。”</h3><h3 id=\"“文化革命”到来之时，有些人高兴，有些人不高兴。刘老先生对我说过，一开头他就想自杀。因为他见那势头，总觉得躲不过去。但是他想到再峨嵋酒家还能吃到东坡肘子，又觉得死了太亏。”\"><a href=\"#“文化革命”到来之时，有些人高兴，有些人不高兴。刘老先生对我说过，一开头他就想自杀。因为他见那势头，总觉得躲不过去。但是他想到再峨嵋酒家还能吃到东坡肘子，又觉得死了太亏。”\" class=\"headerlink\" title=\"　　“文化革命”到来之时，有些人高兴，有些人不高兴。刘老先生对我说过，一开头他就想自杀。因为他见那势头，总觉得躲不过去。但是他想到再峨嵋酒家还能吃到东坡肘子，又觉得死了太亏。”\"></a>　　“文化革命”到来之时，有些人高兴，有些人不高兴。刘老先生对我说过，一开头他就想自杀。因为他见那势头，总觉得躲不过去。但是他想到再峨嵋酒家还能吃到东坡肘子，又觉得死了太亏。”</h3><h5 id=\"有时候让你坚持下去往往是一些很不起眼的东西。\"><a href=\"#有时候让你坚持下去往往是一些很不起眼的东西。\" class=\"headerlink\" title=\"　　有时候让你坚持下去往往是一些很不起眼的东西。\"></a>　　有时候让你坚持下去往往是一些很不起眼的东西。</h5><h3 id=\"“我活得很没劲，好像一个没用的人。人到了这步田地，反而会脑子伟大的想法。那时我想：要是发生了战争就好了。”\"><a href=\"#“我活得很没劲，好像一个没用的人。人到了这步田地，反而会脑子伟大的想法。那时我想：要是发生了战争就好了。”\" class=\"headerlink\" title=\"　　“我活得很没劲，好像一个没用的人。人到了这步田地，反而会脑子伟大的想法。那时我想：要是发生了战争就好了。”\"></a>　　“我活得很没劲，好像一个没用的人。人到了这步田地，反而会脑子伟大的想法。那时我想：要是发生了战争就好了。”</h3><h3 id=\"“人在四十岁之前，过得很慢，过了四十岁，过得就快了。”\"><a href=\"#“人在四十岁之前，过得很慢，过了四十岁，过得就快了。”\" class=\"headerlink\" title=\"　　“人在四十岁之前，过得很慢，过了四十岁，过得就快了。”\"></a>　　“人在四十岁之前，过得很慢，过了四十岁，过得就快了。”</h3><h3 id=\"“爬铜炉子没有一点好处，只能带来刻骨铭心的痛苦，但我还是要爬。这大概是说明你干的事情越傻，决心就会越大吧。这也说明我喜欢自己愚弄自己，却不喜欢被别人愚弄。”\"><a href=\"#“爬铜炉子没有一点好处，只能带来刻骨铭心的痛苦，但我还是要爬。这大概是说明你干的事情越傻，决心就会越大吧。这也说明我喜欢自己愚弄自己，却不喜欢被别人愚弄。”\" class=\"headerlink\" title=\"　　“爬铜炉子没有一点好处，只能带来刻骨铭心的痛苦，但我还是要爬。这大概是说明你干的事情越傻，决心就会越大吧。这也说明我喜欢自己愚弄自己，却不喜欢被别人愚弄。”\"></a>　　“爬铜炉子没有一点好处，只能带来刻骨铭心的痛苦，但我还是要爬。这大概是说明你干的事情越傻，决心就会越大吧。这也说明我喜欢自己愚弄自己，却不喜欢被别人愚弄。”</h3><h3 id=\"“在革命时期里，我随时准备承认自己是一只猪，来换取安宁。”\"><a href=\"#“在革命时期里，我随时准备承认自己是一只猪，来换取安宁。”\" class=\"headerlink\" title=\"　　“在革命时期里，我随时准备承认自己是一只猪，来换取安宁。”\"></a>　　“在革命时期里，我随时准备承认自己是一只猪，来换取安宁。”</h3><h3 id=\"“既然人饿了就要吃饭，渴了就要喝水，到了一定岁数就想性交，上了会场就要发呆，同属万般无奈；所以吃饭喝水性交和发呆，都属天赋人权的范畴。假如人犯了错误，可以用别的方法来惩办，却不能令他不发呆。如不其然，就会引起火灾。”\"><a href=\"#“既然人饿了就要吃饭，渴了就要喝水，到了一定岁数就想性交，上了会场就要发呆，同属万般无奈；所以吃饭喝水性交和发呆，都属天赋人权的范畴。假如人犯了错误，可以用别的方法来惩办，却不能令他不发呆。如不其然，就会引起火灾。”\" class=\"headerlink\" title=\"　　“既然人饿了就要吃饭，渴了就要喝水，到了一定岁数就想性交，上了会场就要发呆，同属万般无奈；所以吃饭喝水性交和发呆，都属天赋人权的范畴。假如人犯了错误，可以用别的方法来惩办，却不能令他不发呆。如不其然，就会引起火灾。”\"></a>　　“既然人饿了就要吃饭，渴了就要喝水，到了一定岁数就想性交，上了会场就要发呆，同属万般无奈；所以吃饭喝水性交和发呆，都属天赋人权的范畴。假如人犯了错误，可以用别的方法来惩办，却不能令他不发呆。如不其然，就会引起火灾。”</h3><h3 id=\"“对于不能恨的人，我只能用爱来化解仇恨。我爱上她了。”\"><a href=\"#“对于不能恨的人，我只能用爱来化解仇恨。我爱上她了。”\" class=\"headerlink\" title=\"　　“对于不能恨的人，我只能用爱来化解仇恨。我爱上她了。”\"></a>　　“对于不能恨的人，我只能用爱来化解仇恨。我爱上她了。”</h3><h3 id=\"“人活在世界上，快乐和痛苦本就分不清。所以我只求它货真价实。”\"><a href=\"#“人活在世界上，快乐和痛苦本就分不清。所以我只求它货真价实。”\" class=\"headerlink\" title=\"　　“人活在世界上，快乐和痛苦本就分不清。所以我只求它货真价实。”\"></a>　　“人活在世界上，快乐和痛苦本就分不清。所以我只求它货真价实。”</h3><h3 id=\"“有关我爸爸打我的事，还有一些要补充的地方。他戴着高帽子游街，我看到他时笑了一笑，于是我就挨了一顿打。由此容易得出一个结论：在那种场合应该苦着脸。但是这个结论是错的，因为哭丧着脸也要挨打。正确的结论是到了我该挨打的时候就会挨打，不管我是哭还是笑。既然活在世界上，不管怎样都要挨打，所以做什么都没有了意义。唯一有意义的事就是寻找神奇。”\"><a href=\"#“有关我爸爸打我的事，还有一些要补充的地方。他戴着高帽子游街，我看到他时笑了一笑，于是我就挨了一顿打。由此容易得出一个结论：在那种场合应该苦着脸。但是这个结论是错的，因为哭丧着脸也要挨打。正确的结论是到了我该挨打的时候就会挨打，不管我是哭还是笑。既然活在世界上，不管怎样都要挨打，所以做什么都没有了意义。唯一有意义的事就是寻找神奇。”\" class=\"headerlink\" title=\"　　“有关我爸爸打我的事，还有一些要补充的地方。他戴着高帽子游街，我看到他时笑了一笑，于是我就挨了一顿打。由此容易得出一个结论：在那种场合应该苦着脸。但是这个结论是错的，因为哭丧着脸也要挨打。正确的结论是到了我该挨打的时候就会挨打，不管我是哭还是笑。既然活在世界上，不管怎样都要挨打，所以做什么都没有了意义。唯一有意义的事就是寻找神奇。”\"></a>　　“有关我爸爸打我的事，还有一些要补充的地方。他戴着高帽子游街，我看到他时笑了一笑，于是我就挨了一顿打。由此容易得出一个结论：在那种场合应该苦着脸。但是这个结论是错的，因为哭丧着脸也要挨打。正确的结论是到了我该挨打的时候就会挨打，不管我是哭还是笑。既然活在世界上，不管怎样都要挨打，所以做什么都没有了意义。唯一有意义的事就是寻找神奇。”</h3><h3 id=\"“弗洛伊德说，受虐狂是这样形成的：假如人处于一种不能克服的痛苦之中，就会爱上这种痛苦，把它看成幸福。”\"><a href=\"#“弗洛伊德说，受虐狂是这样形成的：假如人处于一种不能克服的痛苦之中，就会爱上这种痛苦，把它看成幸福。”\" class=\"headerlink\" title=\"　　“弗洛伊德说，受虐狂是这样形成的：假如人处于一种不能克服的痛苦之中，就会爱上这种痛苦，把它看成幸福。”\"></a>　　“弗洛伊德说，受虐狂是这样形成的：假如人处于一种不能克服的痛苦之中，就会爱上这种痛苦，把它看成幸福。”</h3><h3 id=\"“在革命时期自己失掉了一个人，就如损失了十几块钱，有点伤心。这时候我们背上一段毛主席语录：“这种方法也要介绍到老百姓那里去，村上的人死了，开个追悼会，用这种方法寄托我们的哀思……”，然后就一点也不伤心，因为伤心被这种程式消化了。这种种程式就是高级智能。因为有了这种种程式，好多东西失去了它本来的意义——连死都不真了。”\"><a href=\"#“在革命时期自己失掉了一个人，就如损失了十几块钱，有点伤心。这时候我们背上一段毛主席语录：“这种方法也要介绍到老百姓那里去，村上的人死了，开个追悼会，用这种方法寄托我们的哀思……”，然后就一点也不伤心，因为伤心被这种程式消化了。这种种程式就是高级智能。因为有了这种种程式，好多东西失去了它本来的意义——连死都不真了。”\" class=\"headerlink\" title=\"　　“在革命时期自己失掉了一个人，就如损失了十几块钱，有点伤心。这时候我们背上一段毛主席语录：“这种方法也要介绍到老百姓那里去，村上的人死了，开个追悼会，用这种方法寄托我们的哀思……”，然后就一点也不伤心，因为伤心被这种程式消化了。这种种程式就是高级智能。因为有了这种种程式，好多东西失去了它本来的意义——连死都不真了。”\"></a>　　“在革命时期自己失掉了一个人，就如损失了十几块钱，有点伤心。这时候我们背上一段毛主席语录：“这种方法也要介绍到老百姓那里去，村上的人死了，开个追悼会，用这种方法寄托我们的哀思……”，然后就一点也不伤心，因为伤心被这种程式消化了。这种种程式就是高级智能。因为有了这种种程式，好多东西失去了它本来的意义——连死都不真了。”</h3><h3 id=\"“小孙和我谈恋爱，结果是我们俩都变成了一种气体，叫做什么一氧化二氮，或者说，叫做笑气，人家一见到我们在一起就要笑。”\"><a href=\"#“小孙和我谈恋爱，结果是我们俩都变成了一种气体，叫做什么一氧化二氮，或者说，叫做笑气，人家一见到我们在一起就要笑。”\" class=\"headerlink\" title=\"　　“小孙和我谈恋爱，结果是我们俩都变成了一种气体，叫做什么一氧化二氮，或者说，叫做笑气，人家一见到我们在一起就要笑。”\"></a>　　“小孙和我谈恋爱，结果是我们俩都变成了一种气体，叫做什么一氧化二氮，或者说，叫做笑气，人家一见到我们在一起就要笑。”</h3><h3 id=\"“李先生见了我就说这件事，同时愁眉苦脸。我就安慰他说：这也好，省得再找我修。我这样安慰过以后，他好像更伤心了。这件事证明了一个道理：萨特先生说得很对，他人是你的地狱。”\"><a href=\"#“李先生见了我就说这件事，同时愁眉苦脸。我就安慰他说：这也好，省得再找我修。我这样安慰过以后，他好像更伤心了。这件事证明了一个道理：萨特先生说得很对，他人是你的地狱。”\" class=\"headerlink\" title=\"　　“李先生见了我就说这件事，同时愁眉苦脸。我就安慰他说：这也好，省得再找我修。我这样安慰过以后，他好像更伤心了。这件事证明了一个道理：萨特先生说得很对，他人是你的地狱。”\"></a>　　“李先生见了我就说这件事，同时愁眉苦脸。我就安慰他说：这也好，省得再找我修。我这样安慰过以后，他好像更伤心了。这件事证明了一个道理：萨特先生说得很对，他人是你的地狱。”</h3><h3 id=\"“李先生干出了一件大家都干不出的事，这一点没有问题。这证明了他和大家不一样，这一点也没有问题。但是这种不一样是聪明还是有毛病，还没有定论。既然如此，就应该少数服从多数。大家说你聪明，你就是聪明，大家觉得你有毛病，你就是有毛病。”\"><a href=\"#“李先生干出了一件大家都干不出的事，这一点没有问题。这证明了他和大家不一样，这一点也没有问题。但是这种不一样是聪明还是有毛病，还没有定论。既然如此，就应该少数服从多数。大家说你聪明，你就是聪明，大家觉得你有毛病，你就是有毛病。”\" class=\"headerlink\" title=\"　　“李先生干出了一件大家都干不出的事，这一点没有问题。这证明了他和大家不一样，这一点也没有问题。但是这种不一样是聪明还是有毛病，还没有定论。既然如此，就应该少数服从多数。大家说你聪明，你就是聪明，大家觉得你有毛病，你就是有毛病。”\"></a>　　“李先生干出了一件大家都干不出的事，这一点没有问题。这证明了他和大家不一样，这一点也没有问题。但是这种不一样是聪明还是有毛病，还没有定论。既然如此，就应该少数服从多数。大家说你聪明，你就是聪明，大家觉得你有毛病，你就是有毛病。”</h3>","site":{"data":{}},"excerpt":"","more":"<h5 id=\"《黄金时代》包括中篇小说《黄金时代》、《三十而立》、《似水流年》、《革命时期的爱情》和《我的阴阳两界》等。\"><a href=\"#《黄金时代》包括中篇小说《黄金时代》、《三十而立》、《似水流年》、《革命时期的爱情》和《我的阴阳两界》等。\" class=\"headerlink\" title=\"《黄金时代》包括中篇小说《黄金时代》、《三十而立》、《似水流年》、《革命时期的爱情》和《我的阴阳两界》等。\"></a>《黄金时代》包括中篇小说《黄金时代》、《三十而立》、《似水流年》、《革命时期的爱情》和《我的阴阳两界》等。</h5><h2 id=\"笔记\"><a href=\"#笔记\" class=\"headerlink\" title=\"笔记\"></a>笔记</h2><h3 id=\"“我是这么想的：假如我想证明她不是破鞋，就能证明她不是破鞋，那事情未免太容易了。实际上我什么都不能证明，除了那些不需要证明的东西。”\"><a href=\"#“我是这么想的：假如我想证明她不是破鞋，就能证明她不是破鞋，那事情未免太容易了。实际上我什么都不能证明，除了那些不需要证明的东西。”\" class=\"headerlink\" title=\"　　“我是这么想的：假如我想证明她不是破鞋，就能证明她不是破鞋，那事情未免太容易了。实际上我什么都不能证明，除了那些不需要证明的东西。”\"></a>　　“我是这么想的：假如我想证明她不是破鞋，就能证明她不是破鞋，那事情未免太容易了。实际上我什么都不能证明，除了那些不需要证明的东西。”</h3><h5 id=\"在某些程度上，我们什么都证明不了。姓名、年龄、经历。因为这些都是建立在一定的某些基础之上，当世界上的人说你不是你自己时，你就不是你自己。你没法证明。\"><a href=\"#在某些程度上，我们什么都证明不了。姓名、年龄、经历。因为这些都是建立在一定的某些基础之上，当世界上的人说你不是你自己时，你就不是你自己。你没法证明。\" class=\"headerlink\" title=\"　　在某些程度上，我们什么都证明不了。姓名、年龄、经历。因为这些都是建立在一定的某些基础之上，当世界上的人说你不是你自己时，你就不是你自己。你没法证明。\"></a>　　在某些程度上，我们什么都证明不了。姓名、年龄、经历。因为这些都是建立在一定的某些基础之上，当世界上的人说你不是你自己时，你就不是你自己。你没法证明。</h5><h3 id=\"“我想到，用不着写诗给别人看，如果一个人来享受静夜，我的诗对他毫无用处。别人念了它，只会妨碍他享受自己的静夜诗。如果一个人不会唱，那么全世界的歌对他毫无用处；如果他会唱，那他一定要唱自己的歌。这就是说，诗人这个行当应该取消，每个人都要做自己的诗人。”\"><a href=\"#“我想到，用不着写诗给别人看，如果一个人来享受静夜，我的诗对他毫无用处。别人念了它，只会妨碍他享受自己的静夜诗。如果一个人不会唱，那么全世界的歌对他毫无用处；如果他会唱，那他一定要唱自己的歌。这就是说，诗人这个行当应该取消，每个人都要做自己的诗人。”\" class=\"headerlink\" title=\"　　“我想到，用不着写诗给别人看，如果一个人来享受静夜，我的诗对他毫无用处。别人念了它，只会妨碍他享受自己的静夜诗。如果一个人不会唱，那么全世界的歌对他毫无用处；如果他会唱，那他一定要唱自己的歌。这就是说，诗人这个行当应该取消，每个人都要做自己的诗人。”\"></a>　　“我想到，用不着写诗给别人看，如果一个人来享受静夜，我的诗对他毫无用处。别人念了它，只会妨碍他享受自己的静夜诗。如果一个人不会唱，那么全世界的歌对他毫无用处；如果他会唱，那他一定要唱自己的歌。这就是说，诗人这个行当应该取消，每个人都要做自己的诗人。”</h3><h5 id=\"从古至今留存下来的诗集，从来都是作者对自己内心的一种情感抒发。每个人都要做自己的诗人\"><a href=\"#从古至今留存下来的诗集，从来都是作者对自己内心的一种情感抒发。每个人都要做自己的诗人\" class=\"headerlink\" title=\"　　从古至今留存下来的诗集，从来都是作者对自己内心的一种情感抒发。每个人都要做自己的诗人\"></a>　　从古至今留存下来的诗集，从来都是作者对自己内心的一种情感抒发。每个人都要做自己的诗人</h5><h3 id=\"“照批者认为，这李先生是无聊之辈，你何必理他？既然理他，你也是无聊之辈。但是李先生对着大字报倒是认真答辩了。他认为大道理管小道理，其实是不讲理。大问题管小问题，实则混淆命题。就算揭批查重要，也不能叫人龟头血肿呀？只论大小重要不重要，不论是非真伪，是混蛋逻辑。”\"><a href=\"#“照批者认为，这李先生是无聊之辈，你何必理他？既然理他，你也是无聊之辈。但是李先生对着大字报倒是认真答辩了。他认为大道理管小道理，其实是不讲理。大问题管小问题，实则混淆命题。就算揭批查重要，也不能叫人龟头血肿呀？只论大小重要不重要，不论是非真伪，是混蛋逻辑。”\" class=\"headerlink\" title=\"　　“照批者认为，这李先生是无聊之辈，你何必理他？既然理他，你也是无聊之辈。但是李先生对着大字报倒是认真答辩了。他认为大道理管小道理，其实是不讲理。大问题管小问题，实则混淆命题。就算揭批查重要，也不能叫人龟头血肿呀？只论大小重要不重要，不论是非真伪，是混蛋逻辑。”\"></a>　　“照批者认为，这李先生是无聊之辈，你何必理他？既然理他，你也是无聊之辈。但是李先生对着大字报倒是认真答辩了。他认为大道理管小道理，其实是不讲理。大问题管小问题，实则混淆命题。就算揭批查重要，也不能叫人龟头血肿呀？只论大小重要不重要，不论是非真伪，是混蛋逻辑。”</h3><h3 id=\"“文化革命”到来之时，有些人高兴，有些人不高兴。刘老先生对我说过，一开头他就想自杀。因为他见那势头，总觉得躲不过去。但是他想到再峨嵋酒家还能吃到东坡肘子，又觉得死了太亏。”\"><a href=\"#“文化革命”到来之时，有些人高兴，有些人不高兴。刘老先生对我说过，一开头他就想自杀。因为他见那势头，总觉得躲不过去。但是他想到再峨嵋酒家还能吃到东坡肘子，又觉得死了太亏。”\" class=\"headerlink\" title=\"　　“文化革命”到来之时，有些人高兴，有些人不高兴。刘老先生对我说过，一开头他就想自杀。因为他见那势头，总觉得躲不过去。但是他想到再峨嵋酒家还能吃到东坡肘子，又觉得死了太亏。”\"></a>　　“文化革命”到来之时，有些人高兴，有些人不高兴。刘老先生对我说过，一开头他就想自杀。因为他见那势头，总觉得躲不过去。但是他想到再峨嵋酒家还能吃到东坡肘子，又觉得死了太亏。”</h3><h5 id=\"有时候让你坚持下去往往是一些很不起眼的东西。\"><a href=\"#有时候让你坚持下去往往是一些很不起眼的东西。\" class=\"headerlink\" title=\"　　有时候让你坚持下去往往是一些很不起眼的东西。\"></a>　　有时候让你坚持下去往往是一些很不起眼的东西。</h5><h3 id=\"“我活得很没劲，好像一个没用的人。人到了这步田地，反而会脑子伟大的想法。那时我想：要是发生了战争就好了。”\"><a href=\"#“我活得很没劲，好像一个没用的人。人到了这步田地，反而会脑子伟大的想法。那时我想：要是发生了战争就好了。”\" class=\"headerlink\" title=\"　　“我活得很没劲，好像一个没用的人。人到了这步田地，反而会脑子伟大的想法。那时我想：要是发生了战争就好了。”\"></a>　　“我活得很没劲，好像一个没用的人。人到了这步田地，反而会脑子伟大的想法。那时我想：要是发生了战争就好了。”</h3><h3 id=\"“人在四十岁之前，过得很慢，过了四十岁，过得就快了。”\"><a href=\"#“人在四十岁之前，过得很慢，过了四十岁，过得就快了。”\" class=\"headerlink\" title=\"　　“人在四十岁之前，过得很慢，过了四十岁，过得就快了。”\"></a>　　“人在四十岁之前，过得很慢，过了四十岁，过得就快了。”</h3><h3 id=\"“爬铜炉子没有一点好处，只能带来刻骨铭心的痛苦，但我还是要爬。这大概是说明你干的事情越傻，决心就会越大吧。这也说明我喜欢自己愚弄自己，却不喜欢被别人愚弄。”\"><a href=\"#“爬铜炉子没有一点好处，只能带来刻骨铭心的痛苦，但我还是要爬。这大概是说明你干的事情越傻，决心就会越大吧。这也说明我喜欢自己愚弄自己，却不喜欢被别人愚弄。”\" class=\"headerlink\" title=\"　　“爬铜炉子没有一点好处，只能带来刻骨铭心的痛苦，但我还是要爬。这大概是说明你干的事情越傻，决心就会越大吧。这也说明我喜欢自己愚弄自己，却不喜欢被别人愚弄。”\"></a>　　“爬铜炉子没有一点好处，只能带来刻骨铭心的痛苦，但我还是要爬。这大概是说明你干的事情越傻，决心就会越大吧。这也说明我喜欢自己愚弄自己，却不喜欢被别人愚弄。”</h3><h3 id=\"“在革命时期里，我随时准备承认自己是一只猪，来换取安宁。”\"><a href=\"#“在革命时期里，我随时准备承认自己是一只猪，来换取安宁。”\" class=\"headerlink\" title=\"　　“在革命时期里，我随时准备承认自己是一只猪，来换取安宁。”\"></a>　　“在革命时期里，我随时准备承认自己是一只猪，来换取安宁。”</h3><h3 id=\"“既然人饿了就要吃饭，渴了就要喝水，到了一定岁数就想性交，上了会场就要发呆，同属万般无奈；所以吃饭喝水性交和发呆，都属天赋人权的范畴。假如人犯了错误，可以用别的方法来惩办，却不能令他不发呆。如不其然，就会引起火灾。”\"><a href=\"#“既然人饿了就要吃饭，渴了就要喝水，到了一定岁数就想性交，上了会场就要发呆，同属万般无奈；所以吃饭喝水性交和发呆，都属天赋人权的范畴。假如人犯了错误，可以用别的方法来惩办，却不能令他不发呆。如不其然，就会引起火灾。”\" class=\"headerlink\" title=\"　　“既然人饿了就要吃饭，渴了就要喝水，到了一定岁数就想性交，上了会场就要发呆，同属万般无奈；所以吃饭喝水性交和发呆，都属天赋人权的范畴。假如人犯了错误，可以用别的方法来惩办，却不能令他不发呆。如不其然，就会引起火灾。”\"></a>　　“既然人饿了就要吃饭，渴了就要喝水，到了一定岁数就想性交，上了会场就要发呆，同属万般无奈；所以吃饭喝水性交和发呆，都属天赋人权的范畴。假如人犯了错误，可以用别的方法来惩办，却不能令他不发呆。如不其然，就会引起火灾。”</h3><h3 id=\"“对于不能恨的人，我只能用爱来化解仇恨。我爱上她了。”\"><a href=\"#“对于不能恨的人，我只能用爱来化解仇恨。我爱上她了。”\" class=\"headerlink\" title=\"　　“对于不能恨的人，我只能用爱来化解仇恨。我爱上她了。”\"></a>　　“对于不能恨的人，我只能用爱来化解仇恨。我爱上她了。”</h3><h3 id=\"“人活在世界上，快乐和痛苦本就分不清。所以我只求它货真价实。”\"><a href=\"#“人活在世界上，快乐和痛苦本就分不清。所以我只求它货真价实。”\" class=\"headerlink\" title=\"　　“人活在世界上，快乐和痛苦本就分不清。所以我只求它货真价实。”\"></a>　　“人活在世界上，快乐和痛苦本就分不清。所以我只求它货真价实。”</h3><h3 id=\"“有关我爸爸打我的事，还有一些要补充的地方。他戴着高帽子游街，我看到他时笑了一笑，于是我就挨了一顿打。由此容易得出一个结论：在那种场合应该苦着脸。但是这个结论是错的，因为哭丧着脸也要挨打。正确的结论是到了我该挨打的时候就会挨打，不管我是哭还是笑。既然活在世界上，不管怎样都要挨打，所以做什么都没有了意义。唯一有意义的事就是寻找神奇。”\"><a href=\"#“有关我爸爸打我的事，还有一些要补充的地方。他戴着高帽子游街，我看到他时笑了一笑，于是我就挨了一顿打。由此容易得出一个结论：在那种场合应该苦着脸。但是这个结论是错的，因为哭丧着脸也要挨打。正确的结论是到了我该挨打的时候就会挨打，不管我是哭还是笑。既然活在世界上，不管怎样都要挨打，所以做什么都没有了意义。唯一有意义的事就是寻找神奇。”\" class=\"headerlink\" title=\"　　“有关我爸爸打我的事，还有一些要补充的地方。他戴着高帽子游街，我看到他时笑了一笑，于是我就挨了一顿打。由此容易得出一个结论：在那种场合应该苦着脸。但是这个结论是错的，因为哭丧着脸也要挨打。正确的结论是到了我该挨打的时候就会挨打，不管我是哭还是笑。既然活在世界上，不管怎样都要挨打，所以做什么都没有了意义。唯一有意义的事就是寻找神奇。”\"></a>　　“有关我爸爸打我的事，还有一些要补充的地方。他戴着高帽子游街，我看到他时笑了一笑，于是我就挨了一顿打。由此容易得出一个结论：在那种场合应该苦着脸。但是这个结论是错的，因为哭丧着脸也要挨打。正确的结论是到了我该挨打的时候就会挨打，不管我是哭还是笑。既然活在世界上，不管怎样都要挨打，所以做什么都没有了意义。唯一有意义的事就是寻找神奇。”</h3><h3 id=\"“弗洛伊德说，受虐狂是这样形成的：假如人处于一种不能克服的痛苦之中，就会爱上这种痛苦，把它看成幸福。”\"><a href=\"#“弗洛伊德说，受虐狂是这样形成的：假如人处于一种不能克服的痛苦之中，就会爱上这种痛苦，把它看成幸福。”\" class=\"headerlink\" title=\"　　“弗洛伊德说，受虐狂是这样形成的：假如人处于一种不能克服的痛苦之中，就会爱上这种痛苦，把它看成幸福。”\"></a>　　“弗洛伊德说，受虐狂是这样形成的：假如人处于一种不能克服的痛苦之中，就会爱上这种痛苦，把它看成幸福。”</h3><h3 id=\"“在革命时期自己失掉了一个人，就如损失了十几块钱，有点伤心。这时候我们背上一段毛主席语录：“这种方法也要介绍到老百姓那里去，村上的人死了，开个追悼会，用这种方法寄托我们的哀思……”，然后就一点也不伤心，因为伤心被这种程式消化了。这种种程式就是高级智能。因为有了这种种程式，好多东西失去了它本来的意义——连死都不真了。”\"><a href=\"#“在革命时期自己失掉了一个人，就如损失了十几块钱，有点伤心。这时候我们背上一段毛主席语录：“这种方法也要介绍到老百姓那里去，村上的人死了，开个追悼会，用这种方法寄托我们的哀思……”，然后就一点也不伤心，因为伤心被这种程式消化了。这种种程式就是高级智能。因为有了这种种程式，好多东西失去了它本来的意义——连死都不真了。”\" class=\"headerlink\" title=\"　　“在革命时期自己失掉了一个人，就如损失了十几块钱，有点伤心。这时候我们背上一段毛主席语录：“这种方法也要介绍到老百姓那里去，村上的人死了，开个追悼会，用这种方法寄托我们的哀思……”，然后就一点也不伤心，因为伤心被这种程式消化了。这种种程式就是高级智能。因为有了这种种程式，好多东西失去了它本来的意义——连死都不真了。”\"></a>　　“在革命时期自己失掉了一个人，就如损失了十几块钱，有点伤心。这时候我们背上一段毛主席语录：“这种方法也要介绍到老百姓那里去，村上的人死了，开个追悼会，用这种方法寄托我们的哀思……”，然后就一点也不伤心，因为伤心被这种程式消化了。这种种程式就是高级智能。因为有了这种种程式，好多东西失去了它本来的意义——连死都不真了。”</h3><h3 id=\"“小孙和我谈恋爱，结果是我们俩都变成了一种气体，叫做什么一氧化二氮，或者说，叫做笑气，人家一见到我们在一起就要笑。”\"><a href=\"#“小孙和我谈恋爱，结果是我们俩都变成了一种气体，叫做什么一氧化二氮，或者说，叫做笑气，人家一见到我们在一起就要笑。”\" class=\"headerlink\" title=\"　　“小孙和我谈恋爱，结果是我们俩都变成了一种气体，叫做什么一氧化二氮，或者说，叫做笑气，人家一见到我们在一起就要笑。”\"></a>　　“小孙和我谈恋爱，结果是我们俩都变成了一种气体，叫做什么一氧化二氮，或者说，叫做笑气，人家一见到我们在一起就要笑。”</h3><h3 id=\"“李先生见了我就说这件事，同时愁眉苦脸。我就安慰他说：这也好，省得再找我修。我这样安慰过以后，他好像更伤心了。这件事证明了一个道理：萨特先生说得很对，他人是你的地狱。”\"><a href=\"#“李先生见了我就说这件事，同时愁眉苦脸。我就安慰他说：这也好，省得再找我修。我这样安慰过以后，他好像更伤心了。这件事证明了一个道理：萨特先生说得很对，他人是你的地狱。”\" class=\"headerlink\" title=\"　　“李先生见了我就说这件事，同时愁眉苦脸。我就安慰他说：这也好，省得再找我修。我这样安慰过以后，他好像更伤心了。这件事证明了一个道理：萨特先生说得很对，他人是你的地狱。”\"></a>　　“李先生见了我就说这件事，同时愁眉苦脸。我就安慰他说：这也好，省得再找我修。我这样安慰过以后，他好像更伤心了。这件事证明了一个道理：萨特先生说得很对，他人是你的地狱。”</h3><h3 id=\"“李先生干出了一件大家都干不出的事，这一点没有问题。这证明了他和大家不一样，这一点也没有问题。但是这种不一样是聪明还是有毛病，还没有定论。既然如此，就应该少数服从多数。大家说你聪明，你就是聪明，大家觉得你有毛病，你就是有毛病。”\"><a href=\"#“李先生干出了一件大家都干不出的事，这一点没有问题。这证明了他和大家不一样，这一点也没有问题。但是这种不一样是聪明还是有毛病，还没有定论。既然如此，就应该少数服从多数。大家说你聪明，你就是聪明，大家觉得你有毛病，你就是有毛病。”\" class=\"headerlink\" title=\"　　“李先生干出了一件大家都干不出的事，这一点没有问题。这证明了他和大家不一样，这一点也没有问题。但是这种不一样是聪明还是有毛病，还没有定论。既然如此，就应该少数服从多数。大家说你聪明，你就是聪明，大家觉得你有毛病，你就是有毛病。”\"></a>　　“李先生干出了一件大家都干不出的事，这一点没有问题。这证明了他和大家不一样，这一点也没有问题。但是这种不一样是聪明还是有毛病，还没有定论。既然如此，就应该少数服从多数。大家说你聪明，你就是聪明，大家觉得你有毛病，你就是有毛病。”</h3>"},{"layout":"book","title":"鼠疫","author":"阿尔贝·加缪","date":"2017-09-27T16:00:00.000Z","cover":"pestis.jpeg","_content":"","source":"_posts/read/pestis.md","raw":"---\nlayout: book\ntitle: 鼠疫\nauthor: 阿尔贝·加缪\ndate: 2017/09/28\ncover: pestis.jpeg\ncategories: [read]\n---","slug":"read/pestis","published":1,"updated":"2017-09-28T11:15:14.024Z","comments":1,"photos":[],"link":"","_id":"cj8jros86002230s619hnlvue","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"book","title":"沉默的大多数","author":"王小波","date":"2017-09-17T16:00:00.000Z","cover":"silentMajority.jpeg","_content":"","source":"_posts/read/silentMajority.md","raw":"---\nlayout: book\ntitle: 沉默的大多数\nauthor: 王小波\ndate: 2017/09/18\ncover: silentMajority.jpeg\ncategories: [read]\n---","slug":"read/silentMajority","published":1,"updated":"2017-09-28T11:10:51.327Z","comments":1,"photos":[],"link":"","_id":"cj8jros87002430s6adxja6r7","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"book","title":"血字的研究","date":"2017-09-30T16:00:00.000Z","cover":"TangledSkein.jpg","_content":"","source":"_posts/read/tangledSkein.md","raw":"---\nlayout: book\ntitle: 血字的研究\ndate: 2017/10/01\ncover: TangledSkein.jpg\ncategories: [read]\n---\n","slug":"read/tangledSkein","published":1,"updated":"2017-10-06T13:10:27.845Z","comments":1,"photos":[],"link":"","_id":"cj8jros88002630s6f8ssii88","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"book","title":"爱你就像爱生命","date":"2016-12-14T16:00:00.000Z","cover":"loveYou.jpeg","_content":"","source":"_posts/read/loveYou.md","raw":"---\nlayout: book\ntitle: 爱你就像爱生命\ndate: 2016/12/15\ncover: loveYou.jpeg\ncategories: [read]\n---\n","slug":"read/loveYou","published":1,"updated":"2017-08-15T11:31:46.000Z","comments":1,"photos":[],"link":"","_id":"cj8jros8a002830s673ei4rda","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"post","title":"river工具介绍","date":"2017-06-01T16:00:00.000Z","original":true,"tag":[["river","river"]],"_content":"\n##### 　　river是一个java工具包，是对java的method的增强。在原有的method调用流程不变的情况下，尽可能用注解去增强目标方法的灵活性。river希望做的是解耦java method 之间的调用关系。实现代码无侵入或者少侵入的流程控制。\n<!--more-->\n\n#### github地址：[river](https://github.com/winx402/river)\n\n## river基础\n##### river是基于cglib动态代理以及guava作为基础来实现的，这里并没有使用jdk自带的代理方式实现。部分功能的实现是依靠guava或者在guava之上封装来完成的。\n\n## river现有功能\n### aop\n##### 　　aop是一个比较典型的例子，aop实现在目标方法之前、之后、异常等情况下的代码插入。这些插入的代码可以做类似于日志记录，流量统计等工作。也可以在before代码中修改目标方法参数，在after中修改目标方法返回值。但是没有办法控制目标方法是否继续（除非抛出异常）。\n\n### 缓存\n##### 　　cache显而易见，是对目标方法结果的缓存，在缓存结果有效期内，新的调用并不会去执行目标方法，而是直接拿缓存结果。并且用户可以自定义缓存的key（从入参中选取一部分参数，或者是某个对象中的某些属性来作为缓存的key）。\n### 限流\n##### 　　rate limit是对目标方法每秒的调用频率的限制。在限制的流量内，调用会非常顺畅。在超出的流量之外，调用会阻塞，直到新的调用机会。此外，也可以设置超时时间，如果有超时时间设置，在调用之前会先检查在超时时间内能否拿到调用的机会，如果不能，直接返回超时异常。\n### 线程池\n##### 　　目标方法会用新的线程去执行。可以理解成方法之间的异步执行，如果返回值是void或者是指定的类型。其他的返回值类型，虽然启用的新的线程去执行，但是会等待线程执行完成后拿到返回值再返回。\n### around\n##### 　　around是最灵活的，around是现在river的功能的核心，around可以在A方法调用B方法之间插入C方法。C方法就叫做对B的around，C可以拿到B的入参、返回、method对象等，也可以控制调用B方法的时机，甚至是不调用。实际上，上面的各种功能的实现都可以用around自己实现，但是实现以上功能的成本对于普通使用者来说成本太高也没有必要。因此一些核心且重要的功能都已经单独实现，只需要使用相应的注解就可以了","source":"_posts/river/RiverIntroduce.md","raw":"---\nlayout: post\ntitle: river工具介绍\ndate: 2017/06/02\noriginal: true\ntags: [tech, river, index, java]\ntag: [[river, river]]\n---\n\n##### 　　river是一个java工具包，是对java的method的增强。在原有的method调用流程不变的情况下，尽可能用注解去增强目标方法的灵活性。river希望做的是解耦java method 之间的调用关系。实现代码无侵入或者少侵入的流程控制。\n<!--more-->\n\n#### github地址：[river](https://github.com/winx402/river)\n\n## river基础\n##### river是基于cglib动态代理以及guava作为基础来实现的，这里并没有使用jdk自带的代理方式实现。部分功能的实现是依靠guava或者在guava之上封装来完成的。\n\n## river现有功能\n### aop\n##### 　　aop是一个比较典型的例子，aop实现在目标方法之前、之后、异常等情况下的代码插入。这些插入的代码可以做类似于日志记录，流量统计等工作。也可以在before代码中修改目标方法参数，在after中修改目标方法返回值。但是没有办法控制目标方法是否继续（除非抛出异常）。\n\n### 缓存\n##### 　　cache显而易见，是对目标方法结果的缓存，在缓存结果有效期内，新的调用并不会去执行目标方法，而是直接拿缓存结果。并且用户可以自定义缓存的key（从入参中选取一部分参数，或者是某个对象中的某些属性来作为缓存的key）。\n### 限流\n##### 　　rate limit是对目标方法每秒的调用频率的限制。在限制的流量内，调用会非常顺畅。在超出的流量之外，调用会阻塞，直到新的调用机会。此外，也可以设置超时时间，如果有超时时间设置，在调用之前会先检查在超时时间内能否拿到调用的机会，如果不能，直接返回超时异常。\n### 线程池\n##### 　　目标方法会用新的线程去执行。可以理解成方法之间的异步执行，如果返回值是void或者是指定的类型。其他的返回值类型，虽然启用的新的线程去执行，但是会等待线程执行完成后拿到返回值再返回。\n### around\n##### 　　around是最灵活的，around是现在river的功能的核心，around可以在A方法调用B方法之间插入C方法。C方法就叫做对B的around，C可以拿到B的入参、返回、method对象等，也可以控制调用B方法的时机，甚至是不调用。实际上，上面的各种功能的实现都可以用around自己实现，但是实现以上功能的成本对于普通使用者来说成本太高也没有必要。因此一些核心且重要的功能都已经单独实现，只需要使用相应的注解就可以了","slug":"river/RiverIntroduce","published":1,"updated":"2017-10-06T16:26:24.379Z","comments":1,"photos":[],"link":"","_id":"cj8jros8b002a30s6eatc5zau","content":"<h5 id=\"river是一个java工具包，是对java的method的增强。在原有的method调用流程不变的情况下，尽可能用注解去增强目标方法的灵活性。river希望做的是解耦java-method-之间的调用关系。实现代码无侵入或者少侵入的流程控制。\"><a href=\"#river是一个java工具包，是对java的method的增强。在原有的method调用流程不变的情况下，尽可能用注解去增强目标方法的灵活性。river希望做的是解耦java-method-之间的调用关系。实现代码无侵入或者少侵入的流程控制。\" class=\"headerlink\" title=\"　　river是一个java工具包，是对java的method的增强。在原有的method调用流程不变的情况下，尽可能用注解去增强目标方法的灵活性。river希望做的是解耦java method 之间的调用关系。实现代码无侵入或者少侵入的流程控制。\"></a>　　river是一个java工具包，是对java的method的增强。在原有的method调用流程不变的情况下，尽可能用注解去增强目标方法的灵活性。river希望做的是解耦java method 之间的调用关系。实现代码无侵入或者少侵入的流程控制。</h5><a id=\"more\"></a>\n<h4 id=\"github地址：river\"><a href=\"#github地址：river\" class=\"headerlink\" title=\"github地址：river\"></a>github地址：<a href=\"https://github.com/winx402/river\">river</a></h4><h2 id=\"river基础\"><a href=\"#river基础\" class=\"headerlink\" title=\"river基础\"></a>river基础</h2><h5 id=\"river是基于cglib动态代理以及guava作为基础来实现的，这里并没有使用jdk自带的代理方式实现。部分功能的实现是依靠guava或者在guava之上封装来完成的。\"><a href=\"#river是基于cglib动态代理以及guava作为基础来实现的，这里并没有使用jdk自带的代理方式实现。部分功能的实现是依靠guava或者在guava之上封装来完成的。\" class=\"headerlink\" title=\"river是基于cglib动态代理以及guava作为基础来实现的，这里并没有使用jdk自带的代理方式实现。部分功能的实现是依靠guava或者在guava之上封装来完成的。\"></a>river是基于cglib动态代理以及guava作为基础来实现的，这里并没有使用jdk自带的代理方式实现。部分功能的实现是依靠guava或者在guava之上封装来完成的。</h5><h2 id=\"river现有功能\"><a href=\"#river现有功能\" class=\"headerlink\" title=\"river现有功能\"></a>river现有功能</h2><h3 id=\"aop\"><a href=\"#aop\" class=\"headerlink\" title=\"aop\"></a>aop</h3><h5 id=\"aop是一个比较典型的例子，aop实现在目标方法之前、之后、异常等情况下的代码插入。这些插入的代码可以做类似于日志记录，流量统计等工作。也可以在before代码中修改目标方法参数，在after中修改目标方法返回值。但是没有办法控制目标方法是否继续（除非抛出异常）。\"><a href=\"#aop是一个比较典型的例子，aop实现在目标方法之前、之后、异常等情况下的代码插入。这些插入的代码可以做类似于日志记录，流量统计等工作。也可以在before代码中修改目标方法参数，在after中修改目标方法返回值。但是没有办法控制目标方法是否继续（除非抛出异常）。\" class=\"headerlink\" title=\"　　aop是一个比较典型的例子，aop实现在目标方法之前、之后、异常等情况下的代码插入。这些插入的代码可以做类似于日志记录，流量统计等工作。也可以在before代码中修改目标方法参数，在after中修改目标方法返回值。但是没有办法控制目标方法是否继续（除非抛出异常）。\"></a>　　aop是一个比较典型的例子，aop实现在目标方法之前、之后、异常等情况下的代码插入。这些插入的代码可以做类似于日志记录，流量统计等工作。也可以在before代码中修改目标方法参数，在after中修改目标方法返回值。但是没有办法控制目标方法是否继续（除非抛出异常）。</h5><h3 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h3><h5 id=\"cache显而易见，是对目标方法结果的缓存，在缓存结果有效期内，新的调用并不会去执行目标方法，而是直接拿缓存结果。并且用户可以自定义缓存的key（从入参中选取一部分参数，或者是某个对象中的某些属性来作为缓存的key）。\"><a href=\"#cache显而易见，是对目标方法结果的缓存，在缓存结果有效期内，新的调用并不会去执行目标方法，而是直接拿缓存结果。并且用户可以自定义缓存的key（从入参中选取一部分参数，或者是某个对象中的某些属性来作为缓存的key）。\" class=\"headerlink\" title=\"　　cache显而易见，是对目标方法结果的缓存，在缓存结果有效期内，新的调用并不会去执行目标方法，而是直接拿缓存结果。并且用户可以自定义缓存的key（从入参中选取一部分参数，或者是某个对象中的某些属性来作为缓存的key）。\"></a>　　cache显而易见，是对目标方法结果的缓存，在缓存结果有效期内，新的调用并不会去执行目标方法，而是直接拿缓存结果。并且用户可以自定义缓存的key（从入参中选取一部分参数，或者是某个对象中的某些属性来作为缓存的key）。</h5><h3 id=\"限流\"><a href=\"#限流\" class=\"headerlink\" title=\"限流\"></a>限流</h3><h5 id=\"rate-limit是对目标方法每秒的调用频率的限制。在限制的流量内，调用会非常顺畅。在超出的流量之外，调用会阻塞，直到新的调用机会。此外，也可以设置超时时间，如果有超时时间设置，在调用之前会先检查在超时时间内能否拿到调用的机会，如果不能，直接返回超时异常。\"><a href=\"#rate-limit是对目标方法每秒的调用频率的限制。在限制的流量内，调用会非常顺畅。在超出的流量之外，调用会阻塞，直到新的调用机会。此外，也可以设置超时时间，如果有超时时间设置，在调用之前会先检查在超时时间内能否拿到调用的机会，如果不能，直接返回超时异常。\" class=\"headerlink\" title=\"　　rate limit是对目标方法每秒的调用频率的限制。在限制的流量内，调用会非常顺畅。在超出的流量之外，调用会阻塞，直到新的调用机会。此外，也可以设置超时时间，如果有超时时间设置，在调用之前会先检查在超时时间内能否拿到调用的机会，如果不能，直接返回超时异常。\"></a>　　rate limit是对目标方法每秒的调用频率的限制。在限制的流量内，调用会非常顺畅。在超出的流量之外，调用会阻塞，直到新的调用机会。此外，也可以设置超时时间，如果有超时时间设置，在调用之前会先检查在超时时间内能否拿到调用的机会，如果不能，直接返回超时异常。</h5><h3 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h3><h5 id=\"目标方法会用新的线程去执行。可以理解成方法之间的异步执行，如果返回值是void或者是指定的类型。其他的返回值类型，虽然启用的新的线程去执行，但是会等待线程执行完成后拿到返回值再返回。\"><a href=\"#目标方法会用新的线程去执行。可以理解成方法之间的异步执行，如果返回值是void或者是指定的类型。其他的返回值类型，虽然启用的新的线程去执行，但是会等待线程执行完成后拿到返回值再返回。\" class=\"headerlink\" title=\"　　目标方法会用新的线程去执行。可以理解成方法之间的异步执行，如果返回值是void或者是指定的类型。其他的返回值类型，虽然启用的新的线程去执行，但是会等待线程执行完成后拿到返回值再返回。\"></a>　　目标方法会用新的线程去执行。可以理解成方法之间的异步执行，如果返回值是void或者是指定的类型。其他的返回值类型，虽然启用的新的线程去执行，但是会等待线程执行完成后拿到返回值再返回。</h5><h3 id=\"around\"><a href=\"#around\" class=\"headerlink\" title=\"around\"></a>around</h3><h5 id=\"around是最灵活的，around是现在river的功能的核心，around可以在A方法调用B方法之间插入C方法。C方法就叫做对B的around，C可以拿到B的入参、返回、method对象等，也可以控制调用B方法的时机，甚至是不调用。实际上，上面的各种功能的实现都可以用around自己实现，但是实现以上功能的成本对于普通使用者来说成本太高也没有必要。因此一些核心且重要的功能都已经单独实现，只需要使用相应的注解就可以了\"><a href=\"#around是最灵活的，around是现在river的功能的核心，around可以在A方法调用B方法之间插入C方法。C方法就叫做对B的around，C可以拿到B的入参、返回、method对象等，也可以控制调用B方法的时机，甚至是不调用。实际上，上面的各种功能的实现都可以用around自己实现，但是实现以上功能的成本对于普通使用者来说成本太高也没有必要。因此一些核心且重要的功能都已经单独实现，只需要使用相应的注解就可以了\" class=\"headerlink\" title=\"　　around是最灵活的，around是现在river的功能的核心，around可以在A方法调用B方法之间插入C方法。C方法就叫做对B的around，C可以拿到B的入参、返回、method对象等，也可以控制调用B方法的时机，甚至是不调用。实际上，上面的各种功能的实现都可以用around自己实现，但是实现以上功能的成本对于普通使用者来说成本太高也没有必要。因此一些核心且重要的功能都已经单独实现，只需要使用相应的注解就可以了\"></a>　　around是最灵活的，around是现在river的功能的核心，around可以在A方法调用B方法之间插入C方法。C方法就叫做对B的around，C可以拿到B的入参、返回、method对象等，也可以控制调用B方法的时机，甚至是不调用。实际上，上面的各种功能的实现都可以用around自己实现，但是实现以上功能的成本对于普通使用者来说成本太高也没有必要。因此一些核心且重要的功能都已经单独实现，只需要使用相应的注解就可以了</h5>","site":{"data":{}},"excerpt":"<h5 id=\"river是一个java工具包，是对java的method的增强。在原有的method调用流程不变的情况下，尽可能用注解去增强目标方法的灵活性。river希望做的是解耦java-method-之间的调用关系。实现代码无侵入或者少侵入的流程控制。\"><a href=\"#river是一个java工具包，是对java的method的增强。在原有的method调用流程不变的情况下，尽可能用注解去增强目标方法的灵活性。river希望做的是解耦java-method-之间的调用关系。实现代码无侵入或者少侵入的流程控制。\" class=\"headerlink\" title=\"　　river是一个java工具包，是对java的method的增强。在原有的method调用流程不变的情况下，尽可能用注解去增强目标方法的灵活性。river希望做的是解耦java method 之间的调用关系。实现代码无侵入或者少侵入的流程控制。\"></a>　　river是一个java工具包，是对java的method的增强。在原有的method调用流程不变的情况下，尽可能用注解去增强目标方法的灵活性。river希望做的是解耦java method 之间的调用关系。实现代码无侵入或者少侵入的流程控制。</h5>","more":"<h4 id=\"github地址：river\"><a href=\"#github地址：river\" class=\"headerlink\" title=\"github地址：river\"></a>github地址：<a href=\"https://github.com/winx402/river\">river</a></h4><h2 id=\"river基础\"><a href=\"#river基础\" class=\"headerlink\" title=\"river基础\"></a>river基础</h2><h5 id=\"river是基于cglib动态代理以及guava作为基础来实现的，这里并没有使用jdk自带的代理方式实现。部分功能的实现是依靠guava或者在guava之上封装来完成的。\"><a href=\"#river是基于cglib动态代理以及guava作为基础来实现的，这里并没有使用jdk自带的代理方式实现。部分功能的实现是依靠guava或者在guava之上封装来完成的。\" class=\"headerlink\" title=\"river是基于cglib动态代理以及guava作为基础来实现的，这里并没有使用jdk自带的代理方式实现。部分功能的实现是依靠guava或者在guava之上封装来完成的。\"></a>river是基于cglib动态代理以及guava作为基础来实现的，这里并没有使用jdk自带的代理方式实现。部分功能的实现是依靠guava或者在guava之上封装来完成的。</h5><h2 id=\"river现有功能\"><a href=\"#river现有功能\" class=\"headerlink\" title=\"river现有功能\"></a>river现有功能</h2><h3 id=\"aop\"><a href=\"#aop\" class=\"headerlink\" title=\"aop\"></a>aop</h3><h5 id=\"aop是一个比较典型的例子，aop实现在目标方法之前、之后、异常等情况下的代码插入。这些插入的代码可以做类似于日志记录，流量统计等工作。也可以在before代码中修改目标方法参数，在after中修改目标方法返回值。但是没有办法控制目标方法是否继续（除非抛出异常）。\"><a href=\"#aop是一个比较典型的例子，aop实现在目标方法之前、之后、异常等情况下的代码插入。这些插入的代码可以做类似于日志记录，流量统计等工作。也可以在before代码中修改目标方法参数，在after中修改目标方法返回值。但是没有办法控制目标方法是否继续（除非抛出异常）。\" class=\"headerlink\" title=\"　　aop是一个比较典型的例子，aop实现在目标方法之前、之后、异常等情况下的代码插入。这些插入的代码可以做类似于日志记录，流量统计等工作。也可以在before代码中修改目标方法参数，在after中修改目标方法返回值。但是没有办法控制目标方法是否继续（除非抛出异常）。\"></a>　　aop是一个比较典型的例子，aop实现在目标方法之前、之后、异常等情况下的代码插入。这些插入的代码可以做类似于日志记录，流量统计等工作。也可以在before代码中修改目标方法参数，在after中修改目标方法返回值。但是没有办法控制目标方法是否继续（除非抛出异常）。</h5><h3 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h3><h5 id=\"cache显而易见，是对目标方法结果的缓存，在缓存结果有效期内，新的调用并不会去执行目标方法，而是直接拿缓存结果。并且用户可以自定义缓存的key（从入参中选取一部分参数，或者是某个对象中的某些属性来作为缓存的key）。\"><a href=\"#cache显而易见，是对目标方法结果的缓存，在缓存结果有效期内，新的调用并不会去执行目标方法，而是直接拿缓存结果。并且用户可以自定义缓存的key（从入参中选取一部分参数，或者是某个对象中的某些属性来作为缓存的key）。\" class=\"headerlink\" title=\"　　cache显而易见，是对目标方法结果的缓存，在缓存结果有效期内，新的调用并不会去执行目标方法，而是直接拿缓存结果。并且用户可以自定义缓存的key（从入参中选取一部分参数，或者是某个对象中的某些属性来作为缓存的key）。\"></a>　　cache显而易见，是对目标方法结果的缓存，在缓存结果有效期内，新的调用并不会去执行目标方法，而是直接拿缓存结果。并且用户可以自定义缓存的key（从入参中选取一部分参数，或者是某个对象中的某些属性来作为缓存的key）。</h5><h3 id=\"限流\"><a href=\"#限流\" class=\"headerlink\" title=\"限流\"></a>限流</h3><h5 id=\"rate-limit是对目标方法每秒的调用频率的限制。在限制的流量内，调用会非常顺畅。在超出的流量之外，调用会阻塞，直到新的调用机会。此外，也可以设置超时时间，如果有超时时间设置，在调用之前会先检查在超时时间内能否拿到调用的机会，如果不能，直接返回超时异常。\"><a href=\"#rate-limit是对目标方法每秒的调用频率的限制。在限制的流量内，调用会非常顺畅。在超出的流量之外，调用会阻塞，直到新的调用机会。此外，也可以设置超时时间，如果有超时时间设置，在调用之前会先检查在超时时间内能否拿到调用的机会，如果不能，直接返回超时异常。\" class=\"headerlink\" title=\"　　rate limit是对目标方法每秒的调用频率的限制。在限制的流量内，调用会非常顺畅。在超出的流量之外，调用会阻塞，直到新的调用机会。此外，也可以设置超时时间，如果有超时时间设置，在调用之前会先检查在超时时间内能否拿到调用的机会，如果不能，直接返回超时异常。\"></a>　　rate limit是对目标方法每秒的调用频率的限制。在限制的流量内，调用会非常顺畅。在超出的流量之外，调用会阻塞，直到新的调用机会。此外，也可以设置超时时间，如果有超时时间设置，在调用之前会先检查在超时时间内能否拿到调用的机会，如果不能，直接返回超时异常。</h5><h3 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h3><h5 id=\"目标方法会用新的线程去执行。可以理解成方法之间的异步执行，如果返回值是void或者是指定的类型。其他的返回值类型，虽然启用的新的线程去执行，但是会等待线程执行完成后拿到返回值再返回。\"><a href=\"#目标方法会用新的线程去执行。可以理解成方法之间的异步执行，如果返回值是void或者是指定的类型。其他的返回值类型，虽然启用的新的线程去执行，但是会等待线程执行完成后拿到返回值再返回。\" class=\"headerlink\" title=\"　　目标方法会用新的线程去执行。可以理解成方法之间的异步执行，如果返回值是void或者是指定的类型。其他的返回值类型，虽然启用的新的线程去执行，但是会等待线程执行完成后拿到返回值再返回。\"></a>　　目标方法会用新的线程去执行。可以理解成方法之间的异步执行，如果返回值是void或者是指定的类型。其他的返回值类型，虽然启用的新的线程去执行，但是会等待线程执行完成后拿到返回值再返回。</h5><h3 id=\"around\"><a href=\"#around\" class=\"headerlink\" title=\"around\"></a>around</h3><h5 id=\"around是最灵活的，around是现在river的功能的核心，around可以在A方法调用B方法之间插入C方法。C方法就叫做对B的around，C可以拿到B的入参、返回、method对象等，也可以控制调用B方法的时机，甚至是不调用。实际上，上面的各种功能的实现都可以用around自己实现，但是实现以上功能的成本对于普通使用者来说成本太高也没有必要。因此一些核心且重要的功能都已经单独实现，只需要使用相应的注解就可以了\"><a href=\"#around是最灵活的，around是现在river的功能的核心，around可以在A方法调用B方法之间插入C方法。C方法就叫做对B的around，C可以拿到B的入参、返回、method对象等，也可以控制调用B方法的时机，甚至是不调用。实际上，上面的各种功能的实现都可以用around自己实现，但是实现以上功能的成本对于普通使用者来说成本太高也没有必要。因此一些核心且重要的功能都已经单独实现，只需要使用相应的注解就可以了\" class=\"headerlink\" title=\"　　around是最灵活的，around是现在river的功能的核心，around可以在A方法调用B方法之间插入C方法。C方法就叫做对B的around，C可以拿到B的入参、返回、method对象等，也可以控制调用B方法的时机，甚至是不调用。实际上，上面的各种功能的实现都可以用around自己实现，但是实现以上功能的成本对于普通使用者来说成本太高也没有必要。因此一些核心且重要的功能都已经单独实现，只需要使用相应的注解就可以了\"></a>　　around是最灵活的，around是现在river的功能的核心，around可以在A方法调用B方法之间插入C方法。C方法就叫做对B的around，C可以拿到B的入参、返回、method对象等，也可以控制调用B方法的时机，甚至是不调用。实际上，上面的各种功能的实现都可以用around自己实现，但是实现以上功能的成本对于普通使用者来说成本太高也没有必要。因此一些核心且重要的功能都已经单独实现，只需要使用相应的注解就可以了</h5>"},{"layout":"book","title":"Java编程思想","date":"2016-12-14T16:00:00.000Z","cover":"thinkingInJava.jpeg","_content":"","source":"_posts/read/thinkInJava.md","raw":"---\nlayout: book\ntitle: Java编程思想\ndate: 2016/12/15\ncover: thinkingInJava.jpeg\ncategories: [read]\n---","slug":"read/thinkInJava","published":1,"updated":"2017-08-15T11:31:46.000Z","comments":1,"photos":[],"link":"","_id":"cj8jros8c002c30s6d9irimta","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"book","title":"边城","date":"2017-03-22T16:00:00.000Z","cover":"town.jpg","_content":"","source":"_posts/read/town.md","raw":"---\nlayout: book\ntitle: 边城\ndate: 2017/03/23\ncover: town.jpg\ncategories: [read]\n---\n","slug":"read/town","published":1,"updated":"2017-08-15T11:31:46.000Z","comments":1,"photos":[],"link":"","_id":"cj8jros8e002f30s690l1okus","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"book","title":"白夜行","date":"2017-03-14T16:00:00.000Z","cover":"walkAtNight.jpeg","_content":"\n#### 作为一个中国观众，有点没办法接受这样的结局。雪慧居然没有绳之于法。\n##### 东野圭吾的小说看着很舒服，因为作者本身的语言比较简单，但是不代表他所表达的意思简单或者含糊不清。相反，这种简单直白的文字使得作者想要表达的意思很容易就被读者所接收到。\n\n##### 回过头去想，白夜行所讲的故事其实很简单。书中的很多关键信息作者并不会直接给出（那不就成了新闻了，哈哈）。作者通过很多的故事线，去表达人物的情感和内心。","source":"_posts/read/walkAtNight.md","raw":"---\nlayout: book\ntitle: 白夜行\ndate: 2017/03/15\ncover: walkAtNight.jpeg\ncategories: [read]\n---\n\n#### 作为一个中国观众，有点没办法接受这样的结局。雪慧居然没有绳之于法。\n##### 东野圭吾的小说看着很舒服，因为作者本身的语言比较简单，但是不代表他所表达的意思简单或者含糊不清。相反，这种简单直白的文字使得作者想要表达的意思很容易就被读者所接收到。\n\n##### 回过头去想，白夜行所讲的故事其实很简单。书中的很多关键信息作者并不会直接给出（那不就成了新闻了，哈哈）。作者通过很多的故事线，去表达人物的情感和内心。","slug":"read/walkAtNight","published":1,"updated":"2017-08-15T11:31:46.000Z","comments":1,"photos":[],"link":"","_id":"cj8jros8e002i30s61ytywl62","content":"<h4 id=\"作为一个中国观众，有点没办法接受这样的结局。雪慧居然没有绳之于法。\"><a href=\"#作为一个中国观众，有点没办法接受这样的结局。雪慧居然没有绳之于法。\" class=\"headerlink\" title=\"作为一个中国观众，有点没办法接受这样的结局。雪慧居然没有绳之于法。\"></a>作为一个中国观众，有点没办法接受这样的结局。雪慧居然没有绳之于法。</h4><h5 id=\"东野圭吾的小说看着很舒服，因为作者本身的语言比较简单，但是不代表他所表达的意思简单或者含糊不清。相反，这种简单直白的文字使得作者想要表达的意思很容易就被读者所接收到。\"><a href=\"#东野圭吾的小说看着很舒服，因为作者本身的语言比较简单，但是不代表他所表达的意思简单或者含糊不清。相反，这种简单直白的文字使得作者想要表达的意思很容易就被读者所接收到。\" class=\"headerlink\" title=\"东野圭吾的小说看着很舒服，因为作者本身的语言比较简单，但是不代表他所表达的意思简单或者含糊不清。相反，这种简单直白的文字使得作者想要表达的意思很容易就被读者所接收到。\"></a>东野圭吾的小说看着很舒服，因为作者本身的语言比较简单，但是不代表他所表达的意思简单或者含糊不清。相反，这种简单直白的文字使得作者想要表达的意思很容易就被读者所接收到。</h5><h5 id=\"回过头去想，白夜行所讲的故事其实很简单。书中的很多关键信息作者并不会直接给出（那不就成了新闻了，哈哈）。作者通过很多的故事线，去表达人物的情感和内心。\"><a href=\"#回过头去想，白夜行所讲的故事其实很简单。书中的很多关键信息作者并不会直接给出（那不就成了新闻了，哈哈）。作者通过很多的故事线，去表达人物的情感和内心。\" class=\"headerlink\" title=\"回过头去想，白夜行所讲的故事其实很简单。书中的很多关键信息作者并不会直接给出（那不就成了新闻了，哈哈）。作者通过很多的故事线，去表达人物的情感和内心。\"></a>回过头去想，白夜行所讲的故事其实很简单。书中的很多关键信息作者并不会直接给出（那不就成了新闻了，哈哈）。作者通过很多的故事线，去表达人物的情感和内心。</h5>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"作为一个中国观众，有点没办法接受这样的结局。雪慧居然没有绳之于法。\"><a href=\"#作为一个中国观众，有点没办法接受这样的结局。雪慧居然没有绳之于法。\" class=\"headerlink\" title=\"作为一个中国观众，有点没办法接受这样的结局。雪慧居然没有绳之于法。\"></a>作为一个中国观众，有点没办法接受这样的结局。雪慧居然没有绳之于法。</h4><h5 id=\"东野圭吾的小说看着很舒服，因为作者本身的语言比较简单，但是不代表他所表达的意思简单或者含糊不清。相反，这种简单直白的文字使得作者想要表达的意思很容易就被读者所接收到。\"><a href=\"#东野圭吾的小说看着很舒服，因为作者本身的语言比较简单，但是不代表他所表达的意思简单或者含糊不清。相反，这种简单直白的文字使得作者想要表达的意思很容易就被读者所接收到。\" class=\"headerlink\" title=\"东野圭吾的小说看着很舒服，因为作者本身的语言比较简单，但是不代表他所表达的意思简单或者含糊不清。相反，这种简单直白的文字使得作者想要表达的意思很容易就被读者所接收到。\"></a>东野圭吾的小说看着很舒服，因为作者本身的语言比较简单，但是不代表他所表达的意思简单或者含糊不清。相反，这种简单直白的文字使得作者想要表达的意思很容易就被读者所接收到。</h5><h5 id=\"回过头去想，白夜行所讲的故事其实很简单。书中的很多关键信息作者并不会直接给出（那不就成了新闻了，哈哈）。作者通过很多的故事线，去表达人物的情感和内心。\"><a href=\"#回过头去想，白夜行所讲的故事其实很简单。书中的很多关键信息作者并不会直接给出（那不就成了新闻了，哈哈）。作者通过很多的故事线，去表达人物的情感和内心。\" class=\"headerlink\" title=\"回过头去想，白夜行所讲的故事其实很简单。书中的很多关键信息作者并不会直接给出（那不就成了新闻了，哈哈）。作者通过很多的故事线，去表达人物的情感和内心。\"></a>回过头去想，白夜行所讲的故事其实很简单。书中的很多关键信息作者并不会直接给出（那不就成了新闻了，哈哈）。作者通过很多的故事线，去表达人物的情感和内心。</h5>"},{"layout":"post","title":"Aop","date":"2017-06-03T16:00:00.000Z","original":true,"color":"#E30D23","tag":[["river","river"]],"_content":"\n##### 　　aop是一个比较典型的例子，aop实现在目标方法之前、之后、异常等情况下的代码插入。这些插入的代码可以做类似于日志记录，流量统计等工作。也可以在before代码中修改目标方法参数，在after中修改目标方法返回值。但是没有办法控制目标方法是否继续（除非抛出异常）。\n<!--more-->\n\n### 实例代码\n#### 首先需要实现一个继承自`AopPoint`的类。\n```java\npublic class AopTest extends AopPoint {\n\n    public void before() {\n        System.out.println(\"before....params:\" + Arrays.toString(getParams()));\n        setParams(new Object[]{\"change params\"});\n    }\n\n    public void after() {\n        System.out.println(\"after...result:\" + getResult());\n    }\n\n    public void afterReturing() {\n    }\n\n    public void afterThrowing() {\n    }\n}\n```\n#### 在目标方法中加入`Aop`注解,在Aop注解中设置自己实现的`AopPoint`类Class\n```java\n@Aop(AopTest.class)\npublic String aop(String param){\n    System.out.println(\"aop param : \" + param);\n    return param + \" success\";\n}\n```\n#### 获取目标方法类的代理实例，然后执行\n```java\nCrudServiceImpl proxy = ProxyFactory.getSingleProxy(CrudServiceImpl.class);\nproxy.aop(\"test\");\n```\n#### 执行结果\n```none\nbefore....params:[test]\naop param : change params\nafter...result:change params success\n```\n\n### 代码分析\n#### 继承自`AopPoint`的类,需要实现4个方法：\n##### `before`：在目标方法之前执行；\n##### `after`：在目标方法之后执行，无论目标执行是否成功；\n##### `afterReturing`：在目标方法执行之后执行；\n##### `afterThrowing`：在目标方法抛出异常后调用执行。\n#### 在`AopPoint`的子类中，设置了一些对目标方法的操作：\n```java\n/**\n * 获取目标方法Method对象\n */\nprotected Method getMethod() {}\n\n/**\n * 获取入参\n */\nprotected Object[] getParams() {}\n\n/**\n * 修改入参\n */\nprotected void setParams(Object[] objects) {}\n\n/**\n * 获取返回结果\n * 在before中调用这个方法将返回null\n */\nprotected Object getResult() {}\n\n/**\n * 修改返回结果\n * 在before中设置的返回结果将被正真的结果覆盖\n */\nprotected void setResult(Object result) {}\n```\n#### `AopPoint`的实现类会使用单例模式，所以当你Aop多个方法的时候，调用的都是将是同一个实例。因此下面这种代码将会出现线程安全问题\n```java\npublic class AopTest extends AopPoint {\n\n    private int i = 0;\n\n    public void before() {\n        System.out.println(++i);\n    }\n\n    ...\n}\n```\n##### 这种线程安全问题只能自己保证共享对象的安全。现在还不能通过参数改变aop的实例类是否单例。\n```java\npublic class AopTest extends AopPoint {\n\n    private AtomicInteger i = new AtomicInteger(0);\n\n    public void before() {\n        System.out.println(i.incrementAndGet());\n    }\n\n    ...\n}\n```\n\n#### aop大法好，但是也有一些局限性，说一说还能实现的一些细节点：\n1. 目前代理对象还是需要手动的去获取，这个在后期接入spring逻辑后，可以使用spring注入。\n2. 没有办法做到流程控制，是否可以在`AopPoint`中加入流程控制，当发现参数不对时，阻止流程的继续。\n3. 当目标方法比较多时，需要添加注解的地方比较多，这点Spring使用的是切面的解决方法，个人认为这种方法会使得使用的学习成本变高，因为每次我想要使用的时候需要翻看笔记。是否可以使得`Aop`支持类的注解，以减轻这种现象。\n4. 是否应该控制`AopPoint`实现类的单例与否。","source":"_posts/river/aop.md","raw":"---\nlayout: post\ntitle: Aop\ndate: 2017/06/04\noriginal: true\ntags: [tech, river, index, java]\ncolor: '#E30D23'\ntag: [[river, river]]\n---\n\n##### 　　aop是一个比较典型的例子，aop实现在目标方法之前、之后、异常等情况下的代码插入。这些插入的代码可以做类似于日志记录，流量统计等工作。也可以在before代码中修改目标方法参数，在after中修改目标方法返回值。但是没有办法控制目标方法是否继续（除非抛出异常）。\n<!--more-->\n\n### 实例代码\n#### 首先需要实现一个继承自`AopPoint`的类。\n```java\npublic class AopTest extends AopPoint {\n\n    public void before() {\n        System.out.println(\"before....params:\" + Arrays.toString(getParams()));\n        setParams(new Object[]{\"change params\"});\n    }\n\n    public void after() {\n        System.out.println(\"after...result:\" + getResult());\n    }\n\n    public void afterReturing() {\n    }\n\n    public void afterThrowing() {\n    }\n}\n```\n#### 在目标方法中加入`Aop`注解,在Aop注解中设置自己实现的`AopPoint`类Class\n```java\n@Aop(AopTest.class)\npublic String aop(String param){\n    System.out.println(\"aop param : \" + param);\n    return param + \" success\";\n}\n```\n#### 获取目标方法类的代理实例，然后执行\n```java\nCrudServiceImpl proxy = ProxyFactory.getSingleProxy(CrudServiceImpl.class);\nproxy.aop(\"test\");\n```\n#### 执行结果\n```none\nbefore....params:[test]\naop param : change params\nafter...result:change params success\n```\n\n### 代码分析\n#### 继承自`AopPoint`的类,需要实现4个方法：\n##### `before`：在目标方法之前执行；\n##### `after`：在目标方法之后执行，无论目标执行是否成功；\n##### `afterReturing`：在目标方法执行之后执行；\n##### `afterThrowing`：在目标方法抛出异常后调用执行。\n#### 在`AopPoint`的子类中，设置了一些对目标方法的操作：\n```java\n/**\n * 获取目标方法Method对象\n */\nprotected Method getMethod() {}\n\n/**\n * 获取入参\n */\nprotected Object[] getParams() {}\n\n/**\n * 修改入参\n */\nprotected void setParams(Object[] objects) {}\n\n/**\n * 获取返回结果\n * 在before中调用这个方法将返回null\n */\nprotected Object getResult() {}\n\n/**\n * 修改返回结果\n * 在before中设置的返回结果将被正真的结果覆盖\n */\nprotected void setResult(Object result) {}\n```\n#### `AopPoint`的实现类会使用单例模式，所以当你Aop多个方法的时候，调用的都是将是同一个实例。因此下面这种代码将会出现线程安全问题\n```java\npublic class AopTest extends AopPoint {\n\n    private int i = 0;\n\n    public void before() {\n        System.out.println(++i);\n    }\n\n    ...\n}\n```\n##### 这种线程安全问题只能自己保证共享对象的安全。现在还不能通过参数改变aop的实例类是否单例。\n```java\npublic class AopTest extends AopPoint {\n\n    private AtomicInteger i = new AtomicInteger(0);\n\n    public void before() {\n        System.out.println(i.incrementAndGet());\n    }\n\n    ...\n}\n```\n\n#### aop大法好，但是也有一些局限性，说一说还能实现的一些细节点：\n1. 目前代理对象还是需要手动的去获取，这个在后期接入spring逻辑后，可以使用spring注入。\n2. 没有办法做到流程控制，是否可以在`AopPoint`中加入流程控制，当发现参数不对时，阻止流程的继续。\n3. 当目标方法比较多时，需要添加注解的地方比较多，这点Spring使用的是切面的解决方法，个人认为这种方法会使得使用的学习成本变高，因为每次我想要使用的时候需要翻看笔记。是否可以使得`Aop`支持类的注解，以减轻这种现象。\n4. 是否应该控制`AopPoint`实现类的单例与否。","slug":"river/aop","published":1,"updated":"2017-10-06T16:05:44.337Z","comments":1,"photos":[],"link":"","_id":"cj8jros8f002k30s6txyal9a5","content":"<h5 id=\"aop是一个比较典型的例子，aop实现在目标方法之前、之后、异常等情况下的代码插入。这些插入的代码可以做类似于日志记录，流量统计等工作。也可以在before代码中修改目标方法参数，在after中修改目标方法返回值。但是没有办法控制目标方法是否继续（除非抛出异常）。\"><a href=\"#aop是一个比较典型的例子，aop实现在目标方法之前、之后、异常等情况下的代码插入。这些插入的代码可以做类似于日志记录，流量统计等工作。也可以在before代码中修改目标方法参数，在after中修改目标方法返回值。但是没有办法控制目标方法是否继续（除非抛出异常）。\" class=\"headerlink\" title=\"　　aop是一个比较典型的例子，aop实现在目标方法之前、之后、异常等情况下的代码插入。这些插入的代码可以做类似于日志记录，流量统计等工作。也可以在before代码中修改目标方法参数，在after中修改目标方法返回值。但是没有办法控制目标方法是否继续（除非抛出异常）。\"></a>　　aop是一个比较典型的例子，aop实现在目标方法之前、之后、异常等情况下的代码插入。这些插入的代码可以做类似于日志记录，流量统计等工作。也可以在before代码中修改目标方法参数，在after中修改目标方法返回值。但是没有办法控制目标方法是否继续（除非抛出异常）。</h5><a id=\"more\"></a>\n<h3 id=\"实例代码\"><a href=\"#实例代码\" class=\"headerlink\" title=\"实例代码\"></a>实例代码</h3><h4 id=\"首先需要实现一个继承自AopPoint的类。\"><a href=\"#首先需要实现一个继承自AopPoint的类。\" class=\"headerlink\" title=\"首先需要实现一个继承自AopPoint的类。\"></a>首先需要实现一个继承自<code>AopPoint</code>的类。</h4><pre><code class=\"lang-java\">public class AopTest extends AopPoint {\n\n    public void before() {\n        System.out.println(&quot;before....params:&quot; + Arrays.toString(getParams()));\n        setParams(new Object[]{&quot;change params&quot;});\n    }\n\n    public void after() {\n        System.out.println(&quot;after...result:&quot; + getResult());\n    }\n\n    public void afterReturing() {\n    }\n\n    public void afterThrowing() {\n    }\n}\n</code></pre>\n<h4 id=\"在目标方法中加入Aop注解-在Aop注解中设置自己实现的AopPoint类Class\"><a href=\"#在目标方法中加入Aop注解-在Aop注解中设置自己实现的AopPoint类Class\" class=\"headerlink\" title=\"在目标方法中加入Aop注解,在Aop注解中设置自己实现的AopPoint类Class\"></a>在目标方法中加入<code>Aop</code>注解,在Aop注解中设置自己实现的<code>AopPoint</code>类Class</h4><pre><code class=\"lang-java\">@Aop(AopTest.class)\npublic String aop(String param){\n    System.out.println(&quot;aop param : &quot; + param);\n    return param + &quot; success&quot;;\n}\n</code></pre>\n<h4 id=\"获取目标方法类的代理实例，然后执行\"><a href=\"#获取目标方法类的代理实例，然后执行\" class=\"headerlink\" title=\"获取目标方法类的代理实例，然后执行\"></a>获取目标方法类的代理实例，然后执行</h4><pre><code class=\"lang-java\">CrudServiceImpl proxy = ProxyFactory.getSingleProxy(CrudServiceImpl.class);\nproxy.aop(&quot;test&quot;);\n</code></pre>\n<h4 id=\"执行结果\"><a href=\"#执行结果\" class=\"headerlink\" title=\"执行结果\"></a>执行结果</h4><pre><code class=\"lang-none\">before....params:[test]\naop param : change params\nafter...result:change params success\n</code></pre>\n<h3 id=\"代码分析\"><a href=\"#代码分析\" class=\"headerlink\" title=\"代码分析\"></a>代码分析</h3><h4 id=\"继承自AopPoint的类-需要实现4个方法：\"><a href=\"#继承自AopPoint的类-需要实现4个方法：\" class=\"headerlink\" title=\"继承自AopPoint的类,需要实现4个方法：\"></a>继承自<code>AopPoint</code>的类,需要实现4个方法：</h4><h5 id=\"before：在目标方法之前执行；\"><a href=\"#before：在目标方法之前执行；\" class=\"headerlink\" title=\"before：在目标方法之前执行；\"></a><code>before</code>：在目标方法之前执行；</h5><h5 id=\"after：在目标方法之后执行，无论目标执行是否成功；\"><a href=\"#after：在目标方法之后执行，无论目标执行是否成功；\" class=\"headerlink\" title=\"after：在目标方法之后执行，无论目标执行是否成功；\"></a><code>after</code>：在目标方法之后执行，无论目标执行是否成功；</h5><h5 id=\"afterReturing：在目标方法执行之后执行；\"><a href=\"#afterReturing：在目标方法执行之后执行；\" class=\"headerlink\" title=\"afterReturing：在目标方法执行之后执行；\"></a><code>afterReturing</code>：在目标方法执行之后执行；</h5><h5 id=\"afterThrowing：在目标方法抛出异常后调用执行。\"><a href=\"#afterThrowing：在目标方法抛出异常后调用执行。\" class=\"headerlink\" title=\"afterThrowing：在目标方法抛出异常后调用执行。\"></a><code>afterThrowing</code>：在目标方法抛出异常后调用执行。</h5><h4 id=\"在AopPoint的子类中，设置了一些对目标方法的操作：\"><a href=\"#在AopPoint的子类中，设置了一些对目标方法的操作：\" class=\"headerlink\" title=\"在AopPoint的子类中，设置了一些对目标方法的操作：\"></a>在<code>AopPoint</code>的子类中，设置了一些对目标方法的操作：</h4><pre><code class=\"lang-java\">/**\n * 获取目标方法Method对象\n */\nprotected Method getMethod() {}\n\n/**\n * 获取入参\n */\nprotected Object[] getParams() {}\n\n/**\n * 修改入参\n */\nprotected void setParams(Object[] objects) {}\n\n/**\n * 获取返回结果\n * 在before中调用这个方法将返回null\n */\nprotected Object getResult() {}\n\n/**\n * 修改返回结果\n * 在before中设置的返回结果将被正真的结果覆盖\n */\nprotected void setResult(Object result) {}\n</code></pre>\n<h4 id=\"AopPoint的实现类会使用单例模式，所以当你Aop多个方法的时候，调用的都是将是同一个实例。因此下面这种代码将会出现线程安全问题\"><a href=\"#AopPoint的实现类会使用单例模式，所以当你Aop多个方法的时候，调用的都是将是同一个实例。因此下面这种代码将会出现线程安全问题\" class=\"headerlink\" title=\"AopPoint的实现类会使用单例模式，所以当你Aop多个方法的时候，调用的都是将是同一个实例。因此下面这种代码将会出现线程安全问题\"></a><code>AopPoint</code>的实现类会使用单例模式，所以当你Aop多个方法的时候，调用的都是将是同一个实例。因此下面这种代码将会出现线程安全问题</h4><pre><code class=\"lang-java\">public class AopTest extends AopPoint {\n\n    private int i = 0;\n\n    public void before() {\n        System.out.println(++i);\n    }\n\n    ...\n}\n</code></pre>\n<h5 id=\"这种线程安全问题只能自己保证共享对象的安全。现在还不能通过参数改变aop的实例类是否单例。\"><a href=\"#这种线程安全问题只能自己保证共享对象的安全。现在还不能通过参数改变aop的实例类是否单例。\" class=\"headerlink\" title=\"这种线程安全问题只能自己保证共享对象的安全。现在还不能通过参数改变aop的实例类是否单例。\"></a>这种线程安全问题只能自己保证共享对象的安全。现在还不能通过参数改变aop的实例类是否单例。</h5><pre><code class=\"lang-java\">public class AopTest extends AopPoint {\n\n    private AtomicInteger i = new AtomicInteger(0);\n\n    public void before() {\n        System.out.println(i.incrementAndGet());\n    }\n\n    ...\n}\n</code></pre>\n<h4 id=\"aop大法好，但是也有一些局限性，说一说还能实现的一些细节点：\"><a href=\"#aop大法好，但是也有一些局限性，说一说还能实现的一些细节点：\" class=\"headerlink\" title=\"aop大法好，但是也有一些局限性，说一说还能实现的一些细节点：\"></a>aop大法好，但是也有一些局限性，说一说还能实现的一些细节点：</h4><ol>\n<li>目前代理对象还是需要手动的去获取，这个在后期接入spring逻辑后，可以使用spring注入。</li>\n<li>没有办法做到流程控制，是否可以在<code>AopPoint</code>中加入流程控制，当发现参数不对时，阻止流程的继续。</li>\n<li>当目标方法比较多时，需要添加注解的地方比较多，这点Spring使用的是切面的解决方法，个人认为这种方法会使得使用的学习成本变高，因为每次我想要使用的时候需要翻看笔记。是否可以使得<code>Aop</code>支持类的注解，以减轻这种现象。</li>\n<li>是否应该控制<code>AopPoint</code>实现类的单例与否。</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h5 id=\"aop是一个比较典型的例子，aop实现在目标方法之前、之后、异常等情况下的代码插入。这些插入的代码可以做类似于日志记录，流量统计等工作。也可以在before代码中修改目标方法参数，在after中修改目标方法返回值。但是没有办法控制目标方法是否继续（除非抛出异常）。\"><a href=\"#aop是一个比较典型的例子，aop实现在目标方法之前、之后、异常等情况下的代码插入。这些插入的代码可以做类似于日志记录，流量统计等工作。也可以在before代码中修改目标方法参数，在after中修改目标方法返回值。但是没有办法控制目标方法是否继续（除非抛出异常）。\" class=\"headerlink\" title=\"　　aop是一个比较典型的例子，aop实现在目标方法之前、之后、异常等情况下的代码插入。这些插入的代码可以做类似于日志记录，流量统计等工作。也可以在before代码中修改目标方法参数，在after中修改目标方法返回值。但是没有办法控制目标方法是否继续（除非抛出异常）。\"></a>　　aop是一个比较典型的例子，aop实现在目标方法之前、之后、异常等情况下的代码插入。这些插入的代码可以做类似于日志记录，流量统计等工作。也可以在before代码中修改目标方法参数，在after中修改目标方法返回值。但是没有办法控制目标方法是否继续（除非抛出异常）。</h5>","more":"<h3 id=\"实例代码\"><a href=\"#实例代码\" class=\"headerlink\" title=\"实例代码\"></a>实例代码</h3><h4 id=\"首先需要实现一个继承自AopPoint的类。\"><a href=\"#首先需要实现一个继承自AopPoint的类。\" class=\"headerlink\" title=\"首先需要实现一个继承自AopPoint的类。\"></a>首先需要实现一个继承自<code>AopPoint</code>的类。</h4><pre><code class=\"lang-java\">public class AopTest extends AopPoint {\n\n    public void before() {\n        System.out.println(&quot;before....params:&quot; + Arrays.toString(getParams()));\n        setParams(new Object[]{&quot;change params&quot;});\n    }\n\n    public void after() {\n        System.out.println(&quot;after...result:&quot; + getResult());\n    }\n\n    public void afterReturing() {\n    }\n\n    public void afterThrowing() {\n    }\n}\n</code></pre>\n<h4 id=\"在目标方法中加入Aop注解-在Aop注解中设置自己实现的AopPoint类Class\"><a href=\"#在目标方法中加入Aop注解-在Aop注解中设置自己实现的AopPoint类Class\" class=\"headerlink\" title=\"在目标方法中加入Aop注解,在Aop注解中设置自己实现的AopPoint类Class\"></a>在目标方法中加入<code>Aop</code>注解,在Aop注解中设置自己实现的<code>AopPoint</code>类Class</h4><pre><code class=\"lang-java\">@Aop(AopTest.class)\npublic String aop(String param){\n    System.out.println(&quot;aop param : &quot; + param);\n    return param + &quot; success&quot;;\n}\n</code></pre>\n<h4 id=\"获取目标方法类的代理实例，然后执行\"><a href=\"#获取目标方法类的代理实例，然后执行\" class=\"headerlink\" title=\"获取目标方法类的代理实例，然后执行\"></a>获取目标方法类的代理实例，然后执行</h4><pre><code class=\"lang-java\">CrudServiceImpl proxy = ProxyFactory.getSingleProxy(CrudServiceImpl.class);\nproxy.aop(&quot;test&quot;);\n</code></pre>\n<h4 id=\"执行结果\"><a href=\"#执行结果\" class=\"headerlink\" title=\"执行结果\"></a>执行结果</h4><pre><code class=\"lang-none\">before....params:[test]\naop param : change params\nafter...result:change params success\n</code></pre>\n<h3 id=\"代码分析\"><a href=\"#代码分析\" class=\"headerlink\" title=\"代码分析\"></a>代码分析</h3><h4 id=\"继承自AopPoint的类-需要实现4个方法：\"><a href=\"#继承自AopPoint的类-需要实现4个方法：\" class=\"headerlink\" title=\"继承自AopPoint的类,需要实现4个方法：\"></a>继承自<code>AopPoint</code>的类,需要实现4个方法：</h4><h5 id=\"before：在目标方法之前执行；\"><a href=\"#before：在目标方法之前执行；\" class=\"headerlink\" title=\"before：在目标方法之前执行；\"></a><code>before</code>：在目标方法之前执行；</h5><h5 id=\"after：在目标方法之后执行，无论目标执行是否成功；\"><a href=\"#after：在目标方法之后执行，无论目标执行是否成功；\" class=\"headerlink\" title=\"after：在目标方法之后执行，无论目标执行是否成功；\"></a><code>after</code>：在目标方法之后执行，无论目标执行是否成功；</h5><h5 id=\"afterReturing：在目标方法执行之后执行；\"><a href=\"#afterReturing：在目标方法执行之后执行；\" class=\"headerlink\" title=\"afterReturing：在目标方法执行之后执行；\"></a><code>afterReturing</code>：在目标方法执行之后执行；</h5><h5 id=\"afterThrowing：在目标方法抛出异常后调用执行。\"><a href=\"#afterThrowing：在目标方法抛出异常后调用执行。\" class=\"headerlink\" title=\"afterThrowing：在目标方法抛出异常后调用执行。\"></a><code>afterThrowing</code>：在目标方法抛出异常后调用执行。</h5><h4 id=\"在AopPoint的子类中，设置了一些对目标方法的操作：\"><a href=\"#在AopPoint的子类中，设置了一些对目标方法的操作：\" class=\"headerlink\" title=\"在AopPoint的子类中，设置了一些对目标方法的操作：\"></a>在<code>AopPoint</code>的子类中，设置了一些对目标方法的操作：</h4><pre><code class=\"lang-java\">/**\n * 获取目标方法Method对象\n */\nprotected Method getMethod() {}\n\n/**\n * 获取入参\n */\nprotected Object[] getParams() {}\n\n/**\n * 修改入参\n */\nprotected void setParams(Object[] objects) {}\n\n/**\n * 获取返回结果\n * 在before中调用这个方法将返回null\n */\nprotected Object getResult() {}\n\n/**\n * 修改返回结果\n * 在before中设置的返回结果将被正真的结果覆盖\n */\nprotected void setResult(Object result) {}\n</code></pre>\n<h4 id=\"AopPoint的实现类会使用单例模式，所以当你Aop多个方法的时候，调用的都是将是同一个实例。因此下面这种代码将会出现线程安全问题\"><a href=\"#AopPoint的实现类会使用单例模式，所以当你Aop多个方法的时候，调用的都是将是同一个实例。因此下面这种代码将会出现线程安全问题\" class=\"headerlink\" title=\"AopPoint的实现类会使用单例模式，所以当你Aop多个方法的时候，调用的都是将是同一个实例。因此下面这种代码将会出现线程安全问题\"></a><code>AopPoint</code>的实现类会使用单例模式，所以当你Aop多个方法的时候，调用的都是将是同一个实例。因此下面这种代码将会出现线程安全问题</h4><pre><code class=\"lang-java\">public class AopTest extends AopPoint {\n\n    private int i = 0;\n\n    public void before() {\n        System.out.println(++i);\n    }\n\n    ...\n}\n</code></pre>\n<h5 id=\"这种线程安全问题只能自己保证共享对象的安全。现在还不能通过参数改变aop的实例类是否单例。\"><a href=\"#这种线程安全问题只能自己保证共享对象的安全。现在还不能通过参数改变aop的实例类是否单例。\" class=\"headerlink\" title=\"这种线程安全问题只能自己保证共享对象的安全。现在还不能通过参数改变aop的实例类是否单例。\"></a>这种线程安全问题只能自己保证共享对象的安全。现在还不能通过参数改变aop的实例类是否单例。</h5><pre><code class=\"lang-java\">public class AopTest extends AopPoint {\n\n    private AtomicInteger i = new AtomicInteger(0);\n\n    public void before() {\n        System.out.println(i.incrementAndGet());\n    }\n\n    ...\n}\n</code></pre>\n<h4 id=\"aop大法好，但是也有一些局限性，说一说还能实现的一些细节点：\"><a href=\"#aop大法好，但是也有一些局限性，说一说还能实现的一些细节点：\" class=\"headerlink\" title=\"aop大法好，但是也有一些局限性，说一说还能实现的一些细节点：\"></a>aop大法好，但是也有一些局限性，说一说还能实现的一些细节点：</h4><ol>\n<li>目前代理对象还是需要手动的去获取，这个在后期接入spring逻辑后，可以使用spring注入。</li>\n<li>没有办法做到流程控制，是否可以在<code>AopPoint</code>中加入流程控制，当发现参数不对时，阻止流程的继续。</li>\n<li>当目标方法比较多时，需要添加注解的地方比较多，这点Spring使用的是切面的解决方法，个人认为这种方法会使得使用的学习成本变高，因为每次我想要使用的时候需要翻看笔记。是否可以使得<code>Aop</code>支持类的注解，以减轻这种现象。</li>\n<li>是否应该控制<code>AopPoint</code>实现类的单例与否。</li>\n</ol>"},{"layout":"post","title":"缓存","date":"2017-06-04T16:00:00.000Z","original":true,"tag":[["river","river"]],"_content":"\n##### 　　cache的功能显而易见，是对目标方法结果的缓存，在缓存结果有效期内，新的调用并不会去执行目标方法，而是直接拿缓存结果。并且用户可以自定义缓存的key（从入参中选取一部分参数，或者是某个对象中的某些属性来作为缓存的key）。\n<!--more-->\n\n### 实例代码\n#### 目标方法添加`cache`注解\n```java\n@Cache(maxSize = 2, timeOut = 1, timeUnit = TimeUnit.MINUTES)\npublic String cache(String param){\n    System.out.println(\"cache param : \" + param);\n    return param + \" success\";\n}\n```\n#### 获取代理对象实例，调用目标方法\n```java\nfinal CrudServiceImpl proxy = ProxyFactory.getSingleProxy(CrudServiceImpl.class);\nfor (int i = 0; i < 10; i ++){\n    System.out.println(proxy.cache(\"cache key\"));\n}\n```\n#### 执行结果\n```none\ncache param : cache key\ncache key success\ncache key success\ncache key success\ncache key success\ncache key success\ncache key success\ncache key success\ncache key success\ncache key success\ncache key success\n```\n\n### 代码分析\n\n#### 缓存大法好，但是也有一些局限性，说一说还能实现的一些细节点：\n1. 目前代理对象还是需要手动的去获取，这个在后期接入spring逻辑后，可以使用spring注入。","source":"_posts/river/cache.md","raw":"---\nlayout: post\ntitle: 缓存\ndate: 2017/06/05\noriginal: true\ntags: [tech, river, index, java]\ntag: [[river, river]]\n---\n\n##### 　　cache的功能显而易见，是对目标方法结果的缓存，在缓存结果有效期内，新的调用并不会去执行目标方法，而是直接拿缓存结果。并且用户可以自定义缓存的key（从入参中选取一部分参数，或者是某个对象中的某些属性来作为缓存的key）。\n<!--more-->\n\n### 实例代码\n#### 目标方法添加`cache`注解\n```java\n@Cache(maxSize = 2, timeOut = 1, timeUnit = TimeUnit.MINUTES)\npublic String cache(String param){\n    System.out.println(\"cache param : \" + param);\n    return param + \" success\";\n}\n```\n#### 获取代理对象实例，调用目标方法\n```java\nfinal CrudServiceImpl proxy = ProxyFactory.getSingleProxy(CrudServiceImpl.class);\nfor (int i = 0; i < 10; i ++){\n    System.out.println(proxy.cache(\"cache key\"));\n}\n```\n#### 执行结果\n```none\ncache param : cache key\ncache key success\ncache key success\ncache key success\ncache key success\ncache key success\ncache key success\ncache key success\ncache key success\ncache key success\ncache key success\n```\n\n### 代码分析\n\n#### 缓存大法好，但是也有一些局限性，说一说还能实现的一些细节点：\n1. 目前代理对象还是需要手动的去获取，这个在后期接入spring逻辑后，可以使用spring注入。","slug":"river/cache","published":1,"updated":"2017-10-06T16:05:44.344Z","comments":1,"photos":[],"link":"","_id":"cj8jros8h002n30s67m31t00m","content":"<h5 id=\"cache的功能显而易见，是对目标方法结果的缓存，在缓存结果有效期内，新的调用并不会去执行目标方法，而是直接拿缓存结果。并且用户可以自定义缓存的key（从入参中选取一部分参数，或者是某个对象中的某些属性来作为缓存的key）。\"><a href=\"#cache的功能显而易见，是对目标方法结果的缓存，在缓存结果有效期内，新的调用并不会去执行目标方法，而是直接拿缓存结果。并且用户可以自定义缓存的key（从入参中选取一部分参数，或者是某个对象中的某些属性来作为缓存的key）。\" class=\"headerlink\" title=\"　　cache的功能显而易见，是对目标方法结果的缓存，在缓存结果有效期内，新的调用并不会去执行目标方法，而是直接拿缓存结果。并且用户可以自定义缓存的key（从入参中选取一部分参数，或者是某个对象中的某些属性来作为缓存的key）。\"></a>　　cache的功能显而易见，是对目标方法结果的缓存，在缓存结果有效期内，新的调用并不会去执行目标方法，而是直接拿缓存结果。并且用户可以自定义缓存的key（从入参中选取一部分参数，或者是某个对象中的某些属性来作为缓存的key）。</h5><a id=\"more\"></a>\n<h3 id=\"实例代码\"><a href=\"#实例代码\" class=\"headerlink\" title=\"实例代码\"></a>实例代码</h3><h4 id=\"目标方法添加cache注解\"><a href=\"#目标方法添加cache注解\" class=\"headerlink\" title=\"目标方法添加cache注解\"></a>目标方法添加<code>cache</code>注解</h4><pre><code class=\"lang-java\">@Cache(maxSize = 2, timeOut = 1, timeUnit = TimeUnit.MINUTES)\npublic String cache(String param){\n    System.out.println(&quot;cache param : &quot; + param);\n    return param + &quot; success&quot;;\n}\n</code></pre>\n<h4 id=\"获取代理对象实例，调用目标方法\"><a href=\"#获取代理对象实例，调用目标方法\" class=\"headerlink\" title=\"获取代理对象实例，调用目标方法\"></a>获取代理对象实例，调用目标方法</h4><pre><code class=\"lang-java\">final CrudServiceImpl proxy = ProxyFactory.getSingleProxy(CrudServiceImpl.class);\nfor (int i = 0; i &lt; 10; i ++){\n    System.out.println(proxy.cache(&quot;cache key&quot;));\n}\n</code></pre>\n<h4 id=\"执行结果\"><a href=\"#执行结果\" class=\"headerlink\" title=\"执行结果\"></a>执行结果</h4><pre><code class=\"lang-none\">cache param : cache key\ncache key success\ncache key success\ncache key success\ncache key success\ncache key success\ncache key success\ncache key success\ncache key success\ncache key success\ncache key success\n</code></pre>\n<h3 id=\"代码分析\"><a href=\"#代码分析\" class=\"headerlink\" title=\"代码分析\"></a>代码分析</h3><h4 id=\"缓存大法好，但是也有一些局限性，说一说还能实现的一些细节点：\"><a href=\"#缓存大法好，但是也有一些局限性，说一说还能实现的一些细节点：\" class=\"headerlink\" title=\"缓存大法好，但是也有一些局限性，说一说还能实现的一些细节点：\"></a>缓存大法好，但是也有一些局限性，说一说还能实现的一些细节点：</h4><ol>\n<li>目前代理对象还是需要手动的去获取，这个在后期接入spring逻辑后，可以使用spring注入。</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h5 id=\"cache的功能显而易见，是对目标方法结果的缓存，在缓存结果有效期内，新的调用并不会去执行目标方法，而是直接拿缓存结果。并且用户可以自定义缓存的key（从入参中选取一部分参数，或者是某个对象中的某些属性来作为缓存的key）。\"><a href=\"#cache的功能显而易见，是对目标方法结果的缓存，在缓存结果有效期内，新的调用并不会去执行目标方法，而是直接拿缓存结果。并且用户可以自定义缓存的key（从入参中选取一部分参数，或者是某个对象中的某些属性来作为缓存的key）。\" class=\"headerlink\" title=\"　　cache的功能显而易见，是对目标方法结果的缓存，在缓存结果有效期内，新的调用并不会去执行目标方法，而是直接拿缓存结果。并且用户可以自定义缓存的key（从入参中选取一部分参数，或者是某个对象中的某些属性来作为缓存的key）。\"></a>　　cache的功能显而易见，是对目标方法结果的缓存，在缓存结果有效期内，新的调用并不会去执行目标方法，而是直接拿缓存结果。并且用户可以自定义缓存的key（从入参中选取一部分参数，或者是某个对象中的某些属性来作为缓存的key）。</h5>","more":"<h3 id=\"实例代码\"><a href=\"#实例代码\" class=\"headerlink\" title=\"实例代码\"></a>实例代码</h3><h4 id=\"目标方法添加cache注解\"><a href=\"#目标方法添加cache注解\" class=\"headerlink\" title=\"目标方法添加cache注解\"></a>目标方法添加<code>cache</code>注解</h4><pre><code class=\"lang-java\">@Cache(maxSize = 2, timeOut = 1, timeUnit = TimeUnit.MINUTES)\npublic String cache(String param){\n    System.out.println(&quot;cache param : &quot; + param);\n    return param + &quot; success&quot;;\n}\n</code></pre>\n<h4 id=\"获取代理对象实例，调用目标方法\"><a href=\"#获取代理对象实例，调用目标方法\" class=\"headerlink\" title=\"获取代理对象实例，调用目标方法\"></a>获取代理对象实例，调用目标方法</h4><pre><code class=\"lang-java\">final CrudServiceImpl proxy = ProxyFactory.getSingleProxy(CrudServiceImpl.class);\nfor (int i = 0; i &lt; 10; i ++){\n    System.out.println(proxy.cache(&quot;cache key&quot;));\n}\n</code></pre>\n<h4 id=\"执行结果\"><a href=\"#执行结果\" class=\"headerlink\" title=\"执行结果\"></a>执行结果</h4><pre><code class=\"lang-none\">cache param : cache key\ncache key success\ncache key success\ncache key success\ncache key success\ncache key success\ncache key success\ncache key success\ncache key success\ncache key success\ncache key success\n</code></pre>\n<h3 id=\"代码分析\"><a href=\"#代码分析\" class=\"headerlink\" title=\"代码分析\"></a>代码分析</h3><h4 id=\"缓存大法好，但是也有一些局限性，说一说还能实现的一些细节点：\"><a href=\"#缓存大法好，但是也有一些局限性，说一说还能实现的一些细节点：\" class=\"headerlink\" title=\"缓存大法好，但是也有一些局限性，说一说还能实现的一些细节点：\"></a>缓存大法好，但是也有一些局限性，说一说还能实现的一些细节点：</h4><ol>\n<li>目前代理对象还是需要手动的去获取，这个在后期接入spring逻辑后，可以使用spring注入。</li>\n</ol>"}],"PostAsset":[],"PostCategory":[{"post_id":"cj8jros7d000n30s67xh97hsf","category_id":"cj8g07xl200154kh9r28xa2k3","_id":"cj8jros7h000s30s666vklz1k"},{"post_id":"cj8jros7e000p30s6bpxnq8ce","category_id":"cj8g07xl200154kh9r28xa2k3","_id":"cj8jros7i000u30s6iqe88ggm"},{"post_id":"cj8jros80001o30s6il8t8b0t","category_id":"cj8g07xl200154kh9r28xa2k3","_id":"cj8jros84001v30s6qrm1yrju"},{"post_id":"cj8jros82001q30s6gg0pxq2t","category_id":"cj8g07xl200154kh9r28xa2k3","_id":"cj8jros85001y30s6qkw7rxmt"},{"post_id":"cj8jros82001s30s6h8udouda","category_id":"cj8g07xl200154kh9r28xa2k3","_id":"cj8jros86002130s6cl7e6l0b"},{"post_id":"cj8jros83001u30s6so5uqla3","category_id":"cj8g07xl200154kh9r28xa2k3","_id":"cj8jros87002330s6r4sw6geo"},{"post_id":"cj8jros84001x30s6lyk2vqe1","category_id":"cj8g07xl200154kh9r28xa2k3","_id":"cj8jros88002530s6gtrpbjk3"},{"post_id":"cj8jros85002030s60nv3i1du","category_id":"cj8g07xl200154kh9r28xa2k3","_id":"cj8jros89002730s6gs38cn6m"},{"post_id":"cj8jros86002230s619hnlvue","category_id":"cj8g07xl200154kh9r28xa2k3","_id":"cj8jros8a002930s6mvfh1cps"},{"post_id":"cj8jros87002430s6adxja6r7","category_id":"cj8g07xl200154kh9r28xa2k3","_id":"cj8jros8c002b30s6u4qd0pi8"},{"post_id":"cj8jros88002630s6f8ssii88","category_id":"cj8g07xl200154kh9r28xa2k3","_id":"cj8jros8c002d30s6abe9ir1r"},{"post_id":"cj8jros8a002830s673ei4rda","category_id":"cj8g07xl200154kh9r28xa2k3","_id":"cj8jros8e002g30s6c00a4bq3"},{"post_id":"cj8jros8c002c30s6d9irimta","category_id":"cj8g07xl200154kh9r28xa2k3","_id":"cj8jros8g002l30s6m6fa8qjd"},{"post_id":"cj8jros8e002f30s690l1okus","category_id":"cj8g07xl200154kh9r28xa2k3","_id":"cj8jros8h002o30s6onqihvsc"},{"post_id":"cj8jros8e002i30s61ytywl62","category_id":"cj8g07xl200154kh9r28xa2k3","_id":"cj8jros8i002q30s6kx5p6nbn"}],"PostTag":[{"post_id":"cj8g07xkd000b4kh972c7v05f","tag_id":"cj8g07xlh00224kh9hk241f6n","_id":"cj8g07xlj002b4kh96km20ddg"},{"post_id":"cj8g07xkd000b4kh972c7v05f","tag_id":"cj8g07xkc000a4kh9qmkn5f7x","_id":"cj8g07xlk002d4kh9riwyie23"},{"post_id":"cj8g07xkl000c4kh90yhlzlzy","tag_id":"cj8g07xlh00224kh9hk241f6n","_id":"cj8g07xlk002e4kh9wfprh1f0"},{"post_id":"cj8g07xkl000c4kh90yhlzlzy","tag_id":"cj8g07xkc000a4kh9qmkn5f7x","_id":"cj8g07xlk002g4kh9u19yi12n"},{"post_id":"cj8g07xko000g4kh90lmowpxv","tag_id":"cj8g07xlh00224kh9hk241f6n","_id":"cj8g07xll002h4kh9vr72t5ca"},{"post_id":"cj8g07xko000g4kh90lmowpxv","tag_id":"cj8g07xkc000a4kh9qmkn5f7x","_id":"cj8g07xll002j4kh91hxwdc3f"},{"post_id":"cj8g07xkp000j4kh90zb3f7jm","tag_id":"cj8g07xlh00224kh9hk241f6n","_id":"cj8g07xll002k4kh9cvnnpnt9"},{"post_id":"cj8g07xkp000j4kh90zb3f7jm","tag_id":"cj8g07xkc000a4kh9qmkn5f7x","_id":"cj8g07xll002m4kh9v24ykflh"},{"post_id":"cj8g07xkq000l4kh955xvs1i9","tag_id":"cj8g07xlh00224kh9hk241f6n","_id":"cj8g07xll002n4kh9r1o9o0f7"},{"post_id":"cj8g07xkq000l4kh955xvs1i9","tag_id":"cj8g07xkc000a4kh9qmkn5f7x","_id":"cj8g07xlm002p4kh9ngjmb6xv"},{"post_id":"cj8jros6q000030s6w98402ss","tag_id":"cj8g07xk400034kh9y2lfvz4t","_id":"cj8jros6w000230s6ig4f0nmg"},{"post_id":"cj8jros6q000030s6w98402ss","tag_id":"cj8g07xk900074kh9widthci2","_id":"cj8jros6x000430s67th9ea5v"},{"post_id":"cj8jros6q000030s6w98402ss","tag_id":"cj8g07xkc000a4kh9qmkn5f7x","_id":"cj8jros6z000630s64yy2uaap"},{"post_id":"cj8jros6u000130s68u7rnj5r","tag_id":"cj8g07xk400034kh9y2lfvz4t","_id":"cj8jros72000830s6jccncu79"},{"post_id":"cj8jros6u000130s68u7rnj5r","tag_id":"cj8g07xk900074kh9widthci2","_id":"cj8jros74000a30s6ena5wepj"},{"post_id":"cj8jros6u000130s68u7rnj5r","tag_id":"cj8g07xkc000a4kh9qmkn5f7x","_id":"cj8jros75000c30s6g7bbq57r"},{"post_id":"cj8jros6w000330s6opr5x2g4","tag_id":"cj8g07xk400034kh9y2lfvz4t","_id":"cj8jros78000e30s6bkubn62u"},{"post_id":"cj8jros6w000330s6opr5x2g4","tag_id":"cj8g07xk900074kh9widthci2","_id":"cj8jros7a000g30s6g278cp7v"},{"post_id":"cj8jros6w000330s6opr5x2g4","tag_id":"cj8g07xkc000a4kh9qmkn5f7x","_id":"cj8jros7b000i30s6j1r40767"},{"post_id":"cj8jros6y000530s69egc7q0b","tag_id":"cj8g07xk400034kh9y2lfvz4t","_id":"cj8jros7c000k30s666fqcfmw"},{"post_id":"cj8jros6y000530s69egc7q0b","tag_id":"cj8g07xk900074kh9widthci2","_id":"cj8jros7d000m30s6ccyj3xxm"},{"post_id":"cj8jros6y000530s69egc7q0b","tag_id":"cj8g07xkc000a4kh9qmkn5f7x","_id":"cj8jros7e000o30s6huy2loaz"},{"post_id":"cj8jros6z000730s6dss3ly4l","tag_id":"cj8g07xk400034kh9y2lfvz4t","_id":"cj8jros7f000q30s6aylnkxnl"},{"post_id":"cj8jros6z000730s6dss3ly4l","tag_id":"cj8g07xk900074kh9widthci2","_id":"cj8jros7g000r30s6fcbiazzu"},{"post_id":"cj8jros6z000730s6dss3ly4l","tag_id":"cj8g07xkc000a4kh9qmkn5f7x","_id":"cj8jros7h000t30s6zab5mjzj"},{"post_id":"cj8jros73000930s6twknjkqb","tag_id":"cj8g07xk400034kh9y2lfvz4t","_id":"cj8jros7j000v30s6r3vqpb1a"},{"post_id":"cj8jros73000930s6twknjkqb","tag_id":"cj8g07xk900074kh9widthci2","_id":"cj8jros7k000x30s645m8xe2m"},{"post_id":"cj8jros73000930s6twknjkqb","tag_id":"cj8g07xkc000a4kh9qmkn5f7x","_id":"cj8jros7l000y30s6uczs9n02"},{"post_id":"cj8jros74000b30s69lvrys09","tag_id":"cj8g07xk400034kh9y2lfvz4t","_id":"cj8jros7l000z30s6fyx3ok8b"},{"post_id":"cj8jros74000b30s69lvrys09","tag_id":"cj8g07xk900074kh9widthci2","_id":"cj8jros7m001030s62bsx9avz"},{"post_id":"cj8jros74000b30s69lvrys09","tag_id":"cj8g07xkc000a4kh9qmkn5f7x","_id":"cj8jros7m001130s6952yju5o"},{"post_id":"cj8jros76000d30s655rdl9gr","tag_id":"cj8g07xk400034kh9y2lfvz4t","_id":"cj8jros7m001230s61c119vnx"},{"post_id":"cj8jros76000d30s655rdl9gr","tag_id":"cj8g07xk900074kh9widthci2","_id":"cj8jros7m001330s6tfq8phpm"},{"post_id":"cj8jros76000d30s655rdl9gr","tag_id":"cj8g07xkc000a4kh9qmkn5f7x","_id":"cj8jros7m001430s6n9e11tiv"},{"post_id":"cj8jros78000f30s6plny8nkv","tag_id":"cj8g07xk400034kh9y2lfvz4t","_id":"cj8jros7n001530s6reaimtzf"},{"post_id":"cj8jros78000f30s6plny8nkv","tag_id":"cj8g07xll002i4kh9o7rasyho","_id":"cj8jros7n001630s6m95bytc0"},{"post_id":"cj8jros78000f30s6plny8nkv","tag_id":"cj8g07xkc000a4kh9qmkn5f7x","_id":"cj8jros7n001730s6cy2sol85"},{"post_id":"cj8jros78000f30s6plny8nkv","tag_id":"cj8g07xlp00344kh9c36amedm","_id":"cj8jros7n001830s6aydp7nec"},{"post_id":"cj8jros7a000h30s698jqf0ss","tag_id":"cj8g07xk400034kh9y2lfvz4t","_id":"cj8jros7n001930s6a95jtlta"},{"post_id":"cj8jros7a000h30s698jqf0ss","tag_id":"cj8g07xll002i4kh9o7rasyho","_id":"cj8jros7o001a30s6ehdrmybo"},{"post_id":"cj8jros7a000h30s698jqf0ss","tag_id":"cj8g07xkc000a4kh9qmkn5f7x","_id":"cj8jros7o001b30s6w41fcreu"},{"post_id":"cj8jros7a000h30s698jqf0ss","tag_id":"cj8g07xlm002r4kh9xntz4p1l","_id":"cj8jros7o001c30s6o2dabks6"},{"post_id":"cj8jros7b000j30s6ak5w6c2t","tag_id":"cj8g07xk400034kh9y2lfvz4t","_id":"cj8jros7o001d30s6y2vfw64z"},{"post_id":"cj8jros7b000j30s6ak5w6c2t","tag_id":"cj8g07xll002i4kh9o7rasyho","_id":"cj8jros7p001e30s6e1rvsuvs"},{"post_id":"cj8jros7b000j30s6ak5w6c2t","tag_id":"cj8g07xkc000a4kh9qmkn5f7x","_id":"cj8jros7p001f30s6qscyuex2"},{"post_id":"cj8jros7c000l30s61ssyjfjd","tag_id":"cj8g07xk400034kh9y2lfvz4t","_id":"cj8jros7p001g30s6yk5e6zos"},{"post_id":"cj8jros7c000l30s61ssyjfjd","tag_id":"cj8g07xll002i4kh9o7rasyho","_id":"cj8jros7p001h30s6432tkpdt"},{"post_id":"cj8jros7c000l30s61ssyjfjd","tag_id":"cj8g07xkc000a4kh9qmkn5f7x","_id":"cj8jros7p001i30s6svaunzpo"},{"post_id":"cj8jros7c000l30s61ssyjfjd","tag_id":"cj8g31i8n0000chh9qewbxcme","_id":"cj8jros7p001j30s67srauz7f"},{"post_id":"cj8jros7j000w30s69pdn7dkh","tag_id":"cj8g07xk400034kh9y2lfvz4t","_id":"cj8jros7p001k30s6owqtbm7d"},{"post_id":"cj8jros7j000w30s69pdn7dkh","tag_id":"cj8g07xll002i4kh9o7rasyho","_id":"cj8jros7p001l30s6akx0ufce"},{"post_id":"cj8jros7j000w30s69pdn7dkh","tag_id":"cj8g07xkc000a4kh9qmkn5f7x","_id":"cj8jros7p001m30s6g3yf3ig4"},{"post_id":"cj8jros7z001n30s6nvwh0rem","tag_id":"cj8g07xk400034kh9y2lfvz4t","_id":"cj8jros81001p30s6k54pulla"},{"post_id":"cj8jros7z001n30s6nvwh0rem","tag_id":"cj8g07xll002i4kh9o7rasyho","_id":"cj8jros82001r30s6f37c273p"},{"post_id":"cj8jros7z001n30s6nvwh0rem","tag_id":"cj8g07xkc000a4kh9qmkn5f7x","_id":"cj8jros83001t30s6hrlr73bj"},{"post_id":"cj8jros7z001n30s6nvwh0rem","tag_id":"cj8g07xll002l4kh9q42m4rsq","_id":"cj8jros84001w30s6fc7zj01c"},{"post_id":"cj8jros7z001n30s6nvwh0rem","tag_id":"cj8g31i8n0000chh9qewbxcme","_id":"cj8jros85001z30s6veb2qscf"},{"post_id":"cj8jros8b002a30s6eatc5zau","tag_id":"cj8g07xk400034kh9y2lfvz4t","_id":"cj8jros8e002e30s6qg843mwd"},{"post_id":"cj8jros8b002a30s6eatc5zau","tag_id":"cj8g07xm6003u4kh9exzk59q9","_id":"cj8jros8e002h30s6618eysb0"},{"post_id":"cj8jros8b002a30s6eatc5zau","tag_id":"cj8g07xkc000a4kh9qmkn5f7x","_id":"cj8jros8f002j30s6ea3u9922"},{"post_id":"cj8jros8b002a30s6eatc5zau","tag_id":"cj8g31i8n0000chh9qewbxcme","_id":"cj8jros8h002m30s6ofx3tu9t"},{"post_id":"cj8jros8f002k30s6txyal9a5","tag_id":"cj8g07xk400034kh9y2lfvz4t","_id":"cj8jros8i002p30s6zdbnlvyw"},{"post_id":"cj8jros8f002k30s6txyal9a5","tag_id":"cj8g07xm6003u4kh9exzk59q9","_id":"cj8jros8i002r30s6ofen2r7t"},{"post_id":"cj8jros8f002k30s6txyal9a5","tag_id":"cj8g07xkc000a4kh9qmkn5f7x","_id":"cj8jros8j002s30s63e957236"},{"post_id":"cj8jros8f002k30s6txyal9a5","tag_id":"cj8g31i8n0000chh9qewbxcme","_id":"cj8jros8j002t30s6g6vlaj6c"},{"post_id":"cj8jros8h002n30s67m31t00m","tag_id":"cj8g07xk400034kh9y2lfvz4t","_id":"cj8jros8k002u30s6clmjc0o1"},{"post_id":"cj8jros8h002n30s67m31t00m","tag_id":"cj8g07xm6003u4kh9exzk59q9","_id":"cj8jros8k002v30s63d6d22hn"},{"post_id":"cj8jros8h002n30s67m31t00m","tag_id":"cj8g07xkc000a4kh9qmkn5f7x","_id":"cj8jros8k002w30s67aa2xpln"},{"post_id":"cj8jros8h002n30s67m31t00m","tag_id":"cj8g31i8n0000chh9qewbxcme","_id":"cj8jros8k002x30s6u2r5t1pi"}],"Tag":[{"name":"tech","_id":"cj8g07xk400034kh9y2lfvz4t"},{"name":"arithmetic","_id":"cj8g07xk900074kh9widthci2"},{"name":"index","_id":"cj8g07xkc000a4kh9qmkn5f7x"},{"name":"life","_id":"cj8g07xlh00224kh9hk241f6n"},{"name":"note","_id":"cj8g07xll002i4kh9o7rasyho"},{"name":"spring","_id":"cj8g07xll002l4kh9q42m4rsq"},{"name":"network","_id":"cj8g07xlm002r4kh9xntz4p1l"},{"name":"redis","_id":"cj8g07xlp00344kh9c36amedm"},{"name":"river","_id":"cj8g07xm6003u4kh9exzk59q9"},{"name":"java","_id":"cj8g31i8n0000chh9qewbxcme"}]}}