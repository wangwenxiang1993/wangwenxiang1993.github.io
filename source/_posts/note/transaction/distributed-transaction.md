---
layout: post
title: 分布式事务
date: 2019/10/14
tags: [tech, index]
original: true
---

## 什么是事务
##### 事务是数据库操作的最小工作单元，是作为单个逻辑工作单元执行的一系列操作；这些操作作为一个整体一起向系统提交，要么都执行、要么都不执行；事务是一组不可再分割的操作集合（工作逻辑单元）；
<!--more-->

### 事务的四大特性（ACID）：
#### 原子性
##### 事务是数据库的逻辑工作单位，事务中包含的各操作要么都做，要么都不做 
#### 一致性
##### 事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。如果数据库系统 运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是 不一致的状态。 
#### 隔离性
##### 一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。
#### 持续性
##### 也称永久性，指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的。接下来的其它操作或故障不应该对其执行结果有任何影响。

## 什么是分布式事务
#### 起初，事务仅限于对单一数据库资源的访问控制：
![单服务单数据库资源的访问](/img/transaction/distributedTransaction01.png) <div class='img-note'>单服务单数据库资源的访问</div>
##### 这类基于单个服务单一数据库资源访问的事务，被称为本地事务（Local Transaction）。本地事务主要限制在单个会话内，不涉及多个数据库资源。
#### 分布式事务应用架构
##### 早期分布式事务应用架构很简单，不涉及服务间的访问调用，仅仅是服务内操作涉及到对多个数据库资源的访问：
![单服务多数据库资源的访问](/img/transaction/distributedTransaction02.png) <div class='img-note'>单服务多数据库资源的访问</div>
##### 当前的分布式系统会更复杂，面临多服务多数据库资源的访问：
![多服务多数据库资源的访问](/img/transaction/distributedTransaction03.png) <div class='img-note'>多服务多数据库资源的访问</div>

##### 分布式事务就是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。简单的说，就是一次大的操作由不同的小操作组成，这些小的操作分布在不同的服务器上，且属于不同的应用，分布式事务需要保证这些小操作要么全部成功，要么全部失败。本质上来说，分布式事务就是为了保证不同数据库的数据一致性。

## 一致性模型
##### 现今互联网界，分布式系统和微服务架构盛行。业界著名的CAP理论也告诉我们，在设计和实现一个分布式系统时，需要将数据一致性、系统可用性和分区容忍性放在一起考虑。

#### 分布式事务单元的三种状态：
* 成功
* 失败
* 超时

### CAP定理
##### CAP定理又被叫作布鲁尔定理。对于设计分布式系统来说(不仅仅是分布式事务)的架构师来说，CAP就是你的入门理论。
#### 一致性（Consistency）
##### 对某个指定的客户端来说，读操作能返回最新的写操作。对于数据分布在不同节点上的数据上来说，如果在某个节点更新了数据，那么在其他节点如果都能读取到这个最新的数据，那么就称为强一致，如果有某个节点没有读取到，那就是分布式不一致。
#### 可用性（Availability）
##### 非故障的节点在合理的时间内返回合理的响应(不是错误和超时的响应)。可用性的两个关键一个是合理的时间，一个是合理的响应。合理的时间指的是请求不能无限被阻塞，应该在合理的时间给出返回。合理的响应指的是系统应该明确返回结果并且结果是正确的，这里的正确指的是比如应该返回50，而不是返回40。
#### 分区容错性（Partition Tolerance）
##### 当出现网络分区后，系统能够继续工作。打个比方，这里个集群有多台机器，有台机器网络出现了问题，但是这个集群仍然可以正常工作。
![CAP理论](/img/transaction/distributedTransaction04.png) <div class='img-note'>CAP定理</div>

### Base理论
* **基本可用（Basically Available）**:指分布式系统在出现故障时，允许损失部分的可用性来保证核心可用。

* **软状态（Soft State）**:指允许分布式系统存在中间状态，该中间状态不会影响到系统的整体可用性。

* **最终一致性（Eventual Consistency）**:指分布式系统中的所有副本数据经过一定时间后，最终能够达到一致的状态。

### 一致性模型
##### 数据的一致性模型可以分成以下 3 类：
* **强一致性**：数据更新成功后，任意时刻所有副本中的数据都是一致的，一般采用同步的方式实现。
* **弱一致性**：数据更新成功后，系统不承诺立即可以读到最新写入的值，也不承诺具体多久之后可以读到。
* **最终一致性**：弱一致性的一种形式，数据更新成功后，系统不承诺立即可以返回最新写入的值，但是保证最终会返回上一次更新操作的值。

### 刚性事务和柔性事务
* **刚性事务**：严格遵循ACID原则（原子性、一致性、隔离性、持久性）的事务。基本上指的是本地数据库事务。根据CAP原则，分布式下的事务都不是刚性事务。
* **柔性事务**：遵循CAP理论或者其变种BASE理论的事务。分布式事务基本上都是柔性事务。

## 分布式事务解决方案
##### 分布式事务的目的是保障分布式存储中数据一致性，而跨库事务会遇到各种不可控制的问题，如个别节点宕机，像单机事务一样的ACID是无法奢望的。
### 两阶段提交协议（2PC）
##### 两阶段提交协议，顾名思义，该协议将一个分布式的事务过程拆分成两个阶段： 投票阶段 和 事务提交阶段 。为了让整个数据库集群能够正常的运行，该协议指定了一个“协调者”单点，用于协调整个数据库集群的运行，为了简化描述，我们将数据库里面的各个节点称为“参与者”，三阶段提交协议中同样包含“协调者”和“参与者”这两个定义。

#### 二阶段提交算法的成立基于以下假设：
1. 该分布式系统中，存在一个节点作为协调者(协调者)，其他节点作为参与者(Participants)。且节点之间可以进行网络通信。
2. 所有节点都采用预写式日志，且日志被写入后即被保持在可靠的存储设备上，即使节点损坏不会导致日志数据的消失。
3. 所有节点不会永久性损坏，即使损坏后仍然可以恢复。

![2pc流程](/img/transaction/distributedTransaction05.png) <div class='img-note'>2pc流程</div>

#### 第一阶段(提交请求阶段)
1.协调者节点向所有参与者节点询问是否可以执行提交操作，并开始等待各参与者节点的响应。
2. 参与者节点执行询问发起为止的所有事务操作，并将Undo信息和Redo信息写入日志。
3. 各参与者节点响应协调者节点发起的询问。如果参与者节点的事务操作实际执行成功，则它返回一个"同意"消息；如果参与者节点的事务操作实际执行失败，则它返回一个"中止"消息。

##### 有时候，第一阶段也被称作**投票阶段**，即各参与者投票是否要继续接下来的提交操作。

#### 第二阶段(提交执行阶段)
##### **成功**：当协调者节点从所有参与者节点获得的相应消息都为"同意"时：
1.协调者节点向所有参与者节点发出"正式提交"的请求。
2. 参与者节点正式完成操作，并释放在整个事务期间内占用的资源。
3. 参与者节点向协调者节点发送"完成"消息。
4.协调者节点收到所有参与者节点反馈的"完成"消息后，完成事务。

##### **失败**：如果任一参与者节点在第一阶段返回的响应消息为"终止"，或者协调者节点在第一阶段的询问超时之前无法获取所有参与者节点的响应消息时：
1.协调者节点向所有参与者节点发出"回滚操作"的请求。
2. 参与者节点利用之前写入的Undo信息执行回滚，并释放在整个事务期间内占用的资源。
3. 参与者节点向协调者节点发送"回滚完成"消息。
4.协调者节点收到所有参与者节点反馈的"回滚完成"消息后，取消事务。

##### 有时候，第二阶段也被称作**完成阶段**，因为无论结果怎样，协调者都必须在此阶段结束当前事务。

#### 2PC 一致性问题
##### 2PC 是否可以在任何情况下都可以解决一致性问题，在实际的网络生产中，各种情况都有可能发生，这里，我们先从理论上分析各种意外情况。
##### 2PC 在执行过程中可能发生协调者或者参与者突然宕机的情况，在不同时期宕机可能有不同的现象。

* **协调者挂了，参与者没挂**
##### 这种情况其实比较好解决，只要找一个协调者的替代者。当他成为新的协调者的时候，询问所有参与者的最后那条事务的执行情况，他就可以知道是应该做什么样的操作了。所以，这种情况不会导致数据不一致。
* **参与者挂了（无法恢复），协调者没挂**
##### 如果挂了之后没有恢复，那么是不会导致数据一致性问题。
* **参与者挂了（后来恢复），协调者没挂**
##### 恢复后参与者如果发现有未执行完的事务操作，直接取消，然后再询问协调者目前我应该怎么做，协调者就会比对自己的事务执行记录和该参与者的事务执行记录，告诉他应该怎么做来保持数据的一致性。

##### 还有一种情况是：参与者挂了，协调者也挂了，需要再细分为几种类型来讨论：

* **协调者和参与者在第一阶段挂了**
##### 由于这时还没有执行 commit 操作，新选出来的协调者可以询问各个参与者的情况，再决定是进行 commit 还是 roolback。因为还没有 commit，所以不会导致数据一致性问题。
* **协调者和参与者在第二阶段挂了，但是挂的这个参与者在挂之前还没有做相关操作**
##### 这种情况下，当新的协调者被选出来之后，他同样是询问所有参与者的情况。只要有机器执行了 abort（roolback）操作或者第一阶段返回的信息是 No 的话，那就直接执行 roolback 操作。如果没有人执行 abort 操作，但是有机器执行了 commit 操作，那么就直接执行 commit 操作。这样，当挂掉的参与者恢复之后，只要按照协调者的指示进行事务的 commit 还是 roolback 操作就可以了。因为挂掉的机器并没有做 commit 或者 roolback 操作，而没有挂掉的机器们和新的协调者又执行了同样的操作，那么这种情况不会导致数据不一致现象。
* **协调者和参与者在第二阶段挂了，挂的这个参与者在挂之前已经执行了操作。但是由于他挂了，没有人知道他执行了什么操作。**
##### 这种情况下，新的协调者被选出来之后，如果他想负起协调者的责任的话他就只能按照之前那种情况来执行 commit 或者 roolback 操作。这样新的协调者和所有没挂掉的参与者就保持了数据的一致性，我们假定他们执行了 commit。但是，这个时候，那个挂掉的参与者恢复了怎么办，因为他已经执行完了之前的事务，如果他执行的是 commit 那还好，和其他的机器保持一致了，万一他执行的是 roolback 操作呢？这不就导致数据的不一致性了么？虽然这个时候可以再通过手段让他和协调者通信，再想办法把数据搞成一致的，但是，这段时间内他的数据状态已经是不一致的了！

##### 所以，2PC协议中，如果出现协调者和参与者都挂了的情况，有可能导致数据不一致。为了解决这个问题，衍生除了3PC。

#### 2PC优缺点
* **优点**：原理简洁清晰、实现方便；
* **缺点**：
1. 二阶段提交算法的最大缺点就在于 它的执行过程中间，节点都处于阻塞状态。即节点之间在等待对方的响应消息时，它将什么也做不了。特别是，当一个节点在已经占有了某项资源的情况下，为了等待其他节点的响应消息而陷入阻塞状态时，当第三个节点尝试访问该节点占有的资源时，这个节点也将连带陷入阻塞状态。
2. 另外，协调者节点指示参与者节点进行提交等操作时，如有参与者节点出现了崩溃等情况而导致协调者始终无法获取所有参与者的响应信息，这时协调者将只能依赖协调者自身的超时机制来生效。但往往超时机制生效时，协调者都会指示参与者进行回滚操作。这样的策略显得比较保守。

### 三阶段提交协议（3PC）
##### 与两阶段提交不同的是，三阶段提交是“非阻塞”协议。三阶段提交在两阶段提交的第一阶段与第二阶段之间插入了一个准备阶段，使得原先在两阶段提交中，参与者在投票之后，由于协调者发生崩溃或错误，而导致参与者处于无法知晓是否提交或者中止的“不确定状态”所产生的可能相当长的延时的问题得以解决。 

![3pc流程](/img/transaction/distributedTransaction06.png) <div class='img-note'>3pc流程</div>

#### 阶段一 CanCommit
1. **事务询问**：协调者向各参与者发送 CanCommit 的请求，询问是否可以执行事务提交操作，并开始等待各参与者的响应；
2. **参与者向协调者反馈询问的响应**：参与者收到 CanCommit 请求后，正常情况下，如果自身认为可以顺利执行事务，那么会反馈 Yes 响应，并进入预备状态，否则反馈 No。

#### 阶段二 PreCommit
##### **执行事务预提交**：如果协调者接收到各参与者反馈都是Yes，那么执行事务预提交：

1. **发送预提交请求**：协调者向各参与者发送 preCommit 请求，并进入 prepared 阶段；
2. **事务预提交**：参与者接收到 preCommit 请求后，会执行事务操作，并将 Undo 和 Redo 信息记录到事务日记中；
3. **各参与者向协调者反馈事务执行的响应**：如果各参与者都成功执行了事务操作，那么反馈给协调者 ACK 响应，同时等待最终指令，提交 commit 或者终止 abort，结束流程；

##### **中断事务**：如果任何一个参与者向协调者反馈了 No 响应，或者在等待超时后，协调者无法接收到所有参与者的反馈，那么就会中断事务。

1. **发送中断请求：协调者向所有参与者发送 abort 请求；
2. 中断事务：无论是收到来自协调者的 abort 请求，还是等待超时，参与者都中断事务。

#### 阶段三 doCommit
##### **执行提交**

1. **发送提交请求**：假设协调者正常工作，接收到了所有参与者的 ack 响应，那么它将从预提交阶段进入提交状态，并向所有参与者发送 doCommit 请求；
2. **事务提交**：参与者收到 doCommit 请求后，正式提交事务，并在完成事务提交后释放占用的资源；
3. **反馈事务提交结果**：参与者完成事务提交后，向协调者发送 ACK 信息；
4. **完成事务**：协调者接收到所有参与者 ack 信息，完成事务。

##### **中断事务**：假设协调者正常工作，并且有任一参与者反馈 No，或者在等待超时后无法接收所有参与者的反馈，都会中断事务

1. **发送中断请求**：协调者向所有参与者节点发送 abort 请求；
2. **事务回滚**：参与者接收到 abort 请求后，利用 undo 日志执行事务回滚，并在完成事务回滚后释放占用的资源；
3. **反馈事务回滚结果**：参与者在完成事务回滚之后，向协调者发送 ack 信息；
4. **中断事务**：协调者接收到所有参与者反馈的 ack 信息后，中断事务。

#### 3PC 分析
##### 3PC 虽然解决了协调者与参与者都异常情况下导致数据不一致的问题，3PC 依然带来其他问题：比如，网络分区问题，在 preCommit 消息发送后突然两个机房断开，这时候协调者所在机房会 abort, 另外剩余参与者的机房则会 commit。
##### 而且由于3PC 的设计过于复杂，在解决2PC 问题的同时也引入了新的问题，所以在实际上应用不是很广泛。

### Paxos算法

### Raft协议


## 参考文章：
* [再有人问你分布式事务，把这篇扔给他](https://www.cnblogs.com/bigben0123/p/9453830.html)
* [分布式系统事务一致性](https://www.cnblogs.com/luxiaoxun/p/8832915.html)
* [分布式事务综述](https://www.jianshu.com/p/08600dca788f)
* [分布式事务：两阶段提交与三阶段提交](https://segmentfault.com/a/1190000012534071?utm_source=tag-newest)
* [分布式系统的一致性协议之 2PC 和 3PC](https://matt33.com/2018/07/08/distribute-system-consistency-protocol/)
* [维基百科：二阶段提交](https://zh.wikipedia.org/wiki/%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4)
* [维基百科：三阶段提交](https://zh.wikipedia.org/wiki/%E4%B8%89%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4)


