---
layout: post
title: BitMap在Mysql中的实际应用
date: 2018/12/23
tags: [tech, arithmetic, index]
original: true
tag: [[算法, arithmetic]]
---

### 这是一个实际开发中遇到的问题：
##### 仓库中存在多种物料，每种物料都有其适配的车型。比如A物料适配1、2、3车型；B物料适配2、4车型。数据存储在mysql中，如果需要将适配车型作为一种筛选条件。那么mysql中应该如何存储呢？
<!--more-->

### 1、实际中的存储方式
##### 在实际开发中，常常因为需求比较急，或者是前瞻性不够，导致没有充分考虑到后面的需求变化情况。在这个例子中，我们的实际存储结构是车型之间使用逗号分隔，存储在一个数据字段中：
|物料|车型|
| --- |--- |
|A|1,2,3|
|B|2,4|

##### 这样做最大的好处就是使用方便，在存储功能上没有任何问题。
#### 优点：
1. 存储结果简单，直观明了；
2. 在一定范围内不用考虑数据量的问题，不用关心数据之间的关联关系爆炸。

#### 缺点：
1. 耦合严重，如果需要修改物料和车型之间的关系。通常需要程序处理，而不是mysql自处理。
2. 关系方向单一，这里是物料->车型。如果需求中出现了车型->物料，就会使得这种结构不适用。

##### 实际中我们就是这样存储的，并且出现了车型筛选物料的需求，而且这种关系的依赖越来越重。刚开始时，我们使用JAVA程序内过滤。不考虑车型，将其他条件符合的数据都筛选出来，然后在程序内将车型不符合数据过滤掉。

##### 但是这样就产生了新的问题，就是**<font color='#2d7788'>分页</font>**。之前可以用mysql做逻辑分页，使用这种处理方式之后，mysql的分页就很不适用。需要转换成内存中的物理分页。

### 2、最常见的存储方式
##### 对于多对多的数据存储，mysql最常见的存储方式就是产生关系表，两两绑定其关系。在上面的实际例子中就是增加物料-车型关系表。表的结构大致如下：
|物料|车型|
| --- |--- |
|A|1|
|A|2|
|A|3|
|B|2|
|B|4|

#### 优点：
1. 关系解耦，不在是一个整体，我们可以单独处理物料A和车型1的关系，而不用影响其他的关系；
2. 双向选择，物料适配车型的选择，和按照车型选择物料。
3. 关系拓展，如果需要记录关系的绑定或者解除时间，或者绑定关系有多种。显然这种存储结果更易于扩展

#### 缺点：
1. 相对于上面的存储，结构更加复杂。插入一条物料数据，需要写入多个数据表。
2. 按照车型筛选物料时，会用到关联查询，这个在实际开发中是不太推荐的。

### 3、最终的方案
##### 如果做出一定的牺牲（容忍一定程度的关联查询），上面介绍的关系表是一种可以接受的方案。但是在我们的需求中，改动点实在有点多，做出这种数据结构的改动是我们不太愿意其发生的。于是产生了我们的最终方案-bitMap筛选方案。关于bitMap的一些思想，可以参考我的另一篇文章：[BloomFilter](../bloomfilter)
#### 首先我们定义每种车型对应的bit位：
|车型|bit位|十进制表示|
| --- |--- --- |
|1|0001|1|
|2|0010|2|
|3|0100|4|
|4|1000|8|

#### 在原物料表中增加一列表示所有车型的bit表示
|物料|车型|车型bit|
| --- |--- |--- |
|A|1,2,3|7|
|B|2,4|10|

#### 那么到这就很简单了。首先我们计算出需要查询的几种车型的bit总和，比如查询条件是车型2和3，那么bitSum=6。常见的两种车型过滤条件示例：
1. 多种车型筛选，任一车型匹配则符合：
```
where `车型bit` & #{bitSum} > 0
```
2. 多种车型筛选，全部车型匹配则符合：
```
where `车型bit` & #{bitSum} = #{bitSum}
```

#### 使用这种方式，很好的解决了方案1中的某些弊端，使得车型->物料的选择变的清晰。当然这种方式也有很多弊端：
1. 增加mysql的计算逻辑。
2. 因为有位运算，使得车型bit的索引是不会生效的。
3. 直接修改数据库（当然我们需要避免这种情况）的时候，通常不会联动修改`车型bit`。因此所有操作都得经过程序的处理，或者增加程序入口，重新计算所有。