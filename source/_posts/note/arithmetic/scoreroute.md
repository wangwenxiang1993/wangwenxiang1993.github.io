---
layout: post
title: 顺路程度算法
date: 2018/05/18
tags: [tech, arithmetic, index]
original: true
tag: [[算法, arithmetic]]
---

##### 之前在做私车同行项目中，需要用一个分数值去表现司机和乘客行程的顺路匹配程度。以此来做一些类似于推荐和排序的需求。奈何于网络上没有找到相对满意的理论和工程实现。因此我们尝试从某些维度出发，将其赋予不同的权重值，通过参数的调节，达到一个相对满意的程度。

<!-- more -->

## 概述
##### 我们的需求当中，类似于顺风车场景，司机和乘客都有自己原本的出发地和到达地，并且司机和乘客为预约出发，但是我们的顺路算法不用考虑实时性以及路况信息。因此我们将算法分成了几个部分：基础分、时间、顺路、绕路、方向。其中除了方向以为，其他的维度都有一个权重值，并且所有权重相加等于1。最终的分数计算公式为：
<pre><code class="hljs"><div>总分数 = 基础分 + 时间分 + (顺路分 + 绕路分) * 方向
</div></code></pre>

### 基础、时间
##### 基础和时间是相对独立的分数计算。特别是基础分，我们给了一个固定值，以此来保证分数看起来相对稳定，因为用户对分数的敏感程度和算法之间会有一个差距，因此需要通过一个基础分数来平衡这种差距。

##### 时间分数也很简单，我们的逻辑是按照乘客的出发时间和司机的出发时间来匹配的，我们认为如果出发时间相差30分钟以上，则时间得分为0。出发时间相等则得到时间满分。

### 顺路、绕路、方向
##### 其实这三个维度的分数计算才是描述两个行程是否相似的核心。司机和乘客行程路线可以简化为下图：
![司机乘客行程简图](/img/arithmetic/scoreroute.png)

##### 图中路线主要有以下几种：
1. 司机假设行程：DS-DE
2. 乘客行程：PS-PE
3. 司机实际行程：DS-PS-PE-DE

#### 顺路
##### 顺路即在整个行程当中，乘客的路线距离占比。
<pre><code class="hljs"><div>顺路 = PS-PE / DS-PS-PE-DE
</div></code></pre>

##### 因为PS-PE是包含在DS-PS-PE-DE中的，因此顺路计算出来的值为0-1之间。并且越接近1分数应该越高。

#### 绕路
##### 绕路即在整个行程当中，司机的路线距离占比。
<pre><code class="hljs"><div>绕路 = DS-DE / DS-PS-PE-DE
</div></code></pre>

##### 实际上DS-DE和DS-PS-PE-DE可以理解为两条完全不相关的路线，理论上来说绕路的分数值也在0-1之间，并且越接近1，则表示司机绕路越少。但是实际开发中，犹豫地图的实时性以及稳定性等因素，有可能会造成DS-DE的值大于DS-PS-PE-DE的值。因此通常可以采用重试、缓存（将正确的距离缓存，不用每次都实时获取）、默认值等方式去处理这种特殊的边界情况。

#### 方向
##### 方向则表示DS-DE和PS-PE两条直线之间的角度，方向的区间为[0,180]，越接近0得分应该越高。但是分数没有单独拿出来分配权重，而是作为顺路和绕路的一个辅助因数，使得顺路和绕路的计算更加丰富，可调节的程度更多一些。

### 分数的分布
##### 前面介绍了时间、顺路、绕路、方向等计算公式，他们都可以将结果转换为0-1之间的小数。那么如何将分数分布在这些区间之内呢？均匀分布？分段分布？
##### 这里说一下分数分布的重要性，比如时间，出发时间完全相等是非常难的，通常来说，用户会觉得相差10分钟以内都是相似度很高的。以及方向，我们计算的方向是按照直线的角度来算的，如果出现以下情况，长的线段和短的线段直接是有大概20度的角度差，但是短线段所在的点正在司机回家的路过点，这种情况通常来说顺路分数应该相对高一些。因此我们应该减小小角度的影响范围。
![司机乘客行程简图](/img/arithmetic/scoreroute1.png)

##### 相应的场景还有很多，比如顺路比，如果司机在回家的路上刚好路过乘客的起终点，那么尽管乘客的行程距离很短，我们也应该给出较高的分数。

##### 那么我们是如何去控制和调节这些分数的分布的呢，分段分布是一种解决方法，但是力度不够细，段的多少很难控制，以及段内的分布呢？我们的解决办法很简单，通过幂次方来控制。
![司机乘客行程简图](/img/arithmetic/scoreroute2.jpeg)

##### 以上为公式Math.pow(x,t)的走势，从左往右t的大小依次为0.2、0.6、1、1.8、5。x值为区间值，也就是[0,1]，y等于x的分数映射，也就是分数分布结果。可以看到：
1. t=1，为线性增长
2. t<1，分数的分布重心在x的前半段
2. t>1，分数的分布重心在x的后半段

##### 举个例子，在我们的应用中，方向的t设置为0.3。则当两条路线的角度为90度时，y的值大概等于0.8。我们认为这是一个相对合理的得分。

##### 这个只是比较粗糙的分布，我们可以更加细致将x区间分成多段，然后在每个段内设置不同的t参数以及y的起终点，达到相对连续平滑的复杂分布效果。

## 总结
##### 上面分析了算法的基本原理已经实现中一些问题的解决方案，该算法主要有优缺点：
#### 优点：
1. 算法简单易懂，容易理解，容易实现
2. 可调节范围还是挺多的，对于各种应用场景都能相对兼容

#### 缺点：
1. 比较依赖地图给出的路面距离，在实际应用中可能误差较大