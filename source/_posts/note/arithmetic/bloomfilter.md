---
layout: post
title: 大量订单的去重计算-BloomFilter
date: 2018/05/08
tags: [tech, arithmetic, index]
original: true
tag: [[算法, arithmetic]]
---

##### 如果需要对数据进行去重，我们最先想到一定是集合set，以及数据库的唯一索引。如果数据有持久化的需求，数据库的唯一索引是一个比较好的解决办法，因为这样你可以做分布式处理并且保证最终的一致性。如果数据不需要持久存储，只需要在内存当中去处理重复数据，则我们通常会使用set集合做处理。但是如果数据量特别大呢？我们如何处理
<!-- more -->

##### 最近的遇到的需求场景如下。我们有大量的用户打车订单数据，需要将订单和企业地理位置做挂钩。按照企业位置的一定半径范围统计订单情况，那么离得比较近的公司在一定范围内的很多订单都是重复的，为了不对这部分订单做重复处理，并且订单信息也不做数据库存储。我们需要在每次任务计算的时候对订单做是否重复判断。
##### 目前的订单数据量大约在千万级别（只计算很小部分城市），能够预测到的未来将有数10亿的订单量。如果按照订单id做去重，订单的id为long类型，占用8个字节64bit。则订单号在内存中的占用量大约为：
1. 1000w数据量
<pre><code class="hljs"><h6>8byte * 10<sup>7</sup> = 1024 * 1024 * 76.29 = 76.29MB
</h6></code></pre>
2. 10亿数据量
<pre><code class="hljs"><h6>76.29MB * 100 = 7.45GB
</h6></code></pre>

##### 可以看到，在数10亿的情况下内存占用已经达到7.5GB左右，虽然该占用量不是不能接受，但还是有优化空间的。那就是布隆过滤器（BloomFilter）。

## BitMap
##### 在介绍布隆过滤器之前，首先介绍BitMap，因为布隆过滤器的思路和原理就是通过BitMap转换过来的。
##### 对于一个整型数，比如int a=1 在java内存中占32bit位，这是为了方便计算机的运算。但是对于某些应用场景而言，这属于一种巨大的浪费。比如我们判断这个数是否存在，我们真的需要把这个数用int类型完整的保留下来吗？答案当然是不需要，我们只需要用一个bit位去记录，0-未出现，1-出现。因此我们可以用对应的32bit位对应存储十进制的0-31，而这就是Bit-map的基本思想。Bit-map算法利用这种思想处理大量数据的排序、查询以及去重。

### Bit-map应用之快速去重

##### 2.5亿个整数中找出不重复的整数的个数，内存空间不足以容纳这2.5亿个整数。 
##### 首先，根据“内存空间不足以容纳这2.5亿个整数”我们可以快速的联想到Bit-map。下边关键的问题就是怎么设计我们的Bit-map来表示这2.5亿个数字的状态了。其实这个问题很简单，一个数字的状态只有两种，分别为不存在，存在。因此，我们只需要1bit就可以对一个数字的状态进行存储了，我们设定一个数字不存在为0，存在一次1。那我们大概需要存储空间几十兆左右。
##### 接下来的任务就是遍历一次这2.5亿个数字，判断对应下标的bit位，如果为0则表示之前没有出现过，并且将该位设置为1。如果为1则表示之前已经出现过，为重复数据，则可以丢弃。
#### 优点：
* 占用内存少 
* 运算效率高

#### 缺点：
* 对于非连续数据，有可能中间会有大量的bit位没有使用，导致部分空间浪费
* 对于不是从0开始的数据，需要找到一种映射关系，将已有的数据表示为从0开始的数据。比如原始数据是从100000为起点的整数，如果使用bitmap，将导致前面的100000个bit位没有使用上。最简单的办法是我们可以将原始数据做减100000的映射表示。

### Bit-map应用之快速排序
##### 假设我们要对0-7内的5个元素(4,7,2,5,3)排序（这里假设这些元素没有重复）,我们就可以采用Bit-map的方法来达到排序的目的。要表示8个数，我们就只需要8个Bit（1Bytes），将这些空间的所有Bit位都置为0。
<table><tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr></table>

##### 将元素(4,7,2,5,3)对应下标位设置为1:
<table><tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr></table>

##### 遍历一遍Bit区域，将该位是一的位的编号输出（2，3，4，5，7），这样就达到了排序的目的，时间复杂度O(n)。
#### 优点：
* 运算效率高，不需要进行比较和移位；
* 占用内存少，比如N=10000000；只需占用内存为N/8=1250000Byte=1.25M。 

#### 缺点：
* 所有的数据不能重复。即不可对重复的数据进行排序和查找。

### JAVA当中的BitMap
##### 既然介绍到BitMap，则简单介绍下JAVA当中的实现-BitSet
##### BitSet实现中，使用long类型数组来表示所有的bit位，数组当中的一个long字段可以表示64位：
```java
/**
 * The number of words in the logical size of this BitSet.
 */
private long[] words;
```

##### 具体的BitSet使用和原理，可以参考以下文章：
1. [Java Bitset类 | 菜鸟教程](http://www.runoob.com/java/java-bitset-class.html)
2. [Java BitSet](https://blog.csdn.net/top_code/article/details/40583279)

## BloomFilter