---
layout: post
title: 妇女节快乐，字符串包含
date: 2017/03/08
tags: [arithmetic, index]
---

## 题目要求：
##### 给定两个分别由字母组成的字符串A和字符串B，字符串B的长度比字符串A短。请问，如何最快地判断字符串B中所有字母是否都在字符串A里？
##### 为了简单起见，我们规定输入的字符串只包含大写英文字母
<!--more-->

#### 比如
##### String 1：ABCD
##### String 2：BAD
##### 答案是true，即String2里的字母在String1里也都有，或者说String2是String1的真子集。
##### 如果是下面两个字符串：
##### String 1：ABCD
##### String 2：BCE
##### 答案是false，因为字符串String2里的E字母不在字符串String1里。


## 分析过程：
##### 题目可以简单理解成集合A，集合B。判断集合B是否为集合A的真子集。只是与集合不同的是，在本题中，字符串中是允许存在相同的字符的，这无疑是增加了题目的难度。

### 最简单的解法
##### 最容易想到的也就是最简单的解决方法当然是依次比较。利用两层循环，遍历字符串B，将字符串B中每一个字符在字符串A中依次比较，看是否存在于字符串A中。
##### 假设字符串A的长度为n，字符串B的长度为m，则该方法的时间复杂度为O(n*m)。

### 利用排序优化算法时间
##### 上一种解法的时间复杂度无疑是最长的。我们当然可以利用排序对算法进行优化。方法是先将字符串A进行堆排序，其时间复杂度为O(n log n)。之后再将字符串B中的每个字符在排序后的堆中查找，则时间复杂度为O(m log n)。相加后的时间复杂度O((m+n) log n)

### 最优解法，时间复杂度O(m+n)
##### 题目到这好像没有办法解决下去，两个字符串的长度分别为n和m。只遍历一遍就得出结果，这种算法真的存在吗？其实这个题目就可以简化成集合元素存在的判断。
##### 这里又要用到二进制的概念，二进制的一些属性完美的解决了题目中的一些问题。
#### 1.相同字符的处理
##### "或"操作指的是，两个相应的二进位中只要有一个为1，该位的结果值为1。
##### 0101 OR 0011 = 0111
##### 所以当两个相同字符存在时，用或操作，还是得到一个字符的值。
#### 2.字符的存在问题，如何判断一个字符存在于字符集
##### "与"操作指的是，两个相应的二进位都为1，该位的结果值才为1
##### 0101 AND 0011 = 0001
##### 也就是只有两边都存在同一个字符时，才会得出1

##### 因此我们可以将所有字符都进行二进制的编码，因为每一个字符都有两种状态（存在和不存在），所以对应在二进制中，每一个字符都占用一位。
```c
bool StringContain(string &a,string &b)
{
    int hash = 0;
    for (int i = 0; i < a.length(); ++i)
    {
        hash |= (1 << (a[i] - 'A'));
    }
    for (int i = 0; i < b.length(); ++i)
    {
        if ((hash & (1 << (b[i] - 'A'))) == 0)
        {
            return false;
        }
    }
    return true;
}
```


## 最后再说一些：
##### 最后的算法和之前的[切金条](http://localhost:4000/arithmetic/glodBars/)算法有一些相似之处。这是这里对二进制的理解和运用更加灵活。只有对此很熟悉，才能想到这种方法。否则会比较困难。
